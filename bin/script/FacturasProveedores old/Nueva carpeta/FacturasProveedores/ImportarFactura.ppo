#line 38 "C:\fw195\Gestool\bin\include\FiveWin.Ch"
      static bError
#line 203 "C:\fw195\Gestool\bin\include\hbclass.ch"
DECLARE HBClass  New( cName AS STRING, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS OBJECT  Instance() AS OBJECT  AddClsMethod( cName AS STRING, @MethodName(), nScope AS NUMERIC, n2 AS NUMERIC, n3 AS NUMERIC )  AddMultiClsData( cType AS STRING, uVal, nScope AS NUMERIC, aDatas AS ARRAY OF STRING )  AddMultiData( cType AS STRING, uVal, nScope AS NUMERIC, aDatas AS ARRAY OF STRING, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS STRING, @MethodName(), nScope AS NUMERIC )  AddInLine( cName AS STRING, bBlock AS CODEBLOCK, nScope AS NUMERIC )  AddVirtual( cName AS STRING )
#line 79 "C:\fw195\Gestool\bin\include\FiveWin.Ch"
         EXTERNAL FW_GT











extern errorsys
#line 10 "C:\fw195\Gestool\bin\Script\FacturasProveedores\ImportarFactura.prg"
Function ImportarExcelArguelles( nView )

   local oImportarExcel    := TImportarExcelArguelles():New( nView )

   oImportarExcel:Run()

Return nil



_HB_CLASS TImportarExcelArguelles ; function TImportarExcelArguelles ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TImportarExcelArguelles", iif( .T., { @TImportarExcel() }, { @HBObject() } ), @TImportarExcelArguelles() ) ) ;

; _HB_MEMBER { nFila } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nFila"}, .F. )
; _HB_MEMBER { nFilaInicio } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nFilaInicio"}, .F. )
; _HB_MEMBER { nFilaFinal } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nFilaFinal"}, .F. )
; _HB_MEMBER { nContadorPagina } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nContadorPagina"}, .F. )
; _HB_MEMBER { aLineasPedido } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aLineasPedido"}, .F. )
; _HB_MEMBER { lFinPage } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lFinPage"}, .F. )

; _HB_MEMBER { cSerieFactura } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cSerieFactura"}, .F. )
; _HB_MEMBER { cNumeroFactura } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cNumeroFactura"}, .F. )
; _HB_MEMBER { cSufijoFactura } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cSufijoFactura"}, .F. )

; _HB_MEMBER { dFechaFactura } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"dFechaFactura"}, .F. )
; _HB_MEMBER { cHoraFactura } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cHoraFactura"}, .F. )

; _HB_MEMBER { cSuFactura } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cSuFactura"}, .F. )
; _HB_MEMBER { nPuntoVerde } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nPuntoVerde"}, .F. )

; _HB_MEMBER { hLine } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hLine"}, .F. )

; _HB_MEMBER { cCodigoProveedor } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cCodigoProveedor"}, .F. )

; _HB_MEMBER { cError } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cError"}, .F. )

; _HB_MEMBER { nCount } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nCount"}, .F. )

   _HB_MEMBER New(); oClass:AddMethod( "New", @TImportarExcelArguelles_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Run(); oClass:AddMethod( "Run", @TImportarExcelArguelles_Run(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getCampoClave(); oClass:AddInline( "getCampoClave", {|Self | ( ( Self ) ), ( alltrim( ::getExcelString( ::cColumnaCampoClave ) ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER procesaFicheroExcel(); oClass:AddMethod( "procesaFicheroExcel", @TImportarExcelArguelles_procesaFicheroExcel(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER procesaHojaExcel( nContadorPagina); oClass:AddMethod( "procesaHojaExcel", @TImportarExcelArguelles_procesaHojaExcel(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER procesaLinea(); oClass:AddMethod( "procesaLinea", @TImportarExcelArguelles_procesaLinea(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER procesaLote(); oClass:AddMethod( "procesaLote", @TImportarExcelArguelles_procesaLote(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getLotesLine(); oClass:AddMethod( "getLotesLine", @TImportarExcelArguelles_getLotesLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER formatArrayLote( aLotes); oClass:AddMethod( "formatArrayLote", @TImportarExcelArguelles_formatArrayLote(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER addCabeceraFactura(); oClass:AddMethod( "addCabeceraFactura", @TImportarExcelArguelles_addCabeceraFactura(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER addLineasFactura(); oClass:AddMethod( "addLineasFactura", @TImportarExcelArguelles_addLineasFactura(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER addLineaPuntoVerde(); oClass:AddMethod( "addLineaPuntoVerde", @TImportarExcelArguelles_addLineaPuntoVerde(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER recalculaFactura(); oClass:AddMethod( "recalculaFactura", @TImportarExcelArguelles_recalculaFactura(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER addSuFactura(); oClass:AddMethod( "addSuFactura", @TImportarExcelArguelles_addSuFactura(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TImportarExcelArguelles ;



static FUNCTION TImportarExcelArguelles_New( nView ) ; local Self AS CLASS TImportarExcelArguelles := QSelf() AS CLASS TImportarExcelArguelles

   ::nView                    := nView

   ::cFicheroExcel            := cGetFile( "Excel ( *.Xlsx ) | " + "*.Xlsx", "Seleccione la hoja de calculo" )

   ::aLineasPedido            := {}

   ::nContadorPagina          := 1
   ::nFilaInicio              := 57
   ::nFilaFinal               := 84
   ::lFinPage                 := .F.

   ::cColumnaCampoClave       := "A"

   ::cCodigoProveedor         := "0000001"

   ::hLine                    := {=>}

   ::cError                   := ""

   ::cSuFactura               := ""

   ::nPuntoVerde              := 0

Return ( Self )



static FUNCTION TImportarExcelArguelles_Run( ) ; local Self AS CLASS TImportarExcelArguelles := QSelf() AS CLASS TImportarExcelArguelles

   if !file( ::cFicheroExcel )
      msgStop( "El fichero " + ::cFicheroExcel + " no existe." )
      Return ( .F. )
   end

   msgrun( "Procesando fichero " + ::cFicheroExcel, "Espere por favor...",  {|| ::procesaFicheroExcel() } )

   ::addCabeceraFactura()

   ::addLineasFactura()

   ::addLineaPuntoVerde()

   ::RecalculaFactura()

   MsgInfo( ::cError, "CÃ³digos que no existen" )

   msginfo( "Proceso finalizado" )

Return ( .T. )



static FUNCTION TImportarExcelArguelles_procesaFicheroExcel( ) ; local Self AS CLASS TImportarExcelArguelles := QSelf() AS CLASS TImportarExcelArguelles

   ::oExcel                      := TOleExcel():New( "Importando hoja de excel", "Conectando...", .F. )

   ::oExcel:oExcel:Visible       := .T.
   ::oExcel:oExcel:DisplayAlerts := .F.
   ::oExcel:oExcel:WorkBooks:Open( ::cFicheroExcel )

   while !::lFinPage

      ::procesaHojaExcel()

      ::nContadorPagina               := ::nContadorPagina + 1

   end

   ::oExcel:oExcel:Quit()
   ::oExcel:oExcel:DisplayAlerts := .T.
   ::oExcel:End()

Return nil



static FUNCTION TImportarExcelArguelles_procesaHojaExcel( ) ; local Self AS CLASS TImportarExcelArguelles := QSelf() AS CLASS TImportarExcelArguelles

   if !::lFinPage
      ::oExcel:oExcel:WorkSheets( ::nContadorPagina ):Activate()
   end

   ::addSuFactura()

   if ::nContadorPagina > 2

      ::nPuntoVerde  := ::getExcelNumeric( "AJ", 95 )

   end

   for ::nFila       := ::nFilaInicio to ::nFilaFinal

      if ::lFinPage
         Return nil
      end

      ::procesaLinea()

      ::procesaLote()

      ::hLine     := {=>}

   next

Return nil



static FUNCTION TImportarExcelArguelles_procesaLinea( ) ; local Self AS CLASS TImportarExcelArguelles := QSelf() AS CLASS TImportarExcelArguelles

   local lChangeDto  := .F.

   if Empty( ::getExcelString( "A", ::nFila ) )
      ::lFinPage     := .T.
   end

   hSet( ::hLine, "codigoBaras", ::getExcelString( "A", ::nFila ) )
   hSet( ::hLine, "descripcion", ::getExcelString( "D", ::nFila ) )

   if !Empty( ::getExcelString( "J", ::nFila ) )
      hSet( ::hLine, "unidades", ::getExcelNumeric( "J", ::nFila ) )
   else
      hSet( ::hLine, "unidades", ::getExcelNumeric( "M", ::nFila ) )
   end

   if !Empty( ::getExcelString( "P", ::nFila ) )
      hSet( ::hLine, "preciounitario", ::getExcelNumeric( "P", ::nFila ) )
   else
      hSet( ::hLine, "preciounitario", ::getExcelNumeric( "T", ::nFila ) )
      lChangeDto := .T.
   end

   if !Empty( ::getExcelString( "T", ::nFila ) )
      hSet( ::hLine, "descuento", ( ( ::getExcelNumeric( "T", ::nFila ) * 100 ) / ::getExcelNumeric( "Q", ::nFila ) ) )
   else
      hSet( ::hLine, "descuento", ( ( ::getExcelNumeric( "Y", ::nFila ) * 100 ) / ::getExcelNumeric( "U", ::nFila ) ) )
   end

   hSet( ::hLine, "lote", "" )

   hSet( ::hLine, "caducidad", "" )

   ::nFila    := ::nFila + 1

Return nil



static FUNCTION TImportarExcelArguelles_procesaLote( ) ; local Self AS CLASS TImportarExcelArguelles := QSelf() AS CLASS TImportarExcelArguelles

   local cString
   local hlin
   local hLote
   local aLotes      := ::getLotesLine()

   hLin              := ::hLine

   if Empty( aLotes )

      aadd( ::aLineasPedido, hLin )

   else

      for each hLote in aLotes

         hSet( hLin, "lote", hGet( hLote, "lote" ) )
         hSet( hLin, "unidades", hGet( hLote, "unidades" ) )
         hSet( hLin, "caducidad", hGet( hLote, "caducidad" ) )

         aadd( ::aLineasPedido, hLin )

      next

   end

Return nil



static FUNCTION TImportarExcelArguelles_getLotesLine( ) ; local Self AS CLASS TImportarExcelArguelles := QSelf() AS CLASS TImportarExcelArguelles

   local cString
   local aLotes      := {}

   cString           := ::getExcelString( "H", ::nFila )

   if Empty( cString )
      cString        := ::getExcelString( "I", ::nFila )
   end

   if At( ";", cString ) <> 0

      aLotes   := HB_ATokens( cString, ";" )

   else

      aAdd( aLotes, cString )

   end

Return ::formatArrayLote( aLotes )



static FUNCTION TImportarExcelArguelles_formatArrayLote( aLotes ) ; local Self AS CLASS TImportarExcelArguelles := QSelf() AS CLASS TImportarExcelArguelles

   local cLote
   local hLotes      := {=>}
   local aHashLotes  := {}

   if Empty( aLotes )
      Return ( hLotes )
   end

   for each cLote in aLotes

      hLotes      := {=>}

      hSet( hLotes, "lote", AllTrim( SubStr( cLote, 1, at( "[", cLote ) -1 ) ) )
      hSet( hLotes, "unidades", val( SubStr( cLote, at( "[", cLote ) + 1, ( at( "]", cLote ) ) - ( at( "[", cLote ) + 1 ) ) ) )
      hSet( hLotes, "caducidad", cTod( "01" + AllTrim( SubStr( cLote, at( "]", cLote ) + 1 ) ) ) )

      aAdd( aHashLotes, hLotes )

   end

Return ( aHashLotes )



static FUNCTION TImportarExcelArguelles_addCabeceraFactura( ) ; local Self AS CLASS TImportarExcelArguelles := QSelf() AS CLASS TImportarExcelArguelles

   ::cSerieFactura      := cNewSer( "nFacPrv", D():Contadores( ::nView ) )
   ::cNumeroFactura     := nNewDoc( ::cSerieFactura, D():FacturasProveedores( ::nView ), "NFACPRV", , D():Contadores( ::nView ) )
   ::cSufijoFactura     := Application():CodigoDelegacion()
   ::dFechaFactura      := getSysDate()
   ::cHoraFactura       := getSysTime()

   ( D():FacturasProveedores( ::nView ) )->( dbAppend() )

   ( D():FacturasProveedores( ::nView ) )->CSERFAC       := ::cSerieFactura
   ( D():FacturasProveedores( ::nView ) )->NNUMFAC       := ::cNumeroFactura
   ( D():FacturasProveedores( ::nView ) )->CSUFFAC       := ::cSufijoFactura
   ( D():FacturasProveedores( ::nView ) )->CTURFAC       := cCurSesion()
   ( D():FacturasProveedores( ::nView ) )->DFECFAC       := ::dFechaFactura
   ( D():FacturasProveedores( ::nView ) )->tFecFac       := ::cHoraFactura
   ( D():FacturasProveedores( ::nView ) )->CCODALM       := Application():codigoAlmacen()
   ( D():FacturasProveedores( ::nView ) )->CCODCAJ       := Application():CodigoCaja()
   ( D():FacturasProveedores( ::nView ) )->CDTOESP       := "General"
   ( D():FacturasProveedores( ::nView ) )->CDPP          := "Pronto pago"
   ( D():FacturasProveedores( ::nView ) )->CDIVFAC       := cDivEmp()
   ( D():FacturasProveedores( ::nView ) )->NVDVFAC       := nChgDiv( cDivEmp(), D():Divisas( ::nView ) )
   ( D():FacturasProveedores( ::nView ) )->CCODUSR       := Auth():Codigo()
   ( D():FacturasProveedores( ::nView ) )->nTipRet       := 1
   ( D():FacturasProveedores( ::nView ) )->cCodDlg       := ::cSufijoFactura
   ( D():FacturasProveedores( ::nView ) )->nTotNet       := 0
   ( D():FacturasProveedores( ::nView ) )->nTotIva       := 0
   ( D():FacturasProveedores( ::nView ) )->nTotReq       := 0
   ( D():FacturasProveedores( ::nView ) )->nTotFac       := 0

   ( D():FacturasProveedores( ::nView ) )->CSUPED        := ::cSuFactura

   ( D():FacturasProveedores( ::nView ) )->CCODPRV       := ::cCodigoProveedor

   if ( D():Proveedores( ::nView ) )->( dbSeek( ::cCodigoProveedor  ) )
      ( D():FacturasProveedores( ::nView ) )->CNOMPRV    := ( D():Proveedores( ::nView ) )->Titulo
      ( D():FacturasProveedores( ::nView ) )->CDIRPRV    := ( D():Proveedores( ::nView ) )->Domicilio
      ( D():FacturasProveedores( ::nView ) )->CPOBPRV    := ( D():Proveedores( ::nView ) )->Poblacion
      ( D():FacturasProveedores( ::nView ) )->CPROVPROV  := ( D():Proveedores( ::nView ) )->Poblacion
      ( D():FacturasProveedores( ::nView ) )->CPOSPRV    := ( D():Proveedores( ::nView ) )->CodPostal
      ( D():FacturasProveedores( ::nView ) )->CDNIPRV    := ( D():Proveedores( ::nView ) )->Nif
      ( D():FacturasProveedores( ::nView ) )->CCODPAGO   := ( D():Proveedores( ::nView ) )->fPago
   end

   ( D():FacturasProveedores( ::nView ) )->( dbUnLock() )

Return ( .T. )



static FUNCTION TImportarExcelArguelles_addLineasFactura( ) ; local Self AS CLASS TImportarExcelArguelles := QSelf() AS CLASS TImportarExcelArguelles

   local hLine
   local nRecAntCodeBar
   local nOrdAntCodeBar
   local nRecAntArticulos
   local nOrdAntArticulos
   local cCodigoArticulo

   ::nCount            := 1

   nRecAntArticulos     := ( D():Articulos( ::nView ) )->( recno() )
   nOrdAntArticulos     := ( D():Articulos( ::nView ) )->( OrdSetFocus( "Codigo" ) )

   nRecAntCodeBar       := ( D():ArticulosCodigosBarras( ::nView ) )->( recno() )
   nOrdAntCodeBar       := ( D():ArticulosCodigosBarras( ::nView ) )->( OrdSetFocus( "cCodBar" ) )

   for each hLine in ::aLineasPedido

      if ( D():ArticulosCodigosBarras( ::nView ) )->( dbSeek( hGet( hLine, "codigoBaras" ) ) )

         cCodigoArticulo      := ( D():ArticulosCodigosBarras( ::nView ) )->cCodArt

         ( D():FacturasProveedoresLineas( ::nView ) )->( dbAppend() )

         ( D():FacturasProveedoresLineas( ::nView ) )->CSERFAC       :=  ::cSerieFactura
         ( D():FacturasProveedoresLineas( ::nView ) )->NNUMFAC       :=  ::cNumeroFactura
         ( D():FacturasProveedoresLineas( ::nView ) )->CSUFFAC       :=  ::cSufijoFactura
         ( D():FacturasProveedoresLineas( ::nView ) )->dFecFac       :=  ::dFechaFactura
         ( D():FacturasProveedoresLineas( ::nView ) )->cCodPrv       :=  ::cCodigoProveedor
         ( D():FacturasProveedoresLineas( ::nView ) )->tFecFac       :=  ::cHoraFactura
         ( D():FacturasProveedoresLineas( ::nView ) )->nPosPrint     :=  ::nCount

         ( D():FacturasProveedoresLineas( ::nView ) )->CREF          := cCodigoArticulo

         if ( D():Articulos( ::nView ) )->( dbSeek( cCodigoArticulo ) )

            ( D():FacturasProveedoresLineas( ::nView ) )->CDETALLE   :=  ( D():Articulos( ::nView ) )->Nombre
            ( D():FacturasProveedoresLineas( ::nView ) )->CUNIDAD    :=  ( D():Articulos( ::nView ) )->cUnidad
            ( D():FacturasProveedoresLineas( ::nView ) )->NIVA       :=  nIva( D():TiposIva( ::nView ), ( D():Articulos( ::nView ) )->TipoIva )
            ( D():FacturasProveedoresLineas( ::nView ) )->NCTLSTK    :=  ( D():Articulos( ::nView ) )->NCTLSTOCK
            ( D():FacturasProveedoresLineas( ::nView ) )->CCODFAM    :=  ( D():Articulos( ::nView ) )->Familia

         end

         ( D():FacturasProveedoresLineas( ::nView ) )->NPREUNIT      := hGet( hLine, "preciounitario" )
         ( D():FacturasProveedoresLineas( ::nView ) )->NUNICAJA      := hGet( hLine, "unidades" )
         ( D():FacturasProveedoresLineas( ::nView ) )->nCanEnt       := 1
         ( D():FacturasProveedoresLineas( ::nView ) )->NDTOLIN       := hGet( hLine, "descuento" )
         ( D():FacturasProveedoresLineas( ::nView ) )->CALMLIN       := Application():codigoAlmacen()
         ( D():FacturasProveedoresLineas( ::nView ) )->LLOTE         := .T.
         ( D():FacturasProveedoresLineas( ::nView ) )->cLote         := hGet( hLine, "lote" )
         ( D():FacturasProveedoresLineas( ::nView ) )->NNUMLIN       := ::nCount
         ( D():FacturasProveedoresLineas( ::nView ) )->dFecCad       := hGet( hLine, "caducidad" )

         ( D():FacturasProveedoresLineas( ::nView ) )->( dbUnLock() )

         ::nCount    := ::nCount + 1

      else

         ::cError    += hGet( hLine, "codigoBaras" ) + " - " + hGet( hLine, "descripcion" ) + Chr(13)+Chr(10)

      end

   next

   ( D():Articulos( ::nView ) )->( OrdSetFocus( nOrdAntArticulos ) )
   ( D():Articulos( ::nView ) )->( dbGoTo( nRecAntArticulos ) )

   ( D():ArticulosCodigosBarras( ::nView ) )->( OrdSetFocus( nOrdAntCodeBar ) )
   ( D():ArticulosCodigosBarras( ::nView ) )->( dbGoTo( nRecAntCodeBar ) )

Return ( .T. )



static FUNCTION TImportarExcelArguelles_addLineaPuntoVerde( ) ; local Self AS CLASS TImportarExcelArguelles := QSelf() AS CLASS TImportarExcelArguelles

   ( D():FacturasProveedoresLineas( ::nView ) )->( dbAppend() )

   ( D():FacturasProveedoresLineas( ::nView ) )->CSERFAC       :=  ::cSerieFactura
   ( D():FacturasProveedoresLineas( ::nView ) )->NNUMFAC       :=  ::cNumeroFactura
   ( D():FacturasProveedoresLineas( ::nView ) )->CSUFFAC       :=  ::cSufijoFactura
   ( D():FacturasProveedoresLineas( ::nView ) )->dFecFac       :=  ::dFechaFactura
   ( D():FacturasProveedoresLineas( ::nView ) )->cCodPrv       :=  ::cCodigoProveedor
   ( D():FacturasProveedoresLineas( ::nView ) )->tFecFac       :=  ::cHoraFactura
   ( D():FacturasProveedoresLineas( ::nView ) )->nPosPrint     :=  ::nCount

   ( D():FacturasProveedoresLineas( ::nView ) )->MLNGDES       := "Aporte de punto verde"

   ( D():FacturasProveedoresLineas( ::nView ) )->NPREUNIT      := ::nPuntoVerde
   ( D():FacturasProveedoresLineas( ::nView ) )->NUNICAJA      := 1
   ( D():FacturasProveedoresLineas( ::nView ) )->nCanEnt       := 1
   ( D():FacturasProveedoresLineas( ::nView ) )->CALMLIN       := Application():codigoAlmacen()
   ( D():FacturasProveedoresLineas( ::nView ) )->NNUMLIN       := ::nCount

   ( D():FacturasProveedoresLineas( ::nView ) )->( dbUnLock() )

Return ( .T. )



static FUNCTION TImportarExcelArguelles_recalculaFactura( ) ; local Self AS CLASS TImportarExcelArguelles := QSelf() AS CLASS TImportarExcelArguelles

   local nRec     := ( D():FacturasProveedores( ::nView ) )->( recno() )
   local nOrdAnt  := ( D():FacturasProveedores( ::nView ) )->( OrdSetFocus( "NNUMFAC" ) )

   if ( D():FacturasProveedores( ::nView ) )->( dbSeek( ::cSerieFactura + Str( ::cNumeroFactura ) + ::cSufijoFactura ) )







      GenPgoFacPrv( ::cSerieFactura + Str( ::cNumeroFactura ) + ::cSufijoFactura, D():FacturasProveedores( ::nView ), D():FacturasProveedoresLineas( ::nView ), D():FacturasProveedoresPagos( ::nView ), D():Proveedores( ::nView ), D():TiposIva( ::nView ), D():FormasPago( ::nView ) )

      if dbLock( D():FacturasProveedores( ::nView ) )







         aTotFac                 := aTotFacPrv( ::cSerieFactura + Str( ::cNumeroFactura ) + ::cSufijoFactura, D():FacturasProveedores( ::nView ), D():FacturasProveedoresLineas( ::nView ), D():TiposIva( ::nView ), D():Divisas( ::nView ), D():FacturasProveedoresPagos( ::nView ), ( D():FacturasProveedores( ::nView ) )->cDivFac )

         ( D():FacturasProveedores( ::nView ) )->nTotNet := aTotFac[1]
         ( D():FacturasProveedores( ::nView ) )->nTotIva := aTotFac[2]
         ( D():FacturasProveedores( ::nView ) )->nTotReq := aTotFac[3]
         ( D():FacturasProveedores( ::nView ) )->nTotFac := aTotFac[4]

         ( D():FacturasProveedores( ::nView ) )->( dbUnLock() )

      end

   end

Return ( .T. )



static FUNCTION TImportarExcelArguelles_addSuFactura( ) ; local Self AS CLASS TImportarExcelArguelles := QSelf() AS CLASS TImportarExcelArguelles

   local nPos

   ::cSuFactura      := ::getExcelString( "AI", 42 )

   nPos              := at( ":", ::cSuFactura )

   if nPos <> 0
      ::cSuFactura      := AllTrim( SubStr( ::cSuFactura, nPos + 1 ) )
   end

Return ( .T. )
#line 11 "C:\fw195\Gestool\bin\Script\FacturasProveedores\ImportarExcel.prg"
Function ImportarExcel( nView )

   TImportarExcel():New( nView ):Run()

Return nil



_HB_CLASS TImportarExcel ; function TImportarExcel ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TImportarExcel", iif( .F., { }, { @HBObject() } ), @TImportarExcel() ) ) ;

; _HB_MEMBER { nView } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nView"}, .F. )

; _HB_MEMBER { oExcel } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oExcel"}, .F. )

; _HB_MEMBER { cFicheroExcel } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cFicheroExcel"}, .F. )

; _HB_MEMBER { nFilaInicioImportacion } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nFilaInicioImportacion"}, .F. )

; _HB_MEMBER { cColumnaCampoClave } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cColumnaCampoClave"}, .F. )

   _HB_MEMBER New(); oClass:AddMethod( "New", @TImportarExcel_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Run(); oClass:AddMethod( "Run", @TImportarExcel_Run(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER procesaFicheroExcel(); oClass:AddMethod( "procesaFicheroExcel", @TImportarExcel_procesaFicheroExcel(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER filaValida(); oClass:AddMethod( "filaValida", @TImportarExcel_filaValida(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER siguienteLinea(); oClass:AddInline( "siguienteLinea", {|Self | ( ( Self ) ), ( ++::nFilaInicioImportacion ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getExcelValue(); oClass:AddMethod( "getExcelValue", @TImportarExcel_getExcelValue(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getExcelString(); oClass:AddMethod( "getExcelString", @TImportarExcel_getExcelString(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getExcelNumeric( columna, fila); oClass:AddMethod( "getExcelNumeric", @TImportarExcel_getExcelNumeric(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getExcelLogic( columna, fila); oClass:AddMethod( "getExcelLogic", @TImportarExcel_getExcelLogic(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER openExcel(); oClass:AddMethod( "openExcel", @TImportarExcel_openExcel(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER closeExcel(); oClass:AddMethod( "closeExcel", @TImportarExcel_closeExcel(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER existeRegistro(); oClass:AddInline( "existeRegistro", {|Self | ( ( Self ) ), ( D():gotoArticulos( ::getExcelValue( ::cColumnaCampoClave ), ::nView ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER appendRegistro(); oClass:AddInline( "appendRegistro", {|Self | ( ( Self ) ), ( ( D():Articulos( ::nView ) )->( dbappend() ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER bloqueaRegistro(); oClass:AddInline( "bloqueaRegistro", {|Self | ( ( Self ) ), ( ( D():Articulos( ::nView ) )->( dbrlock() ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER desbloqueaRegistro(); oClass:AddInline( "desbloqueaRegistro", {|Self | ( ( Self ) ), ( ( D():Articulos( ::nView ) )->( dbcommit() ), ( D():Articulos( ::nView ) )->( dbunlock() ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER importarCampos(); oClass:AddMethod( "importarCampos", @TImportarExcel_importarCampos(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TImportarExcel ;



static FUNCTION TImportarExcel_New( nView ) ; local Self AS CLASS TImportarExcel := QSelf() AS CLASS TImportarExcel

   ::nView                    := nView





   ::cFicheroExcel            := "C:\Users\calero\Desktop\Importar.xlsx"





   ::nFilaInicioImportacion   := 7





   ::cColumnaCampoClave       := "A"

Return ( Self )



static FUNCTION TImportarExcel_Run( ) ; local Self AS CLASS TImportarExcel := QSelf() AS CLASS TImportarExcel

   if !file( ::cFicheroExcel )
      msgStop( "El fichero " + ::cFicheroExcel + " no existe." )
      Return ( .F. )
   end



   msgrun(  "Procesando fichero " + ::cFicheroExcel, "Espere por favor...", {|| ::procesaFicheroExcel() } )

   msginfo( "Proceso finalizado" )

Return ( .T. )



static FUNCTION TImportarExcel_openExcel( ) ; local Self AS CLASS TImportarExcel := QSelf() AS CLASS TImportarExcel

   ::oExcel                        := TOleExcel():New( "Importando hoja de excel", "Conectando...", .F. )

   ::oExcel:oExcel:Visible         := .T.
   ::oExcel:oExcel:DisplayAlerts   := .F.
   ::oExcel:oExcel:WorkBooks:Open( ::cFicheroExcel )
   ::oExcel:oExcel:WorkSheets( 1 ):Activate()

Return ( Self )



static FUNCTION TImportarExcel_closeExcel( ) ; local Self AS CLASS TImportarExcel := QSelf() AS CLASS TImportarExcel

   ::oExcel:oExcel:Quit()
   ::oExcel:oExcel:DisplayAlerts := .T.
   ::oExcel:End()

Return ( Self )



static FUNCTION TImportarExcel_procesaFicheroExcel( ) ; local Self AS CLASS TImportarExcel := QSelf() AS CLASS TImportarExcel

   ::oExcel                        := TOleExcel():New( "Importando hoja de excel", "Conectando...", .F. )

   ::oExcel:oExcel:Visible         := .T.
   ::oExcel:oExcel:DisplayAlerts   := .F.
   ::oExcel:oExcel:WorkBooks:Open( ::cFicheroExcel )
   ::oExcel:oExcel:WorkSheets( 1 ):Activate()

   while ( ::filaValida() )

      if ::existeRegistro()
         ::bloqueaRegistro()
      else
         ::appendRegistro()
      end

      if !( neterr() )

         ::importarCampos()

         ::desbloqueaRegistro()

      endif

      ::siguienteLinea()

   end

   ::oExcel:oExcel:Quit()
   ::oExcel:oExcel:DisplayAlerts := .T.
   ::oExcel:End()

Return nil






static FUNCTION TImportarExcel_importarCampos( ) ; local Self AS CLASS TImportarExcel := QSelf() AS CLASS TImportarExcel

   ( D():Articulos( ::nView ) )->Codigo   := ::getExcelValue( "A" )
   ( D():Articulos( ::nView ) )->Nombre   := ::getExcelValue( "B" )

Return nil



static FUNCTION TImportarExcel_filaValida( ) ; local Self AS CLASS TImportarExcel := QSelf() AS CLASS TImportarExcel

Return ( !empty( ::getExcelValue( ::cColumnaCampoClave ) ) )



static FUNCTION TImportarExcel_getExcelValue( columna, fila, valorPorDefecto ) ; local Self AS CLASS TImportarExcel := QSelf() AS CLASS TImportarExcel

   local oBlock
   local oError
   local excelValue

   If( fila == nil, fila := ::nFilaInicioImportacion, ) ;

   oBlock               := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   excelValue           := ::oExcel:oExcel:ActiveSheet:Range( columna + ltrim( str( fila ) ) ):Value

   RECOVER USING oError

   end

   ErrorBlock( oBlock )

   if empty( excelValue )
      Return ( valorPorDefecto )
   end

Return ( excelValue )



static FUNCTION TImportarExcel_getExcelString( columna, fila ) ; local Self AS CLASS TImportarExcel := QSelf() AS CLASS TImportarExcel

   local excelValue
   local valorPorDefecto      := ""

   If( fila == nil, fila := ::nFilaInicioImportacion, ) ;

   excelValue                 := ::getExcelValue( columna, fila, valorPorDefecto )

   if valtype( excelValue ) == "N"
      excelValue              := int( excelValue )
   end

   if valtype( excelValue ) <> "C"
      excelValue              := cvaltochar( excelValue )
   end

   if empty( excelValue )
      Return ( valorPorDefecto )
   end

Return ( excelValue )



static FUNCTION TImportarExcel_getExcelNumeric( columna, fila ) ; local Self AS CLASS TImportarExcel := QSelf() AS CLASS TImportarExcel

   local excelValue
   local valorPorDefecto      := 0

   If( fila == nil, fila := ::nFilaInicioImportacion, ) ;

   excelValue                 := ::getExcelValue( columna, fila, valorPorDefecto )

   if valtype( excelValue ) <> "N"
      excelValue              := strtran( excelValue, ",", "." )
      excelValue              := val( AllTrim( excelValue ) )
   end





Return ( excelValue )



static FUNCTION TImportarExcel_getExcelLogic( columna, fila ) ; local Self AS CLASS TImportarExcel := QSelf() AS CLASS TImportarExcel

   local excelValue
   local valorPorDefecto      := .F.

   If( fila == nil, fila := ::nFilaInicioImportacion, ) ;

   excelValue                 := ::getExcelValue( columna, fila, valorPorDefecto )

   if valtype( excelValue ) == "C"
      excelValue              := ( upper( excelValue ) == "SI" )
   end

   if valtype( excelValue ) == "N"
      excelValue              := ( excelValue == 1 )
   end

   if empty( excelValue )
      Return ( valorPorDefecto )
   end

Return ( excelValue )
