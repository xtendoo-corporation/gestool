#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 26 ".\.\Prg\Almacen.prg"
static bEdit   := { |aTemp, aoGet, dbfAlmT, oBrw, bWhen, bValid, nMode | EdtRec( aTemp, aoGet, dbfAlmT, oBrw, bWhen, bValid, nMode ) }
static bEdit2  := { |aTemp, aoGet, dbfAlmL, oBrw, bWhen, bValid, nMode, cCodAlm | EdtDet( aTemp, aoGet, dbfAlmL, oBrw, bWhen, bValid, nMode, cCodAlm ) }



static oWndBrw

static dbfAlmT
static dbfAlmL
static dbfAgent
static dbfTmp

static cNewFile

static oTreePadre





FUNCTION Almacen( oMenuItem, oWnd )

   local nLevel

   If( oMenuItem == nil, oMenuItem := "01035", ) ;
   If( oWnd == nil, oWnd := oWnd(), ) ;

    IF oWndBrw == NIL





      nLevel            := Auth():Level( oMenuItem )
      if nAnd( nLevel, 1 ) == 0
         msgStop( "Acceso no permitido." )
         RETURN nil
      end





      if oWnd <> nil
         SysRefresh(); oWnd:CloseAll(); SysRefresh()
      end





      if !lOpenFiles()
         RETURN nil
      end





      AddMnuNext( "Almacen", ProcName() )














      oWndBrw := TShell():New( 2, 10, 18, 70, "Almacén",, oWnd,,, .F.,,, ( dbfAlmT ),,,,, {"Código",    "Nombre"}, {||( WinAppRec( oWndBrw:oBrw, bEdit, dbfAlmT ) )}, {||( WinEdtRec( oWndBrw:oBrw, bEdit, dbfAlmT ) )}, {||( DBDelRec(  oWndBrw:oBrw, dbfAlmT ) )}, {||( WinDupRec( oWndBrw:oBrw, bEdit, dbfAlmT ) )}, nil, nLevel, "gc_package_16", ( 128 + ( 57 * 256 ) + ( 123 * 65536 ) ),,, .T. )

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodAlm"
         :bEditValue       := {|| ( dbfAlmT )->cCodAlm }
         :nWidth           := 120
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cNomAlm"
         :bEditValue       := {|| ( dbfAlmT )->cNomAlm }
         :nWidth           := 280
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Domicilio"
         :bEditValue       := {|| ( dbfAlmT )->cDirAlm }
         :nWidth           := 280
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Código postal"
         :bEditValue       := {|| ( dbfAlmT )->cPosAlm }
         :nWidth           := 60
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Población"
         :bEditValue       := {|| ( dbfAlmT )->cPobAlm }
         :nWidth           := 180
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Provincia"
         :bEditValue       := {|| ( dbfAlmT )->cProAlm }
         :nWidth           := 140
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Padre"
         :bEditValue       := {|| ( dbfAlmT )->cComAlm }
         :nWidth           := 120
         :lHide            := .F.
      end

      oWndBrw:cHtmlHelp    := "Almacen"

      oWndBrw:CreateXFromCode()





      oWndBrw:NewAt( "BUS",,, {||( oWndBrw:SearchSetFocus() )}, "(B)uscar", "B",,,,, .F. )

      oWndBrw:AddSeaBar()








      oWndBrw:NewAt( "NEW",,, {||( oWndBrw:RecAdd() )}, "(A)ñadir", "A",,, 2,, .F. )







      oWndBrw:NewAt( "DUP",,, {||( oWndBrw:RecDup() )}, "(D)uplicar", "D",,, 2,, .F. )







        oWndBrw:NewAt( "EDIT",,, {||( oWndBrw:RecEdit() )}, "(M)odificar", "M",,, 4,, .F. )







        oWndBrw:NewAt( "ZOOM",,, {||( WinZooRec( oWndBrw:oBrw, bEdit, dbfAlmT ) )}, "(Z)oom", "Z",,, 8,, .F. )







        oWndBrw:NewAt( "DEL",,, {||( oWndBrw:RecDel() )}, "(E)liminar", "E",,, 16,, .F. )






      oWndBrw:NewAt( "IMP",,, {||( InfAlm():New( "Listado de almacenes" ):Play() )}, "(L)istado", "L",,, 32,, .F. )





      oWndBrw:NewAt( "END",,, {||( oWndBrw:End() )}, "(S)alir", "S",,,,, .F. )

        oWndBrw:Activate(, oWndBrw:bLClicked, oWndBrw:bRClicked, oWndBrw:bMoved, oWndBrw:bResized, oWndBrw:bPainted, oWndBrw:bKeyDown, oWndBrw:bInit,,,,,,,,, {|| ( CloseFiles() )},, oWndBrw:bLButtonUp, .F. )

    ELSE

        oWndBrw:SetFocus()

    end

RETURN NIL



STATIC FUNCTION EdtRec( aTemp, aoGet, dbfAlmT, oBrw, bWhen, bValid, nMode )

    local oDlg
   local oGet
   local oGet2
    local oBrw2
   local cCodCli
   local oCodCli
   local oFld
   local oBmpGeneral

   BeginTrans( aTemp )

   if nMode == 1
      aTemp[ 12 ]  := win_uuidcreatestring()
   end

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "Almacén", "ALMACEN",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )








      oFld := TFolder():ReDefine( 100, {"&General", "&Facturación y agentes"}, { "ALMACEN_01","ALMACEN_02" }, oDlg,,,,, .F., )




      oBmpGeneral := TBitmap():ReDefine( 990, "gc_package_48",, oFld:aDialogs[1],,, .F., .F.,,, .F.,,, .T. )





      oBmpGeneral := TBitmap():ReDefine( 990, "gc_businessman2_48",, oFld:aDialogs[2],,, .F., .F.,,, .F.,,, .T. )






      oGet := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTemp[ 1 ], aTemp[ 1 ]:= u ) }, oFld:aDialogs[1],, "@!", {||    ( NotValid( oGet, dbfAlmT, .F. ) )},,,,,, .F., {||     ( nMode == 1 .OR. nMode == 4 )},, .F., .F.,,,,,, nil,,, )





      oGet2 := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTemp[ 2 ], aTemp[ 2 ]:= u ) }, oFld:aDialogs[1],,,, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





        TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTemp[ 3 ], aTemp[ 3 ]:= u ) }, oFld:aDialogs[1],, "@!",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )




        TGetHlp():ReDefine( 130, { | u | If( PCount()==0, aTemp[ 4 ], aTemp[ 4 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )




        TGetHlp():ReDefine( 140, { | u | If( PCount()==0, aTemp[ 5 ], aTemp[ 5 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )




        TGetHlp():ReDefine( 150, { | u | If( PCount()==0, aTemp[ 6 ], aTemp[ 6 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





        TGetHlp():ReDefine( 160, { | u | If( PCount()==0, aTemp[ 7 ], aTemp[ 7 ]:= u ) }, oFld:aDialogs[1],, "@R ##########",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





        TGetHlp():ReDefine( 170, { | u | If( PCount()==0, aTemp[ 8 ], aTemp[ 8 ]:= u ) }, oFld:aDialogs[1],, "@R ##########",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )




        TGetHlp():ReDefine( 180, { | u | If( PCount()==0, aTemp[ 9 ], aTemp[ 9 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )



      oTreePadre                     := TTreeView():Redefine( 200, oFld:aDialogs[1] )
      oTreePadre:bItemSelectChanged  := {|| ChangeTreeState() }









      aoGet[ 10 ] := TGetHlp():ReDefine( 190, { | u | If( PCount()==0, aTemp[ 10 ], aTemp[ 10 ]:= u ) }, oFld:aDialogs[2],,, {||    ( cClient( aoGet[ 10 ], , oCodCli ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwClient( aoGet[ 10 ], oCodCli ) )}, nil, "LUPA",, )




      oCodCli := TGetHlp():ReDefine( 200, { | u | If( PCount()==0, cCodCli, cCodCli:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )

      oBrw2                := IXBrowse():New( oFld:aDialogs[2] )

      oBrw2:bClrSel        := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw2:bClrSelFocus   := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw2:cAlias         := dbfTmp
      oBrw2:nMarqueeStyle  := 5

      with object ( oBrw2:AddCol() )
         :cHeader          := "Código"
         :bEditValue       := {|| ( dbfTmp )->cCodAge }
         :nWidth           := 120
      end

      with object ( oBrw2:AddCol() )
         :cHeader          := "Agente"
         :bEditValue       := {|| RetNbrAge( ( dbfTmp )->cCodAge, dbfAgent ) }
         :nWidth           := 550
      end

      oBrw2:bLDblClick     := {|| oDlg:end( 1 ) }

      oBrw2:CreateFromResource( 210 )

      if nMode <> 3
         oBrw2:bLDblClick  := {|| EdtDeta( oBrw2, bEdit2, aTemp ) }
      end





      TButton():ReDefine( 500, {||( AppDeta( oBrw2, bEdit2, aTemp) )}, oFld:aDialogs[2],,, .F., {||         ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 501, {||( EdtDeta( oBrw2, bEdit2, aTemp ) )}, oFld:aDialogs[2],,, .F., {||         ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 502, {||( DelDeta( oBrw2, aTemp ) )}, oFld:aDialogs[2],,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 524, {||( DbSwapUp( dbfTmp, oBrw2 ) )}, oFld:aDialogs[2],,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 525, {||( DbSwapDown( dbfTmp, oBrw2 ) )}, oFld:aDialogs[2],,, .F., {||         ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 1, {||( EndTrans( aTemp, aoGet, dbfAlmT, oBrw, nMode, oDlg, oGet, oGet2 ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

      if nMode <> 3
         oFld:aDialogs[2]:AddFastKey( 113, {|| AppDeta( oBrw2, bEdit2, aTemp) } )
         oFld:aDialogs[2]:AddFastKey( 114, {|| EdtDeta( oBrw2, bEdit2, aTemp ) } )
         oFld:aDialogs[2]:AddFastKey( 115, {|| DelDeta( oBrw2, aTemp ) } )
         oDlg:AddFastKey( 116, {|| if( nMode == 4, if( oGet:lValid(), EndTrans( aTemp, aoGet, dbfAlmT, oBrw, nMode, oDlg, oGet, oGet2 ), ), EndTrans( aTemp, aoGet, dbfAlmT, oBrw, nMode, oDlg, oGet, oGet2 ) ) } )
      end

   oDlg:bStart    := {|| StartEdtRec( aTemp ) }

    oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted := {|hDC,cPS|( EvalGet( aoGet ) )}, .T.,,,, oDlg:bRClicked,,, )





   oBmpGeneral:End()

   KillTrans( oBrw2 )

RETURN ( oDlg:nResult == 1 )



Static Function StartEdtRec( aTemp )

   LoadTree()

   SetTreeState( , , aTemp[ 11 ] )

RETURN nil



Static Function BeginTrans( aTemp )

   local cDbf     := "TAlmL"
    local cCodAlm    := aTemp[ ( dbfAlmT )->( FieldPos( "CCODALM" ) ) ]

   cNewFile       := cGetNewFileName( cPatTmp() + cDbf )





   dbCreate( cNewFile, aSqlStruct( aItmAlmAgente() ), cLocalDriver() )
   dbUseArea( .T., cLocalDriver(), cNewFile, cCheckArea( cDbf, @dbfTmp ), .F. )

   if !( dbfTmp )->( neterr() )
      ( dbfTmp )->( OrdCondSet( "!Deleted()", {||!Deleted() } ) )
      ( dbfTmp )->( OrdCreate( cNewFile, "Recno", "Str( Recno() )", {|| Str( Recno() ) } ) )





      if ( dbfAlmL )->( dbSeek( cCodAlm ) )

         while ( ( dbfAlmL )->CCODALM == cCodAlm .AND. !( dbfAlmL )->( Eof() ) )
            dbPass( dbfAlmL, dbfTmp, .T. )
            ( dbfAlmL )->( DbSkip() )
         end

      end

      ( dbfTmp )->( dbGoTop() )

   end

RETURN nil







STATIC FUNCTION AppDeta( oBrw, bEdit2, aTemp )

RETURN WinAppRec( oBrw, bEdit2, dbfTmp, , , aTemp[(dbfAlmT)->( FieldPos( "CCODALM" ) )] )







STATIC FUNCTION EdtDeta( oBrw, bEdit2, aTemp )

RETURN WinEdtRec( oBrw, bEdit2, dbfTmp )







STATIC FUNCTION DelDeta( oBrw )

RETURN DBDelRec( oBrw, dbfTmp )



STATIC FUNCTION EndTrans( aTemp, aoGet, dbfAlmT, oBrw, nMode, oDlg, oGet, oGet2 )

   local oError
   local oBlock
   local aTabla
   local cCodAlm  := aTemp[ ( dbfAlmT )->( FieldPos( "CCODALM" ) ) ]

   if nMode == 1 .OR. nMode == 4

      if Empty( aTemp[ 1 ] )
         MsgStop( "El código del almacén no puede estar vacío." )
         oGet:SetFocus()
         RETURN nil
      end

      if dbSeekInOrd( aTemp[ 1 ], "CCODALM", dbfAlmT )
         MsgStop( "Código ya existe " + Rtrim( aTemp[ 1 ] ) )
         RETURN nil
      end

   end

   if Empty( aTemp[ 2 ] )
      MsgStop( "El nombre del almacén no puede estar vacío." )
      oGet2:SetFocus()
      RETURN nil
   end



   aTemp[ 11 ]        := ""

   GetTreeState( aTemp )

   if ( aTemp[ 11 ] == aTemp[ 1 ] )
      MsgStop( "Almacén padre no puede ser el mismo" )
      oTreePadre:SetFocus()
      RETURN nil
   end

   if aScan( aChildAlmacen( aTemp[ 1 ] ), aTemp[ 11 ] ) <> 0
      MsgStop( "Almacén padre contiene referencia circular" )
      oTreePadre:SetFocus()
      RETURN nil
   end





   CursorWait()

   oBlock      := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   BeginTransaction()

   oDlg:Disable()





   while ( dbfAlmL )->( dbSeek( cCodAlm ) )
      if ( dbfAlmL )->( dbRLock() )
         ( dbfAlmL )->( dbDelete() )
         ( dbfAlmL )->( dbUnLock() )
      end
   end





    ( dbfTmp )->( DbGoTop() )
   while ( dbfTmp )->( !Eof() )

      aTabla                                          := DBScatter( dbfTmp )
      aTabla[( dbfAlmL )->( FieldPos( "CCODALM" ) )]  := cCodAlm
        ( dbfAlmL )->( dbAppend() )
        DBGather( aTabla, dbfAlmL )
        ( dbfTmp )->( dbSkip() )

   end

   WinGather( aTemp, aoGet, dbfAlmT, oBrw, nMode )





   dbCommitAll()

   CommitTransaction()

   RECOVER USING oError

      RollBackTransaction()
      msgStop( "Imposible eliminar datos anteriores" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end
   ErrorBlock( oBlock )

   oDlg:Enable()

   oDlg:end( 1 )

   CursorWe()

RETURN nil



STATIC FUNCTION KillTrans( oBrw2 )





    ( dbfTmp )->( dbCloseArea() )
   dbfErase( cNewFile )

RETURN .T.




STATIC FUNCTION EdtDet( aTemp, aoGet, dbfTmp, oBrw, bWhen, bValid, nMode, cCodAlm )

    local oDlg
    local oGet
    local oGetTxt
    local cGetTxt

    IF nMode == 1
        aTemp[ (dbfAlmL)->( FieldPos( "CCODALM" ) ) ] := cCodAlm
    end

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "Agentes relacionados", "AGEALM",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )








        oGet := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTemp[ (dbfAlmL)->( FieldPos( "CCODAGE" ) ) ], aTemp[ (dbfAlmL)->( FieldPos( "CCODAGE" ) ) ]:= u ) }, oDlg,,, {||     ( cAgentes( oGet, dbfAgent, oGetTxt ) )}, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( BrwAgentes( oGet, oGetTxt ) )}, nil, "LUPA",, )





        oGetTxt := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, cGetTxt, cGetTxt:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||         ( .F. )},, .F., .F.,,,,,, nil,,, )





      TButton():ReDefine( 1, {||( lPreSave( aTemp, aoGet, dbfTmp, oBrw, nMode, oDlg, oGet ) )}, oDlg,,, .F., {||         (     nMode <> 3 )},,, .F. )





        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| lPreSave( aTemp, aoGet, dbfTmp, oBrw, nMode, oDlg, oGet ) } )
   end

    oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted := {|hDC,cPS|( oGet:lValid() )}, .T.,,,, oDlg:bRClicked,,, )

RETURN ( oDlg:nResult == 1 )



Static Function lPreSave( aTemp, aoGet, dbfTmp, oBrw, nMode, oDlg, oGet )

   if Empty( aTemp[ (dbfAlmL)->( FieldPos( "CCODAGE" ) ) ] )
      MsgStop( "El código del agente no puede estar vacío" )
      oGet:SetFocus()
      RETURN nil
   end

   WinGather( aTemp, aoGet, dbfTmp, oBrw, nMode )

RETURN ( oDlg:end( 1 ) )



FUNCTION RetAlmacen( cCodAlm, dbfAlmT )

   local oBlock
   local oError
    local cAlmacen     := ""
   local lClose      := .F.

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

    IF dbfAlmT == NIL
      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALMACEN.DBF" ), ( cCheckArea( "ALMACEN", @dbfAlmT ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ALMACEN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClose         := .T.
    end

   do case
      case Valtype( dbfAlmT ) == "C"

         if ( dbfAlmT )->( DbSeek( cCodAlm ) )
            cAlmacen       := ( dbfAlmT )->cNomAlm
         end

      case Valtype( dbfAlmT ) == "O"

         if dbfAlmT:Seek( cCodAlm )
            cAlmacen       := dbfAlmT:cNomAlm
         end

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos de almacenes" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

    IF lClose
        ( dbfAlmT )->( dbCloseArea() )
    end

RETURN cAlmacen






FUNCTION RetCliAlm( cCodAlm, dbfAlmT )

   local oBlock
   local oError
    local cAlmacen     := ""
   local lClose      := .F.

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if dbfAlmT == nil
      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALMACEN.DBF" ), ( cCheckArea( "ALMACEN", @dbfAlmT ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ALMACEN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClose         := .T.
   end

   if ( dbfAlmT )->( dbSeek( cCodAlm ) )
      cAlmacen       := ( dbfAlmT)->cCodCli
   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos de agentes" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClose
      ( dbfAlmT )->( dbCloseArea() )
   end

RETURN cAlmacen



FUNCTION aItmAlm()

   local aItmAlm  := {}

   aAdd( aItmAlm, { "cCodAlm",  "C",     16,     0, "Código de almacen"              ,  "",   "", "( cDbfAlm )" } )
   aAdd( aItmAlm, { "cNomAlm",  "C",    100,     0, "Nombre de almacen"              ,  "",   "", "( cDbfAlm )" } )
   aAdd( aItmAlm, { "cDirAlm",  "C",     50,     0, "Domicilio de almacen"           ,  "",   "", "( cDbfAlm )" } )
   aAdd( aItmAlm, { "cPosAlm",  "C",      7,     0, "Código postal de almacen"       ,  "",   "", "( cDbfAlm )" } )
   aAdd( aItmAlm, { "cPobAlm",  "C",     30,     0, "Población de almacen"           ,  "",   "", "( cDbfAlm )" } )
   aAdd( aItmAlm, { "cProAlm",  "C",     20,     0, "Provincia de almacen"           ,  "",   "", "( cDbfAlm )" } )
   aAdd( aItmAlm, { "cTfnAlm",  "C",     12,     0, "Teléfono de almacen"            ,  "",   "", "( cDbfAlm )" } )
   aAdd( aItmAlm, { "cFaxAlm",  "C",     12,     0, "Fax de almacen"                 ,  "",   "", "( cDbfAlm )" } )
   aAdd( aItmAlm, { "cPerAlm",  "C",     50,     0, "Persona de contacto de almacen" ,  "",   "", "( cDbfAlm )" } )
   aAdd( aItmAlm, { "cCodCli",  "C",     12,     0, "Codigo del cliente"             ,  "",   "", "( cDbfAlm )" } )
   aAdd( aItmAlm, { "cComAlm",  "C",     16,     0, "Código de almacen padre"        ,  "",   "", "( cDbfAlm )" } )
   aAdd( aItmAlm, { "Uuid",     "C",     40,     0, "Uuid"                           ,  "",   "", "( cDbfAlm )" } )

RETURN ( aItmAlm )



Function aItmAlmAgente()

   local aItmAlmAgente  := {}

   aAdd( aItmAlmAgente, { "CCODALM",  "C",     16,     0, "" } )
   aAdd( aItmAlmAgente, { "CCODAGE",  "C",      3,     0, "" } )

RETURN aItmAlmAgente





Function cGetUbica( cCodAlm, dbfAlm, nNumUbica )

   local cNomUbica := ""

RETURN cNomUbica



Function SelectAlmacen()

   local oDlg
   local oBrw
   local oBmp
   local oGetBuscar
   local cGetBuscar     := Space( 100 )
   local oCbxOrden
   local cCbxOrden      := "Código"

   if !lOpenFiles()
      RETURN .F.
   end




   oDlg = TDialog():New(,,,, "Seleccionar almacén", "SelectItem",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )




      oBmp := TBitmap():ReDefine( 300, "gc_package_48",, oDlg,,, .F., .F.,,, .F.,,, .T. )






      oGetBuscar := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, cGetBuscar, cGetBuscar:= u ) }, oDlg,,,,,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, dbfAlmT, nil, nil, .F. ) ) }, .F., .F.,,,,,, nil, "FIND",, )






      oCbxOrden := TComboBox():ReDefine( 110, { | u | If( PCount()==0, cCbxOrden, cCbxOrden:= u ) }, { "Código", "Nombre" }, oDlg,,, {|Self|( ( dbfAlmT )->( OrdSetFocus( oCbxOrden:nAt ) ), oBrw:Refresh(), oGetBuscar:SetFocus() )},,,, .F.,,,,,,, "oCbxOrden",,,,,,, )

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:cAlias          := dbfAlmT
      oBrw:nMarqueeStyle   := 5

      with object ( oBrw:AddCol() )
         :cHeader          := "Código"
         :bEditValue       := {|| ( dbfAlmT )->cCodAlm }
         :cSortOrder       := "cCodAlm"
         :nWidth           := 40
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Nombre"
         :bEditValue       := {|| ( dbfAlmT )->cNomAlm }
         :cSortOrder       := "cNomAlm"
         :nWidth           := 200
      end

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }

      oBrw:CreateFromResource( 200 )




      TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )





      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )
   oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if oDlg:nResult == 1
      Application():setAlmacen( ( dbfAlmT )->Uuid, ( dbfAlmT )->cCodAlm )
   else

      MsgInfo( "No seleccionó ningún almacén, se establecerá el almacén por defecto." + Chr(13)+Chr(10) +  "Almacén actual, " + Application():codigoAlmacen() )
   end

   CloseFiles()

   if oBmp <> nil
      oBmp:End()
   end

RETURN ( oDlg:nResult == 1 )






























_HB_CLASS pdaAlmacenSenderReciver ; function pdaAlmacenSenderReciver ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "pdaAlmacenSenderReciver", iif( .F., { }, { @HBObject() } ), @pdaAlmacenSenderReciver() ) ) ;

   _HB_MEMBER CreateData(); oClass:AddMethod( "CreateData", @pdaAlmacenSenderReciver_CreateData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS pdaAlmacenSenderReciver ;







static FUNCTION pdaAlmacenSenderReciver_CreateData( oPgrActual, oSayStatus, cPatPreVenta ) ; local Self AS CLASS pdaAlmacenSenderReciver := QSelf() AS CLASS pdaAlmacenSenderReciver

   local oBlock
   local oError
   local dbfAlm
   local tmpAlm
   local lExist      := .F.
   local cFileName
   local cPatPc      := if( Empty( cPatPreVenta ), cPatPc(), cPatPreVenta )

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "Almacen.Dbf" ), ( cCheckArea( "Almacen", @dbfAlm ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "Almacen.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

   dbUseArea( .T., cDriver(), cPatPc + "Almacen.Dbf", cCheckArea( "Almacen", @tmpAlm ), .T. )
   ( tmpAlm )->( ordListAdd( cPatPc + "Almacen.Cdx" ) )

   if !Empty( oPgrActual )
      oPgrActual:SetRange( 0, ( tmpAlm )->( OrdKeyCount() ) )
   end

   ( tmpAlm )->( dbGoTop() )
   while !( tmpAlm )->( eof() )

         if ( dbfAlm )->( dbSeek( ( tmpAlm )->cCodAlm ) )
            dbPass( tmpAlm, dbfAlm, .F. )
         else
            dbPass( tmpAlm, dbfAlm, .T. )
         end

         ( tmpAlm )->( dbSkip() )

         if !Empty( oSayStatus )
            oSayStatus:SetText( "Sincronizando Almacenes " + Alltrim( Str( ( tmpAlm )->( OrdKeyNo() ) ) ) + " de " + Alltrim( Str( ( tmpAlm )->( OrdKeyCount() ) ) ) )
         end

      SysRefresh()

      if !Empty( oPgrActual )
         oPgrActual:SetPos( ( tmpAlm )->( OrdKeyNo() ) )
      end

      SysRefresh()

   end

   ( tmpAlm )->( dbCloseArea() )
   ( dbfAlm )->( dbCloseArea() )

RETURN ( Self )

function IsAlmacen( cPatEmp )

   local oBlock
   local oError

   local dbfAlmT
   local lIsAlmacen  := .F.

   If( cPatEmp == nil, cPatEmp := cPatEmp(), ) ;

   if !lExistTable( cPatEmp + "Almacen.Dbf" ) .OR. !lExistTable( cPatEmp + "AlmacenL.Dbf" )
      mkAlmacen()
   end

   if !lExistIndex( cPatEmp + "Almacen.Cdx" ) .OR. !lExistIndex( cPatEmp + "AlmacenL.Cdx" )
      rxAlmacen()
   end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatEmp + "ALMACEN.DBF" ), ( cCheckArea( "ALMACEN", @dbfAlmT ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
   if !lAIS() ; ordListAdd( ( cPatEmp + "ALMACEN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   if ( dbfAlmT )->( ordKeyCount() ) == 0
      ( dbfAlmT )->( dbAppend() )
      ( dbfAlmT )->cCodAlm := "000"
      ( dbfAlmT )->cNomAlm := "Almacén principal"
      ( dbfAlmT )->( dbUnLock() )
   end

   lIsAlmacen        := .T.

   ( dbfAlmT )->( dbCloseArea() )

   RECOVER USING oError

      msgStop( "Imposible abrir base de datos de almacenes" + Chr(13)+Chr(10) + ErrorMessage( oError )  )

   end

   ErrorBlock( oBlock )

RETURN ( lIsAlmacen )



FUNCTION mkAlmacen( cPath, lAppend, cPathOld, oMeter )

   If( cPath == nil, cPath := cPatEmp(), ) ;
    If( lAppend == nil, lAppend := .F., ) ;

    IF oMeter <> NIL
        oMeter:cText    := "Generando Bases"
        sysrefresh()
    end

   IF !lExistTable( cPath + "ALMACEN.DBF" )
      dbCreate( cPath + "ALMACEN.DBF", aSqlStruct( aItmAlm() ), cDriver() )
    end

   IF !lExistTable( cPath + "ALMACENL.DBF" )
      dbCreate( cPath + "ALMACENL.DBF", aSqlStruct( aItmAlmAgente() ), cDriver() )
    end

    rxAlmacen( cPath, oMeter )

    IF lAppend .AND. lIsDir( cPathOld )
      AppDbf( cPathOld, cPath, "ALMACEN" )
    end

    IF lAppend .AND. lIsDir( cPathOld )
      AppDbf( cPathOld, cPath, "ALMACENL" )
    end

RETURN .T.



FUNCTION rxAlmacen( cPath, oMeter )

    local dbfAlmT
    local dbfAlmL

   If( cPath == nil, cPath := cPatEmp(), ) ;

   IF !lExistTable( cPath + "ALMACEN.DBF" )
      dbCreate( cPath + "ALMACEN.DBF", aSqlStruct( aItmAlm() ), cDriver() )
    end

   fEraseIndex( cPath + "ALMACEN.CDX" )

   dbUseArea( .T., cDriver(), cPath + "ALMACEN.DBF", cCheckArea( "ALMACEN", @dbfAlmT ), .F. )

   if !( dbfAlmT )->( neterr() )
      ( dbfAlmT )->( __dbPack() )

      ( dbfAlmT )->( ordCondSet( "!Deleted()", {|| !Deleted() } ) )
      ( dbfAlmT )->( ordCreate( cPath + "ALMACEN.CDX", "CCODALM", "CCODALM", {|| Field->cCodAlm } ) )

      ( dbfAlmT )->( ordCondSet( "!Deleted()", {|| !Deleted() } ) )
      ( dbfAlmT )->( ordCreate( cPath + "ALMACEN.CDX", "CNOMALM", "Upper( CNOMALM )", {|| Upper( Field->cNomAlm ) }, ) )

      ( dbfAlmT )->( ordCondSet( "!Deleted()", {|| !Deleted() } ) )
      ( dbfAlmT )->( ordCreate( cPath + "ALMACEN.CDX", "CCOMALM", "CCOMALM", {|| Field->cComAlm } ) )

      ( dbfAlmT )->( dbeval( {|| Field->uuid := win_uuidcreatestring() }, {|| empty( field->uuid ) } ) )

      ( dbfAlmT )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de almacenes" )
   end

   IF !lExistTable( cPath + "ALMACENL.DBF" )
      dbCreate( cPath + "ALMACENL.DBF", aSqlStruct( aItmAlmAgente() ), cDriver() )
    end

   fErase( cPath + "ALMACENL.CDX" )

   dbUseArea( .T., cDriver(), cPath + "ALMACENL.DBF", cCheckArea( "ALMACENL", @dbfAlmL ), .F. )

   if !( dbfAlmL )->( neterr() )
      ( dbfAlmL )->( __dbPack() )

      ( dbfAlmL )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfAlmL )->( ordCreate( cPath + "ALMACENL.CDX", "CCODALM", "CCODALM", {|| Field->cCodAlm } ) )

      ( dbfAlmL )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de almacenes" )
   end

RETURN NIL



Function cSeekStoreView( cCodigoAlmacen, nView )

   if dbSeekInOrd( cCodigoAlmacen, "cCodAlm", D():Almacen( nView ) )
      RETURN .T.
   end

RETURN ( .F. )



Function lValidAlmacen( cCodigoAlmacen, dbfAlmacen )

   if !( dbfAlmacen )->( dbSeekInOrd( cCodigoAlmacen, "cCodAlm",  dbfAlmacen ) )
      msgStop( "Almacén no encontrado" )
      RETURN .F.
   end

RETURN ( .T. )



FUNCTION cAlmacen( oGet, dbfAlmT, oGet2 )

   local oBlock
   local oError
   local lClose   := .F.
   local lValid   := .F.
   local xValor   := oGet:VarGet()

   if Empty( xValor ) .OR. ( xValor == Replicate( "Z", 16 ) )
      if( oGet2 <> nil, oGet2:cText( "" ), )
      RETURN .T.
   end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if dbfAlmT == nil
      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALMACEN.DBF" ), ( cCheckArea( "ALMACEN", @dbfAlmT ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ALMACEN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClose      := .T.
   end

   do case
      case Valtype( dbfAlmT ) == "C"

         if ( dbfAlmT )->( dbSeek( xValor ) )
            oGet:cText( ( dbfAlmT )->cCodAlm )
            if( oGet2 <> nil, oGet2:cText( ( dbfAlmT )->cNomAlm ), )
            lValid   := .T.
         else
            oGet:Refresh()
            msgStop( "Almacén no encontrado" )
         end

      case Valtype( dbfAlmT ) == "O"

         if dbfAlmT:Seek( xValor )
            oGet:cText( dbfAlmT:cCodAlm )

            if oGet2 <> nil
               oGet2:cText( dbfAlmT:cNomAlm )
            end

            lValid   := .T.
         else
            oGet:Refresh()
            msgStop( "Almacén no encontrado" )
         end

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos de almacenes" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClose
      ( dbfAlmT )->( dbCloseArea() )
   end

RETURN lValid



FUNCTION BrwAlmacen( oGet, oGet2, lBigStyle )

    local oDlg
    local oBrw
   local oFont
   local oBtn
    local oGet1
    local cGet1
   local nOrdAnt        := GetBrwOpt( "BrwAlmacen" )
    local oCbxOrd
   local aCbxOrd        := { "Código", "Nombre" }
   local cCbxOrd
   local nLevel         := Auth():Level( "01035" )
   local oSayText
   local cSayText       := "Listado de almacenes"
   local cRETURN        := ""

   nOrdAnt              := Min( Max( nOrdAnt, 1 ), len( aCbxOrd ) )
   cCbxOrd              := aCbxOrd[ nOrdAnt ]

   If( lBigStyle == nil, lBigStyle := .F., ) ;

   if lOpenFiles()

      nOrdAnt           := ( dbfAlmT )->( OrdSetFocus( nOrdAnt ) )

      ( dbfAlmT )->( dbGoTop() )

   if lBigStyle

      oDlg = TDialog():New(,,,, "Seleccionar almacén", "BIGHELPENTRY",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )






      oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,, {||    ( OrdClearScope( oBrw, dbfAlmT ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, dbfAlmT ) ) }, .F., .F.,,,,,, nil, "FIND",, )

   else

      oDlg = TDialog():New(,,,, "Seleccionar almacén", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )






      oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,, {||    ( OrdClearScope( oBrw, dbfAlmT ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, dbfAlmT ) ) }, .F., .F.,,,,,, nil, "FIND",, )

   end






        oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,, {|Self|( ( dbfAlmT )->( OrdSetFocus( oCbxOrd:nAt ) ), oBrw:refresh(), oGet1:SetFocus(), oCbxOrd:refresh() )},,,, .F.,,,,,,, "oCbxOrd",,,,,,, )

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:cAlias          := dbfAlmT
      oBrw:nMarqueeStyle   := 5
      oBrw:cName           := "Browse.Almacen"

      with object ( oBrw:AddCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodAlm"
         :bEditValue       := {|| ( dbfAlmT )->cCodAlm }
         :nWidth           := 140
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cNomAlm"
         :bEditValue       := {|| ( dbfAlmT )->cNomAlm }
         :nWidth           := 280
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Domicilio"
         :cSortOrder       := "cDirAlm"
         :bEditValue       := {|| ( dbfAlmT )->cDirAlm }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }
      oBrw:bRClicked       := {| nRow, nCol, nFlags | oBrw:RButtonDown( nRow, nCol, nFlags ) }

      oBrw:CreateFromResource( 105 )

      if lBigStyle
         oBrw:nHeaderHeight   := 36
         oBrw:nFooterHeight   := 36
         oBrw:nLineHeight     := 36
      end

      if ( "PDA" $ appParamsMain() )



         oSayText := TSay():ReDefine( 100, {|| cSayText}, oDlg,,,, .F.,, .F., .F., )

      end




        TButton():ReDefine( 1, {||( oDlg:end(1) )}, oDlg,,, .F.,,,, .F. )





        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

      if !( "PDA" $ appParamsMain() )





        TButton():ReDefine( 500, {||( WinAppRec( oBrw, bEdit, dbfAlmT ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 2 ) <> 0 .AND. !IsReport() )},,, .F. )





        TButton():ReDefine( 501, {||( WinEdtRec( oBrw, bEdit, dbfAlmT ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 4 ) <> 0 .AND. !IsReport() )},,, .F. )

      if !IsReport()
         oDlg:AddFastKey( 113,    {|| if( nAnd( nLevel, 2 ) <> 0, WinAppRec( oBrw, bEdit, dbfAlmT ), ) } )
         oDlg:AddFastKey( 114,    {|| if( nAnd( nLevel, 4 ) <> 0, WinEdtRec( oBrw, bEdit, dbfAlmT ), ) } )
      end

      end

      oDlg:AddFastKey( 13,   {|| oDlg:end(1) } )
      oDlg:AddFastKey( 116,       {|| oDlg:end(1) } )

      oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

      cRETURN                 := ( dbfAlmT )->cCodAlm

      if oDlg:nResult == 1

         if !Empty( oGet )
            oGet:cText( cRETURN )
            oGet:lValid()
         end

         if !Empty( oGet2 ) .AND. ValType( oGet2 ) == "O"
            oGet2:cText( ( dbfAlmT )->cNomAlm )
         end

      end

      DestroyFastFilter( dbfAlmT )

      SetBrwOpt( "BrwAlmacen", ( dbfAlmT )->( OrdNumber() ) )

        CloseFiles()

      if !Empty( oGet )
         oGet:setFocus()
      end

   end

RETURN ( cRETURN )



STATIC FUNCTION lOpenFiles()

   local lOpen       := .T.
   local oBlock      := ErrorBlock( {| oError | ApoloBreak( oError ) } )

   BEGIN SEQUENCE


      IF !lExistTable( cPatEmp() + "ALMACEN.DBF" ) .OR. !lExistTable( cPatEmp() + "ALMACENL.DBF" )
            mkAlmacen()
        end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALMACEN.DBF" ), ( cCheckArea( "ALMACEN", @dbfAlmT ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ALMACEN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "ALMACENL.DBF" ), ( cCheckArea( "ALMACENL", @dbfAlmL ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "ALMACENL.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "AGENTES.DBF" ), ( cCheckArea( "AGENTES", @dbfAgent ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "AGENTES.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   RECOVER

      msgStop( "Imposible abrir todas las bases de datos" )
      CloseFiles()
      lOpen       := .F.

   end

   ErrorBlock( oBlock )

RETURN lOpen



STATIC FUNCTION CloseFiles()

   ( dbfAlmT  )->( dbCloseArea() )
   ( dbfAlmL  )->( dbCloseArea() )
   ( dbfAgent )->( dbCloseArea() )

   dbfAlmT   := nil
   dbfAlmL   := nil
   dbfAgent  := nil

   oWndBrw   := nil

RETURN .T.






FUNCTION EdtAlm( cCodAlm )

   local nLevel         := Auth():Level( "01035" )

   if nAnd( nLevel, 1 ) == 0 .OR. nAnd( nLevel, 4 ) == 0
      msgStop( "Acceso no permitido." )
      RETURN .T.
   end

   if lOpenFiles()

      if dbSeekInOrd( cCodAlm, "cCodAlm", dbfAlmT )
         WinEdtRec( nil, bEdit, dbfAlmT )
      end

      CloseFiles()

   end

RETURN .T.



static function LoadTree( oTree, cComAlm )

   local nRec
   local nOrd
   local oNode

   If( oTree == nil, oTree := oTreePadre, ) ;

   if Empty( cComAlm )
      cComAlm        := Space( 16 )
   end

   CursorWait()

   nRec              := ( dbfAlmT )->( Recno() )
   nOrd              := ( dbfAlmT )->( OrdSetFocus( "cComAlm" ) )

   if ( dbfAlmT )->( dbSeek( cComAlm ) )

      while ( ( dbfAlmT )->cComAlm == cComAlm .AND. !( dbfAlmT )->( Eof() ) )

         oNode       := oTree:Add( Alltrim( ( dbfAlmT )->cNomAlm ) )
         oNode:Cargo := ( dbfAlmT )->cCodAlm

         LoadTree( oNode, ( dbfAlmT )->cCodAlm )

         ( dbfAlmT )->( dbSkip() )

      end

   end

   ( dbfAlmT )->( OrdSetFocus( nOrd ) )
   ( dbfAlmT )->( dbGoTo( nRec ) )

   CursorWE()

   oTree:Expand()

RETURN ( .T. )



static function SetTreeState( oTree, aItems, cComAlm )

   local oItem

   If( oTree == nil, oTree := oTreePadre, ) ;

   if Empty( aItems )
      aItems      := oTree:aItems
   end

   for each oItem in aItems

      if ( cComAlm == oItem:Cargo )

         oTree:Select( oItem )


         oTree:GetCheck( oItem, .T. )

         SysRefresh()

      end

      if len( oItem:aItems ) > 0
         SetTreeState( oTree, oItem:aItems, cComAlm )
      end

   next

RETURN ( .T. )




Static Function ChangeTreeState( oTree, aItems )

   local oItem

   If( oTree == nil, oTree := oTreePadre, ) ;

   if Empty( aItems )
      aItems      := oTree:aItems
   end

   for each oItem in aItems

      SysRefresh()



      oTree:SetCheck( oItem, .F. )

      if len( oItem:aItems ) > 0
         ChangeTreeState( oTree, oItem:aItems )
      end

   next

RETURN ( .T. )



Static Function GetTreeState( aTemp, oTree, aItems )

   local oItem

   If( oTree == nil, oTree := oTreePadre, ) ;

   if Empty( aItems )
      aItems               := oTree:aItems
   end

   for each oItem in aItems



      if oTree:GetCheck( oItem )
         aTemp[ 11 ]  := oItem:Cargo
      end

      if len( oItem:aItems ) > 0
         GetTreeState( aTemp, oTree, oItem:aItems )
      end

   next

RETURN ( aTemp )



Function aChildAlmacen( cCodigoAlmacen, aChild, dbfAlmacen )

   local nRec
   local nOrd

   If( dbfAlmacen == nil, dbfAlmacen := dbfAlmT, ) ;
   If( aChild == nil, aChild := {}, ) ;

   if empty( dbfAlmacen )
      RETURN ( aChild )
   end

   CursorWait()

   nRec                 := ( dbfAlmacen )->( Recno() )
   nOrd                 := ( dbfAlmacen )->( OrdSetFocus( "cComAlm" ) )

   if ( dbfAlmacen )->( dbSeek( cCodigoAlmacen ) )

      while ( ( dbfAlmacen )->cComAlm == cCodigoAlmacen .AND. !( dbfAlmacen )->( Eof() ) )

         aAdd( aChild, ( dbfAlmacen )->cCodAlm )

         aChildAlmacen( ( dbfAlmacen )->cCodAlm, aChild, dbfAlmacen )

         ( dbfAlmacen )->( dbSkip() )

      end

   end

   ( dbfAlmacen )->( OrdSetFocus( nOrd ) )
   ( dbfAlmacen )->( dbGoTo( nRec ) )

   CursorWE()

RETURN ( aChild )



Function aAllAlmacen( cCodigoAlmacen, aChild, dbfAlmacen )

   local nRec
   local nOrd

   If( aChild == nil, aChild := {}, ) ;
   If( dbfAlmacen == nil, dbfAlmacen := dbfAlmT, ) ;

   CursorWait()

   nRec                 := ( dbfAlmacen )->( recno() )
   nOrd                 := ( dbfAlmacen )->( ordsetfocus( "cCodAlm" ) )

   ( dbfAlmacen )->( dbgotop() )

   while !( dbfAlmacen )->( eof() )

      if ascan( aChild, ( dbfAlmacen )->cCodAlm ) == 0
         aadd( aChild, ( dbfAlmacen )->cCodAlm )
      end

      ( dbfAlmacen )->( dbskip() )

   end

   ( dbfAlmacen )->( ordsetfocus( nOrd ) )
   ( dbfAlmacen )->( dbgoto( nRec ) )

   CursorWE()

RETURN ( aChild )
