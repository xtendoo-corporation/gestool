#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 13 ".\.\Prg\Autoseek.prg"
   Static lTmpIndex  := .T.


static cBagAnterior
static cOldIndexName
static nRecAnterior
static cTmpAnterior
static cNamAnterior
static cFiltroUsuario
static cFiltroFecha












FUNCTION Searching( cAlias, aIndex, oBrw, cPreFij )

    local oDlg
   local cType
   local oIndice
    local cIndice
    local oCadena
   local xValueToSearch  := Space( 100 )
    local nOrdAnt

    If( cAlias == nil, cAlias := Alias(), ) ;
   If( aIndex == nil, aIndex := { "Código", "Descripción" }, ) ;

   nOrdAnt        := ( cAlias )->( OrdNumber() )
   cIndice        := aIndex[ Min( nOrdAnt, Len( aIndex ) ) ]
   cType          := ( cAlias )->( dbOrderInfo( 24 ) )

   oDlg = TDialog():New(,,,,, "SSEARCH",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )







    oCadena := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, xValueToSearch, xValueToSearch:= u ) }, oDlg,, "@!", {||       ( OrdClearScope( oBrw, cAlias ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( lBigSeek( nil, oCadena, cAlias ), ( if( !empty( oBrw ), oBrw:Refresh(), ) ) ) }, .F., .F.,,,,,, nil,,, )




    oIndice := TComboBox():ReDefine( 101, { | u | If( PCount()==0, cIndice, cIndice:= u ) }, aIndex, oDlg,,, {|Self|( ( cAlias )->( OrdSetFocus( oIndice:nAt ) ), oBrw:Refresh(), oCadena:SetFocus(), oCadena:SelectAll() )},,,, .F.,,,,,,, "oIndice",,,,,,, )





    TButton():ReDefine( 510, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

    oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   OrdClearScope( oBrw, cAlias )

   ( cAlias )->( OrdSetFocus( nOrdAnt ) )

RETURN NIL









FUNCTION AutoSeek( nKey, nFlags, oGet, oBrw, xAlias, lUpper, cPreFij, lAllowFilter, lNotUser, lNotFecha, nLen )

   local cType
    local xValueToSearch
   local lReturn        := .T.

   If( xAlias == nil, xAlias := Alias(), ) ;
   If( lUpper == nil, lUpper := .T., ) ;
   If( lAllowFilter == nil, lAllowFilter := .T., ) ;
   If( lNotUser == nil, lNotUser := .T., ) ;
   If( lNotFecha == nil, lNotFecha := .T., ) ;
   If( nLen == nil, nLen := 10, ) ;

   if ValType( xAlias ) == "O"
      xAlias            := xAlias:cAlias
   end

   oGet:Assign()
   xValueToSearch       := oGet:VarGet()

   if isChar( xValueToSearch )
      xValueToSearch    := Rtrim( xValueToSearch )
   else
      xValueToSearch    := ""
   end

   cType                := ( xAlias )->( dbOrderInfo( 24 ) )

   do case
      case cType == "C"

         if lUpper
            xValueToSearch     := Upper( xValueToSearch )
         end

      case cType == "N"

         xValueToSearch        := Val( xValueToSearch )

   end

   if lBigSeek( cPreFij, xValueToSearch, xAlias, oBrw, lNotUser, lNotFecha, nLen, lAllowFilter ) .OR. empty( xValueToSearch )

      oGet:SetColor( ( 0 + ( 0 * 256 ) + ( 0 * 65536 ) ), ( 255 + ( 255 * 256 ) + ( 255 * 65536 ) ) )

   else

      oGet:SetColor( ( 255 + ( 255 * 256 ) + ( 255 * 65536 ) ), ( 255 + ( 102 * 256 ) + ( 102 * 65536 ) ) )

      lReturn           := .F.

   end

   if oBrw <> nil
      oBrw:Refresh()
   end

Return ( lReturn )



FUNCTION lBigSeek( cPreFij, xValueToSearch, xAlias, oBrw, lNotUser, lNotFecha, nLen, lAllowFilter )

   local oCol
   local xVal
   local nRec
   local lRet              := .F.
   local cSort
   local nSort

   If( lNotUser == nil, lNotUser := .T., ) ;
   If( lNotFecha == nil, lNotFecha := .T., ) ;
   If( nLen == nil, nLen := 10, ) ;
   If( lAllowFilter == nil, lAllowFilter := .T., ) ;

   if isObject( xValueToSearch )
      xValueToSearch:Assign()
      xValueToSearch        := xValueToSearch:VarGet()
   end

   if isObject( xAlias )
      xAlias         := xAlias:cAlias
   end

   if !( xAlias )->( Used() )
      return .T.
   end



   if lAllowFilter .AND. isChar( xValueToSearch )

      xValueToSearch        := StrTran( xValueToSearch, Chr( 8 ), "" )
      if !empty( cPreFij )
         xValueToSearch     := cPreFij + xValueToSearch
      end
      xValueToSearch        := Alltrim( xValueToSearch )

      DestroyFastFilter( xAlias, .F., .F. )

      CreateFastFilter( "", xAlias, .F., , , , lNotUser, lNotFecha )

      if Left( xValueToSearch, 1 ) == "*" .AND. Right( xValueToSearch, 1 ) == "*" .AND. len( Rtrim( xValueToSearch ) ) > 1

         CreateFastFilter( SubStr( xValueToSearch, 2, len( xValueToSearch ) - 2 ), xAlias, .T. , , , , lNotUser, lNotFecha )

         return .T.

      end

   end



   cSort       := ( xAlias )->( OrdSetFocus() )

   lRet        := lMiniSeek( xValueToSearch, xAlias, nLen )

   if !lRet
      ( xAlias )->( OrdSetFocus( cSort ) )
   end

RETURN ( lRet )



Function lMiniSeek( xValueToSearch, xAlias, nLen )

   local lRet              := .F.

   If( nLen == nil, nLen := 10, ) ;

   lRet                    := lSeekKeyType( xValueToSearch, xAlias )

   if !lRet .AND. ( xAlias )->( dbOrderInfo( 24 ) ) == "C"
      lRet                 := seekDocumento( xValueToSearch, xAlias, nLen )
   end

Return ( lRet )



Function lSeekKeyWild( xValueToSearch, xAlias )

   local nRec              := ( xAlias )->( recno() )
   local lFound            := .F.

   if left( xValueToSearch, 1 ) == "*" .AND. right( xValueToSearch, 1 ) == "*" .AND. len( rtrim( xValueToSearch ) ) > 1
      lFound               := ( xAlias )->( ordWildSeek( xValueToSearch, .F., .T. ) )
   end

   if !lFound
      ( xAlias )->( dbgoto( nRec ) )
   end

Return ( lFound )



Function lSeekKeySimple( xValueToSearch, xAlias )

Return ( lSeekKey( xValueToSearch, xAlias, .F. ) )



Function lSeekKeyType( xValueToSearch, xAlias )

Return ( lSeekKey( xValueToSearch, xAlias, .T. ) )



Function lSeekKey( xValueToSearch, xAlias, lScope )

   local nRec
   local lRet              := .F.
   local cType
   local oBlock
   local oError

   cType                   := ( xAlias )->( dbOrderInfo( 24 ) )

   if !( cType $ "CDN" )
      return .F.
   end

   If( lScope == nil, lScope := .T., ) ;

   oBlock                  := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   nRec                    := ( xAlias )->( Recno() )

   if !empty( xValueToSearch )

      if lScope
         ( xAlias )->( OrdScope( 0, nil ) )
         ( xAlias )->( OrdScope( 1, nil ) )
      end

      do case
      case cType == "D"

         if len( Rtrim( xValueToSearch ) ) == 10
            if ( xAlias )->( dbSeek( Ctod( xValueToSearch ), .T. ) )
               if lScope
                  ( xAlias )->( OrdScope( 0, Ctod( xValueToSearch ) ) )
                  ( xAlias )->( OrdScope( 1, Ctod( xValueToSearch ) ) )
               end
            else
               if lScope
                  ( xAlias )->( OrdScope( 0, nil ) )
                  ( xAlias )->( OrdScope( 1, nil ) )
               end
            end
         end

         lRet     := .T.

      case cType == "N"

         xValueToSearch := alltrim( xValueToSearch )
         xValueToSearch := strtran( xValueToSearch, ",", "." )
         xValueToSearch := val( xValueToSearch )

         ( xAlias )->( dbSeek( xValueToSearch, .T. ) )

         lRet           := .T.

      case cType == "C"

         if ( xAlias )->( dbSeek( xValueToSearch, .T. ) )

            if lScope
               ( xAlias )->( OrdScope( 0, xValueToSearch ) )
               ( xAlias )->( OrdScope( 1, xValueToSearch ) )
            end

            lRet  := .T.

         end

      end

   end

   if !lRet
      ( xAlias )->( dbgoto( nRec ) )
   end

   RECOVER USING oError

   end

   ErrorBlock( oBlock )

Return ( lRet )



Function seekCodigoTerceros( xValueToSearch, xAlias, nLenCodigo )

   local nRec
   local lRet        := .F.

   nRec              := ( xAlias )->( Recno() )

   xValueToSearch           :=  rjust( alltrim( xValueToSearch ), "0", nLenCodigo )

   if ( xAlias )->( dbSeek( xValueToSearch ) )

      ( xAlias )->( OrdScope( 0, xValueToSearch ) )
      ( xAlias )->( OrdScope( 1, xValueToSearch ) )

      lRet           := .T.

   end

   if !lRet
      ( xAlias )->( dbGoTo( nRec ) )
   end

return ( lRet )



Function seekDocumentoSimple( xValueToSearch, xAlias, nLen )

Return seekDocumento( xValueToSearch, xAlias, nLen, .F. )



Function seekDocumento( xValueToSearch, xAlias, nLen, lScope )

   local n
   local nRec
   local cPre
   local cPos
   local lRet        := .F.

   If( nLen == nil, nLen := 12, ) ;
   If( lScope == nil, lScope := .T., ) ;

   nRec              := ( xAlias )->( Recno() )

   cPre              := SubStr( xValueToSearch, 1, 1 )
   cPos              := Padl( Rtrim( SubStr( xValueToSearch, 2, nLen - 1 ) ), nLen - 1 )

   for n := 1 to nLen

      if ( xAlias )->( dbSeek( cPre + cPos, .F. ) )

         if lScope
            ( xAlias )->( OrdScope( 0, cPre + cPos ) )
            ( xAlias )->( OrdScope( 1, cPre + cPos ) )
         end

         lRet  := .T.

         exit

      end

      if empty( SubStr( cPos, 2, 1 ) )
         lRet  := .F.
         cPos  := SubStr( cPos, 2, len( cPos ) - 1 )
      else
         lRet  := .F.
         exit
      end

   next

   if !lRet
      ( xAlias )->( dbGoTo( nRec ) )
   end

Return ( lRet )



Function CreateUserFilter( cExpresionFilter, cAlias, lInclude, oMeter, cExpUsuario, cExpFecha )

RETURN ( CreateFastFilter( cExpresionFilter, cAlias, lInclude, oMeter, cExpUsuario, cExpFecha, .F., .F. ) )



Function CreateFastFilter( cExpresionFilter, cAlias, lInclude, oMeter, cExpUsuario, cExpFecha, lNotUser, lNotFecha )

   local nEvery
   local bEvery
   local cOrdKey
   local bOrdKey
   local bExpFilter
   local oBlock
   local oError
   local cCondAnterior

   If( lInclude == nil, lInclude := .T., ) ;
   If( cExpUsuario == nil, cExpUsuario := "", ) ;
   If( cExpFecha == nil, cExpFecha := "", ) ;
   If( lNotUser == nil, lNotUser := .T., ) ;
   If( lNotFecha == nil, lNotFecha := .T., ) ;

   if empty( cAlias )
      return .F.
   end

   oBlock                  := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if !empty( cExpUsuario )
      cFiltroUsuario       := cExpUsuario
   else
      cFiltroUsuario       := ""
   end

   if !empty( cExpFecha )

      if cExpFecha == "all"
         cFiltroFecha      := ""
      else
         cFiltroFecha      := cExpFecha
      end

   end

   if lAIS()

      buildSetFilter( cExpresionFilter, cAlias, lInclude, cExpUsuario, cExpFecha )

   else

      nRecAnterior         := ( cAlias )->( Recno() )
      cOldIndexName        := ( cAlias )->( OrdSetFocus() )
      cBagAnterior         := ( cAlias )->( dbOrderInfo( 20 ) )
      cNamAnterior         := "OrdTmp" + Auth():Codigo()
      cCondAnterior        := ( cAlias )->( dbOrderInfo( 1 ) )

      cOrdKey              := ( cAlias )->( OrdKey() )
      bOrdKey              := c2Block( cOrdKey )

      if !empty( oMeter )
         nEvery            := Int( ( cAlias )->( OrdKeyCount() ) / 10 )
         bEvery            := {|| oMeter:Set( ( cAlias )->( OrdKeyNo() ) ) }
      end

      if lInclude
         cExpresionFilter  := "'" + cExpresionFilter + "' $ " + cOrdKey + ".and. " + cCondAnterior
      end

      if !lNotUser .AND. empty( cExpUsuario ) .AND. !empty( cFiltroUsuario )
         if !empty( cExpresionFilter )
            cExpresionFilter     += " .and. " + cFiltroUsuario
         else
            cExpresionFilter     := cFiltroUsuario
         end
      end

      if !lNotFecha .AND. empty( cExpFecha ) .AND. !empty( cFiltroFecha )
         if !empty( cExpresionFilter )
            cExpresionFilter     += " .and. " + cFiltroFecha
         else
            cExpresionFilter     := cFiltroFecha
         end
      end

      dbSelectArea( ( cAlias ) )

      bExpFilter           := bCheck2Block( cExpresionFilter )

      if !empty( bExpFilter ) .AND. !empty( cOldIndexName ) .AND. !empty( cBagAnterior )
         ( cAlias )->( OrdCondSet( cExpresionFilter, bExpFilter ) )
         ( cAlias )->( OrdCreate( cBagAnterior, cNamAnterior, cOrdKey, bOrdKey ) )
         ( cAlias )->( OrdSetFocus( cNamAnterior, cBagAnterior ) )
         ( cAlias )->( dbGoTop() )
      else
         cOldIndexName     := nil
         nRecAnterior      := nil
         cBagAnterior      := nil
      end

   end

   RECOVER USING oError

      bExpFilter           := nil

      msgStop( "Imposible crear el filtro en el indice" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

Return ( .T. )



Function DestroyFastFilter( cAlias, lUser, lFecha )

   If( lUser == nil, lUser := .F., ) ;
   If( lFecha == nil, lFecha := .F., ) ;

   if lAds() .OR. lAIS()

      if !empty( cAlias ) .AND. ( cAlias )->( used() )
         ( cAlias )->( dbClearFilter() )
      end

   else

      if !empty( cBagAnterior )

         if !empty( cAlias ) .AND. ( cAlias )->( Used() )

            ( cAlias )->( OrdSetFocus( cOldIndexName, cBagAnterior ) )
            ( cAlias )->( OrdDestroy( cNamAnterior, cBagAnterior ) )
            ( cAlias )->( dbGoTo( nRecAnterior ) )

            cOldIndexName  := nil
            nRecAnterior   := nil
            cBagAnterior   := nil

         end

      end

   end

   if lUser
      cFiltroUsuario    := ""
   end

   if lFecha
      cFiltroFecha      := ""
   end

Return .T.



Function OrdClearScope( oBrw, dbf )

   if !empty( dbf ) .AND. ( dbf )->( Used() )
      ( dbf )->( OrdScope( 0, nil ) )
      ( dbf )->( OrdScope( 1, nil ) )
   end

   if oBrw <> nil
      oBrw:Refresh()
   end

Return .T.



Function buildSetFilter( cExpresionFilter, cAlias, lInclude, cExpUsuario, cExpFecha )

   local cOrdKey
   local bExpFilter

   If( lInclude == nil, lInclude := .T., ) ;
   If( cExpUsuario == nil, cExpUsuario := "", ) ;
   If( cExpFecha == nil, cExpFecha := "", ) ;

   cOrdKey              := ( cAlias )->( OrdKey() )

   if lInclude
      cExpresionFilter  := "'" + cExpresionFilter + "' $ " + cOrdKey + " .and. !Deleted()"
   end

   if empty( cExpUsuario ) .AND. !empty( cFiltroUsuario )
      cExpresionFilter  += if( !empty( cExpresionFilter ), " .and. ", "" ) + cFiltroUsuario
   end

   if empty( cExpFecha ) .AND. !empty( cFiltroFecha )
      cExpresionFilter  += if( !empty( cExpresionFilter ), " .and. ", "" ) + cFiltroFecha
   end

   if !empty( cExpresionFilter )
      ( cAlias )->( adsSetAOF( cExpresionFilter ) )
      ( cAlias )->( dbgotop() )
   end

Return nil



Function quitSetFilter( cAlias )

   if !empty( cAlias ) .AND. ( cAlias )->( used() )
      ( cAlias )->( dbClearFilter() )
   end

Return nil
