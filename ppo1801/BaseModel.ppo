#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 7 ".\Prg\Models\BaseModel.prg"
_HB_CLASS ADSBaseModel ; function ADSBaseModel ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "ADSBaseModel", iif( .F., { }, { @HBObject() } ), @ADSBaseModel() ) ) ;

   _HB_MEMBER { cTableName } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cTableName"}, .F. )

   _HB_MEMBER getTableName() ; oClass:AddVirtual( "getTableName" )

   _HB_MEMBER getEmpresaTableName(); oClass:AddInline( "getEmpresaTableName", {|Self, cTableName | ( ( Self ) ), ( cPatEmp() + if( empty(cTableName), ::cTableName, cTableName ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getDatosTableName(); oClass:AddInline( "getDatosTableName", {|Self, cTableName | ( ( Self ) ), ( cPatDat() + if( empty(cTableName), ::cTableName, cTableName ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getFileName(); oClass:AddInline( "getFileName", {|Self, cPath, cTableName | ( ( Self ) ), ( cPath + "\" + if( empty(cTableName), ::cTableName, cTableName ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getEmpresaTableNameFromEmpresa(); oClass:AddInline( "getEmpresaTableNameFromEmpresa", {|Self, cTableName, cCodEmpresa | ( ( Self ) ), ( "Emp" + if( Empty( cCodEmpresa ), cCodEmp(), allTrim( cCodEmpresa ) ) + if( empty(cTableName), ::cTableName, cTableName ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getField( cField, cBy, cId); oClass:AddMethod( "getField", @ADSBaseModel_getField(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER createFromHash( hFields); oClass:AddMethod( "createFromHash", @ADSBaseModel_createFromHash(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getInsertStatement( hFields); oClass:AddMethod( "getInsertStatement", @ADSBaseModel_getInsertStatement(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER createFile( cPath); oClass:AddMethod( "createFile", @ADSBaseModel_createFile(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER createIndex( cPath); oClass:AddMethod( "createIndex", @ADSBaseModel_createIndex(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER executeSqlStatement( cSql, cSqlStatement, hStatement); oClass:AddMethod( "executeSqlStatement", @ADSBaseModel_executeSqlStatement(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER closeArea(); oClass:AddInline( "closeArea", {|Self, cArea | ( ( Self ) ), ( if( select( cArea ) > 0, ( cArea )->( dbclosearea() ), ), dbselectarea( 0 ), .T. ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER clearFocus(); oClass:AddInline( "clearFocus", {|Self, cArea | ( ( Self ) ), ( if( select( cArea ) > 0, ( ( cArea )->( ordsetfocus( 0 ) ), ( cArea )->( dbgotop() ) ), ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getToOdoo( cArea); oClass:AddMethod( "getToOdoo", @ADSBaseModel_getToOdoo(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS ADSBaseModel ;



static FUNCTION ADSBaseModel_executeSqlStatement( cSql, cSqlStatement, hStatement ) ; local Self AS CLASS ADSBaseModel := QSelf() AS CLASS ADSBaseModel

   local lOk
   local nError
   local oError
   local oBlock
   local cErrorAds

   If( cSqlStatement == nil, cSqlStatement := "ADSArea", ) ;
   If( hStatement == nil, hStatement := 2, ) ;

   if !( lAIS() )
      RETURN ( .F. )
   end

   oBlock                  := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      ::closeArea( cSqlStatement )

      ADSCacheOpenCursors( 0 )

      dbSelectArea( 0 )

      lOk                  := ADSCreateSQLStatement( cSqlStatement, hStatement )
      if lOk

         lOk               := ADSExecuteSQLDirect( cSql )
         if !lOk
            nError         := AdsGetLastError( @cErrorAds )


            msgStop( "Error : " + str( nError) + "[" + cErrorAds + "]" + Chr(13)+Chr(10) + Chr(13)+Chr(10) +  "SQL : " + cSql                                                   , "ERROR en ADSCreateSQLStatement" )
         endif

      else

         ::closeArea( cSqlStatement )

         nError            := AdsGetLastError( @cErrorAds )


         msgStop( "Error : " + str( nError) + "[" + cErrorAds + "]" + Chr(13)+Chr(10) + Chr(13)+Chr(10) +     "SQL : " + cSql                                                      , "ERROR en ADSCreateSQLStatement" )

      end

      if lOk
         ADSCacheOpenCursors( 0 )
         ADSClrCallBack()
      endif

   RECOVER USING oError
      msgStop( ErrorMessage( oError ), "Error en sentencia SQL" )
   end
   ErrorBlock( oBlock )

RETURN ( lOk )



static FUNCTION ADSBaseModel_createFile( cPath ) ; local Self AS CLASS ADSBaseModel := QSelf() AS CLASS ADSBaseModel

   if !lExistTable( ::getFileName( cPath ) )
      dbCreate( ::getFileName( cPath ), ::getStruct(), cDriver() )
   end

RETURN ( Self )



static FUNCTION ADSBaseModel_createIndex( cPath ) ; local Self AS CLASS ADSBaseModel := QSelf() AS CLASS ADSBaseModel

   local cAlias
   local aIndex

   dbUseArea( .T., cDriver(), ::getFileName( cPath ), cCheckArea( "Alias", @cAlias ), .F. )

   if ( cAlias )->( neterr() )
      msgStop( "Imposible abrir en modo exclusivo la tabla : " + ::getFileName( cPath ) )
      RETURN ( Self )
   end

   ( cAlias)->( __dbPack() )

   for each aIndex in ::getIndexes
      ( cAlias )->( ordCondSet( "!Deleted()", {|| !Deleted() }, , , , , , , , , aIndex[ 4 ] ) )
      ( cAlias )->( ordCreate( ::getFileName( cPath ), aIndex[ 1 ], aIndex[ 2 ], aIndex[ 3 ] ) )
   next

   ( cAlias )->( dbCloseArea() )

RETURN ( Self )



static FUNCTION ADSBaseModel_getField( cField, cBy, cId, lDebug ) ; local Self AS CLASS ADSBaseModel := QSelf() AS CLASS ADSBaseModel

   local cStm
   local cSql

   If( lDebug == nil, lDebug := .F., ) ;

   cSql              := "SELECT " + cField + " "
   cSql              +=    "FROM " + ::getTableName() + " "
   cSql              +=    "WHERE " + cBy + " = " + quoted( cId )

   if lDebug
      logwrite( cSql )
      msgInfo( cSql, "debug" )
   endif

   if ::ExecuteSqlStatement( cSql, @cStm )
      RETURN ( ( cStm )->( fieldget( fieldpos( cField ) ) ) )
   end

RETURN ( nil )



static FUNCTION ADSBaseModel_getInsertStatement( hFields ) ; local Self AS CLASS ADSBaseModel := QSelf() AS CLASS ADSBaseModel

   local cStatement

   cStatement           := "INSERT INTO " + ::getTableName() + " "
   cStatement           += "( "

      hEval( hFields,   {| k, v | cStatement += k + ", " } )
   cStatement           := chgAtEnd( cStatement, " ) VALUES ( ", 2 )

      hEval( hFields,   {| k, v | cStatement += toAdsSQLString( v ) + ", " } )
   cStatement           := chgAtEnd( cStatement, " )", 2 )

RETURN ( cStatement )



static FUNCTION ADSBaseModel_createFromHash( hFields ) ; local Self AS CLASS ADSBaseModel := QSelf() AS CLASS ADSBaseModel

   local cStm
   local cSql           := ::getInsertStatement( hFields )

   if ::ExecuteSqlStatement( cSql, @cStm )
      RETURN ( .T. )
   end

RETURN ( .F. )



static FUNCTION ADSBaseModel_getToOdoo( cArea ) ; local Self AS CLASS ADSBaseModel := QSelf() AS CLASS ADSBaseModel

   local cSql  := "SELECT * FROM " + ::getTableName()

RETURN ( ::ExecuteSqlStatement( cSql, @cArea ) )
