#line 91 "\fwh1801\include\FiveWin.ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 13 ".\.\Prg\Brush.prg"
_HB_CLASS TBrush ; function TBrush ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TBrush", iif( .F., { }, { @HBObject() } ), @TBrush() ) ) ;

   _HB_MEMBER { hBrush, hBitmap, hBmpOrgl } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hBrush", "hBitmap", "hBmpOrgl"}, .F. )
   _HB_MEMBER { nBmpFormat } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBmpFormat"}, .F. )
   _HB_MEMBER { nCount, cStyle, nRGBColor, cBmpFile, cBmpRes } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nCount", "cStyle", "nRGBColor", "cBmpFile", "cBmpRes"}, .F. )
   _HB_MEMBER { lSystem } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lSystem"}, .F. )
   _HB_MEMBER { aGrad } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aGrad"}, .F. )
   _HB_MEMBER { uSource } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"uSource"}, .F. )
   _HB_MEMBER { nResizeMode } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nResizeMode"}, .F. )
   _HB_MEMBER { oRect } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oRect"}, .F. )
   _HB_MEMBER { Cargo } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Cargo"}, .F. )

   _HB_MEMBER { aBrushes } ; oClass:AddMultiClsData(, {}, nScope + iif( .F., 16, 0 ) + iif( .T., 32, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aBrushes"}, .F. )

   _HB_MEMBER { aProperties } ; oClass:AddMultiClsData(, { "cStyle", "cBmpFile", "cBmpRes", "nRGBColor", "lSystem" }, nScope + iif( .F., 16, 0 ) + iif( .T., 32, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aProperties"}, .F. )

   _HB_MEMBER New( cStyle, nRGBColor, cBmpFile, cBmpRes, nBmpHandle); oClass:AddMethod( "New", @TBrush_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER cGenPRG(); oClass:AddMethod( "cGenPRG", @TBrush_cGenPRG(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER End(); oClass:AddMethod( "End", @TBrush_End(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Load( cInfo); oClass:AddMethod( "Load", @TBrush_Load(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Release(); oClass:AddInline( "Release", {|Self | ( ( Self ) ), ::End() }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Save(); oClass:AddMethod( "Save", @TBrush_Save(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Resized( x, y, nMode); oClass:AddMethod( "Resized", @TBrush_Resized(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Cropped( oWnd, oRect); oClass:AddMethod( "Cropped", @TBrush_Cropped(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SaveToText( nIndent); oClass:AddMethod( "SaveToText", @TBrush_SaveToText(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Resize( oWnd, nOrgX, nOrgY); oClass:AddMethod( "Resize", @TBrush_Resize(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Copy(); oClass:AddMethod( "Copy", @TBrush_Copy(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SameAs( oBrush); oClass:AddMethod( "SameAs", @TBrush_SameAs(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   oClass:AddInline( "==", {|Self,o| ( ( Self ) ), ::SameAs( o )}, nScope + iif( .F., 2048, 0 ) )

   oClass:AddInline( "!=", {|Self,o| ( ( Self ) ), ! ::SameAs( o )}, nScope + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TBrush ;



static FUNCTION TBrush_New( cStyle, nRGBColor, cBmpFile, cBmpRes, nBmpHandle, cResizeMode ) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local nAt, nFormat := 0
   local aNewTypes := { "BORLAND", "BRICKS", "TILED", "TABS" }

   local aStdTypes := { "HORIZONTAL", "VERTICAL", "FDIAGONAL", "BDIAGONAL", "CROSS", "DIAGCROSS" }

   ::hBrush    = 0
   ::hBitmap   = 0
   ::cStyle    = cStyle
   ::nRGBColor = nRGBColor
   ::cBmpFile  = cBmpFile
   ::cBmpRes   = cBmpRes
   ::lSystem   = .F.

   if ValType( nBmpHandle ) == "N"
      if IsGDIObject( nBmpHandle )
         ::cBmpFile  = LTrim( Str( nBmpHandle ) )
      else
         nBmpHandle  = nil
      endif
   elseif ValType( nBmpHandle ) == "A"
      ::aGrad        = nBmpHandle
      ::nResizeMode  = 1
   else
      nBmpHandle     = nil
   endif

   if ! Empty( cStyle ) .AND. ! Empty( IfNil( cBmpFile, cBmpRes, nBmpHandle ) ) .AND. Empty( cResizeMode )
      cResizeMode    := cStyle
      cStyle         := nil
   endif



   ::uSource   = If( nRGBColor == nil,  IfNil( cStyle, cBmpFile, cBmpRes, nBmpHandle ),  cClrToCode( nRGBColor ) )


   if ! Empty( cResizeMode ) .AND. ::nRGBColor == nil .AND. ::uSource <> nil
      if ValType( ::uSource ) == "A"
         ::nResizeMode  := If( Left( cResizeMode, 3 ) == "HOR", 2, 1 )
      else
         ::nResizeMode  := FW_DeCode( cResizeMode, "STRETCH", 1, "RESIZE", 2, 0 )
      endif
   endif


   if ::nResizeMode == 0 .AND.  ( nAt := AScan( ::aBrushes, {|oBrush| Self == oBrush } ) ) > 0


      if ! Empty( ::aBrushes[ nAt ]:hBitmap ) .AND. ( Empty( ::aBrushes[ nAt ]:cBmpFile ) .AND.  Empty( ::aBrushes[ nAt ]:cBmpRes ) )
         ::aBrushes[ nAt ]:End()

      else

         Self := ::aBrushes[ nAt ]
         ::nCount++
         return Self
      endif

   endif

   do case





      case cStyle == nil .AND. nRGBColor <> nil
           if nRGBColor == 16777215
              ::hBrush  = GetStockObject( 0 )
              ::lSystem = .T.

           elseif nRGBColor == 0
              ::hBrush  = GetStockObject( 4 )
              ::lSystem = .T.

            elseif nRGBColor == 12632256
              ::hBrush  = GetStockObject( 1 )
              ::lSystem = .T.

            elseif nRGBColor == 8421504
              ::hBrush  = GetStockObject( 2 )
              ::lSystem = .T.

            elseif nRGBColor == ( 64 + ( 64 * 256 ) + ( 64 * 65536 ) )
              ::hBrush  = GetStockObject( 3 )
              ::lSystem = .T.

           else
              ::hBrush := CreateSolidBrush( nRGBColor )
           endif

      case cStyle <> nil
           do case
              case cStyle == "NULL"
                   ::hBrush = GetStockObject( 5 )
                   ::lSystem = .T.

              case ( nAt := AScan( aNewTypes, cStyle ) ) <> 0
                   ::hBitmap = FWBrushes( nAt )


                   ::hBrush = If( ::hBitmap <> 0, CreatePatternBrush( ::hBitmap ), )

              case ( nAt := AScan( aStdTypes, cStyle ) ) <> 0
                   ::hBrush = CreateHatchBrush( nAt - 1, nRGBColor )

              otherwise
                 if File( cBmpFile )
                    ::hBitMap = ReadBitmap( 0, cBmpFile )

                    ::hBrush = If( ::hBitmap <> 0, CreatePatternBrush( ::hBitmap ), )
                 endif
           endcase

      case ValType( nBmpHandle ) == "N"
           ::hBitmap = nBmpHandle
           ::hBrush  = CreatePatternBrush( ::hBitmap )

      case cBmpFile <> nil
           if File( cBmpFile )
               if Lower( cFileExt( cBmpFile ) ) == "bmp"
                  ::hBitMap = ReadBitmap( 0, cBmpFile )
               else
                  ::hBitmap = FILoadImg( cBmpFile, @nFormat )
                  ::nBmpFormat = nFormat
               endif
               ::hBrush = If( ::hBitmap <> 0, CreatePatternBrush( ::hBitmap ), )
           endif

      case cBmpRes <> nil
           ::hBitmap = LoadBitmap( GetResources(), cBmpRes )
           ::hBrush  = If( ::hBitmap <> 0, CreatePatternBrush( ::hBitmap ),)

   endcase

   ::nCount    := 1
   If( ::hBmpOrgl == nil, ::hBmpOrgl := ::hBitmap, ) ;

   AAdd( ::aBrushes, Self )

return Self



static FUNCTION TBrush_cGenPRG( cVar ) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local cPrg := ""

   If( cVar == nil, cVar := "oBrush", ) ;

   cPrg     := "   DEFINE BRUSH " + cVar

   if ! Empty( ::cStyle )
      cPrg  += " STYLE '" + ::cStyle + "'"
   endif

   if ! Empty( ::nRGBColor )
      cPrg  += " COLOR " + cClrToCode( ::nRGBColor )
   endif

   if ! Empty( ::cBmpFile )
      cPrg  += " FILE '" + ::cBmpFile + "'"
   elseif ! Empty( ::cBmpRes )
      cPrg  += " RESOURCE '" + ::cBmpRes + "'"
   endif

return cPrg



static FUNCTION TBrush_End( ) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local nAt


   if ::nCount == nil
      ::nCount := 1
   endif

   if --::nCount < 1
      nAt := AScan( ::aBrushes, { | oBrush | oBrush:hBrush = ::hBrush } )
      if nAt > 0
         ADel( ::aBrushes, nAt )
         ASize( ::aBrushes, Len( ::aBrushes ) - 1 )
      endif
   else
      return nil
   endif

   if ::hBrush <> nil .AND. ::hBrush <> 0
      if ! ::lSystem
         if ! DeleteObject( ::hBrush )

            LogFile( "resources.txt", { "DeleteObject( ::hBrush ) failed from TBrush:End()", ::hBrush } )
         endif
      endif
   endif

   if ! Empty( ::hBmpOrgl ) .AND. ::hBmpOrgl <> ::hBitmap
      DeleteObject( ::hBmpOrgl )
   endif

   if ::hBitmap <> nil .AND. ::hBitmap <> 0
      DeleteObject( ::hBitmap )
   endif

   ::hBrush  = 0
   ::hBitmap = 0

return nil



static FUNCTION TBrush_Load( cInfo ) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local nPos := 1, nProps, n, nLen
   local cData, cType, cBuffer

   nProps = Bin2I( SubStr( cInfo, nPos, 2 ) )
   nPos += 2

   for n = 1 to nProps
      nLen  = Bin2I( SubStr( cInfo, nPos, 2 ) )
      nPos += 2
      cData = SubStr( cInfo, nPos, nLen )
      nPos += nLen
      cType = SubStr( cInfo, nPos++, 1 )
      nLen  = Bin2I( SubStr( cInfo, nPos, 2 ) )
      nPos += 2
      cBuffer = SubStr( cInfo, nPos, nLen )
      nPos += nLen

      do case
         case cType == "A"
              OSend( Self, "_" + cData, ARead( cBuffer ) )

         case cType == "O"
              OSend( Self, "_" + cData, ORead( cBuffer ) )

         case cType == "C"
              if SubStr( cData, 1, 2 ) == "On"
                 if ::oWnd == nil
                    OSend( Self, "_" + cData, { | u1, u2, u3, u4 | OSend( Self, cBuffer, u1, u2, u3, u4 ) } )
                 else
                    OSend( Self, "_" + cData, { | u1, u2, u3, u4 | OSend( Self:oWnd, cBuffer, u1, u2, u3, u4 ) } )
                 endif
              else
                 OSend( Self, "_" + cData, cBuffer )
              endif

         case cType == "L"
              OSend( Self, "_" + cData, cBuffer == ".T." )

         case cType == "N"
              OSend( Self, "_" + cData, Val( cBuffer ) )
      endcase
   next

return nil



static FUNCTION TBrush_Resized( x, y, nMode ) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local hBmp     := ResizeBitmap( ::hBitmap, x, y, nMode )

return TBrush():New( ,,,, hBmp )



static FUNCTION TBrush_Cropped( oWnd, oChildRect ) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local hBmp, hDC
   local oBrush, hCrop, oRect

   oBrush      := oWnd:oBrush
   if oBrush:nResizeMode > 0 .AND. oBrush:aGrad == nil
      oRect       := DataRect( oWnd )
      if oBrush:aGrad == nil
         hBmp     := ResizeBitmap( oBrush:hBmpOrgl, oRect:nWidth, oRect:nHeight, oBrush:nResizeMode )
      else
         hDC      := oWnd:GetDC()

         hBmp     := GradientBmp( hDC, oRect:nWidth, oRect:nHeight,  oBrush:aGrad, oBrush:nResizeMode == 1 )
         oWnd:ReleaseDC()
      endif
      hCrop       := CropBmp( hBmp, oChildRect )
      DeleteObject( hBmp )
   else
      return oBrush:Copy()
   endif

return TBrush():New( nil, nil, nil, nil, hCrop )



static FUNCTION TBrush_Save( ) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local n
   local cType, cInfo := "", cMethod
   local oBrush := &( ::ClassName() + "()" )
   local uData, nProps := 0

   oBrush = oBrush:New()

   for n = 1 to Len( ::aProperties )

       if ! ( uData := OSend( Self, ::aProperties[ n ] ) ) ==  OSend( oBrush, ::aProperties[ n ] )

          cInfo += ( I2Bin( Len( ::aProperties[ n ] ) ) +  ::aProperties[ n ] )
          nProps++
          cType = ValType( uData )
          do case
             case cType == "A"
                  cInfo += ASave( uData )

             case cType == "O"
                  cInfo += uData:Save()

             otherwise

                  cInfo += ( cType + I2Bin( Len( uData := cValToChar( uData ) ) ) +  uData )
          endcase
       endif
   next

   oBrush:End()



return "O" + I2Bin( 2 + Len( ::ClassName() ) + 2 + Len( cInfo ) ) +  I2Bin( Len( ::ClassName() ) ) +  ::ClassName() + I2Bin( nProps ) + cInfo



static FUNCTION TBrush_SaveToText( nIndent ) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local n, m, cType, cInfo
   local cMethod, uData, nProps := 0
   local oBrush := &( ::ClassName() + "()" )
   local cParams1, cParams2

   If( nIndent == nil, nIndent := 0, ) ;





   cInfo := Space( nIndent ) + "OBJECT " + If( nIndent > 0, "::", "" ) +  "oBrush AS " +  If( nIndent > 0, Upper( Left( ::ClassName(), 2 ) ) +  Lower( SubStr( ::ClassName(), 3 ) ), If( ::IsDerivedFrom( "TFORM" ), ::cClassName, ::ClassName() ) ) +  Chr(13)+Chr(10) + Chr(13)+Chr(10)

   oBrush = oBrush:New()

   for n = 1 to Len( ::aProperties )

       if ! ( uData := OSend( Self, ::aProperties[ n ] ) ) ==  OSend( oBrush, ::aProperties[ n ] )
          nProps++
          cType = ValType( uData )
          do case
             case cType == "C"
                  cInfo += Space( nIndent ) + "   ::" + ::aProperties[ n ] + " = "
                  cInfo += '"' + uData + '"' + Chr(13)+Chr(10)

             case cType == "A"

                  cInfo += Space( nIndent + 3 ) + "::" + ::aProperties[ n ] +  " = Array( " + AllTrim( Str( Len( uData ) ) ) + " )" + Chr(13)+Chr(10) + Chr(13)+Chr(10)
                  cInfo += AToText( uData, ::aProperties[ n ], nIndent + 3 )

             case cType == "O"
                  cInfo += Chr(13)+Chr(10) + uData:SaveToText( nIndent + 3 )

             otherwise
                  cInfo += Space( nIndent ) + "   ::" + ::aProperties[ n ] + " = "
                  cInfo += cValToChar( uData ) + Chr(13)+Chr(10)
          endcase
       endif
   next

   cInfo += Chr(13)+Chr(10) + Space( nIndent ) + "ENDOBJECT" + If( nIndent > 0, Chr(13)+Chr(10), "" )

   oBrush:End()

return cInfo



static FUNCTION TBrush_Copy( ) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local oBrush

   if Empty( ::nResizeMode )
      oBrush   := Self
   else
      oBrush   := TBrush():New()
      WITH OBJECT oBrush
         :cBmpFile      := ::cBmpFile
         :cBmpRes       := ::cBmpRes

         :hBitmap       :=  :hBmpOrgl      := ResizeBitmap( ::hBmpOrgl )
         :nBmpFormat    := ::nBmpFormat
         :lSystem       := ::lSystem
         :aGrad         := ::aGrad
         :uSource       := ::uSource
         :nResizeMode   := ::nResizeMode
      END

   endif

return oBrush



static FUNCTION TBrush_SameAs( oBrush ) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush







   return  ValType( oBrush ) == "O"                           .AND.  oBrush:IsKindOf( "TBRUSH" )                        .AND.  ! Empty( oBrush:uSource )                          .AND.  ValType( oBrush:uSource )  == ValType( ::uSource ) .AND.  oBrush:uSource             == ::uSource            .AND.  oBrush:nResizeMode         == ::nResizeMode



static FUNCTION TBrush_Resize( oWnd, nOrgX, nOrgY ) ; local Self AS CLASS TBrush := QSelf() AS CLASS TBrush

   local hDC, oRect

   If( nOrgX == nil, nOrgX := 0, ) ; If( nOrgY == nil, nOrgY := 0, );

   oRect    := DataRect( oWnd )
   if ::nResizeMode == 0
      ::oRect  := oRect
      if ! Empty( ::hBmpOrgl )
         if ! Empty( ::hBitmap ) .AND. ::hBitmap <> ::hBmpOrgl
            DeleteObject( ::hBitmap )
            DeleteObject( ::hBrush )
            ::hBitmap := ::hBrush := nil
         endif

         If( ::hBitmap == nil, ::hBitmap := ::hBmpOrgl, ) ; If( ::hBrush == nil, ::hBrush := CreatePatternBrush( ::hBitmap ), );

      endif
   else
      if ::oRect == nil .OR. !( ::oRect == oRect ) .OR. ::hBrush == nil
         if ::hBrush <> nil
            DeleteObject( ::hBrush )
            ::hBrush      := nil
         endif
         if ::hBitmap <> ::hBmpOrgl
            DeleteObject( ::hBitmap )
         endif
         if Empty( ::aGrad )
            if ! Empty( ::hBmpOrgl )
               ::hBitmap   := ResizeBitmap( ::hBmpOrgl, oRect:nWidth, oRect:nHeight, ::nResizeMode )
            endif
         else
            hDC         := oWnd:GetDC()
            ::hBitmap   := GradientBmp( hDC, oRect:nWidth, oRect:nHeight, ::aGrad, ::nResizeMode == 1 )
            If( ::hBmpOrgl == nil, ::hBmpOrgl := ::hBitmap, ) ;
            oWnd:ReleaseDC()
         endif
         ::oRect     := oRect
         If( ::hBrush == nil, ::hBrush := CreatePatternBrush( ::hBitmap ), ) ;
      endif
   endif

   nOrgX    += ::oRect:nLeft
   nOrgY    += ::oRect:nTop

return oRect



function ResizeBitmap( hBmp, nWndW, nWndH, nMode )

   local hBmpNew
   local nWidth, nHeight
   local nBmpW       := nBmpWidth(  hBmp )
   local nBmpH       := nBmpHeight( hBmp )

   if Empty( nWndW ) .AND. Empty( nWndH )
      nMode          := 0
   else
      If( nMode == nil, nMode := 1, ) ;
      If( nWndW == nil, nWndW := nWndH * nBmpW / nBmpH, ) ;
      If( nWndH == nil, nWndH := nWndW * nBmpH / nBmpW, ) ;
   endif

   if nMode == 0
      nWidth := nBmpW; nHeight := nBmpH
   elseif nMode == 1
      nWidth := nWndW; nHeight := nWndH

   elseif ( nMode == 3 .AND. ( nWndW / nBmpW ) < ( nWndH / nBmpH ) ) .OR.  ( nMode == 2 .AND. ( nWndW / nBmpW ) > ( nWndH / nBmpH ) )
      nWidth := nWndW; nHeight := nBmpH * ( nWndW / nBmpW )
   else
      nHeight := nWndH; nWidth := nBmpW * ( nWndH / nBmpH )
   endif

   hBmpNew     := ResizeImg( hBmp, nWidth, nHeight )

return hBmpNew



static function GradientBmp( hDC, nWidth, nHeight, aColors, lVert )

   local hDC2, hBmp, hBmpOld
   local lDC := .F.

   If( lVert == nil, lVert := .T., ) ; If( nWidth == nil, nWidth := 319, ); If( nHeight == nil, nHeight := 153, );

   if hDC == nil
      hDC   := GetDC( 0 )
      lDC   :=.T.
   endif
   hDC2     := CreateCompatibleDC( hDC )
   hBmp     := CreateCompatibleBitMap( hDC, nWidth, nHeight )
   hBmpOld  := SelectObject( hDC2, hBmp )
   GradientFill( hDC2, 0, 0, nHeight, nWidth, aColors,lVert )

   SelectObject( hDC2, hBmpOld )
   DeleteDC( hDC2 )
   if lDC
      ReleaseDC( 0, hDC )
   endif

return hBmp



static function CropBmp( hBmp, oRect )
return CropImage( hBmp, oRect:nTop, oRect:nLeft, oRect:nBottom, oRect:nRight )



function GradientBrush( hDC, nTop, nLeft, nWidth, nHeight, aColors, lVert )

   local hDC2, hBmp, hBmpOld , hBrush

   If( lVert == nil, lVert := .T., ) ;

   if lVert
      nWidth   := 1
   else
      nHeight  := 1
   endif

   hDC2     := CreateCompatibleDC( hDC )
   hBmp     := CreateCompatibleBitMap( hDC, nWidth, nHeight )
   hBmpOld  := SelectObject( hDC2, hBmp )
   GradientFill( hDC2, 0, 0, nHeight, nWidth, aColors,lVert )

   hBrush = CreatePatternBrush( hBmp )
   SelectObject( hDC2, hBmpOld )
   DeleteObject( hBmp )
   DeleteDC( hDC2 )

return hBrush



static function DataRect( oWnd )

   local oRect

   if __ObjHasMethod( oWnd, "DATARECT" )
      oRect    := oWnd:DataRect()
      if ValType( oRect ) == "A"
         oRect := TRect():New( oRect )
      endif
   else
      oRect    := oWnd:GetCliRect()
















   endif

return oRect



static function ContainerWnd( oWnd, nTop, nLeft )

   local oRet     := oWnd

   If( nTop == nil, nTop := 0, ) ; If( nLeft == nil, nLeft := 0, );





   while lAnd( oRet:nStyle, 1073741824 ) .AND.  ( oRet:IsKindOf( "TCONTROL" ) .OR.   oRet:IsKindOf( "TDIALOG" )  ) .AND.  oWnd:oBrush == oRet:oBrush    .AND.  oRet:oWnd:lTransparent == .T.

      nTop     += oRet:nTop
      nLeft    += oRet:nLeft
      oRet     := oRet:oWnd
   enddo

return oRet



#pragma BEGINDUMP

#include "windows.h"
#include "hbapi.h"

HB_FUNC( CROPIMAGE ) //hOriginalBmp, nTop, nLeft, nBottom, nRight --> hCroppedBmp
{
   HDC hdc1, hdcSrc, hdcDest;
   HBITMAP hbmpSrc  = ( HBITMAP ) hb_parnl( 1 );
   HBITMAP hbmpDest, hold1, hold2;
   RECT rct;
   BITMAP bm;

   GetObject( ( HGDIOBJ ) hbmpSrc, sizeof( BITMAP ), ( LPSTR ) &bm );

   rct.top    = hb_pcount() > 1 ? hb_parnl( 2 ) : 0;
   rct.left   = hb_pcount() > 2 ? hb_parnl( 3 ) : 0;
   rct.bottom = hb_pcount() > 3 ? hb_parnl( 4 ) : bm.bmHeight;
   rct.right  = hb_pcount() > 4 ? hb_parnl( 5 ) : bm.bmWidth;


   hdc1 = GetDC( GetDesktopWindow() );
   hdcSrc = CreateCompatibleDC( hdc1 );
   hdcDest = CreateCompatibleDC( hdc1 );

   hbmpDest = CreateCompatibleBitmap( hdc1, rct.right - rct.left, rct.bottom - rct.top );

   ReleaseDC( GetDesktopWindow(), hdc1 );

   hold1 = ( HBITMAP ) SelectObject( hdcSrc, hbmpSrc );
   hold2 = ( HBITMAP ) SelectObject( hdcDest, hbmpDest );

   BitBlt( hdcDest, 0, 0, rct.right, rct.bottom, hdcSrc, rct.left, rct.top, SRCCOPY );

   SelectObject( hdcSrc, hold1 );
   SelectObject( hdcDest, hold2 );

   DeleteDC( hdcSrc );
   DeleteDC( hdcDest );

   hb_retnl( ( LONG ) hbmpDest );

}

#pragma ENDDUMP
