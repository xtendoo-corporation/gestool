#line 91 "\fwh1801\include\fivewin.ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 5 ".\.\Prg\Carpeta.prg"
_HB_CLASS TCarpeta ; function TCarpeta ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TCarpeta", iif( .F., { }, { @HBObject() } ), @TCarpeta() ) ) ;

      _HB_MEMBER { AS NUMERIC nInitID } ; oClass:AddMultiClsData( "NUMERIC", 2000, nScope + iif( .F., 16, 0 ) + iif( .T., 32, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nInitID"}, .F. )

      _HB_MEMBER { AS ARRAY aGrupos } ; oClass:AddMultiData( "ARRAY", {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aGrupos"}, .F. )
      _HB_MEMBER { bWhen } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bWhen"}, .F. )
      _HB_MEMBER { AS CHARACTER cName } ; oClass:AddMultiData( "CHARACTER", "oCarpeta", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cName"}, .F. )
      _HB_MEMBER { cPrompt } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cPrompt"}, .F. )
      _HB_MEMBER { AS LOGICAL lAjustados } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lAjustados"}, .F. )
      _HB_MEMBER { AS LOGICAL lEnabled } ; oClass:AddMultiData( "LOGICAL", .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lEnabled"}, .F. )
      _HB_MEMBER { AS NUMERIC nClrBorde } ; oClass:AddMultiData( "NUMERIC", ( 141 + ( 178 * 256 ) + ( 227 * 65536 ) ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nClrBorde"}, .F. )
      _HB_MEMBER { AS NUMERIC nClrPane0 } ; oClass:AddMultiData( "NUMERIC", ( 218 + ( 229 * 256 ) + ( 243 * 65536 ) ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nClrPane0"}, .F. )
      _HB_MEMBER { AS NUMERIC nClrPane1 } ; oClass:AddMultiData( "NUMERIC", ( 199 + ( 216 * 256 ) + ( 237 * 65536 ) ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nClrPane1"}, .F. )
      _HB_MEMBER { AS NUMERIC nClrPane2 } ; oClass:AddMultiData( "NUMERIC", ( 217 + ( 232 * 256 ) + ( 246 * 65536 ) ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nClrPane2"}, .F. )
      _HB_MEMBER { AS NUMERIC nClrPane3 } ; oClass:AddMultiData( "NUMERIC", ( 195 + ( 217 * 256 ) + ( 243 * 65536 ) ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nClrPane3"}, .F. )
      _HB_MEMBER { AS NUMERIC nClrSolapa1 } ; oClass:AddMultiData( "NUMERIC", ( 239 + ( 245 * 256 ) + ( 254 * 65536 ) ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nClrSolapa1"}, .F. )
      _HB_MEMBER { AS NUMERIC nClrSolapa2 } ; oClass:AddMultiData( "NUMERIC", ( 239 + ( 245 * 256 ) + ( 254 * 65536 ) ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nClrSolapa2"}, .F. )
      _HB_MEMBER { AS NUMERIC nClrText } ; oClass:AddMultiData( "NUMERIC", ( 141 + ( 178 * 256 ) + ( 227 * 65536 ) ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nClrText"}, .F. )
      _HB_MEMBER { nID } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nID"}, .F. )
      _HB_MEMBER { AS NUMERIC nOption } ; oClass:AddMultiData( "NUMERIC", 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nOption"}, .F. )
      _HB_MEMBER { oParent } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oParent"}, .F. )
      _HB_MEMBER { AS ARRAY rcSolapa } ; oClass:AddMultiData( "ARRAY", {0,0,0,0}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"rcSolapa"}, .F. )
      _HB_MEMBER { AS LOGICAL lHide } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lHide"}, .F. )
      _HB_MEMBER { bAction } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bAction"}, .F. )
      _HB_MEMBER { aColorsTab } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aColorsTab"}, .F. )


      _HB_MEMBER New( oWnd, cText, lDefine, bAction, aColorsTab) AS CLASS TCarpeta; oClass:AddMethod( "New", @TCarpeta_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Paint( hDC); oClass:AddMethod( "Paint", @TCarpeta_Paint(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER PintaSolapa( hDC, lSolapa, lOver); oClass:AddMethod( "PintaSolapa", @TCarpeta_PintaSolapa(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER CalcSizes(); oClass:AddMethod( "CalcSizes", @TCarpeta_CalcSizes(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Copy(); oClass:AddMethod( "Copy", @TCarpeta_Copy(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Edit(); oClass:AddMethod( "Edit", @TCarpeta_Edit(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER End() ; oClass:AddVirtual( "End" )
      _HB_MEMBER GenPrg(); oClass:AddMethod( "GenPrg", @TCarpeta_GenPrg(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER HideGroups(); oClass:AddMethod( "HideGroups", @TCarpeta_HideGroups(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER IsOverSolapa(); oClass:AddInline( "IsOverSolapa", {|Self, nRow, nCol | ( ( Self ) ), PtInRect( nRow, nCol, ::rcSolapa ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER RButtonDown( nRow, nCol, nFlags); oClass:AddMethod( "RButtonDown", @TCarpeta_RButtonDown(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Search( cGrupo); oClass:AddMethod( "Search", @TCarpeta_Search(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER ShowGroups(); oClass:AddMethod( "ShowGroups", @TCarpeta_ShowGroups(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER oGrupoOver( nRow, nCol); oClass:AddMethod( "oGrupoOver", @TCarpeta_oGrupoOver(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Paste(); oClass:AddMethod( "Paste", @TCarpeta_Paste(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TCarpeta ;



  static FUNCTION TCarpeta_New( oWnd, cText, lDefine, bAction, aColorsTab ) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta


   if cText == nil;   cText   := "item" ;endif
   if lDefine == nil; lDefine := .F.    ;endif

   ::oParent  := oWnd
   ::cPrompt  := cText

   ::nClrBorde    := ::oParent:oColor:_GRISB
   ::nClrPane0    := ::oParent:oColor:P1GRUPOS
   ::nClrPane1    := ::oParent:oColor:_GRIS2
   ::nClrPane2    := ::oParent:oColor:_GRIS3
   ::nClrPane3    := ::oParent:oColor:_BACKTITLE
   ::nClrSolapa1  := ::oParent:oColor:_GRISBOX2
   ::nClrSolapa2  := ::oParent:oColor:_GRISBOX2
   ::nClrText     := ::oParent:oColor:_GRISB

   if ::nInitID == nil
      ::nInitID  := 20000
   endif

   ::nID      := ::nInitID++

   if !lDefine
      aadd( ::oParent:aCarpetas, self )
      ::oParent:GetCoords()
   endif

   ::bAction := bAction
   ::aColorsTab := aColorsTab

return self



      static FUNCTION TCarpeta_Paint( hDC ) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local lSelected := .F.
local nTop, nLeft, nBottom, nRight
local hPen, hBrush
local hOldPen, hOldBrush
local n
local nLen := len(::aGrupos)
local lRet
local a := {::oParent:nRow, ::oParent:nCol }
local aPoint := {a[1],a[2]}
local lIsOver
local rc := GetClientRect( ::oParent:hWnd )


if ::lHide
   return 0
endif


if ::bWhen <> nil
   lRet := eval( ::bWhen, self )
   ::lEnabled := lRet
endif


if ::oParent:nOption <> 0
   if ::oParent:aCarpetas[::oParent:nOption]:nID == ::nID
      lSelected := .T.
   endif
endif

nTop    := ::rcSolapa[1]
nLeft   := ::rcSolapa[2]
nBottom := ::rcSolapa[3] + 5
nRight  := ::rcSolapa[4]

lIsOver := ::IsOverSolapa( aPoint[1], aPoint[2] ) .AND. !lSelected .AND. GetActiveWindow() == ::oParent:oWnd:hWnd



if lSelected
   if empty( ::aColorsTab )
      FillSolidRect( hDC, {::rcSolapa[3]-2,::rcSolapa[2]+2,::rcSolapa[3]+10,::rcSolapa[4]-2}, ::oParent:oColor:_GRIS1 )
   else
      FillSolidRect( hDC, {::rcSolapa[3]-2,::rcSolapa[2]+2,::rcSolapa[3]-1,::rcSolapa[4]-2}, ::aColorsTab[2] )
      FillSolidRect( hDC, {::rcSolapa[3]-1,rc[2]+4,::rcSolapa[3]+1,rc[4]-3}, ::aColorsTab[2] )
   endif
endif







if lIsOver
   Box( hDC, {::rcSolapa[3]-3,::rcSolapa[2]+1,::rcSolapa[3]-2,::rcSolapa[4]-1}, ( 206 + ( 194 * 256 ) + ( 151 * 65536 ) ) )
endif

   nLeft := 3
   for n := 1 to nLen

       if lSelected
          ::aGrupos[n]:Show()
          ::aGrupos[n]:Paint( hDC )
       else
          ::aGrupos[n]:Hide()
       endif

   next



return 0



static FUNCTION TCarpeta_PintaSolapa( hDC, lSolapa, lOver ) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local hOldFont, nColor, nMode, hFont
local rc := {::rcSolapa[1],::rcSolapa[2],::rcSolapa[3],::rcSolapa[4]}
local oFont := nil
local nClrPane1     := ::oParent:oColor:nClrPaneSolapa1
local nClrPane2     := ::oParent:oColor:nClrPaneSolapa2
local nClrPane1Over := ::oParent:oColor:nClrPaneSolapaOver1
local nClrPane2Over := ::oParent:oColor:nClrPaneSolapaOver2
local a := {::oParent:nRow, ::oParent:nCol }
local aPoint := {a[1],a[2]}
local lIsOver


if ::lHide
   return 0
endif


   if lOver == nil; lOver := .F.; endif

   if lOver .OR. ( ::oParent:lPaintAll .AND. !lSolapa )
      nClrPane1 := nClrPane1Over
      nClrPane2 := nClrPane2Over
   endif

   if ::oParent:oFont <> nil
      hFont := ::oParent:oFont:hFont
   else
      oFont := TFont():New( "Ms Sans Serif", 0, -12.3,,,,,,,,,,,,,, )
      hFont := oFont:hFont
   endif

   if empty( ::aColorsTab )

      if ( lSolapa .AND. !lOver ) .OR. ( lOver .AND. !lSolapa ) .OR. ::oParent:lPaintAll
         VerticalGradient( hDC, { rc[1] + ::oParent:nTopMargin+1, rc[2]+4, rc[3], rc[4] -4}, nClrPane1, nClrPane2 )
         RoundBox        ( hDC,   rc[2] + 2, rc[1]+::oParent:nTopMargin  , rc[4] -  2, rc[3] + 6, ::oParent:oColor:nCorner1, ::oParent:oColor:nCorner1, ::oParent:oColor:_GRISB )
         RoundBox        ( hDC,   rc[2] + 3, rc[1]+::oParent:nTopMargin+1, rc[4] -  3, rc[3] + 6, ::oParent:oColor:nCorner1, ::oParent:oColor:nCorner1, 16777215 )
      endif

      if lSolapa .AND. ::IsOverSolapa( aPoint[1], aPoint[2] )
         VerticalGradient( hDC, { rc[1] + ::oParent:nTopMargin+1, rc[2]+4, rc[3], rc[4] -4}, nClrPane1, nClrPane2 )
         RoundBox        ( hDC,   rc[2] + 2, rc[1]+::oParent:nTopMargin  , rc[4] -  2, rc[3] + 6, ::oParent:oColor:nCorner1, ::oParent:oColor:nCorner1, ::oParent:oColor:ROUNDBOXCAR1 )
         RoundBox        ( hDC,   rc[2] + 3, rc[1]+::oParent:nTopMargin+1, rc[4] -  3, rc[3] + 6, ::oParent:oColor:nCorner1, ::oParent:oColor:nCorner1, ::oParent:oColor:ROUNDBOXCAR2 )
      endif

   else

      VerticalGradient( hDC, { rc[1] + ::oParent:nTopMargin+1, rc[2]+4, rc[3], rc[4] -4}, ::aColorsTab[1], ::aColorsTab[2] )

      if ::aColorsTab[3] <> nil
         RoundBox        ( hDC,   rc[2] + 2, rc[1]+::oParent:nTopMargin  , rc[4] -  2, rc[3] + 6, ::oParent:oColor:nCorner1, ::oParent:oColor:nCorner1, ::aColorsTab[3] )
      endif

      if ::aColorsTab[4] <> nil
         RoundBox        ( hDC,   rc[2] + 3, rc[1]+::oParent:nTopMargin+1, rc[4] -  3, rc[3] + 6, ::oParent:oColor:nCorner1, ::oParent:oColor:nCorner1, ::aColorsTab[4] )
      endif

   endif

   hOldFont := SelectObject( hDC, hFont )

   if empty(::aColorsTab )
      nColor   := SetTextColor( hDC, ( 21 + ( 66 * 256 ) + ( 139 * 65536 ) ) )
   else
      nColor   := SetTextColor( hDC, ::aColorsTab[5] )
   endif

   nMode    := SetBkMode( hDC, 1 )


   DrawText( hDC, ::cPrompt, {rc[1]+1, rc[2]+ 3, rc[3], rc[4]-3}, nOr( 32, 4, 1, 2048, 0x00040000 ) )

   SetBkMode( hDC, nMode )
   SetTextColor( hDC, nColor )
   SelectObject( hDC, hOldFont )

   if oFont <> nil ;      oFont:End();   endif


return 0




      static FUNCTION TCarpeta_HideGroups( ) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local n
local nLen := len(::aGrupos)
for n := 1 to nLen
    ::aGrupos[n]:Hide()
next


return 0


      static FUNCTION TCarpeta_ShowGroups( ) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local n
local nLen := len(::aGrupos)
for n := 1 to nLen
    ::aGrupos[n]:Show()
next

return 0


      static FUNCTION TCarpeta_CalcSizes( ) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local n
local nLen := len( ::aGrupos )
local nWidth
local lAjustado
local oGrupo


   for n := 1 to nLen
       oGrupo := ::aGrupos[n]
       if oGrupo:lAjustado()
          nWidth := oGrupo:SizeCapSm()[1]
       else
          nWidth := ::aGrupos[n]:nWidth
       endif
       if n > 1
          ::aGrupos[n]:nLeft := ::aGrupos[n-1]:nRight + 3
       endif
       ::aGrupos[n]:nRight := ::aGrupos[n]:nLeft + nWidth
       oGrupo:ResizeItems()
   next


return 0


      static FUNCTION TCarpeta_Search( cGrupo ) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local oGrupo
local n, o
local nLen := len( ::aGrupos )

for n := 1 to nLen
    oGrupo := ::aGrupos[n]
    if alltrim( oGrupo:cPrompt ) == alltrim( cGrupo )
       o := oGrupo
       exit
    endif
next

return o


  static FUNCTION TCarpeta_RButtonDown( nRow, nCol, nOption ) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local oPopup
local o := self
local oClp
local cInfo := ""
local lPaste := .F.

  oClp := TClipBoard():New( Upper("TEXT"), )

  if oClp:Open()
     cInfo := oClp:GetText()
     oClp:End()
  endif

  lPaste := at( "tcarpeta()",lower(cInfo)) == 0 .AND. at("tdotnetgroup",lower(cInfo) ) <> 0

  oPopup := MenuBegin( .T.,,, .F., .F.,,,,,,,,,, .F.,, .F., .F., .F., .F.,, ,,,,,, .F.,, .F., .F.,,,,,,,,,, .F.,,,,,, )
     MenuAddItem( "Add grupo",, .F.,, {|oMenuItem|( SetFocus(o:oParent:hWnd ), TDotNetGroup():New( self, 200, "cItem"  ), ::oParent:Refresh())},,,,,,, .F.,,, .F., ,.F., .F.,,,,,,,,,, .F., .F.,,,,,,, ,, .F., .F., .F.,,,,, .F., .F., .F. )
     MenuAddItem(,,,,,,,,,,,,,,,,,.T.,,,,,,,,,,,,,,,,,)
     MenuAddItem( "Copy",, .F.,, {|oMenuItem|::Copy()},,,,,,, .F.,,, .F., ,.F., .F.,,,,,,,,,, .F., .F.,,,,,,, ,, .F., .F., .F.,,,,, .F., .F., .F. )
     if lPaste
        MenuAddItem( "Paste",, .F.,, {|oMenuItem|::Paste()},,,,,,, .F.,,, .F., ,.F., .F.,,,,,,,,,, .F., .F.,,,,,,, ,, .F., .F., .F.,,,,, .F., .F., .F. )
     endif
  MenuEnd()
  oPopup:Activate( nRow, nCol, ::oParent, ! .F., )
  SetFocus(::oParent:hWnd )

return 0




   static FUNCTION TCarpeta_oGrupoOver( nRow, nCol ) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local n, nLen, oGrupo

nLen := len( ::aGrupos )

for n := 1 to nLen

    oGrupo := ::aGrupos[n]

    if oGrupo:IsOver( nRow, nCol )
       return oGrupo
    endif

next

return nil


   static FUNCTION TCarpeta_Edit( ) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local oFont
local bValid := {||.T.}
local o := self
local uVar
local nTop, nLeft, nWidth, nHeight

uVar := padr(::cPrompt, 100)

nTop    := ::rcSolapa[1] + 6
nLeft   := ::rcSolapa[2] +4
nWidth  := ::rcSolapa[4]-::rcSolapa[2] -8
nHeight := ::rcSolapa[3]-::rcSolapa[1] -8

oFont := TFont():New( "Ms Sans Serif", 0, -10,,,,,,,,,,,,,, )

   ::oParent:oGet := TGet():New(nTop,nLeft,{ | u | If( PCount()==0, uVar, uVar:= u ) },o:oParent,nWidth,nHeight,,,0,16777215,oFont,.F.,,.T.,,.F.,,.F.,.F.,,.F.,.F.,.T.,)

   ::oParent:nLastKey := 0
   ::oParent:oGet:SetFocus()
   ::oParent:oGet:bValid := {|| .T. }




   ::oParent:oGet:bLostFocus := {||  o:oParent:oGet:Assign(), o:oParent:oGet:VarPut( o:oParent:oGet:oGet:VarGet() ), o:cPrompt := if( o:oParent:nLastKey <> 27, alltrim(o:oParent:oGet:oGet:VarGet()), o:cPrompt ) , o:oParent:GetCoords(), o:oParent:Refresh() }

   ::oParent:oGet:bKeyDown := { | nKey | If( nKey == 13 .OR. nKey == 27, ( o:oParent:nLastKey := nKey, o:oParent:oGet:End()), ) }



return nil



   static FUNCTION TCarpeta_GenPrg( ) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local cPrg := ""
local n
local nGrupos
local cGrupo := ""
local aGrupos

::cName := "oCarpeta" + + alltrim(str(::nId-2000))

::oParent:cVars += "local " + ::cName + Chr(13)+Chr(10)

cPrg := space( 7 ) + ::cName + " := TCarpeta():New( oBar, " + '"' + ::cPrompt + '"' + " )" + Chr(13)+Chr(10)

nGrupos := len( ::aGrupos )

aGrupos := array( nGrupos )

for n := 1 to nGrupos

    aGrupos[n] := ::aGrupos[n]:GenPrg()

next

for n := 1 to nGrupos

    cGrupo += aGrupos[n]

next


cPrg += cGrupo + Chr(13)+Chr(10)

return cPrg



   static FUNCTION TCarpeta_Copy( ) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local cInfo := ::GenPrg()
local oClp

   oClp := TClipBoard():New( Upper("TEXT"), )

   if oClp:Open()
      oClp:Clear()
      oClp:SetText( cInfo )
      oClp:End()
   else
      msgStop( "The clipboard is not available now!" )
   endif

return nil


   static FUNCTION TCarpeta_Paste( ) ; local Self AS CLASS TCarpeta := QSelf() AS CLASS TCarpeta

local cInfo
local aLines := {}
local nLines
local n := 1
local n2
local nEstado := 0
local cLinea
local aParams := {}
local cWord
local cObject

local aWords := {{"tdotnetgroup():new(" ,3  }    , {"tdotnetbutton():new(",4 } }
local cBar
local aCarpetas := {}
local aGrupos   := {}
local o
local lDefinida := .F.
local oError
local oClp

   oClp := TClipBoard():New( Upper("TEXT"), )

   if oClp:Open()
      cInfo := oClp:GetText()
      oClp:End()
   else
      msgStop( "The clipboard is not available now!" )
   endif


if empty( cInfo )
   MsgInfo("Proceso cancelado")
   return 0
endif

nLines := strcount( cInfo, Chr(13)+Chr(10) )

for n := 1 to nLines
    aadd( aLines, memoline( cInfo,255,n) )
next

n := 1

while n < nLines .AND. nEstado <> 100

    cLinea := alltrim(aLines[n])
    cLinea := strtran(cLinea,'"',"")

    if left( lower(cLinea), len( "local "   )) == "local "   ; cLinea := substr( cLinea, len( "local "   )+1); endif
    if left( lower(cLinea), len( "private " )) == "private " ; cLinea := substr( cLinea, len( "private " )+1); endif
    if left( lower(cLinea), len( "public "  )) == "public "  ; cLinea := substr( cLinea, len( "public "  )+1); endif


    nEstado := 0

    cWord := ""

    for n2 := 1 to len( aWords )
        cWord := lower(aWords[n2,1])
        if at( cWord, lower(cLinea) ) <> 0
           nEstado := aWords[n2,2]
           exit
        endif
    next

       if nEstado <> 0

          asize( aParams, 0 )

          cObject := left  ( cLinea, at(":=",cLinea)-1 )
          cLinea  := substr( cLinea, at( lower(cWord), lower(cLinea) )+len(cWord)+1 )
          cLinea  := left  ( cLinea, len( cLinea ) - 1 )
          aParams := aSplit( cLinea, "," )


          do case
             case nEstado == 3







                     o := TDotNetGroup():New( self, val( aParams[2]), aParams[3], lower(aParams[4])==".t.", nil, aParams[6] )


                     aadd( aGrupos, {cObject, o } )

             case nEstado == 4



                     o := GetMyObject( aGrupos, aParams[2] )








                     o := TDotNetButton():New( val( aParams[1]), o, alltrim(aParams[3]), alltrim(aParams[4]), val(aParams[5]), , , , lower(aParams[9])==".t.", lower(aParams[10])==".t.", lower(aParams[11])==".t." )
          endcase

       endif


    n++


enddo


::oParent:Refresh()


return 0
