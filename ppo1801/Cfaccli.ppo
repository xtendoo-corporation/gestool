#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 10 ".\.\Prg\Cfaccli.prg"
Static Function isIVARegimenGeneralVentas( dbfFactura )

Return ( ( dbfFactura )->nRegIva <= 1 )



Static Function isIVARegimenGeneralCompras( dbfFactura )

Return ( ( dbfFactura )->nRegIva <= 1 .OR. ( dbfFactura )->nRegIva == 4 )



Static Function isIVAComunidadEconomicaEuropea( dbfFactura )

Return ( ( dbfFactura )->nRegIva == 2 )



Static Function isIVAExportacionFueraUE( dbfFactura )

Return ( ( dbfFactura )->nRegIva == 4 )



FUNCTION CntFacCli( lSimula, lPago, lExcCnt, lMessage, oTree, nAsiento, aSimula, dbfFacCliT, dbfFacCliL, dbfFacCliP, dbfAntCliT, dbfCli, dbfDiv, dbfArt, dbfFPago, dbfIva, oNewImp, oBrw, cCodEmp, cCodPro )

   local n
   local nIva
   local cCtaVent
   local nPos
   local dFecha
   local cConcepto
   local cPago
   local cSubCtaIva
   local cSubCtaReq
   local cSubCtaIvm
   local cSubCtaTrn
   local nImpDet
   local nImpTrn
   local nImpPnt
   local nImpIvm
   local nImpIva
   local cRuta
   local nDouDiv
   local nRouDiv
   local nDpvDiv
   local aTotAnt
   local nNetAnt
   local nIvaAnt
   local nAcuAnt        := 0
   local nTotAnt        := 0
   local uIva
   local newIva
   local aIvm           := {}
   local aTrn           := {}
   local aAsiento       := {}
   local nCalculo       := 0
   local nBase          := 0
   local aVentas        := {}
   local lIvaInc        := ( dbfFacCliT )->lIvaInc
   local cCodDiv        := ( dbfFacCliT )->cDivFac
   local cCtaCli        := cCliCta( ( dbfFacCliT )->cCodCli, dbfCli )
   local cCtaCliVta     := cCliCtaVta( ( dbfFacCliT )->cCodCli, dbfCli )
   local cCtaAnticipo   := cCtaAnt()
   local nFactura       := ( dbfFacCliT )->cSerie + str( ( dbfFacCliT )->nNumFac ) + ( dbfFacCliT )->cSufFac
   local cFactura       := ( dbfFacCliT )->cSerie + alltrim( str( ( dbfFacCliT )->nNumFac ) )
   local pFactura       := ( dbfFacCliT )->cSerie + "/" + alltrim( str( ( dbfFacCliT )->nNumFac ) ) + "/" + ( dbfFacCliT )->cSufFac
   local lRecargo       := ( dbfFacCliT )->lRecargo
   local cTerNif        := ( dbfFacCliT )->cDniCli
   local cTerNom        := ( dbfFacCliT )->cNomCli
   local lErrorFound    := .F.
   local cProyecto
   local cClave
   local sTotFacCli
   local ptaDebe
   local ptaRet
   local lReturn        := .T.
   local lOpenDiario    := lOpenDiario()
   local nTotDebe       := 0
   local nTotHaber      := 0
   local nDtoEsp        := 0
   local nDpp           := 0
   local nDtoUno        := 0
   local nDtoDos        := 0
   local nPctDto        := 0
   local nPctIva        := 0
   local nBaseImp       := 0
   local aAsientoSII
   local aAsientosSII   := {}
   local nTotalDtoLineal

   If( lSimula == nil, lSimula := .T., ) ;
   If( nAsiento == nil, nAsiento := 0, ) ;
   If( aSimula == nil, aSimula := {}, ) ;
   If( cCodEmp == nil, cCodEmp := cCodEmpCnt( ( dbfFacCliT )->cSerie ), ) ;
   If( cCodPro == nil, cCodPro := ( dbfFacCliT )->cCodPro, ) ;

   nDouDiv              := nDouDiv( ( dbfFacCliT )->cDivFac, dbfDiv )
   nRouDiv              := nRouDiv( ( dbfFacCliT )->cDivFac, dbfDiv )
   nDpvDiv              := nDpvDiv( ( dbfFacCliT )->cDivFac, dbfDiv )

   dFecha               := ( dbfFacCliT )->dFecFac
   nDtoEsp              := ( dbfFacCliT )->nDtoEsp
   nDpp                 := ( dbfFacCliT )->nDpp
   nDtoUno              := ( dbfFacCliT )->nDtoUno
   nDtoDos              := ( dbfFacCliT )->nDtoDos
   nPctDto              := ( dbfFacCliT )->nPctDto

   sTotFacCli           := sTotFacCli( ( dbfFacCliT )->cSerie + str( ( dbfFacCliT )->nNumFac ) + ( dbfFacCliT )->cSufFac, dbfFacCliT, dbfFacCliL, dbfIva, dbfDiv, dbfFacCliP, dbfAntCliT, nil, nil, .F., lExcCnt  )
   ptaDebe              := sTotFacCli:nTotalDocumento
   ptaRet               := sTotFacCli:nTotalRetencion
   newIva               := sTotFacCli:aTotalIva

   nTotalDtoLineal      := sTotFacCli:nTotalDtoLineal

   cProyecto            := Left( cCodPro, 3 )
   cClave               := Right( cCodPro, 6 )





   cRuta             := cRutCnt()

   if !chkEmpresaAsociada( cCodEmp )
      oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " no se definierón empresas asociadas.", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkRuta( cRutCnt() )
      oTree:Select( oTree:Add(  "Factura cliente : " + rtrim( pFactura ) + " ruta no valida.", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkFecha( cRuta, cCodEmp, ( dbfFacCliT )->dFecFac, .F., oTree, "Factura cliente : " + rtrim( pFactura ) )
      lErrorFound    := .T.
   end





   if Empty( cCtaCli )
      cCtaCli        := cCtaSin()
   end

   if Empty( cCtaCliVta )
      cCtaCliVta     := cCtaCli()
   end





   if ( dbfFacCliL )->( dbSeek( nFactura ) )

      while ( ( dbfFacCliL )->cSerie + str( ( dbfFacCliL )->nNumFac ) + ( dbfFacCliL )->cSufFac == nFactura .AND. !( dbfFacCliL )->( eof() ) )


         if !( dbfFacCliL )->lTotLin                           .AND.  lValLine( dbfFacCliL )




            if ( lExcCnt == nil                                .OR. ( lExcCnt .AND. ( dbfFacCliL )->nCtlStk <> 2 )  .OR. ( !lExcCnt .AND. ( dbfFacCliL )->nCtlStk == 2 ) )

               nIva           := ( dbfFacCliL )->nIva
               nImpDet        := nTotLFacCli( dbfFacCliL, nDouDiv, nRouDiv, nil, .T., .F., .F. )
               nImpTrn        := nTrnLFacCli( dbfFacCliL, nDouDiv, nRouDiv )





               if ( dbfFacCliT )->lOperPV
                  nImpPnt     := nPntLFacCli( dbfFacCliL, nDpvDiv )
               else
                  nImpPnt     := 0
               end

               nImpIva        := nIvaLFacCli( dbfFacCliL, nDouDiv, nRouDiv )
               nImpIvm        := nTotIFacCli( dbfFacCliL, nDouDiv, nRouDiv )





               cCtaVent       := RetCtaVta( ( dbfFacCliL )->cRef, ( nImpDet < 0 ), dbfArt )
               if empty( cCtaVent )
                  cCtaVent    := cCtaCliVta + RetGrpVta( ( dbfFacCliL )->cRef, cRuta, cCodEmp, nIva )
               end





               nPos           := aScan( aVentas, {|x| x[ 1 ] == cCtaVent .AND. x[ 2 ] == nIva } )
               if nPos == 0
                  aAdd( aVentas, { cCtaVent, nIva, nImpDet, nImpPnt, nImpTrn, nImpIva, .T. } )
               else
                  aVentas[ nPos, 3 ]   += nImpDet
                  aVentas[ nPos, 4 ]   += nImpPnt
                  aVentas[ nPos, 5 ]   += nImpTrn
                  aVentas[ nPos, 6 ]   += nImpIva
               end





               if isIVAComunidadEconomicaEuropea( dbfFacCliT )
                  cSubCtaIva  := uFieldEmpresa( "cCtaCeeRpt" )
                  cSubCtaReq  := uFieldEmpresa( "cCtaCeeSpt" )
               else
                  cSubCtaIva  := cSubCuentaIva( nIva, ( dbfFacCliT )->lRecargo, cRuta, cCodEmp, dbfIva )
                  cSubCtaReq  := cSubCuentaRecargo( nIva, ( dbfFacCliT )->lRecargo, cRuta, cCodEmp, dbfIva )
               end

               if uFieldEmpresa( "lIvaImpEsp" )
                  nImpDet     += nImpIvm
               end





               if nImpTrn <> 0

                  cSubCtaTrn  := RetCtaTrn( ( dbfFacCliL )->cRef, dbfArt )

                  nPos        := aScan( aTrn, {|x| x[1] == cSubCtaTrn } )
                  if nPos == 0
                     aAdd( aTrn, { cSubCtaTrn, nImpTrn } )
                  else
                     aTrn[ nPos, 2 ] += nImpTrn
                  end

               end





               nImpIvm        := nTotIFacCli( dbfFacCliL, nDouDiv, nRouDiv )

               if nImpIvm <> 0

                  cSubCtaIvm  := oNewImp:cCtaImp( oNewImp:nValImp( ( dbfFacCliL )->cCodImp ) )

                  if !Empty( cSubCtaIvm )

                     nPos     := aScan( aIvm, {|x| x[1] == cSubCtaIvm } )
                     if nPos == 0
                        aAdd( aIvm, { cSubCtaIvm, nImpIvm } )
                     else
                        aIvm[ nPos, 2 ] += nImpIvm
                     end

                  end

               end

            end

         end

         SysRefresh()

         ( dbfFacCliL )->( dbSkip() )

      end

   else

      oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " factura sin artículos.", 0 ) )

      lErrorFound := .T.

   end






   for n := 1 to Len( aVentas )
      nRestaDescuentoVenta( @aVentas[ n, 3 ], nDtoEsp )
      nRestaDescuentoVenta( @aVentas[ n, 3 ], nDpp )
      nRestaDescuentoVenta( @aVentas[ n, 3 ], nDtoUno )
      nRestaDescuentoVenta( @aVentas[ n, 3 ], nDtoDos )
      nRestaDescuentoVenta( @aVentas[ n, 3 ], nPctDto )
   next





   if ( ( dbfFacCliT )->nManObr <> 0 )

      cSubCtaTrn     := uFieldEmpresa( "cCtaGas")

      nPos           := aScan( aVentas, {|x| x[ 1 ] == cSubCtaTrn .AND. x[ 2 ] == ( dbfFacCliT )->nIvaMan } )
      if nPos == 0
         aAdd( aVentas, { cSubCtaTrn, ( dbfFacCliT )->nIvaMan, ( dbfFacCliT )->nManObr, 0, 0, 0, .F. } )
      else
         aVentas[ nPos, 3 ]   += ( dbfFacCliT )->nManObr
      end

   end





   for n := 1 to Len( aVentas )
      aVentas[ n, 3 ]   += aVentas[ n, 4 ]
   next





   for each uIva in newIva

      if isNum( hGet( uIva, "porcentajeiva" ) )





         if isIVAComunidadEconomicaEuropea( dbfFacCliT )
            cSubCtaIva  := cCuentaVentaIVARepercutidoUE()

            hSet( uIva, "porcentajeiva", 0 )

            hSet( uIva, "cSubCtaIva", cSubCtaIva )
         elseif isIVAExportacionFueraUE( dbfFacCliT )
            cSubCtaIva  := cCuentaVentaIVARepercutidoFueraUE()

            hSet( uIva, "porcentajeiva", 0 )

            hSet( uIva, "cSubCtaIva", cSubCtaIva )
         else

            hSet( uIva, "cSubCtaIva", cSubCuentaIva( hGet( uIva, "porcentajeiva" ), ( dbfFacCliT )->lRecargo, cRuta, cCodEmp, dbfIva ) )

            hSet( uIva, "cSubCuentaRecargo", cSubCuentaRecargo( hGet( uIva, "porcentajeiva" ), ( dbfFacCliT )->lRecargo, cRuta, cCodEmp, dbfIva ) )

            hSet( uIva, "cSubCuentaIvaNRe", cSubCuentaIva( hGet( uIva, "porcentajeiva" ), .F., cRuta, cCodEmp, dbfIva ) )
         end

      end

   next






   if ( dbfFacCliT )->lContab
      oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " contabilizada.", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkSubcuenta( cRuta, cCodEmp, cCtaCli, , .F., .F. )
      oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " subcuenta " + cCtaCli + " no encontada.", 0 ) )
      lErrorFound    := .T.
   end

   if ptaRet <> 0
      if !ChkSubcuenta( cRuta, cCodEmp, cCtaRet(), , .F., .F. )
         oTree:Select( oTree:Add( "Factura cliente : " + rtrim( cFactura ) + " subcuenta " + cCtaRet() + " no encontada.", 0 ) )
         lErrorFound := .T.
      end
   end






   for each uIva in newIva


      if isNum( hGet( uIva, "porcentajeiva" ) )


         if !ChkSubcuenta( cRutCnt(), cCodEmp, hGet( uIva, "cSubCtaIva" ), , .F., .F. )
            oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " subcuenta " + hGet( uIva, "cSubCtaIva" ) + " no encontada.", 0 ) )
            lErrorFound := .T.
         end


         if lRecargo .AND. !ChkSubcuenta( cRutCnt(), cCodEmp, hGet( uIva, "cSubCuentaRecargo" ), , .F., .F. )
            oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " subcuenta " + hGet( uIva, "cSubCuentaRecargo" ) + " no encontada.", 0 ) )
            lErrorFound := .T.
         end

      end

   next

   for n := 1 to len( aVentas )
      if !ChkSubcuenta( cRuta, cCodEmp, aVentas[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " subcuenta " + aVentas[ n, 1 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end
   next

   for n := 1 to len( aIvm )
      if !lSimula .AND. !ChkSubcuenta( cRuta, cCodEmp, aIvm[ n, 1 ], , .F., .F. )
         oTree:Add( "Factura cliente : " + rtrim( nFactura ) + " subcuenta " + aIvm[ n, 1 ] + " no encontada.", 0 )
         lErrorFound := .T.
      end
   next






   for n := 1 to len( aTrn )
      if !ChkSubcuenta( cRuta, cCodEmp, aTrn[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " subcuenta " + aTrn[ n, 1 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end
   next





   if nTotAnt <> 0 .AND. !ChkSubcuenta( cRuta, cCodEmp, cCtaAnticipo, , .F., .F. )
      oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " subcuenta de anticipo " + cCtaAnticipo + " no encontada.", 0 ) )
      lErrorFound := .T.
   end






   cConcepto      := "N/Fcta. N." + ( dbfFacCliT )->CSERIE + "/" + alltrim( str( (dbfFacCliT)->NNUMFAC ) + "/" + (dbfFacCliT)->CSUFFAC )
   cPago          := "C/Fcta. N." + ( dbfFacCliT )->CSERIE + "/" + alltrim( str( (dbfFacCliT)->NNUMFAC ) + "/" + (dbfFacCliT)->CSUFFAC )






   nTotDebe          += Round( ptaDebe, nRouDiv )

   for n := 1 to len( aVentas )

      if lIvaInc

         nCalculo    := Round( aVentas[ n, 3 ], nRouDiv )

         if aVentas[ n, 2 ] <> 0
            nCalculo -= Round( aVentas[ n, 3 ] / ( 100 / aVentas[ n, 2 ] + 1 ), nRouDiv )
         end

      else

         nCalculo    := Round( aVentas[ n, 3 ], nRouDiv )

      end

      nTotHaber      += nCalculo

   next

   nTotDebe          += ptaRet
   nTotDebe          += nAcuAnt

   for n := 1 to Len( aIvm )
      nTotHaber      += Round( aIvm[ n, 2 ], nRouDiv )
   next

   for n := 1 to Len( aTrn )
      nTotHaber      += Round( aTrn[ n, 2 ], nRouDiv )
   next

   for each uIva in newIva









      if isNum( hGet( uIva, "impiva" ) )
         nTotHaber   += hGet( uIva, "impiva" )
      end

      if lRecargo .AND. isNum( hGet( uIva, "impre" ) )
         nTotHaber   += hGet( uIva, "impre" )
      end

   next

   nTotDebe          := Round( nTotDebe, nRouDiv )
   nTotHaber         := Round( nTotHaber, nRouDiv )






   if lSimula .OR. !lErrorFound

      if lOpenDiario .OR. OpenDiario( , cCodEmp )
         nAsiento    := contaplusUltimoAsiento()
      else
         oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " imposible abrir ficheros de contaplus.", 0 ) )
         Return .F.
      end

      setAsientoIntraComunitario( isIVAComunidadEconomicaEuropea( dbfFacCliT ) )





      if lAplicacionContaplus()





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha, cCtaCli, , Round( ptaDebe, nRouDiv ), cConcepto, , cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      else
















         EnlaceA3():getInstance():Add( {  "Empresa"               => cEmpCnt( ( dbfFacCliT )->cSerie ), "Fecha"                 => dFecha , "TipoRegistro"          => "1", "Cuenta"                => cCtaCli, "DescripcionCuenta"     => cTerNom, "TipoFactura"           => "1", "NumeroFactura"         => cFactura, "DescripcionApunte"     => cConcepto, "Importe"               => Round( ptaDebe, nRouDiv ), "Nif"                   => cTerNif, "NombreCliente"         => cTerNom, "CodigoPostal"          => ( dbfFacCliT )->cPosCli, "FechaOperacion"        => dFecha, "FechaFactura"          => dFecha, "Moneda"                => "E", "Render"                => "CabeceraFactura" } )

      end






      for n := 1 to Len( aVentas )

         nCalculo       := Round( aVentas[ n, 3 ], nRouDiv )

         if lIvaInc

            nPctIva     := aVentas[ n, 2 ]

            if ( lRecargo .AND. aVentas[ n, 7 ] )
               nPctIva  += nPReq( dbfIva, aVentas[ n, 2 ] )
            end

            if aVentas[ n, 2 ] <> 0
               nCalculo -= Round( aVentas[ n, 3 ] / ( 100 / nPctIva + 1 ), nRouDiv )
            end

         end

         if lAplicacionContaplus()





















            aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aVentas[ n, 1 ], , , cConcepto, nCalculo, cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

         else



















            EnlaceA3():getInstance():Add( {  "Empresa"               => cEmpCnt( ( dbfFacCliT )->cSerie ), "Fecha"                 => dFecha , "TipoRegistro"          => "9", "Cuenta"                => aVentas[ n, 1 ], "DescripcionCuenta"     => "", "TipoImporte"           => "C", "NumeroFactura"         => cFactura, "DescripcionApunte"     => cConcepto, "SubtipoFactura"        => if( isIVAComunidadEconomicaEuropea( dbfFacCliT ), "02", "01" ), "BaseImponible"         => nCalculo, "PorcentajeIVA"         => aVentas[ n, 2 ], "PorcentajeRecargo"     => if( ( dbfFacCliT )->lRecargo, nPReq( dbfIva, aVentas[ n, 2 ] ), 0 ), "PorcentajeRetencion"   => 0, "Impreso"               => "01", "SujetaIVA"             => if( aVentas[ n, 2 ] <> 0, "S", "N" ), "Modelo415"             => " ", "Analitico"             => " ", "Moneda"                => "E", "Render"                => "VentaFactura" } )

         end

      next





      if lAplicacionContaplus() .AND. ptaRet <> 0





















         aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, cCtaRet(), , ptaRet, cConcepto, , cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      end






      if lAplicacionContaplus() .AND. nTotAnt <> 0





















         aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, cCtaAnticipo, , nAcuAnt, cConcepto, , cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      end






      for n := 1 to Len( aIvm )



















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIvm[ n, 1 ], , , cConcepto, Round( aIvm[ n, 2 ], nRouDiv ), cFactura, , , , , cProyecto, cClave, , , , lSimula ) )

      next






      for n := 1 to Len( aTrn )





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aTrn[ n, 1 ], , , cConcepto, Round( aTrn[ n, 2 ], nRouDiv ), cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      next






      for each uIva in newIva


         if ( len( uIva ) >= 12 )


            nBaseImp    := hGet( uIva, "neto" )

            if uFieldEmpresa( "lIvaImpEsp")

               nBaseImp += hGet( uIva, "nivmh" )
            end











































            aAsiento    := MkAsiento(  nAsiento,  cCodDiv,  dFecha,  hGet( uIva, "cSubCtaIva" ), cCtaCli, , cConcepto, hGet( uIva, "impiva" ) , cFactura, nBaseImp, hGet( uIva, "porcentajeiva" ), if( lRecargo, hGet( uIva, "porcentajere" ), 0 ), , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom )

            aAdd( aSimula, aAsiento )



            aAsientoSII := MkAsientoSII( aAsiento )

            if !empty( aAsientoSII )
               aadd( aAsientosSII, aAsientoSII )
            end

         end
































         if ( lRecargo .AND. len( uIva ) >= 13 .AND. hGet( uIva, "impre" ) <> 0 )





















            aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, hGet( uIva, "cSubCuentaRecargo" ), , , cConcepto, hGet( uIva, "impre" ), cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

         end


































      next





      if ConfiguracionesEmpresaModel():getLogic( "lDtoLinAfterTotal", .F. )






















         aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, Padr( AllTrim( ConfiguracionesEmpresaModel():getValue( "cuenta_descuento_especial", "" ) ), 12 ), , nTotalDtoLineal, "Impuesto especial 0.2€/L", , cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )



      end

   end












   if lPago .AND. !lErrorFound .AND. ( dbfFacCliP )->( dbSeek( nFactura ) )

      while ( ( dbfFacCliP )->cSerie + str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac == nFactura ) .AND. !( dbfFacCliP )->( eof() )



         ContabilizaReciboCliente( oBrw, oTree, .T., aSimula, dbfFacCliT, dbfFacCliP, dbfFPago, dbfCli, dbfDiv, .T., nAsiento )

         ( dbfFacCliP )->( dbSkip() )

      end

   end





   if lSimula

      if lMessage




         lReturn  := msgTblCon(  aSimula, cCodDiv, dbfDiv, !lErrorFound, pFactura, {||   aWriteAsiento( aSimula, cCodDiv, lMessage, oTree, pFactura, nAsiento ), aWriteAsientoSII( aAsientosSII ), lContabilizaFacturaCliente( nFactura, pFactura, nAsiento, aSimula, lPago, oTree, dbfFacCliT, dbfFacCliP ) } )
      end

   else

      if !lErrorFound
         aWriteAsiento( aSimula, cCodDiv, lMessage, oTree, pFactura, nAsiento )

         aWriteAsientoSII( aAsientosSII )

         lReturn  := lContabilizaFacturaCliente( nFactura, pFactura, nAsiento, aSimula, lPago, oTree, dbfFacCliT )
      end

   end





   if !lOpenDiario
      CloseDiario()
   end

   setAsientoIntraComunitario( .F. )

   if !Empty( oBrw )
      oBrw:Refresh()
   end

RETURN ( lReturn )



Static Function lContabilizaFacturaCliente( nFactura, pFactura, nAsiento, aSimula, lPago, oTree, dbfFacCliT, dbfFacCliP )

   local aAsiento                   := atail( aSimula )



   if lAplicacionA3()
      EnlaceA3():getInstance():Render()
   end



   if dbDialogLock( dbfFacCliT )

      ( dbfFacCliT )->lContab       := .T.

      if ( getDiarioDatabaseContaplus() )->( fieldpos( "Guid" ) ) <> 0
         ( dbfFacCliT )->cConGuid   := aAsiento[ ( getDiarioDatabaseContaplus() )->( fieldpos( "Guid" ) ) ]
      end

      ( dbfFacCliT )->( dbUnLock() )

   end



   if lAplicacionA3()
      EnlaceA3():getInstance():WriteInfo( oTree, "Factura cliente : " + rtrim( pFactura ) + " asiento generado." )
   else
      oTree:Select( oTree:Add( "Factura cliente : " + rtrim( pFactura ) + " asiento generado num. " + alltrim( str( nAsiento ) ), 1 ) )
   end



   if !empty( dbfFacCliP ) .AND. lPago

      if ( dbfFacCliP )->( dbseek( nFactura ) )

         while ( ( dbfFacCliP )->cSerie + str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac == nFactura ) .AND. !( dbfFacCliP )->( eof() )

            if dbDialogLock( dbfFacCliP )

               ( dbfFacCliP )->lConPgo       := .T.

               if ( getDiarioDatabaseContaplus() )->( fieldpos( "Guid" ) ) <> 0
                  ( dbfFacCliP )->cConGuid   := aAsiento[ ( getDiarioDatabaseContaplus() )->( fieldpos( "Guid" ) ) ]
               end

               ( dbfFacCliP )->( dbunlock() )

            end

            ( dbfFacCliP )->( dbskip() )

         end

      end

   end

Return ( .T. )



Function DlgCntTicket( oBrw, oNewImp, nView )

   local oRad
   local nRad        := 1
   local oDlg
   local oChk1
   local oChk2
   local lChk1       := .T.
   local lChk2       := .T.
   local oSelTik
   local nSelTik     := 1
   local nOrdAnt     := ( D():Tikets( nView ) )->( OrdSetFocus( 1 ) )
   local nRecAnt     := ( D():Tikets( nView ) )->( RecNo() )
   local oSerIni
   local cSerIni     := ( D():Tikets( nView ) )->cSerTik
   local oDocIni
   local nDocIni     := Val( ( D():Tikets( nView ) )->cNumTik )
   local oSufIni
   local cSufIni     := ( D():Tikets( nView ) )->cSufTik
   local oSerFin
   local cSerFin     := ( D():Tikets( nView ) )->cSerTik
   local oDocFin
   local nDocFin     := Val( ( D():Tikets( nView ) )->cNumTik )
   local cSufFin     := ( D():Tikets( nView ) )->cSufTik
   local oSufFin
   local dFecIni     := ( D():Tikets( nView ) )->dFecTik
   local dFecFin     := ( D():Tikets( nView ) )->dFecTik
   local lSimula     := .T.
   local lCobros     := .T.
   local oMtrInf
   local nMtrInf
   local lFechas     := .T.
   local dDesde      := CtoD( "01/01/" + str( Year( Date() ) ) )
   local dHasta      := Date()
   local oTree
   local oImageList
   local oBtnCancel

   oImageList        := TImageList():New( 16, 16 )
   oImageList:AddMasked( TBitmap():Define( "bRed" ), ( 255 + ( 0 * 256 ) + ( 255 * 65536 ) ) )
   oImageList:AddMasked( TBitmap():Define( "bGreen" ), ( 255 + ( 0 * 256 ) + ( 255 * 65536 ) ) )

   oDlg = TDialog():New(,,,, "Contabilizar tickets", "SelectRango",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )



   oRad := TRadMenu():Redefine( { | u | If( PCount()==0, nRad, nRad:= u ) }, oDlg,, { 80, 81 },,,,, .F.,, )










   oSerIni := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, cSerIni, cSerIni:= u ) }, oDlg,, "@!", {||    ( cSerIni >= "A" .AND. cSerIni <= "Z" )},,,,,, .T., {||     ( oRad:nOption == 2 )},, .F., .T., {||    ( UpSerie( oSerIni ) )}, {||  ( DwSerie( oSerIni ) )},,,, nil,,, )






   TBtnBmp():ReDefine( 101, "Up16",,,,, {|Self|( oDocIni:cText( Val( dbFirst( D():Tikets( nView ), "cNumTik", , cSerIni, "cNumTik" ) ) ) )}, oDlg, .F.,, .F.,,,,,, !.T.,, .F.,,, .F., !.F.,, .F. )










   oSerFin := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, cSerFin, cSerFin:= u ) }, oDlg,, "@!", {||    ( cSerFin >= "A" .AND. cSerFin <= "Z" )},,,,,, .T., {||     ( oRad:nOption == 2 )},, .F., .T., {||    ( UpSerie( oSerFin ) )}, {||  ( DwSerie( oSerFin ) )},,,, nil,,, )






   TBtnBmp():ReDefine( 111, "Down16",,,,, {|Self|( oDocFin:cText( Val( dbLast( D():Tikets( nView ), "cNumTik", , cSerIni, "cNumTik" ) ) ) )}, oDlg, .F.,, .F.,,,,,, !.T.,, .F.,,, .F., !.F.,, .F. )






   oDocIni := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, nDocIni, nDocIni:= u ) }, oDlg,, "999999999",,,,,,, .F., {||     ( nRad == 2 )},, .F., .T.,,,,,, nil,,, )






   oDocFin := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, nDocFin, nDocFin:= u ) }, oDlg,, "999999999",,,,,,, .F., {||     ( nRad == 2 )},, .F., .T.,,,,,, nil,,, )





   oSufIni := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, cSufIni, cSufIni:= u ) }, oDlg,, "##",,,,,,, .F., {||     ( nRad == 2 )},, .F., .F.,,,,,, nil,,, )





   oSufFin := TGetHlp():ReDefine( 150, { | u | If( PCount()==0, cSufFin, cSufFin:= u ) }, oDlg,, "##",,,,,,, .F., {||     ( nRad == 2 )},, .F., .F.,,,,,, nil,,, )



   oChk1 := TCheckBox():ReDefine( 160, { | u | If( PCount()==0, lChk1, lChk1:= u ) }, oDlg,,,,,,, .F.,, .F. )



   oChk2 := TCheckBox():ReDefine( 180, { | u | If( PCount()==0, lChk2, lChk2:= u ) }, oDlg,,,,,,, .F.,, .F. )







   TCheckBox():ReDefine( 300, { | u | If( PCount()==0, lFechas, lFechas:= u ) }, oDlg,,,,,,, .F.,, .F. )





   TGetHlp():ReDefine( 310, { | u | If( PCount()==0, dDesde, dDesde:= u ) }, oDlg,,,,,,,,, .F., {||     ( !lFechas )},, .F., .T.,,,,,, nil,,, )





   TGetHlp():ReDefine( 320, { | u | If( PCount()==0, dHasta, dHasta:= u ) }, oDlg,,,,,,,,, .F., {||     ( !lFechas )},, .F., .T.,,,,,, nil,,, )

   oTree             := TTreeView():Redefine( 170, oDlg )
   oTree:bLDblClick  := {|| TreeChanged( oTree ) }






   oMtrInf := TApoloMeter():ReDefine( 200, { | u | If( PCount()==0, nMtrInf, nMtrInf:= u ) }, ( D():Tikets( nView ) )->( Lastrec() ), oDlg, .F.,, "Proceso", .F.,,,, )




   TButton():ReDefine( 1, {||( ContabilizaTicket( nRad, cSerIni + str( nDocIni, 10 ) + cSufIni, cSerFin + str( nDocFin, 10 ) + cSufFin, lFechas, dDesde, dHasta, lChk1, lChk2, oBrw, oMtrInf, oTree, oDlg, oBtnCancel, oNewImp, nView ) )}, oDlg,,, .F.,,,, .F. )





   oBtnCancel := TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   oDlg:AddFastKey( 116, {|| ContabilizaTicket( nRad, cSerIni + str( nDocIni, 10 ) + cSufIni, cSerFin + str( nDocFin, 10 ) + cSufFin, lFechas, dDesde, dHasta, lChk1, lChk2, oBrw, oMtrInf, oTree, oDlg, oBtnCancel, oNewImp, nView ) } )

   oDlg:bStart := {|| StartGetSelRec( oBrw, oRad, oChk1, oChk2, oSerIni, oSerFin, oDocIni, oDocFin, oSufIni, oSufFin ) }


   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|( oTree:SetImageList( oImageList ) )}, oDlg:bRClicked,,, )

   ( D():Tikets( nView ) )->( OrdSetFocus( nOrdAnt ) )
   ( D():Tikets( nView ) )->( dbGoTo( nRecAnt ) )

   oImageList:End()

   oTree:Destroy()

   oBrw:Refresh()

RETURN ( oDlg:nResult == 1 )



Static Function StartGetSelRec( oBrw, oRad, oChk1, oChk2, oSerIni, oSerFin, oDocIni, oDocFin, oSufIni, oSufFin )

   if !Empty( oBrw ) .AND. ( len( oBrw:oBrw:aSelected ) > 1 )
      oRad:SetOption( 1 )
   else
      oRad:SetOption( 2 )
      oSerIni:Enable()
      oSerFin:Enable()
      oDocIni:Enable()
      oDocFin:Enable()
      oSufIni:Enable()
      oSufFin:Enable()
   end

   if lAplicacionSage50()
      oChk1:Hide()
      oChk2:Hide()
   end

   if lAplicacionContaplus()
      oChk1:SetText( "Simular resultados" )
      oChk2:SetText( "Contabilizar cobros" )
   end

Return ( nil )



Static Function TreeChanged( oTree )

   local oItemTree   := oTree:GetItem()

   if !Empty( oItemTree ) .AND. !Empty( oItemTree:bAction )
      Eval( oItemTree:bAction )
   end

Return nil



Static Function ContabilizaTicket( nRad, cNumIni, cNumFin, lFechas, dDesde, dHasta, lSimula, lCobro, oBrw, oMtrInf, oTree, oDlg, oBtnCancel, oNewImp, nView )

   do case
      case lAplicacionContaplus()
         ContaSerieTiket( nRad, cNumIni, cNumFin, lFechas, dDesde, dHasta, lSimula, lCobro, oBrw, oMtrInf, oTree, oDlg, oBtnCancel, D():Tikets( nView ), D():TiketsLineas( nView ), D():TiketsCobros( nView ), D():Clientes( nView ), D():Articulos( nView ), D():FormasPago( nView ), D():Divisas( nView ), oNewImp )

      case lAplicacionA3()
         MsgInfo( "Contabiliza A3Com" )

      case lAplicacionSage()
         MsgInfo( "Contabiliza sage despacho" )

      case lAplicacionSage50()
         ContaTicketSage50( nRad, cNumIni, cNumFin, lFechas, dDesde, dHasta, lSimula, lCobro, oBrw, oMtrInf, oTree, oDlg, oBtnCancel, nView )

      case lAplicacionMonitor()
         MsgInfo( "Monitor Informática" )

   end

Return nil



Static Function ContaSerieTiket( nRad, cNumIni, cNumFin, lFechas, dDesde, dHasta, lSimula, lCobro, oBrw, oMtrInf, oTree, oDlg, oBtnCancel, dbfTikT, dbfTikL, dbfTikP, dbfCli, dbfArt, dbfFPago, dbfDiv, oNewImp )

   local n        := 0
   local aPos
   local nPos
   local lRet
   local nRecAnt  := ( dbfTikT )->( RecNo() )
   local nOrdAnt  := ( dbfTikT )->( OrdSetFocus( "cNumTik" ) )
   local lWhile   := .T.





   if lSimula
      aPos        := { 0, 0 }
      ClientToScreen( oDlg:hWnd, aPos )
      oDlg:Move( aPos[ 1 ] - 26, aPos[ 2 ] - 510 )
   end





   oDlg:Disable()

   oTree:Enable()
   oTree:DeleteAll()

   oBtnCancel:bAction   := {|| lWhile := .F. }
   oBtnCancel:Enable()

   if nRad == 1

      oMtrInf:SetTotal( len( oBrw:oBrw:aSelected ) )

      for each nPos in ( oBrw:oBrw:aSelected )

         ( dbfTikT )->( dbGoTo( nPos ) )

         if lFechas .OR.( ( dbfTikT )->dFecTik >= dDesde .AND. ( dbfTikT )->dFecTik <= dHasta )

            do case
               case ( dbfTikT )->cTipTik == "1"
                  lRet  := CntTiket( lSimula, lCobro, .F., .T., oTree, 0, , dbfTikT, dbfTikL, dbfTikP, dbfCli, dbfArt, dbfFPago, dbfDiv, oNewImp )
               case ( dbfTikT )->cTipTik == "4"
                  lRet  := CntTiket( lSimula, lCobro, .T., .T., oTree, 0, , dbfTikT, dbfTikL, dbfTikP, dbfCli, dbfArt, dbfFPago, dbfDiv, oNewImp )
            end

         end

         if IsFalse( lRet )
            exit
         end

         oMtrInf:Set( ++n )

         SysRefresh()

         if !lWhile
            exit
         end

      next

      oMtrInf:Set( len( oBrw:oBrw:aSelected ) )

   else

      if ( dbfTikT )->( dbSeek( cNumIni, .T. ) )

         oMtrInf:Set( ( dbfTikT )->( OrdKeyNo() ) )





         while ( lWhile )                                .AND. !Empty( ( dbfTikT )->( OrdKeyVal() ) )    .AND. ( dbfTikT )->( OrdKeyVal() ) >= cNumIni   .AND. ( dbfTikT )->( OrdKeyVal() ) <= cNumFin   .AND. ( dbfTikT )->( !eof() )

            if lFechas .OR.( ( dbfTikT )->dFecTik >= dDesde .AND. ( dbfTikT )->dFecTik <= dHasta )

               do case
                  case ( dbfTikT )->cTipTik == "1"
                     lRet  := CntTiket( lSimula, lCobro, .F., .T., oTree, 0, , dbfTikT, dbfTikL, dbfTikP, dbfCli, dbfArt, dbfFPago, dbfDiv, oNewImp )
                  case ( dbfTikT )->cTipTik == "4"
                     lRet  := CntTiket( lSimula, lCobro, .T., .T., oTree, 0, , dbfTikT, dbfTikL, dbfTikP, dbfCli, dbfArt, dbfFPago, dbfDiv, oNewImp )
               end

               if IsFalse( lRet )
                  exit
               end

            end

            ( dbfTikT )->( dbSkip() )

            oMtrInf:Set( ( dbfTikT )->( OrdKeyNo() ) )

         end

         oMtrInf:Set( ( dbfTikT )->( Lastrec() ) )

      end

   end

   if lSimula
      WndCenter( oDlg:hWnd )
   end

   oBtnCancel:bAction   := {|| oDlg:End() }

   oDlg:Enable()

   ( dbfTikT )->( dbGoTo( nRecAnt ) )
   ( dbfTikT )->( OrdSetFocus( nOrdAnt ) )

Return Nil



Static Function ContaTicketSage50( nRad, cNumIni, cNumFin, lFechas, dDesde, dHasta, lSimula, lCobro, oBrw, oMtrInf, oTree, oDlg, oBtnCancel, nView )

   local n        := 0
   local aPos
   local nPos
   local lRet
   local nRecAnt  := ( D():Tikets( nView ) )->( RecNo() )
   local nOrdAnt  := ( D():Tikets( nView ) )->( OrdSetFocus( "cNumTik" ) )





   oDlg:Disable()

   oTree:Enable()
   oTree:DeleteAll()

   if nRad == 1

      oMtrInf:SetTotal( len( oBrw:oBrw:aSelected ) )

      for each nPos in ( oBrw:oBrw:aSelected )

         ( D():Tikets( nView ) )->( dbGoTo( nPos ) )


         if lFechas .OR.( ( D():Tikets( nView ) )->dFecTik >= dDesde .AND. ( D():Tikets( nView ) )->dFecTik <= dHasta ) .AND. ( D():Tikets( nView ) )->cTipTik == "1"

            EnlaceSage50():GetInstance():ContabilizaTicketCliente( nView, oTree )

         end

         oMtrInf:Set( ++n )

         SysRefresh()

      next

      oMtrInf:Set( len( oBrw:oBrw:aSelected ) )

   else

      if ( D():Tikets( nView ) )->( dbSeek( cNumIni, .T. ) )

         oMtrInf:Set( ( D():Tikets( nView ) )->( OrdKeyNo() ) )




         while !Empty( ( D():Tikets( nView ) )->( OrdKeyVal() ) )    .AND. ( D():Tikets( nView ) )->( OrdKeyVal() ) >= cNumIni   .AND. ( D():Tikets( nView ) )->( OrdKeyVal() ) <= cNumFin   .AND. ( D():Tikets( nView ) )->( !eof() )


            if ( lFechas .OR.( ( D():Tikets( nView ) )->dFecTik >= dDesde .AND. ( D():Tikets( nView ) )->dFecTik <= dHasta ) ) .AND. ( D():Tikets( nView ) )->cTipTik == "1"

               EnlaceSage50():GetInstance():ContabilizaTicketCliente( nView, oTree )

            end

            ( D():Tikets( nView ) )->( dbSkip() )

            oMtrInf:Set( ( D():Tikets( nView ) )->( OrdKeyNo() ) )

         end

         oMtrInf:Set( ( D():Tikets( nView ) )->( Lastrec() ) )

      end

   end

   oDlg:Enable()

   ( D():Tikets( nView ) )->( dbGoTo( nRecAnt ) )
   ( D():Tikets( nView ) )->( OrdSetFocus( nOrdAnt ) )





   EnlaceSage50():GetInstance():WriteASCII()
   EnlaceSage50():DestroyInstance()

Return Nil



Function CntTiket( lSimula, lCobro, lDev, lMessage, oTree, nAsiento, aSimula, dbfTikT, dbfTikL, dbfTikP, dbfCli, dbfArt, dbfFPago, dbfDiv, oNewImp )

   local n
   local nPos
   local dFecha
   local cConcepto
   local cPago
   local nIvaDeta
   local nImpDeta
   local nIvmDeta
   local cSubCtaIvm
   local cSubCtaIva
   local cCtaVent
   local aIva           := {}
   local aIvm           := {}
   local aVentas        := {}
   local aPago          := {}
   local aAsiento       := {}
   local nTotTik        := 0
   local nTotPgo        := 0
   local cCtaPgo        := cCtaCob()
   local cRuta          := cRutCnt()
   local nOrdAnt
   local cCodEmp        := cCodEmpCnt( ( dbfTikT )->cSerTik )
   local cCodPro        := ( dbfTikT )->cCodPro
   local cCtaCli        := cCliCta( ( dbfTikT )->cCliTik, dbfCli )
   local cNumTik        := ( dbfTikT )->cSerTik + ( dbfTikT )->cNumTik + ( dbfTikT )->cSufTik
   local cTxtNumTik     := rtrim( ( dbfTikT )->cSerTik + "/" + alltrim( ( dbfTikT )->cNumTik ) + "/" + ( dbfTikT )->cSufTik )
   local cCodDiv        := ( dbfTikT )->cDivTik
   local nDouDiv        := nDouDiv( ( dbfTikT )->cDivTik, dbfDiv )
   local nRouDiv        := nRouDiv( ( dbfTikT )->cDivTik, dbfDiv )
   local lErrorFound    := .F.
   local cProyecto
   local cClave
   local cTerNif        := ( dbfTikT )->cDniCli
   local cTerNom        := ( dbfTikT )->cNomTik
   local lReturn
   local nBaseImp
   local aAsientoSII
   local aAsientosSII   := {}


   If( nAsiento == nil, nAsiento := 0, ) ;
   If( aSimula == nil, aSimula := {}, ) ;

   cProyecto            := Left( cCodPro, 3 )
   cClave               := Right( cCodPro, 6 )






   if !ChkRuta( cRuta )
      oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " ruta no valida para acceso a Contaplus®", 0 ) )
      lErrorFound       := .T.
   end

   if Empty( cCodEmp )
      oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " empresa de Contaplus® no encontrada", 0 ) )
      lErrorFound       := .T.
   end

   if !ChkFecha( cRuta, cCodEmp, ( dbfTikT )->dFecTik, .F., oTree )
      lErrorFound       := .T.
   end

   if ( dbfTikT )->lConTik
      oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + ", ya contabilizado", 0 ) )
      lErrorFound       := .T.
   end

   nTotTik              := nTotTik( cNumTik, dbfTikT, dbfTikL, dbfDiv, nil, nil, .F., nil )

   if lDev
      nTotTik           := - nTotTik
   end






   if Empty( cCtaCli )
      cCtaCli           := cCtaSin()
   end






   if ( dbfTikL )->( dbSeek( cNumTik ) )

      while ( dbfTikL )->cSerTil + ( dbfTikL )->cNumTil + ( dbfTikL )->cSufTil == cNumTik .AND. !( dbfTikL )->( eof() )









         nImpDeta    := nNetLTpv( dbfTikL, nDouDiv, nRouDiv )

         if ( dbfTikT )->nDtoEsp <> 0
            nImpDeta -= Round( nImpDeta * ( dbfTikT )->nDtoEsp / 100, nRouDiv )
         end

         if ( dbfTikT )->nDpp <> 0
            nImpDeta -= Round( nImpDeta * ( dbfTikT )->nDpp / 100, nRouDiv )
         end





         nIvaDeta    := nTotLTpv( dbfTikL, nDouDiv, nRouDiv )

         if ( dbfTikT )->nDtoEsp <> 0
            nIvaDeta -= Round( nIvaDeta * ( dbfTikT )->nDtoEsp / 100, nRouDiv )
         end

         if ( dbfTikT )->nDpp <> 0
            nIvaDeta -= Round( nIvaDeta * ( dbfTikT )->nDpp / 100, nRouDiv )
         end

         nIvaDeta    -= nImpDeta





         nIvmDeta    := nIvmLTpv( dbfTikL, nDouDiv, nRouDiv )

         if ( dbfTikT )->nDtoEsp <> 0
            nIvmDeta -= Round( nIvmDeta * ( dbfTikT )->nDtoEsp / 100, nRouDiv )
         end

         if ( dbfTikT )->nDpp <> 0
            nIvmDeta -= Round( nIvmDeta * ( dbfTikT )->nDpp / 100, nRouDiv )
         end

         nImpDeta    -= nIvmDeta





         if lDev
            nImpDeta := - nImpDeta
            nIvaDeta := - nIvaDeta
            nIvmDeta := - nIvmDeta
         end





         cCtaVent    := RetCtaVta( ( dbfTikL )->cCbaTil, ( nImpDeta < 0 ), dbfArt )
         if Empty( cCtaVent )
            cCtaVent := cCtaCli() + RetGrpVta( ( dbfTikL )->cCbaTil, cRuta, cCodEmp, ( dbfTikL )->nIvaTil )
         end





         nPos        := aScan( aVentas, {|x| x[ 1 ] == cCtaVent } )
         if nPos == 0
            aadd( aVentas, { cCtaVent, ( dbfTikL )->nIvaTil, nImpDeta, nIvaDeta } )
         else
            aVentas[ nPos, 3 ] += nImpDeta
            aVentas[ nPos, 4 ] += nIvaDeta
         end






         cSubCtaIva  := cSubCuentaIva( ( dbfTikL )->nIvaTil, .F., cRuta, cCodEmp )

         nPos        := aScan( aIva, {|x| x[ 1 ] == cSubCtaIva } )
         if nPos == 0
            aAdd( aIva, { cSubCtaIva, ( dbfTikL )->nIvaTil, nImpDeta, nIvaDeta, nIvmDeta  } )
         else
            aIva[ nPos, 3 ] += nImpDeta
            aIva[ nPos, 4 ] += nIvaDeta
            aIva[ nPos, 5 ] += nIvmDeta
         end






         if nIvmDeta <> 0





           cSubCtaIvm   := oNewImp:cCtaImp( oNewImp:nValImp( ( dbfTikL )->cCodImp ) )

            nPos        := aScan( aIvm, {|x| x[ 1 ] == cSubCtaIvm } )
            if nPos == 0
               aAdd( aIvm, { cSubCtaIvm, nIvmDeta } )
            else
               aIvm[ nPos, 2 ] += nIvmDeta
            end

         end

         ( dbfTikL )->( dbSkip() )

      end

   end






   nOrdAnt           := ( dbfTikP )->( ordsetfocus( "cNumTik" ) )

   if ( dbfTikP )->( dbSeek( cNumTik ) )

      while ( dbfTikP )->cSerTik + ( dbfTikP )->cNumTik + ( dbfTikP )->cSufTik == cNumTik .AND. !( dbfTikP )->( eof() )

         cCtaPgo     := ( dbfTikP )->cCtaPgo

         if empty( cCtaPgo )
            cCtaPgo  := cCtaFPago( ( dbfTikT )->cFpgTik, dbfFPago )
         end

         if empty( cCtaPgo )
            cCtaPgo  := cCtaCob()
         end

         nTotPgo     := nTotUCobTik( dbfTikP, nRouDiv )

         if lDev
            nTotPgo  := - nTotPgo
         end

         nPos        := aScan( aPago, {|x| x[ 1 ] + x[ 2 ] == cCtaPgo + cCtaCli } )
         if nPos == 0
            aAdd( aPago, { cCtaPgo, cCtaCli, nTotPgo } )
         else
            aPago[ nPos, 3 ] += nTotPgo
         end

         ( dbfTikP )->( dbSkip() )

      end

   end

   ( dbfTikP )->( OrdSetFocus( nOrdAnt ) )






   if !ChkSubcuenta( cRuta, cCodEmp, cCtaCli, , .F., .F. )
      oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " subcuenta de cliente " + rtrim( cCtaCli ) + " no encontada, en empresa" + cCodEmp, 0 ) )
      lErrorFound    := .T.
   end

   for n := 1 to len( aVentas )
      if !ChkSubcuenta( cRuta, cCodEmp, aVentas[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " subcuenta de ventas " + rtrim( aVentas[ n, 1 ] ) + " no encontada, en empresa" + cCodEmp, 0 ) )
         lErrorFound := .T.
      end
   next

   for n := 1 to len( aIva )
      if !ChkSubcuenta( cRuta, cCodEmp, aIva[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " subcuenta de " + cImp() + " " + rtrim( aIva[ n, 1 ] ) + " no encontada, en empresa" + cCodEmp, 0 ) )
         lErrorFound := .T.
      end
   next

   for n := 1 to len( aIvm )
      if !ChkSubcuenta( cRuta, cCodEmp, aIvm[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " subcuenta de IVM " + rtrim( aIvm[ n, 1 ] ) + " no encontada, en empresa" + cCodEmp, 0 ) )
         lErrorFound := .T.
      end
   end

   for n := 1 to len( aPago )
      if !ChkSubcuenta( cRuta, cCodEmp, aPago[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " subcuenta de pago " + rtrim( aPago[ n, 1 ] ) + " no encontada, en empresa" + cCodEmp, 0 ) )
         lErrorFound := .T.
      end
   next






   dFecha      := ( dbfTikT )->dFecTik

   cConcepto   := "N/Tiket N. " + cTxtNumTik
   cPago       := "C/Tiket N. " + cTxtNumTik






   if lSimula .OR. !lErrorFound

      if OpenDiario( , cCodEmp )
         nAsiento                := contaplusUltimoAsiento()
      else
         oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " imposible abrir ficheros.", 0 ) )
         return .F.
      end

























      aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha, cCtaCli, , Round( nTotTik, nRouDiv ), cConcepto, , cNumTik, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )






      for n := 1 to Len( aVentas )





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aVentas[ n, 1 ], , , cConcepto, Round( aVentas[ n, 3 ], nRouDiv ), cNumTik, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      next






      for n := 1 to len( aIvm )





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIvm[ n, 1 ], , , cConcepto, Round( aIvm[ n, 2 ], nRouDiv ), cNumTik, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      next






      for n := 1 to len( aIva )

         if aIva[ n, 4 ] <> 0 .OR. uFieldEmpresa( "lConIva" )

            if uFieldEmpresa( "lIvaImpEsp")
               nBaseImp := aIva[ n, 3 ] + aIva[ n, 5 ]
            else
               nBaseImp := aIva[n, 3 ]
            end





















            aAsiento    := MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIva[ n, 1 ], cCtaCli, , cConcepto, aIva[ n, 4 ], cNumTik, nBaseImp, aIva[ n, 2 ], , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom )

            aAdd( aSimula, aAsiento )



            aAsientoSII := MkAsientoSII( aAsiento, 2 )

            if !empty( aAsientoSII )
               aadd( aAsientosSII, aAsientoSII )
            end

         end

      next






      if lCobro

         for n := 1 to len( aPago )

            if aPago[ n, 3 ] <> 0





















               aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha,  aPago[ n, 1 ], , aPago[ n, 3 ], cPago, , cNumTik, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

            end





            if aPago[ n, 3 ] <> 0





















               aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha,  aPago[ n, 2 ], , , cPago, aPago[ n, 3 ], cNumTik, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

            end

         next

      end






      if !lSimula

         if !lErrorFound

            aWriteAsiento( aSimula, cCodDiv, lMessage, oTree, cTxtNumTik, nAsiento )

            aWriteAsientoSII( aAsientosSII )

            lReturn  := lCntTiket( cNumTik, cTxtNumTik, nAsiento, lCobro, oTree, dbfTikT, dbfTikP )

         end

      else

         if lMessage



            lReturn  := msgTblCon( aSimula, cCodDiv, dbfDiv, !( dbfTikT )->lConTik .AND. !lErrorFound, cTxtNumTik, {||   aWriteAsiento( aSimula, cCodDiv, lMessage, oTree, cTxtNumTik, nAsiento ), aWriteAsientoSII( aAsientosSII ), lCntTiket( cNumTik, cTxtNumTik, nAsiento, lCobro, oTree, dbfTikT, dbfTikP ) } )
         end

      end

   end

   CloseDiario()

RETURN ( lReturn )



Static Function lCntTiket( cNumTik, cTxtNumTik, nAsiento, lCobro, oTree, dbfTikT, dbfTikP )

   local nOrdAnt






   if ( dbfTikT )->( dbRLock() )
      ( dbfTikT )->lConTik          := .T.
      ( dbfTikT )->( dbRUnLock() )
   end






   if lCobro

      nOrdAnt  := ( dbfTikP )->( OrdSetFocus( "cNumTik" ) )

      if ( dbfTikP )->( dbSeek( cNumTik ) )

         while ( dbfTikP )->cSerTik + ( dbfTikP )->cNumTik + ( dbfTikP )->cSufTik == cNumTik .AND. !( dbfTikP )->( eof() )

            if ( dbfTikP )->( dbRLock() )
               ( dbfTikP )->lConPgo := .T.
               ( dbfTikP )->( dbRUnLock() )
            end

            ( dbfTikP )->( dbSkip() )

         end

      end

      ( dbfTikP )->( OrdSetFocus( nOrdAnt ) )

   end

   oTree:Select( oTree:Add( "Tiket : " + cTxtNumTik + " asiento generado num. " + alltrim( str( nAsiento ) ), 1 ) )

Return ( .T. )






Function cSubCuentaIva( nIva, lRecargo, cRuta, cCodEmp, dbfIva, lVentas )

   local nReq        := 0
   local cReq        := ""
   local cIva        := RJust( nIva, "0", 2 )
   local cSubCtaIva  := ""

   If( lVentas == nil, lVentas := .T., ) ;

   if ( nLenCuentaContaplus( cRuta, cCodEmp ) >= 4 )
      cReq           := "00"
   end

   if ( lRecargo )
      nReq           := nPReq( dbfIva, nIva )

      if nReq  < 1 .OR. uFieldEmpresa( "lReqDec" )
         nReq        := nReq * 10
      end

      cReq           := RJust( nReq, "0", 2 )
   end

   if lIvaReq()
      cSubCtaIva     := cIva + cReq
   else
      cSubCtaIva     := cReq + cIva
   end

   if lVentas
      cSubCtaIva     := RetCtaEsp( 2 ) + RJust( cSubCtaIva, "0", nLenCuentaContaplus( cRuta, cCodEmp ) )
   else
      cSubCtaIva     := RetCtaEsp( 1 ) + RJust( cSubCtaIva, "0", nLenCuentaContaplus( cRuta, cCodEmp ) )
   end

Return ( cSubCtaIva )






Function cSubCuentaRecargo( nIva, lRecargo, cRuta, cCodEmp, dbfIva )

   local nReq        := 0
   local cSubCtaReq  := ""

   if lRecargo

      nReq           := nPReq( dbfIva, nIva )

      if nReq < 1 .OR. uFieldEmpresa( "lReqDec" )
         nReq        := nReq * 10
      end

   end

   cSubCtaReq        := RetCtaEsp( 3 ) + RJust( nReq, "0", nLenCuentaContaplus( cRuta, cCodEmp ) )

Return ( cSubCtaReq )



FUNCTION CntAlbCli( lSimula, lExcCnt, lMessage, oTree, nAsiento, aSimula, dbfAlbCliT, dbfAlbCliL, dbfCli, dbfDiv, dbfArt, dbfFPago, dbfIva, oNewImp, oBrw )

   local n
   local nIva
   local cCtaVent
   local nPos
   local dFecha
   local ptaDebe
   local cConcepto
   local cPago
   local cSubCtaIva
   local cSubCtaReq
   local cSubCtaIvm
   local cSubCtaTrn
   local nImpDet
   local nImpTrn
   local nImpPnt
   local nImpIvm
   local nImpIva
   local cCodEmp
   local cRuta
   local nDouDiv
   local nRouDiv
   local nDpvDiv
   local nTotAnt     := 0
   local aIva        := {}
   local aIvm        := {}
   local aTrn        := {}
   local nCalculo    := 0
   local nBase       := 0
   local aVentas     := {}
   local lIvaInc     := ( dbfAlbCliT )->lIvaInc
   local cCodDiv     := ( dbfAlbCliT )->cDivAlb
   local cCtaCli     := cCliCta( ( dbfAlbCliT )->cCodCli, dbfCli )
   local cCtaCliVta  := cCliCtaVta( ( dbfAlbCliT )->cCodCli, dbfCli )
   local cCtaAnticipo:= cCtaAnt()
   local nAlbaran    := ( dbfAlbCliT )->cSerAlb + str( ( dbfAlbCliT )->nNumAlb ) + ( dbfAlbCliT )->cSufAlb
   local cAlbaran    := ( dbfAlbCliT )->cSerAlb + alltrim( str( ( dbfAlbCliT )->nNumAlb ) )
   local lRecargo    := ( dbfAlbCliT )->lRecargo
   local lErrorFound := .F.
   local cTerNif     := ( dbfAlbCliT )->cDniCli
   local cTerNom     := ( dbfAlbCliT )->cNomCli
   local lReturn

   If( lSimula == nil, lSimula := .T., ) ;
   If( nAsiento == nil, nAsiento := 0, ) ;
   If( aSimula == nil, aSimula := {}, ) ;

   nDouDiv           := nDouDiv( ( dbfAlbCliT )->cDivAlb, dbfDiv )
   nRouDiv           := nRouDiv( ( dbfAlbCliT )->cDivAlb, dbfDiv )
   nDpvDiv           := nDpvDiv( ( dbfAlbCliT )->cDivAlb, dbfDiv )






   cRuta             := cRutCnt()
   cCodEmp           := cCodEmpCnt( ( dbfAlbCliT )->cSerAlb )

   if !lSimula .AND. !chkEmpresaAsociada( cCodEmp )
      oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " no se definierón empresas asociadas.", 0 ) )
      lErrorFound    := .T.
   end

   if !lSimula .AND. !ChkRuta( cRutCnt() )
      oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " ruta no valida.", 0 ) )
      lErrorFound    := .T.
   end

   if !lSimula .AND. !ChkFecha( cRuta, cCodEmp, ( dbfAlbCliT )->dFecAlb, .F., oTree )
      lErrorFound    := .T.
   end






   if Empty( cCtaCli )
      cCtaCli        := cCtaSin()
   end

   if Empty( cCtaCliVta )
      cCtaCliVta     := cCtaCli()
   end






   if ( dbfAlbCliL )->( dbSeek( nAlbaran ) )

      while ( ( dbfAlbCliL )->cSerAlb + str( ( dbfAlbCliL )->nNumAlb ) + ( dbfAlbCliL )->cSufAlb == nAlbaran .AND. !( dbfAlbCliL )->( eof() ) )




         if !( dbfAlbCliL )->lControl                          .AND.  !( dbfAlbCliL )->lTotLin                           .AND.  lValLine( dbfAlbCliL )                             .AND.  nTotLAlbCli( dbfAlbCliL, nDouDiv, nRouDiv, nil, .T., .F., .F. ) <> 0



            if ( lExcCnt == nil                                .OR. ( lExcCnt .AND. ( dbfAlbCliL )->nCtlStk <> 2 )  .OR. ( !lExcCnt .AND. ( dbfAlbCliL )->nCtlStk == 2 ) )

               nIva        := ( dbfAlbCliL )->nIva
               nImpDet     := nTotLAlbCli( dbfAlbCliL, nDouDiv, nRouDiv, nil, .T., .F., .F. )
               nImpTrn     := nTrnLAlbCli( dbfAlbCliL, nDouDiv, nRouDiv )
               nImpPnt     := nPntLAlbCli( dbfAlbCliL, nDpvDiv )
               nImpIva     := nIvaLAlbCli( dbfAlbCliL, nDouDiv, nRouDiv )





               cCtaVent    := RetCtaVta( ( dbfAlbCliL )->cRef, ( nImpDet < 0 ), dbfArt )
               if Empty( cCtaVent )
                  cCtaVent := cCtaCliVta + RetGrpVta( ( dbfAlbCliL )->cRef, cRuta, cCodEmp, nIva )
               end





               if nImpDet <> 0 .OR. nImpPnt <> 0 .OR. nImpTrn <> 0

                  nPos     := aScan( aVentas, {|x| x[ 1 ] == cCtaVent .AND. x[ 2 ] == nIva } )
                  if nPos  == 0
                     aAdd( aVentas, { cCtaVent, nIva, nImpDet, nImpPnt, nImpTrn, nImpIva } )
                  else
                     aVentas[ nPos, 3 ]   += nImpDet
                     aVentas[ nPos, 4 ]   += nImpPnt
                     aVentas[ nPos, 5 ]   += nImpTrn
                     aVentas[ nPos, 6 ]   += nImpIva
                  end






                  cSubCtaReq  := cSubCuentaRecargo( nIva, ( dbfAlbCliT )->lRecargo, cRuta, cCodEmp, dbfIva )
                  cSubCtaIva  := cSubCuentaIva( nIva, ( dbfAlbCliT )->lRecargo, cRuta, cCodEmp, dbfIva )

                  nPos        := aScan( aIva, {|x| x[ 1 ] == nIva } )
                  if nPos  == 0
                     aAdd( aIva, { nIva, cSubCtaIva, cSubCtaReq, nImpDet, nImpPnt, nImpTrn, 0 } )
                  else
                     aIva[ nPos, 4 ] += nImpDet
                     aIva[ nPos, 5 ] += nImpPnt
                     aIva[ nPos, 6 ] += nImpTrn
                  end





                  if nImpTrn <> 0

                     cSubCtaTrn  := RetCtaTrn( ( dbfAlbCliL )->cRef, dbfArt )

                     nPos        := aScan( aTrn, {|x| x[1] == cSubCtaTrn } )
                     if nPos == 0
                        aAdd( aTrn, { cSubCtaTrn, nImpTrn } )
                     else
                        aIvm[ nPos, 2 ] += nImpTrn
                     end

                  end





                  nImpIvm        := nTotIAlbCli( dbfAlbCliL, nDouDiv, nRouDiv )

                  if nImpIvm <> 0

                     cSubCtaIvm  := oNewImp:cCtaImp( ( dbfAlbCliL )->nValImp )

                     nPos        := aScan( aIvm, {|x| x[1] == cSubCtaIvm } )
                     if nPos == 0
                        aAdd( aIvm, { cSubCtaIvm, nImpIvm } )
                     else
                        aIvm[ nPos, 2 ] += nImpIvm
                     end

                  end

               end

            end

         end

         SysRefresh()

         ( dbfAlbCliL )->( dbSkip() )

      end

   else

      oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " Albaran sin artículos.", 0 ) )
      lErrorFound := .T.

   end






   for n := 1 to Len( aVentas )

      if ( dbfAlbCliT )->nDtoEsp <> 0
         aVentas[ n, 3 ] -= Round( aVentas[ n, 3 ] * ( dbfAlbCliT )->nDtoEsp / 100, nRouDiv )
      end

      if ( dbfAlbCliT )->nDpp <> 0
         aVentas[ n, 3 ] -= Round( aVentas[ n, 3 ] * ( dbfAlbCliT )->nDpp / 100, nRouDiv )
      end

      if ( dbfAlbCliT )->nDtoUno <> 0
         aVentas[ n, 3 ] -= Round( aVentas[ n, 3 ] * ( dbfAlbCliT )->nDtoUno / 100, nRouDiv )
      end

      if ( dbfAlbCliT )->nDtoDos <> 0
         aVentas[ n, 3 ] -= Round( aVentas[ n, 3 ] * ( dbfAlbCliT )->nDtoDos / 100, nRouDiv )
      end

   next





   for n := 1 to Len( aVentas )
      aVentas[ n, 3 ] += aVentas[ n, 4 ]
   next






   for n := 1 to Len( aIva )

      if ( dbfAlbCliT )->nDtoEsp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfAlbCliT )->nDtoEsp / 100, nRouDiv )
      end

      if ( dbfAlbCliT )->nDpp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfAlbCliT )->nDpp / 100, nRouDiv )
      end

      if ( dbfAlbCliT )->nDtoUno <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfAlbCliT )->nDtoUno / 100, nRouDiv )
      end

      if ( dbfAlbCliT )->nDtoDos <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfAlbCliT )->nDtoDos / 100, nRouDiv )
      end

   next





   for n := 1 to Len( aIva )
      aIva[ n, 4 ]   += aIva[ n, 5 ]
   next






   if !lSimula .AND. ( dbfAlbCliT )->lContab
      oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " contabilizada.", 0 ) )
      lErrorFound    := .T.
   end

   if !lSimula .AND. !ChkSubcuenta( cRuta, cCodEmp, cCtaCli, , .F., .F. )
      oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " subcuenta " + cCtaCli + " no encontada.", 0 ) )
      lErrorFound    := .T.
   end






   for n := 1 to len( aIva )

      if !lSimula .AND. !ChkSubcuenta( cRutCnt(), cCodEmp, aIva[ n, 2 ], , .F., .F. )
         oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " subcuenta " + aIva[ n, 2 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end

      if lRecargo .AND. !lSimula .AND. !ChkSubcuenta( cRutCnt(), cCodEmp, aIva[ n, 3 ], , .F., .F. )
         oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " subcuenta " + aIva[ n, 3 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end

   next

   for n := 1 to len( aVentas )
      if !lSimula .AND. !ChkSubcuenta( cRuta, cCodEmp, aVentas[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " subcuenta " + aVentas[ n, 1 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end
   next

   for n := 1 to len( aIvm )
      if !lSimula .AND. !ChkSubcuenta( cRuta, cCodEmp, aIvm[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " subcuenta " + aIvm[ n, 1 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end
   next






   for n := 1 to len( aTrn )
      if !lSimula .AND. !ChkSubcuenta( cRuta, cCodEmp, aTrn[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " subcuenta " + aTrn[ n, 1 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end
   next





   if !lSimula .AND. nTotAnt <> 0 .AND. !ChkSubcuenta( cRuta, cCodEmp, cCtaAnticipo, , .F., .F. )
      oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " subcuenta de anticipo " + cCtaAnticipo + " no encontada.", 0 ) )
      lErrorFound := .T.
   end

   if !lErrorFound






      dFecha      := ( dbfAlbCliT )->dFecAlb
      ptaDebe     := nTotAlbCli( ( dbfAlbCliT )->cSerAlb + str( ( dbfAlbCliT )->nNumAlb ) + ( dbfAlbCliT )->cSufAlb, dbfAlbCliT, dbfAlbCliL, dbfIva, dbfDiv, nil, nil, .F., lExcCnt  )
      cConcepto   := "N/Alb. N." + ( dbfAlbCliT )->cSerAlb + "/" + alltrim( str( ( dbfAlbCliT )->nNumAlb ) + "/" + ( dbfAlbCliT )->cSufAlb )
      cPago       := "C/Alb. N." + ( dbfAlbCliT )->cSerAlb + "/" + alltrim( str( ( dbfAlbCliT )->nNumAlb ) + "/" + ( dbfAlbCliT )->cSufAlb )






      if OpenDiario( , cCodEmp )
         nAsiento := contaplusUltimoAsiento()
      else
         oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " imposible abrir ficheros.", 0 ) )
         return .F.
      end

























      aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha, cCtaCli, , Round( ptaDebe, nRouDiv ), cConcepto, , cAlbaran, , , , , , , , , , lSimula, cTerNif, cTerNom ) )






      for n := 1 to Len( aVentas )

         if lIvaInc

         nCalculo    := Round( aVentas[ n, 3 ], nRouDiv )
         if aVentas[ n, 2 ] <> 0
            nCalculo -= Round( aVentas[ n, 3 ] / ( 100 / aVentas[ n, 2 ] + 1 ), nRouDiv )
         end





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aVentas[ n, 1 ], , , cConcepto, nCalculo, cAlbaran, , , , , , , , , , lSimula, cTerNif, cTerNom ) )

         else





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aVentas[ n, 1 ], , , cConcepto, Round( aVentas[ n, 3 ], nRouDiv ), cAlbaran, , , , , , , , , , lSimula, cTerNif, cTerNom ) )

         end

      next






      for n := 1 to Len( aIvm )





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIvm[ n, 1 ], , , cConcepto, Round( aIvm[ n, 2 ], nRouDiv ), cAlbaran, , , , , , , , , , lSimula, cTerNif, cTerNom ) )

      next






      for n := 1 to Len( aTrn )





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aTrn[ n, 1 ], , , cConcepto, Round( aTrn[ n, 2 ], nRouDiv ), cAlbaran, , , , , , , , , , lSimula, cTerNif, cTerNom ) )

      next






      for n := 1 to len( aIva )

         nBase          := Round( aIva[ n, 4 ], nRouDiv ) + Round( aIva[ n, 7 ], nRouDiv )

         if lIvaInc

            if aIva[ n, 1 ] <> 0
               nCalculo := Round( aIva[ n, 4 ] / ( 100 / aIva[ n, 1 ] + 1 ), nRouDiv )
               nCalculo += Round( aIva[ n, 7 ] / ( 100 / aIva[ n, 1 ] + 1 ), nRouDiv )
            else
               nCalculo := 0
            end

            if aIva[ n, 1 ] <> 0 .OR. uFieldEmpresa( "lConIva" )





















               aAdd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIva[ n, 2 ], cCtaCli, , cConcepto, nCalculo, cAlbaran, nBase - nCalculo, Round( aIva[ n, 1 ], nRouDiv ), If( lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), ), , , , , , , lSimula, cTerNif, cTerNom ) )

            end

         else

            nCalculo    := Round( aIva[ n, 4 ] * aIva[ n, 1 ] / 100, nRouDiv )
            nCalculo    += Round( aIva[ n, 7 ] * aIva[ n, 1 ] / 100, nRouDiv )

            if aIva[ n, 1 ] <> 0 .OR. uFieldEmpresa( "lConIva" )





















               aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIva[ n, 2 ], cCtaCli, , cConcepto, nCalculo, cAlbaran, nBase, Round( aIva[ n, 1 ], nRouDiv ), If( lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), ), , , , , , , lSimula, cTerNif, cTerNom ) )

            end

         end

      next






      if lRecargo

         for n := 1 TO len( aIva )

            if Round( nPReq( dbfIva, aIva[ n, 1 ] ) * ( aIva[ n, 4 ] ) / 100, nRouDiv ) <> 0





















               aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, aIva[ n, 3 ], , , cConcepto, Round( nPReq( dbfIva, aIva[ n, 1 ] ) * ( aIva[ n, 4 ] ) / 100, nRouDiv ), cAlbaran, , , , , , , , , , lSimula, cTerNif, cTerNom ) )
            end

         next

      end






      if !lSimula

         if ( dbfAlbCliT )->( dbRLock() )
            ( dbfAlbCliT )->lContab := .T.
            ( dbfAlbCliT )->( dbUnLock() )
         end

         oTree:Select( oTree:Add( "Albaran cliente : " + rtrim( nAlbaran ) + " asiento generado num. " + alltrim( str( nAsiento ) ), 0 ) )

      else

         if lMessage
            lReturn  := msgTblCon( aSimula, cCodDiv, dbfDiv )
         end

      end

   end

   CloseDiario()

   if oBrw <> NIL
      oBrw:refresh()
   end

RETURN ( lReturn )



Static Function lContabilizaFacturaRectificativa( nFactura, pFactura, nAsiento, aSimula, lPago, oTree, dbfFacRecT, dbfFacCliP )

   local aAsiento                   := atail( aSimula )



   if lAplicacionA3()
      EnlaceA3():getInstance():Render()
   end



   if dbDialogLock( dbfFacRecT )

      ( dbfFacRecT )->lContab       := .T.

      if ( getDiarioDatabaseContaplus() )->( fieldpos( "Guid" ) ) <> 0
         ( dbfFacRecT )->cConGuid   := aAsiento[ ( getDiarioDatabaseContaplus() )->( fieldpos( "Guid" ) ) ]
      end

      ( dbfFacRecT )->( dbUnLock() )

   end

   oTree:Select( oTree:Add( "Factura rectificativa : " + rtrim( pFactura ) + " asiento generado num. " + alltrim( str( nAsiento ) ), 1 ) )

   if !empty( dbfFacCliP ) .AND. lPago

      if ( dbfFacCliP )->( dbseek( nFactura ) )

         while ( ( dbfFacCliP )->cSerie + str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac == nFactura ) .AND. !( dbfFacCliP )->( eof() )

            if dbDialogLock( dbfFacCliP )

               ( dbfFacCliP )->lConPgo       := .T.

               if ( getDiarioDatabaseContaplus() )->( fieldpos( "Guid" ) ) <> 0
                  ( dbfFacCliP )->cConGuid   := aAsiento[ ( getDiarioDatabaseContaplus() )->( fieldpos( "Guid" ) ) ]
               end

               ( dbfFacCliP )->( dbunlock() )

            end

            ( dbfFacCliP )->( dbskip() )

         end

      end

   end

Return ( .T. )






FUNCTION CntFacPrv( lSimula, lPago, lMessage, oTree, nAsiento, aSimula, dbfFacPrvT, dbfFacPrvL, dbfFacPrvP, dbfPrv, dbfDiv, dbfArticulo, dbfFPago, dbfIva, oBrw )

   local n
   local nOrd
   local cCtaVent
   local nPosicion
   local nPosIva
   local dFecha
   local aTotFac
   local nTotFac
   local nTotRet
   local aTotIva
   local cConcepto
   local cConCompr
   local cSubCtaIva
   local cSubCtaReq
   local cRuta
   local cCodEmp
   local nImpDeta
   local nDinDiv     := nDinDiv( ( dbfFacPrvT )->cDivFac, dbfDiv )
   local nRinDiv     := nRinDiv( ( dbfFacPrvT )->cDivFac, dbfDiv )
   local aIva        := {}
   local aVentas     := {}
   local cCodDiv     := ( dbfFacPrvT )->cDivFac
   local cCtaPrv     := cPrvCta( ( dbfFacPrvT )->cCodPrv, dbfPrv )
   local cCtaPrvVta  := cPrvCtaVta( ( dbfFacPrvT )->cCodPrv, dbfPrv )
   local nFactura    := ( dbfFacPrvT )->cSerFac + str( ( dbfFacPrvT )->nNumFac ) + ( dbfFacPrvT )->cSufFac
   local cFactura    := ( dbfFacPrvT )->cSerFac + "/" + Ltrim( str( ( dbfFacPrvT )->nNumFac ) ) + "/" + ( dbfFacPrvT )->cSufFac
   local nNumFac     := ( dbfFacPrvT )->nNumFac
   local cCodPro     := Left( ( dbfFacPrvT )->cCodPro, 3 )
   local cClave      := Right( ( dbfFacPrvT )->cCodPro, 6 )
   local lErrorFound := .F.
   local cTerNif     := ( dbfFacPrvT )->cDniPrv
   local cTerNom     := ( dbfFacPrvT )->cNomPrv
   local lReturn

   If( aSimula == nil, aSimula := {}, ) ;





   if ( dbfFacPrvT )->lContab
      oTree:Select( oTree:Add( "Factura proveedor : " + rtrim( cFactura ) + ", ya contabilizada.", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkRuta( cRutCnt() )
      oTree:Select( oTree:Add( "Factura proveedor : " + rtrim( cFactura ) + ", ruta no valida.", 0 ) )
      lErrorFound    := .T.
   end





   cRuta             := cRutCnt()
   cCodEmp           := cCodEmpCnt( ( dbfFacPrvT )->cSerFac )

   if Empty( cCtaPrvVta )
      cCtaPrvVta     := cCtaPrv()
   end

   if !ChkSubcuenta( cRutCnt(), cCodEmp, cCtaPrv, , .F., .F. )
      oTree:Select( oTree:Add( "Factura proveedor : " + rtrim( cFactura ) + " subcuenta de proveedor " + rtrim( cCtaPrv ) + ", no encontada.", 0 ) )
      lErrorFound    := .T.
   end





   aTotFac           := aTotFacPrv( nFactura, dbfFacPrvT, dbfFacPrvL, dbfIva, dbfDiv, dbfFacPrvP )
   nTotFac           := aTotFac[ 4 ]
   aTotIva           := aTotFac[ 5 ]
   nTotRet           := aTotFac[ 6 ]





   if ( dbfFacPrvT )->lFacGas

      aAdd( aVentas, { ( dbfFacPrvT )->SubCta, aTotFac[ 1 ] } )





      for n := 1 to Len( aTotIva )

         if aTotIva[ n, 1 ] <> 0

            if isIVAComunidadEconomicaEuropea( dbfFacPrvT )
               cSubCtaIva  := cCuentaCompraIVASoportadoUE()
               cSubCtaReq  := cCuentaCompraIVARepercutidoUE()
            else
               cSubCtaIva  := cSubCuentaIva( aTotIva[ n, 3 ], ( dbfFacPrvT )->lRecargo, cRuta, cCodEmp, dbfIva, .F. )
               cSubCtaReq  := cSubCuentaRecargo( aTotIva[ n, 3 ], ( dbfFacPrvT )->lRecargo, cRuta, cCodEmp, dbfIva )
            end

            nPosIva        := aScan( aIva, {|x| x[ 1 ] == aTotIva[ n, 3 ] } )
            if nPosIva == 0
               aadd( aIva, { aTotIva[ n, 3 ], cSubCtaIva, cSubCtaReq, aTotIva[ n, 1 ] } )
            else
               aIva[ nPosIva, 4 ]   += aTotIva[ n, 1 ]
            end

         end

      next

   else





      if ( dbfFacPrvL )->( dbSeek( nFactura ) )

         while ( ( dbfFacPrvL )->cSerFac + str( ( dbfFacPrvL )->nNumFac ) + ( dbfFacPrvL )->cSufFac == nFactura .AND. !( dbfFacPrvL )->( eof() ) )

            nImpDeta       := nTotLFacPrv( dbfFacPrvL, nDinDiv, nRinDiv )

            if nImpDeta <> 0

               cCtaVent    := RetCtaCom( ( dbfFacPrvL )->cRef, ( nImpDeta < 0 ), dbfArticulo )
               if Empty( cCtaVent )
                  cCtaVent := cCtaPrvVta + RetGrpVta( ( dbfFacPrvL )->cRef, cRuta, cCodEmp, ( dbfFacPrvL )->nIva )
               end

               nPosicion   := aScan( aVentas, {|x| x[1] == cCtaVent } )

               if nPosicion == 0
                  aadd( aVentas, { cCtaVent, nImpDeta } )
               else
                  aVentas[ nPosicion, 2 ] += nImpDeta
               end





               if isIVAComunidadEconomicaEuropea( dbfFacPrvT )
                  cSubCtaIva  := cCuentaCompraIVASoportadoUE()
                  cSubCtaReq  := cCuentaCompraIVARepercutidoUE()
               else
                  cSubCtaIva  := cSubCuentaIva( ( dbfFacPrvL )->nIva, ( dbfFacPrvT )->lRecargo, cRuta, cCodEmp, dbfIva, .F. )
                  cSubCtaReq  := cSubCuentaRecargo( ( dbfFacPrvL )->nIva, ( dbfFacPrvT )->lRecargo, cRuta, cCodEmp, dbfIva )
               end

               nPosIva        := aScan( aIva, {|x| x[1] == ( dbfFacPrvL )->nIva } )
               if nPosIva == 0
                  aadd( aIva, { ( dbfFacPrvL )->nIva, cSubCtaIva, cSubCtaReq, nImpDeta } )
               else
                  aIva[ nPosIva, 4 ]   += nImpDeta
               end

            end

            ( dbfFacPrvL )->( dbSkip() )

         end

      else

         oTree:Select( oTree:Add( "Factura proveedor : " + rtrim( cFactura ) + " factura sin artículos.", 0 ) )

         lErrorFound    := .T.

      end

   end





   for n := 1 to Len( aVentas )

      if ( dbfFacPrvT )->nDtoEsp <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfFacPrvT )->nDtoEsp / 100, nRinDiv )
      end

      if ( dbfFacPrvT )->nDpp <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfFacPrvT )->nDpp / 100, nRinDiv )
      end

      if ( dbfFacPrvT )->nDtoUno <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfFacPrvT )->nDtoUno / 100, nRinDiv )
      end

      if ( dbfFacPrvT )->nDtoDos <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfFacPrvT )->nDtoDos / 100, nRinDiv )
      end

   next





   for n := 1 to Len( aIva )

      if ( dbfFacPrvT )->nDtoEsp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfFacPrvT )->nDtoEsp / 100, nRinDiv )
      end

      if ( dbfFacPrvT )->nDpp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfFacPrvT )->nDpp / 100, nRinDiv )
      end

      if ( dbfFacPrvT )->nDtoUno <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfFacPrvT )->nDtoUno / 100, nRinDiv )
      end

      if ( dbfFacPrvT )->nDtoDos <> 0
         aIva[ n, 2 ] -= Round( aIva[ n, 4 ] * ( dbfFacPrvT )->nDtoDos / 100, nRinDiv )
      end

   next





   for n := 1 to len( aVentas )
      if !ChkSubcuenta( cRutCnt(), cCodEmp, aVentas[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura proveedor : " + rtrim( cFactura ) + " subcuenta de ventas " + aVentas[ n, 1 ] + " no encontada.", 0 ) )
         lErrorFound    := .T.
      end
   next





   for n := 1 to len( aIva )

      if !ChkSubcuenta( cRuta, cCodEmp, aIva[ n, 2 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura proveedor : " + rtrim( cFactura ) + " subcuenta de " + cImp() + " " + aIva[ n, 2 ] + ", no encontada.", 0 ) )
         lErrorFound    := .T.
      end

      if !ChkSubcuenta( cRuta, cCodEmp, aIva[ n, 3 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura proveedor : " + rtrim( cFactura ) + " subcuenta de " + cImp() + " " + aIva[ n, 3 ] + ", no encontada.", 0 ) )
         lErrorFound    := .T.
      end

   next

   if nTotRet <> 0

      if !ChkSubcuenta( cRuta, cCodEmp, cCtaRet(), , .F., .F. )
         oTree:Select( oTree:Add( "Factura proveedor : " + rtrim( cFactura ) + " subcuenta de retenciones " + cCtaRet() + ", no encontada.", 0 ) )
         lErrorFound    := .T.
      end

   end





   if !chkFecha( cRuta, cCodEmp, ( dbfFacPrvT )->dFecFac, .F. )
      oTree:Select( oTree:Add(  "Factura proveedor : " + rtrim( cFactura ) + " asiento fuera de fechas.", 0 ) )
      lErrorFound    := .T.
   end





   if lSimula .OR. !lErrorFound

      if Empty( ( dbfFacPrvT )->dFecEnt )
         dFecha      := ( dbfFacPrvT )->dFecFac
      else
         dFecha      := ( dbfFacPrvT )->dFecEnt
      end

      cConCompr      := "S/Fcta."
      if !Empty( ( dbfFacPrvT )->cSuPed )
         nNumFac     := Val( ( dbfFacPrvT )->cSuPed )
         cConCompr   += " N." + rtrim( ( dbfFacPrvT )->cSuPed )
      elseif !Empty( ( dbfFacPrvT )->cNumDoc )
         cConCompr   += " Doc. " + rtrim( ( dbfFacPrvT )->cNumDoc )
      else
         cConCompr   += " N." + rtrim( cFactura )
      end
      cConcepto      := cConCompr + Space( 1 ) + DtoC( ( dbfFacPrvT )->dFecFac )
      cConCompr      += Space( 1 ) + rtrim( ( dbfFacPrvT )->cNomPrv )





      if OpenDiario( , cCodEmp )
         nAsiento    := contaplusUltimoAsiento()
      else
         oTree:Select( oTree:Add( "Factura proveedor : " + rtrim( cFactura ) + " imposible abrir ficheros de contaplus.", 0 ) )
         return .F.
      end

























      aAdd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, cCtaPrv, , , cConcepto, nTotFac, nNumFac, , , , ( dbfFacPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )





      for n := 1 TO len( aVentas )





















         aAdd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, aVentas[ n, 1 ], , aVentas[ n, 2 ], cConCompr, , nNumFac, , , , ( dbfFacPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

      next



      if isIVARegimenGeneralCompras( dbfFacPrvT )

         for n := 1 to len( aIva )

            if aIva[ n, 1 ] <> 0 .OR. uFieldEmpresa( "lConIva" )





















               aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha,  aIva[ n, 2 ], cCtaPrv, Round( aIva[ n, 1 ] * aIva[ n, 4 ] / 100, nRinDiv ), cConCompr, , nNumFac, aIva[ n, 4 ], aIva[ n, 1 ], If( ( dbfFacPrvT )->lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), 0 ), ( dbfFacPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

            end

         next

      end



      if isIVAComunidadEconomicaEuropea( dbfFacPrvT )

         for n := 1 to len( aIva )

            if ( aIva[ n, 1 ] <> 0 .OR. uFieldEmpresa( "lConIva" ) )





















               aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha,  aIva[ n, 3 ], cCtaPrv, Round( aIva[ n, 1 ] * aIva[ n, 4 ] / 100, nRinDiv ), cConCompr, 0, nNumFac, aIva[ n, 4 ], aIva[ n, 1 ], If( ( dbfFacPrvT )->lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), 0 ), ( dbfFacPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )





















               aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha,  aIva[ n, 2 ], cCtaPrv, 0, cConCompr, Round( aIva[ n, 1 ] * aIva[ n, 4 ] / 100, nRinDiv ), nNumFac, aIva[ n, 4 ], aIva[ n, 1 ], If( ( dbfFacPrvT )->lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), 0 ), ( dbfFacPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

            end

         next

      end



      if ( dbfFacPrvT )->lRecargo .AND. isIVARegimenGeneralCompras( dbfFacPrvT )

         for n := 1 to len( aIva )

            if ( aIva[ n, 1 ] <> 0 .OR. uFieldEmpresa( "lConIva" ) ) .AND. ( !empty( aIva[ n, 3 ] ) )





















               aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, aIva[ n, 3 ], , Round( nPReq( dbfIva, aIva[ n, 1 ] ) * aIva[ n, 4 ] / 100, nRinDiv ), cConCompr, , nNumFac, , , , ( dbfFacPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

            end

         next

      end





      if nTotRet <> 0





















         aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, cCtaRet(), , , cConCompr, nTotRet, nNumFac, , , , ( dbfFacPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

      end






      if lPago

         nOrd           := ( dbfFacPrvP )->( ordSetFocus( "nNumFac" ) )

         if ( dbfFacPrvP )->( dbSeek( nFactura ) )

            while ( ( dbfFacPrvP )->cSerFac + str( ( dbfFacPrvP )->nNumFac ) + ( dbfFacPrvP )->cSufFac = nFactura ) .AND. !( dbfFacPrvP )->( eof() )

               lReturn  := CntRecPrv( lSimula, oTree, nAsiento, aSimula, .T., dbfFacPrvT, dbfFacPrvP, dbfPrv, dbfFPago, dbfDiv, , .T. )

               if IsFalse( lReturn )
                  exit
               end

               ( dbfFacPrvP )->( dbSkip() )

            end

         end

         ( dbfFacPrvP )->( ordSetFocus( nOrd ) )

      end





      if lSimula

         if lMessage
            lReturn  := msgTblCon( aSimula, cCodDiv, dbfDiv, !lErrorFound, cFactura, {|| aWriteAsiento( aSimula, cCodDiv, .T., oTree, cFactura, nAsiento ), lCntFacPrv( .T., dbfFacPrvT ) } )
         end

      else

         if !lErrorFound

            aWriteAsiento( aSimula, cCodDiv, .T., oTree, cFactura, nAsiento )

            lReturn  := lCntFacPrv( .T., dbfFacPrvT )

            if lReturn .AND. !Empty( oTree )
               oTree:Select( oTree:Add( "Factura proveedor : " + rtrim( cFactura ) + " asiento generado num. " + alltrim( str( nAsiento ) ), 1 ) )
            end

         end

      end

      CloseDiario()

   end

Return ( lReturn )



Function lCntFacPrv( lContabilizado, dbfFacPrvT )

   local lReturn              := .T.

   if dbLock( dbfFacPrvT )
      ( dbfFacPrvT )->lContab := lContabilizado
      ( dbfFacPrvT )->( dbUnlock() )
   else
      lReturn                 := .F.
   end

Return ( lReturn )



FUNCTION CntRctPrv( lSimula, lPago, lMessage, oTree, nAsiento, aSimula, dbfRctPrvT, dbfRctPrvL, dbfFacPrvP, dbfPrv, dbfDiv, dbfArticulo, dbfFPago, dbfIva, oBrw )

   local n
   local cCtaVent
   local nPosicion
   local nPosIva
   local dFecha
   local aTotFac
   local nTotFac
   local nTotRet
   local cConcepto
   local cConCompr
   local cSubCtaIva
   local cSubCtaReq
   local cRuta
   local cCodEmp
   local nImpDeta
   local nDinDiv     := nDinDiv( ( dbfRctPrvT )->cDivFac, dbfDiv )
   local nRinDiv     := nRinDiv( ( dbfRctPrvT )->cDivFac, dbfDiv )
   local aIva        := {}
   local aVentas     := {}
   local cCodDiv     := ( dbfRctPrvT )->cDivFac
   local cCtaPrv     := cPrvCta( ( dbfRctPrvT )->cCodPrv, dbfPrv )
   local cCtaPrvVta  := cPrvCtaVta( ( dbfRctPrvT )->cCodPrv, dbfPrv )
   local nFactura    := ( dbfRctPrvT )->cSerFac + str( ( dbfRctPrvT )->nNumFac ) + ( dbfRctPrvT )->cSufFac
   local cFactura    := ( dbfRctPrvT )->cSerFac + "/" + Ltrim( str( ( dbfRctPrvT )->nNumFac ) ) + "/" + ( dbfRctPrvT )->cSufFac
   local nNumFac     := ( dbfRctPrvT )->nNumFac
   local cCodPro     := Left( ( dbfRctPrvT )->cCodPro, 3 )
   local cClave      := Right( ( dbfRctPrvT )->cCodPro, 6 )
   local lErrorFound := .F.
   local cTerNif     := ( dbfRctPrvT )->cDniPrv
   local cTerNom     := ( dbfRctPrvT )->cNomPrv
   local lReturn

   If( aSimula == nil, aSimula := {}, ) ;





   IF ( dbfRctPrvT )->lContab
      oTree:Add( "Factura rectificativa proveedor : " + rtrim( cFactura ) + " ya contabilizada.", 0 )
      lErrorFound    := .T.
   end

   IF !ChkRuta( cRutCnt() )
      oTree:Add( "Factura rectificativa proveedor : " + rtrim( cFactura ) + " ruta no valida.", 0 )
      lErrorFound    := .T.
   end





   cRuta             := cRutCnt()
   cCodEmp           := cCodEmpCnt( ( dbfRctPrvT )->cSerFac )

   if Empty( cCtaPrvVta )
      cCtaPrvVta     := cCtaPrv()
   end

   if !ChkSubcuenta( cRutCnt(), cCodEmp, cCtaPrv, , .F., .F. )
      oTree:Add( "Factura rectificativa proveedor : " + rtrim( cFactura ) + " subcuenta " + cCtaPrv + " no encontada.", 0 )
      lErrorFound    := .T.
   end





   aTotFac           := aTotRctPrv( nFactura, dbfRctPrvT, dbfRctPrvL, dbfIva, dbfDiv, dbfFacPrvP )
   nTotFac           := aTotFac[ 4 ]
   nTotRet           := aTotFac[ 6 ]





   if ( dbfRctPrvL )->( dbSeek( nFactura ) )

      while ( ( dbfRctPrvL )->cSerFac + str( ( dbfRctPrvL )->nNumFac ) + ( dbfRctPrvL )->cSufFac == nFactura .AND. !( dbfRctPrvL )->( eof() ) )

         nImpDeta    := nTotLRctPrv( dbfRctPrvL, nDinDiv, nRinDiv, ( dbfRctPrvT )->nVdvFac )

         if nImpDeta <> 0

            cCtaVent := RetCtaCom( ( dbfRctPrvL )->cRef, ( nImpDeta < 0 ), dbfArticulo )
            if Empty( cCtaVent )
               cCtaVent := cCtaPrvVta + RetGrpVta( ( dbfRctPrvL )->cRef, cRuta, cCodEmp, ( dbfRctPrvL )->nIva )
            end

            nPosicion   := aScan( aVentas, {|x| x[1] == cCtaVent } )
            if nPosicion == 0
               aadd( aVentas, { cCtaVent, nImpDeta } )
            else
               aVentas[ nPosicion, 2 ] += nImpDeta
            end





            if isIVAComunidadEconomicaEuropea( dbfRctPrvT )
               cSubCtaIva  := cCuentaCompraIVASoportadoUE()
               cSubCtaReq  := cCuentaCompraIVARepercutidoUE()
            else
               cSubCtaIva  := cSubCuentaIva( ( dbfRctPrvL )->nIva, ( dbfRctPrvT )->lRecargo, cRuta, cCodEmp, dbfIva, .F. )
               cSubCtaReq  := cSubCuentaRecargo( ( dbfRctPrvL )->nIva, ( dbfRctPrvT )->lRecargo, cRuta, cCodEmp, dbfIva )
            end

            nPosIva     := aScan( aIva, {|x| x[1] == ( dbfRctPrvL )->nIva } )
            if nPosIva == 0
               aadd( aIva, { ( dbfRctPrvL )->nIva, cSubCtaIva, cSubCtaReq, nImpDeta } )
            else
               aIva[ nPosIva, 4 ]   += nImpDeta
            end

         end

         ( dbfRctPrvL )->( dbSkip() )

      end

   else

      oTree:Add( "Factura rectificativa proveedor : " + rtrim( cFactura ) + " factura sin artículos.", 0 )
      lErrorFound    := .T.

   end





   for n := 1 to Len( aVentas )

      if ( dbfRctPrvT )->nDtoEsp <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfRctPrvT )->nDtoEsp / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDpp <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfRctPrvT )->nDpp / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDtoUno <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfRctPrvT )->nDtoUno / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDtoDos <> 0
         aVentas[ n, 2 ] -= Round( aVentas[ n, 2 ] * ( dbfRctPrvT )->nDtoDos / 100, nRinDiv )
      end

   next





   for n := 1 to Len( aIva )

      if ( dbfRctPrvT )->nDtoEsp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfRctPrvT )->nDtoEsp / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDpp <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfRctPrvT )->nDpp / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDtoUno <> 0
         aIva[ n, 4 ] -= Round( aIva[ n, 4 ] * ( dbfRctPrvT )->nDtoUno / 100, nRinDiv )
      end

      if ( dbfRctPrvT )->nDtoDos <> 0
         aIva[ n, 2 ] -= Round( aIva[ n, 4 ] * ( dbfRctPrvT )->nDtoDos / 100, nRinDiv )
      end

   next





   for n := 1 to len( aVentas )

      if !ChkSubcuenta( cRutCnt(), cCodEmp, aVentas[ n, 1 ], , .F., .F. )

         oTree:Add( "Factura rectificativa proveedor : " + rtrim( cFactura ) + " subcuenta " + aVentas[ n, 1 ] + " no encontada.", 0 )
         lErrorFound    := .T.

      end

   next





   for n := 1 to len( aIva )

      if !ChkSubcuenta( cRuta, cCodEmp, aIva[ n, 2 ], , .F., .F. )
         oTree:Add( "Factura rectificativa proveedor : " + rtrim( cFactura ) + " subcuenta " + aIva[ n, 2 ] + " no encontada.", 0 )
         lErrorFound    := .T.
      end

      if !ChkSubcuenta( cRuta, cCodEmp, aIva[ n, 3 ], , .F., .F. )
         oTree:Add( "Factura rectificativa proveedor : " + rtrim( cFactura ) + " subcuenta " + aIva[ n, 3 ] + " no encontada.", 0 )
         lErrorFound    := .T.
      end

   next

   if nTotRet <> 0

      if !ChkSubcuenta( cRuta, cCodEmp, cCtaRet(), , .F., .F. )
         oTree:Add( "Factura rectificativa proveedor : " + rtrim( cFactura ) + " subcuenta " + cCtaRet() + " no encontada.", 0 )
         lErrorFound    := .T.
      end

   end





   if !ChkFecha( , , ( dbfRctPrvT )->dFecFac, .F., oTree )
      lErrorFound    := .T.
   end





   if lSimula .OR. !lErrorFound

      if Empty( ( dbfRctPrvT )->dFecEnt )
         dFecha      := ( dbfRctPrvT )->dFecFac
      else
         dFecha      := ( dbfRctPrvT )->dFecEnt
      end

      cConCompr      := "S/Rect."
      if !Empty( ( dbfRctPrvT )->cSuPed )
         nNumFac     := Val( ( dbfRctPrvT )->cSuPed )
         cConCompr   += " N." + rtrim( ( dbfRctPrvT )->cSuPed )
      elseif !Empty( ( dbfRctPrvT )->cNumDoc )
         cConCompr   += " Doc. " + rtrim( ( dbfRctPrvT )->cNumDoc )
      else
         cConCompr   += " N." + rtrim( cFactura )
      end
      cConcepto      := cConCompr + Space( 1 ) + DtoC( ( dbfRctPrvT )->dFecFac )
      cConCompr      += Space( 1 ) + rtrim( ( dbfRctPrvT )->cNomPrv )





      if OpenDiario( , cCodEmp )
         nAsiento    := contaplusUltimoAsiento()
      else
         oTree:Add( "Factura rectificativa proveedor : " + rtrim( cFactura ) + " imposible abrir ficheros de contaplus.", 0 )
         return .F.
      end

























      aAdd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, cCtaPrv, , , cConcepto, nTotFac, nNumFac, , , , ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )





      for n := 1 TO len( aVentas )





















         aAdd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, aVentas[ n, 1 ], , aVentas[ n, 2 ], cConCompr, , nNumFac, , , , ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

      next





      if isIVARegimenGeneralCompras( dbfRctPrvT )

         for n := 1 TO len( aIva )





















            aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha,  aIva[ n, 2 ], cCtaPrv, Round( aIva[ n, 1 ] * aIva[ n, 4 ] / 100, nRinDiv ), cConCompr, , nNumFac, aIva[ n, 4 ], aIva[ n, 1 ], If( ( dbfRctPrvT )->lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), 0 ), ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

         next

      end

      if isIVAComunidadEconomicaEuropea( dbfRctPrvT )

         for n := 1 to len( aIva )





















            aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha,  aIva[ n, 3 ], cCtaPrv, Round( aIva[ n, 1 ] * aIva[ n, 4 ] / 100, nRinDiv ), cConCompr, 0, nNumFac, aIva[ n, 4 ], aIva[ n, 1 ], If( ( dbfRctPrvT )->lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), 0 ), ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )





















            aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha,  aIva[ n, 2 ], cCtaPrv, 0, cConCompr, Round( aIva[ n, 1 ] * aIva[ n, 4 ] / 100, nRinDiv ), nNumFac, aIva[ n, 4 ], aIva[ n, 1 ], If( ( dbfRctPrvT )->lRecargo, nPReq( dbfIva, aIva[ n, 1 ] ), 0 ), ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

         next

      end





      if ( dbfRctPrvT )->lRecargo

         for n := 1 TO len( aIva )





















            aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, aIva[ n, 3 ], , Round( nPReq( dbfIva, aIva[ n, 1 ] ) * aIva[ n, 4 ] / 100, nRinDiv ), cConCompr, , nNumFac, , , , ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

         next

      end





      if nTotRet <> 0





















         aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, cCtaRet(), , , cConCompr, nTotRet, nNumFac, , , , ( dbfRctPrvT )->cNumDoc, cCodPro, cClave, , , , lSimula, cTerNif, cTerNom ) )

      end






      if lPago .AND. ( dbfFacPrvP )->( dbSeek( nFactura ) )


         while ( ( dbfFacPrvP )->cSerFac + str( ( dbfFacPrvP )->nNumFac ) + ( dbfFacPrvP )->cSufFac == nFactura ) .AND. !( dbfFacPrvP )->( eof() )

            lReturn  := CntRecPrv( lSimula, oTree, nAsiento, aSimula, .T., dbfRctPrvT, dbfFacPrvP, dbfPrv, dbfFPago, dbfDiv )

            if IsFalse( lReturn )
               exit
            end

            ( dbfFacPrvP )->( dbSkip() )

         end

      end





      if lSimula

         if lMessage
            lReturn  := msgTblCon( aSimula, cCodDiv, dbfDiv, !lErrorFound, cFactura, {|| aWriteAsiento( aSimula, cCodDiv, .T., oTree, cFactura, nAsiento ), lCntRctPrv( .T., dbfRctPrvT ) } )
         end

      else

         if !lErrorFound

            aWriteAsiento( aSimula, cCodDiv, .T., oTree, cFactura, nAsiento )

            lReturn  := lCntRctPrv( .T., dbfRctPrvT )

            if lReturn .AND. !Empty( oTree )
               oTree:Add( "Factura rectificativa proveedor : " + rtrim( cFactura ) + " asiento generado num. " + alltrim( str( nAsiento ) ), 1 )
            end

         end

      end

      CloseDiario()

   end

Return ( lReturn )



Function lCntRctPrv( lContabilizado, dbfRctPrvT )

   local lReturn              := .T.

   if dbLock( dbfRctPrvT )
      ( dbfRctPrvT )->lContab := lContabilizado
      ( dbfRctPrvT )->( dbUnlock() )
   else
      lReturn                 := .F.
   end

Return ( lReturn )



Function CntRecPrv( lSimula, oTree, nAsiento, aSimula, lFromFactura, dbfFacPrvT, dbfFacPrvP, dbfPrv, dbfFPago, dbfDiv, oBrw, lFactura )

   local cCodEmp
   local cRuta
   local cConcepto
   local cPagoPrv
   local cCtaPgo
   local dFecha
   local nRecno      := ( dbfFacPrvP )->( Recno() )
   local cCodDiv     := ( dbfFacPrvP )->cDivPgo
   local cCodPgo     := ( dbfFacPrvP )->cCodPgo
   local lConFac     := lConFacPrv( ( dbfFacPrvP )->cSerFac + str( ( dbfFacPrvP )->nNumFac, 9 ) + ( dbfFacPrvP )->cSufFac, dbfFacPrvT )
   local cCodPrv     := dPrvFacPrv( ( dbfFacPrvP )->cSerFac + str( ( dbfFacPrvP )->nNumFac, 9 ) + ( dbfFacPrvP )->cSufFac, dbfFacPrvT )
   local cCodPro     := cProFacPrv( ( dbfFacPrvP )->cSerFac + str( ( dbfFacPrvP )->nNumFac, 9 ) + ( dbfFacPrvP )->cSufFac, dbfFacPrvT )
   local cCtaPrv     := cPrvCta( cCodPrv, dbfPrv )
   local cFactura    := ( dbfFacPrvP )->cSerFac + "/" + Ltrim( str( ( dbfFacPrvP )->nNumFac ) ) + "/" + ( dbfFacPrvP )->cSufFac
   local nRecibo     := ( dbfFacPrvP )->cSerFac + str( ( dbfFacPrvP )->nNumFac, 9 ) + ( dbfFacPrvP )->cSufFac + str( ( dbfFacPrvP )->nNumRec )
   local cRecibo     := ( dbfFacPrvP )->cSerFac + "/" + Ltrim( str( ( dbfFacPrvP )->nNumFac, 9 ) ) + "/" + ( dbfFacPrvP )->cSufFac + "-" + str( ( dbfFacPrvP )->nNumRec )
   local cTerNif     := RetFld( ( dbfFacPrvP )->cSerFac + str( ( dbfFacPrvP )->nNumFac, 9 ) + ( dbfFacPrvP )->cSufFac, dbfFacPrvT, "cDniPrv" )
   local cTerNom     := ( dbfFacPrvP )->cNomPrv
   local lRectif     := !Empty( ( dbfFacPrvP )->cTipRec )
   local lErrorFound := .F.
   local lReturn     := .T.

   If( lFactura == nil, lFactura := .F., ) ;






   cRuta             := cRutCnt()
   cCodEmp           := cCodEmpCnt( ( dbfFacPrvP )->cSerFac )

   if !lFromFactura

      if OpenDiario( , cCodEmp )
         nAsiento          := contaplusUltimoAsiento()
      else
         oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " imposible abrir ficheros de contaplus.", 0 ) )
         Return .F.
      end

   end






   if ( dbfFacPrvP )->lConPgo
      oTree:Select( oTree:Add( "Recibo proveedor : " + rtrim( cRecibo ) + " ya contabilizado.", 0 ) )
      lErrorFound    := .T.
   end

   if !( dbfFacPrvP )->lCobrado
      oTree:Select( oTree:Add( "Recibo proveedor : " + rtrim( cRecibo ) + " no cobrado.", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkRuta( cRutCnt() )
      oTree:Select( oTree:Add( "Recibo proveedor : " + rtrim( cRecibo ) + " ruta no valida.", 0 ) )
      lErrorFound    := .T.
   end

   if !lConFac .AND. !lFromFactura
      oTree:Select( oTree:Add( "Factura de Recibo proveedor : " + rtrim( cRecibo ) + " no contabilizada.", 0 ) )
      lErrorFound    := .T.
   end

   if Empty( cCodEmp )
      oTree:Select( oTree:Add( "Recibo proveedor : " + rtrim( cRecibo ) + " no se definieron empresas asociadas.", 0 ) )
      lErrorFound    := .T.
   end






   if !ChkSubcuenta( cRuta, cCodEmp, cCtaPrv, , .F., .F. )
      oTree:Select( oTree:Add( "Recibo proveedor : " + rtrim( cRecibo ) + " subcuenta " + cCtaPrv + " no encontada.", 0 ) )
      lErrorFound    := .T.
   end






   if Empty( cCodPgo )
      cCodPgo        := cPgoFacPrv( ( dbfFacPrvP )->cSerFac + str( ( dbfFacPrvP )->nNumFac, 9 ) + ( dbfFacPrvP )->cSufFac, dbfFacPrvT )
   end

   cCtaPgo           := ( dbfFacPrvP )->cCtaRec

   if Empty( cCtaPgo )
      cCtaPgo        := cCtaFPago( cCodPgo, dbfFPago )
   end

   if Empty( cCtaPgo )
      oTree:Select( oTree:Add( "Recibo proveedor : " + rtrim( cRecibo ) + " no existe cuenta de pago.", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkSubcuenta( cRutCnt(), cCodEmp, cCtaPgo, , .F., .F. )
      oTree:Select( oTree:Add( "Recibo proveedor : " + rtrim( cRecibo ) + " subcuenta " + rtrim( cCtaPgo ) + " no encontada.", 0 ) )
      lErrorFound    := .T.
   end






   if Empty( ( dbfFacPrvP )->dEntrada )
      if dbLock( dbfFacPrvP )
         ( dbfFacPrvP )->dEntrada := date()
         ( dbfFacPrvP )->( dbUnLock() )
      end
   end

   if !ChkFecha( , , ( dbfFacPrvP )->dEntrada, .F., oTree )
      lErrorFound    := .T.
   end






   dFecha            := ( dbfFacPrvP )->dEntrada

   cConcepto         := "P/Recibo N." + alltrim( str( ( dbfFacPrvP )->nNumRec ) ) + Space( 1 )

   if !Empty( ( dbfFacPrvT )->cSuPed )

      cConcepto      += "S/Fcta. N." + rtrim( ( dbfFacPrvT )->cSuPed )

   elseif !Empty( ( dbfFacPrvT )->cNumDoc )

      cConcepto      += "Doc. N." + rtrim( ( dbfFacPrvT )->cNumDoc )

   else

      cConcepto      += "N/Fcta. N." + rtrim( cFactura )

   end

   cConcepto         += Space( 1 ) + rtrim( ( dbfFacPrvT )->cNomPrv )








   if !lFromFactura
      nAsiento    := contaplusUltimoAsiento()
   end






   if ( dbfFacPrvP )->( dbSeek( nRecibo ) )





















      aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha,  cCtaPgo, , , cConcepto, ( dbfFacPrvP )->nImporte, , , , , , cCodPro, , , , , lSimula, cTerNif, cTerNom ) )

























      aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha,  cCtaPrv, , ( dbfFacPrvP )->nImporte, cConcepto, , , , , , , cCodPro, , , , , lSimula, cTerNif, cTerNom ) )

      if ( !lSimula .AND. !lErrorFound )

         if !lFactura
            aWriteAsiento( aSimula, cCodDiv, .T., oTree, cRecibo, nAsiento )
         end

         lReturn     := lCntRecPrv( cRecibo, nAsiento, lFromFactura, oTree, dbfFacPrvP )

      end

      if ( lSimula .AND. !lFromFactura )

         lReturn     := msgTblCon( aSimula, cCodDiv, dbfDiv, !lErrorFound, cRecibo, {|| aWriteAsiento( aSimula, cCodDiv, .T., oTree, cRecibo, nAsiento ), lCntRecPrv( cRecibo, nAsiento, lFromFactura, oTree, dbfFacPrvP ) } )

      end

   end

   if !lFromFactura
      CloseDiario()
   end

   if !Empty( oBrw )
      oBrw:Refresh()
   end

   ( dbfFacPrvP )->( dbGoTo( nRecno ) )

Return ( lReturn )



Function lCntRecPrv( cRecibo, nAsiento, lFromFactura, oTree, dbfFacPrvP )

   local lReturn  := .F.

   if dbLock( dbfFacPrvP )
      ( dbfFacPrvP )->lConPgo  := .T.
      ( dbfFacPrvP )->( dbUnLock() )
      lReturn     := .T.
   end

   if !lFromFactura
      oTree:Select( oTree:Add( "Recibo proveedor : " + rtrim( cRecibo ) + " asiento generado num. " + alltrim( str( nAsiento ) ), 1 ) )
   end

RETURN ( lReturn )



FUNCTION ContabilizaReciboCliente( oBrw, oTree, lSimula, aSimula, dbfFacCliT, dbfFacCliP, dbfFPago, dbfCli, dbfDiv, lFromFactura, nAsiento )

   local cCodEmp
   local cRuta
   local dFecha
   local cConcepto
   local cCtaGas
   local cCtaPgo
   local cCtaCli
   local nDpvDiv
   local lEfePgo
   local nEjeCon        := 0
   local nRecCliT       := ( dbfFacCliT )->( Recno() )
   local nRecCliP       := ( dbfFacCliP )->( Recno() )
   local cCodDiv        := if( ( dbfFacCliP )->lImpEur, "EUR", ( dbfFacCliP )->cDivPgo )
   local nImpRec        := nTotRecCli( dbfFacCliP, dbfDiv )
   local nImpCob        := nTotCobCli( dbfFacCliP, dbfDiv )
   local nImpGas        := nTotGasCli( dbfFacCliP, dbfDiv )
   local nRecibo        := ( dbfFacCliP )->cSerie + str( ( dbfFacCliP )->nNumFac, 9 ) + ( dbfFacCliP )->cSufFac + str( ( dbfFacCliP )->nNumRec )
   local cRecibo        := ( dbfFacCliP )->cSerie + "/" + Ltrim( str( ( dbfFacCliP )->NNUMFAC, 9 ) ) + "/" + ( dbfFacCliP )->CSUFFAC + "-" + str( ( dbfFacCliP )->NNUMREC )
   local lConFac        := lConFacCli( ( dbfFacCliP )->CSERIE + str( ( dbfFacCliP )->NNUMFAC, 9 ) + ( dbfFacCliP )->CSUFFAC, dbfFacCliT )
   local cCodCli        := cCliFacCli( ( dbfFacCliP )->CSERIE + str( ( dbfFacCliP )->NNUMFAC, 9 ) + ( dbfFacCliP )->CSUFFAC, dbfFacCliT )
   local cCodPgo        := cPgoFacCli( ( dbfFacCliP )->CSERIE + str( ( dbfFacCliP )->NNUMFAC, 9 ) + ( dbfFacCliP )->CSUFFAC, dbfFacCliT )
   local cCodPro        := cProFacCli( ( dbfFacCliP )->CSERIE + str( ( dbfFacCliP )->NNUMFAC, 9 ) + ( dbfFacCliP )->CSUFFAC, dbfFacCliT )
   local cTerNif        := RetFld( ( dbfFacCliP )->CSERIE + str( ( dbfFacCliP )->NNUMFAC, 9 ) + ( dbfFacCliP )->CSUFFAC, dbfFacCliT, "CDNICLI" )
   local cNombreCliente := ( dbfFacCliP )->cNomCli
   local lErrorFound    := .F.
   local lRectif        := !Empty( ( dbfFacCliP )->cTipRec )
   local cProyecto      := Left( cCodPro, 3 )
   local cClave         := Right( cCodPro, 6 )
   local lReturn        := .T.

   nDpvDiv              := nDpvDiv( cCodDiv, dbfDiv )

   If( lSimula == nil, lSimula := .F., ) ;
   If( aSimula == nil, aSimula := {}, ) ;
   If( lFromFactura == nil, lFromFactura := .F., ) ;
   If( nAsiento == nil, nAsiento := 0, ) ;

   cRuta                := cRutCnt()
   cCodEmp              := cCodEmpCnt( ( dbfFacCliP )->cSerie )

   if !lFromFactura

      if OpenDiario( , cCodEmp )
         nAsiento       := contaplusUltimoAsiento()
      else
         oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " imposible abrir ficheros de contaplus.", 0 ) )
         Return .F.
      end

   end






   if lAplicacionContaplus()

      if !( ( dbfFacCliP )->lCobrado .OR. ( dbfFacCliP )->lDevuelto )
         oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " no cobrado o no devuelto.", 0, bGenEdtRecCli( nRecibo, lFromFactura ) ) )
         lErrorFound       := .T.
      end

      if ( dbfFacCliP )->lCobrado .AND. !ChkFecha( , , ( dbfFacCliP )->dEntrada, .F. )
         oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " de " + dtoc( ( dbfFacCliP )->dEntrada ) + " asiento fuera de fechas", 0, bGenEdtRecCli( nRecibo, lFromFactura ) ) )
         lErrorFound       := .T.
      end

   end

   if ( dbfFacCliP )->lConPgo
      oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " ya contabilizado.", 0, bGenEdtRecCli( nRecibo, lFromFactura ) ) )
      lErrorFound       := .T.
   end

   if !Empty( ( dbfFacCliP )->nNumRem ) .AND. !( dbfFacCliP )->lDevuelto
      oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " pertenece a remesa.", 0, bGenEdtRecCli( nRecibo, lFromFactura ) ) )
      lErrorFound       := .T.
   end

   if !uFieldEmpresa( "LCONTREC" )

      if !lConFac .AND. !lFromFactura
         oTree:Select( oTree:Add( "Factura de recibo : " + rtrim( cRecibo ) + " no contabilizada.", 0, bGenEdtRecCli( nRecibo, lFromFactura ) ) )
         lErrorFound       := .T.
      end

   end

   if !ChkRuta( cRutCnt() )
      oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " ruta no valida.", 0, bGenEdtRecCli( nRecibo, lFromFactura ) ) )
      lErrorFound       := .T.
   end






   if Empty( cCodEmp )
      oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " no se definieron empresas asociadas.", 0, bGenEdtRecCli( nRecibo, lFromFactura ) ) )
      lErrorFound       := .T.
   end






   if Empty( cCodCli )
      cCodCli           := cCliFacCli( ( dbfFacCliP )->cSerie + str( ( dbfFacCliP )->nNumFac, 9 ) + ( dbfFacCliP )->cSufFac, dbfFacCliT )
   end

   cCtaCli              := cCliCta( cCodCli, dbfCli )

   if Empty( cCtaCli )
      cCtaCli           := cCtaSin()
   end

   if !ChkSubcuenta( cRuta, cCodEmp, cCtaCli, , .F., .F. )
      oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " subcuenta de cliente " + cCtaCli + " no encontada.", 0, bGenEdtRecCli( nRecibo, lFromFactura ) ) )
      lErrorFound       := .T.
   end






   if ( dbfFacCliP )->( dbSeek( nRecibo ) )





      cCtaPgo           := ( dbfFacCliP )->cCtaRec

      if Empty( cCtaPgo )
         cCtaPgo        := cCtaFPago( cCodPgo, dbfFPago )
      end

      if Empty( cCtaPgo )
         cCtaPgo        := cCtaCob()
      end

      if lAplicacionContaplus()

         if Empty( cCtaPgo )
            oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " no existe cuenta de pago.", 0, bGenEdtRecCli( nRecibo, lFromFactura ) ) )
            lErrorFound    := .T.
         end

      end

      if !ChkSubcuenta( cRuta, cCodEmp, cCtaPgo, , .F., .F. )
         oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " subcuenta " + rtrim( cCtaPgo ) + " no encontada.", 0, bGenEdtRecCli( nRecibo, lFromFactura ) ) )
         lErrorFound    := .T.
      end





      if lAplicacionContaplus()

         if ( nTipoPago( cCodPgo, dbfFPago ) == 1 )

            nEjeCon        := nEjercicioContaplus( cRuta, cCodEmp, .F. )

            if Empty( nEjeCon )
               oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " ejercicio no encontado.", 0, bGenEdtRecCli( nRecibo, lFromFactura ) ) )
               lErrorFound := .T.
            end

         end

      end





      if nImpGas <> 0

         if Empty( ( dbfFacCliP )->cCtaGas )
            cCtaGas  := cCtaFGas( cCodPgo, dbfFPago )
         else
            cCtaGas  := ( dbfFacCliP )->cCtaGas
         end

         if Empty( cCtaGas )
            oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " no existe cuenta de gastos.", 0, bGenEdtRecCli( nRecibo, lFromFactura ) ) )
            lErrorFound := .T.
         end

         if !ChkSubcuenta( cRuta, cCodEmp, cCtaGas, , .F., .F. )
            oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " subcuenta " + rtrim( cCtaGas ) + " no encontada.", 0, bGenEdtRecCli( nRecibo, lFromFactura ) ) )
            lErrorFound := .T.
         end

      end

   else

      msginfo( "No encuentro el recibo " + nRecibo )

   end






   if ( !lErrorFound )

      if empty( ( dbfFacCliP )->dPreCob ) .AND. dbDialogLock( dbfFacCliP )
         ( dbfFacCliP )->dPreCob    := date()
         ( dbfFacCliP )->( dbUnLock() )
      end

   end






   if ( lSimula .OR. !lErrorFound )

      if ( dbfFacCliP )->lDevuelto
         cConcepto      := "Dev./Recibo. " + cRecibo
         dFecha         := ( dbfFacCliP )->dFecDev
      else
         cConcepto      := "C/Recibo. " + cRecibo
         dFecha         := ( dbfFacCliP )->dEntrada
      end





      if lAplicacionContaplus()

         if nImpRec <> 0





















             aadd( aSimula, MkAsiento( nAsiento, cCodDiv, dFecha,  cCtaCli, , if( ( dbfFacCliP )->lDevuelto, nImpRec, 0 ), cConcepto, if( ( dbfFacCliP )->lDevuelto, 0, nImpRec ), , , , , , cProyecto, cClave, , , , lSimula, cTerNif, cNombreCliente ) )

         end





         if nImpCob <> 0























            aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha,  cCtaPgo, , if( ( dbfFacCliP )->lDevuelto, 0, nImpCob ), cConcepto, if( ( dbfFacCliP )->lDevuelto, nImpCob, 0 ), , , , , , cProyecto, cClave, , , , lSimula, cTerNif, cNombreCliente, nEjeCon, cCtaCli ) )

         end





         if nImpGas <> 0





















            aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha,  cCtaGas, , if( ( dbfFacCliP )->lDevuelto, 0, nImpGas ), cConcepto, if( ( dbfFacCliP )->lDevuelto, nImpGas, 0 ), , , , , , cProyecto, cClave, , , , lSimula, cTerNif, cNombreCliente ) )

         end

      else











         EnlaceA3():getInstance():Add( {  "Empresa"               => cEmpCnt( ( dbfFacCliP )->cSerie ), "Fecha"                 => ( dbfFacCliP )->dEntrada, "TipoRegistro"          => "0", "Cuenta"                => cCtaPgo, "DescripcionCuenta"     => cNombreCliente, "TipoImporte"           => "D", "ReferenciaDocumento"   => nRecibo, "DescripcionApunte"     => cConcepto, "Importe"               => nImpRec, "Moneda"                => "E", "Render"                => "ApuntesSinIVA" } )











         EnlaceA3():getInstance():Add( {  "Empresa"               => cEmpCnt( ( dbfFacCliP )->cSerie ), "Fecha"                 => ( dbfFacCliP )->dEntrada, "TipoRegistro"          => "0", "Cuenta"                => cCtaCli, "DescripcionCuenta"     => cNombreCliente, "TipoImporte"           => "H", "ReferenciaDocumento"   => nRecibo, "DescripcionApunte"     => cConcepto, "Importe"               => nImpRec, "Moneda"                => "E", "Render"                => "ApuntesSinIVA" } )

      end

      if ( !lSimula .AND. !lErrorFound )

         aWriteAsiento( aSimula, cCodDiv, .T., oTree, cRecibo, nAsiento )

         lReturn     := lContabilizaReciboCliente( nRecibo, cRecibo, nAsiento, aSimula, lFromFactura, oTree, dbfFacCliP )

      end

      if ( lSimula .AND. !lFromFactura )



         lReturn     := msgTblCon( aSimula, cCodDiv, dbfDiv, !lErrorFound, cRecibo,  {||   aWriteAsiento( aSimula, cCodDiv, .T., oTree, cRecibo, nAsiento ),  lContabilizaReciboCliente( nRecibo, cRecibo, nAsiento, aSimula, lFromFactura, oTree, dbfFacCliP ) } )

      end

      if ( lSimula .AND. lFromFactura )
         lContabilizaReciboCliente( nRecibo, cRecibo, nAsiento, aSimula, lFromFactura, oTree, dbfFacCliP )
      end

   end

   if !lFromFactura
      CloseDiario()
   end

   if !Empty( oBrw )
      oBrw:Refresh()
   end

   ( dbfFacCliP )->( dbGoTo( nRecCliP ) )
   ( dbfFacCliT )->( dbGoTo( nRecCliT ) )

RETURN ( lReturn )



Static Function lContabilizaReciboCliente( nRecibo, cRecibo, nAsiento, aSimula, lFromFactura, oTree, dbfFacCliP )

   local aAsiento := atail( aSimula )
   local nRecno   := ( dbfFacCliP )->( recno() )
   local cOrder   := ( dbfFacCliP )->( ordsetfocus() )

   if dbseekinord( nRecibo, "nNumFac", dbfFacCliP )

      if dbDialogLock( dbfFacCliP )

         ( dbfFacCliP )->lConPgo       := .T.

         if ( getDiarioDatabaseContaplus() )->( fieldpos( "Guid" ) ) <> 0
            ( dbfFacCliP )->cConGuid   := aAsiento[ ( getDiarioDatabaseContaplus() )->( fieldpos( "Guid" ) ) ]
         end

         ( dbfFacCliP )->( dbunlock() )

      end

      if !lFromFactura
         oTree:Select( oTree:Add( "Recibo : " + rtrim( cRecibo ) + " asiento generado num. " + alltrim( str( nAsiento ) ), 1 ) )
      end

   else

      msgStop( "Recibo " + nRecibo + " no encontado" )

   end

   ( dbfFacCliP )->( ordsetfocus( cOrder ) )
   ( dbfFacCliP )->( dbgoto( nRecno ) )

RETURN ( .T. )











FUNCTION CntFacRec( lSimula, lPago, lExcCnt, lMessage, oTree, nAsiento, aSimula, dbfFacRecT, dbfFacRecL, dbfFacCliP, dbfCli, dbfDiv, dbfArt, dbfFPago, dbfIva, oNewImp, oBrw, cCodEmp, cCodPro )

   local n
   local nIva
   local cCtaVent
   local nPos
   local dFecha
   local cConcepto
   local cPago
   local cSubCtaIva
   local cSubCtaReq
   local cSubCtaIvm
   local cSubCtaTrn
   local nImpDet
   local nImpTrn
   local nImpPnt
   local nImpIvm
   local nImpIva
   local cRuta
   local nDouDiv
   local nRouDiv
   local nDpvDiv
   local aTotAnt
   local nNetAnt
   local nIvaAnt
   local nAcuAnt        := 0
   local nTotAnt        := 0
   local uIva
   local newIva
   local aIva           := {}
   local aIvm           := {}
   local aTrn           := {}
   local nCalculo       := 0
   local nBase          := 0
   local aVentas        := {}
   local lIvaInc        := ( dbfFacRecT )->lIvaInc
   local cCodDiv        := ( dbfFacRecT )->cDivFac
   local cCtaCli        := cCliCta( ( dbfFacRecT )->cCodCli, dbfCli )
   local cCtaCliVta     := cCliCtaVta( ( dbfFacRecT )->cCodCli, dbfCli )
   local cCtaAnticipo   := cCtaAnt()
   local nFactura       := ( dbfFacRecT )->cSerie + str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac
   local cFactura       := ( dbfFacRecT )->cSerie + alltrim( str( ( dbfFacRecT )->nNumFac ) )
   local pFactura       := ( dbfFacRecT )->cSerie + "/" + alltrim( str( ( dbfFacRecT )->nNumFac ) ) + "/" + ( dbfFacRecT )->cSufFac
   local lRecargo       := ( dbfFacRecT )->lRecargo
   local cTerNif        := ( dbfFacRecT )->cDniCli
   local cTerNom        := ( dbfFacRecT )->cNomCli
   local lErrorFound    := .F.
   local cProyecto
   local cClave
   local sTotFacRec
   local ptaDebe
   local ptaRet
   local lReturn        := .T.
   local lOpenDiario    := lOpenDiario()
   local nTotDebe       := 0
   local nTotHaber      := 0
   local nDtoEsp        := 0
   local nDpp           := 0
   local nDtoUno        := 0
   local nDtoDos        := 0
   local nPctIva        := 0
   local nBaseImp       := 0
   local aAsiento
   local aAsientoSII
   local aAsientosSII   := {}

   If( lSimula == nil, lSimula := .T., ) ;
   If( nAsiento == nil, nAsiento := 0, ) ;
   If( aSimula == nil, aSimula := {}, ) ;
   If( cCodEmp == nil, cCodEmp := cCodEmpCnt( ( dbfFacRecT )->cSerie ), ) ;
   If( cCodPro == nil, cCodPro := ( dbfFacRecT )->cCodPro, ) ;

   nDouDiv           := nDouDiv( ( dbfFacRecT )->cDivFac, dbfDiv )
   nRouDiv           := nRouDiv( ( dbfFacRecT )->cDivFac, dbfDiv )
   nDpvDiv           := nDpvDiv( ( dbfFacRecT )->cDivFac, dbfDiv )

   dFecha            := ( dbfFacRecT )->dFecFac
   nDtoEsp           := ( dbfFacRecT )->nDtoEsp
   nDpp              := ( dbfFacRecT )->nDpp
   nDtoUno           := ( dbfFacRecT )->nDtoUno
   nDtoDos           := ( dbfFacRecT )->nDtoDos

   sTotFacRec        := sTotFacRec( ( dbfFacRecT )->cSerie + str( ( dbfFacRecT )->nNumFac ) + ( dbfFacRecT )->cSufFac, dbfFacRecT, dbfFacRecL, dbfIva, dbfDiv, dbfFacCliP )
   ptaDebe           := sTotFacRec:nTotalDocumento
   ptaRet            := sTotFacRec:nTotalRetencion
   newIva            := sTotFacRec:aTotalIva

   cProyecto         := Left( cCodPro, 3 )
   cClave            := Right( cCodPro, 6 )





   cRuta             := cRutCnt()

   if !chkEmpresaAsociada( cCodEmp )
      oTree:Select( oTree:Add( "Factura rectificativa cliente : " + rtrim( pFactura ) + " no se definierón empresas asociadas.", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkRuta( cRutCnt() )
      oTree:Select( oTree:Add(  "Factura rectificativa cliente : " + rtrim( pFactura ) + " ruta no valida.", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkFecha( cRuta, cCodEmp, ( dbfFacRecT )->dFecFac, .F., oTree, "Factura rectificativa cliente : " + rtrim( pFactura ) )
      lErrorFound    := .T.
   end





   if Empty( cCtaCli )
      cCtaCli        := cCtaSin()
   end

   if Empty( cCtaCliVta )
      cCtaCliVta     := cCtaCli()
   end





   if ( dbfFacRecL )->( dbSeek( nFactura ) )

      while ( ( dbfFacRecL )->cSerie + str( ( dbfFacRecL )->nNumFac ) + ( dbfFacRecL )->cSufFac == nFactura .AND. !( dbfFacRecL )->( eof() ) )



         if !( dbfFacRecL )->lTotLin                           .AND.  lValLine( dbfFacRecL )                             .AND.  nTotLFacRec( dbfFacRecL, nDouDiv, nRouDiv, nil, .T., .T., .T. ) <> 0



            if ( lExcCnt == nil                                .OR. ( lExcCnt .AND. ( dbfFacRecL )->nCtlStk <> 2 )  .OR. ( !lExcCnt .AND. ( dbfFacRecL )->nCtlStk == 2 ) )

               nIva           := ( dbfFacRecL )->nIva
               nImpDet        := nTotLFacRec( dbfFacRecL, nDouDiv, nRouDiv, nil, .T., .F., .F. )
               nImpTrn        := nTrnLFacRec( dbfFacRecL, nDouDiv, nRouDiv )





               if ( dbfFacRecT )->lOperPV
                  nImpPnt     := nPntLFacRec( dbfFacRecL, nDpvDiv )
               else
                  nImpPnt     := 0
               end

               nImpIva        := nIvaLFacRec( dbfFacRecL, nDouDiv, nRouDiv )
               nImpIvm        := nTotIFacRec( dbfFacRecL, nDouDiv, nRouDiv )

               cCtaVent       := RetCtaVta( ( dbfFacRecL )->cRef, ( nImpDet < 0 ), dbfArt )
               if Empty( cCtaVent )
                  cCtaVent    := cCtaCliVta + RetGrpVta( ( dbfFacRecL )->cRef, cRuta, cCodEmp, nIva )
               end





               nPos           := aScan( aVentas, {|x| x[ 1 ] == cCtaVent .AND. x[ 2 ] == nIva } )
               if nPos == 0
                  aAdd( aVentas, { cCtaVent, nIva, nImpDet, nImpPnt, nImpTrn, nImpIva, .F. } )
               else
                  aVentas[ nPos, 3 ]   += nImpDet
                  aVentas[ nPos, 4 ]   += nImpPnt
                  aVentas[ nPos, 5 ]   += nImpTrn
                  aVentas[ nPos, 6 ]   += nImpIva
               end





               if isIVAComunidadEconomicaEuropea( dbfFacRecT )
                  cSubCtaIva  := uFieldEmpresa( "cCtaCeeRpt" )
                  cSubCtaReq  := uFieldEmpresa( "cCtaCeeSpt" )
               else
                  cSubCtaIva  := cSubCuentaIva( nIva, ( dbfFacRecT )->lRecargo, cRuta, cCodEmp, dbfIva )
                  cSubCtaReq  := cSubCuentaRecargo( nIva, ( dbfFacRecT )->lRecargo, cRuta, cCodEmp, dbfIva )
               end

               if uFieldEmpresa( "lIvaImpEsp" )
                  nImpDet     += nImpIvm
               end

               nPos           := aScan( aIva, {|x| x[ 1 ] == nIva } )
               if nPos  == 0
                  aAdd( aIva, { nIva, cSubCtaIva, cSubCtaReq, nImpDet, nImpPnt, nImpTrn, 0, 0, 0 } )
               else
                  aIva[ nPos, 4 ] += nImpDet
                  aIva[ nPos, 5 ] += nImpPnt
                  aIva[ nPos, 6 ] += nImpTrn
               end





               if nImpTrn <> 0

                  cSubCtaTrn  := RetCtaTrn( ( dbfFacRecL )->cRef, dbfArt )

                  nPos        := aScan( aTrn, {|x| x[1] == cSubCtaTrn } )
                  if nPos == 0
                     aAdd( aTrn, { cSubCtaTrn, nImpTrn } )
                  else
                     aTrn[ nPos, 2 ] += nImpTrn
                  end

               end





               nImpIvm        := nTotIFacRec( dbfFacRecL, nDouDiv, nRouDiv )

               if nImpIvm <> 0

                  cSubCtaIvm  := oNewImp:cCtaImp( oNewImp:nValImp( ( dbfFacRecL )->cCodImp ) )

                  if !Empty( cSubCtaIvm )

                     nPos     := aScan( aIvm, {|x| x[1] == cSubCtaIvm } )
                     if nPos == 0
                        aAdd( aIvm, { cSubCtaIvm, nImpIvm } )
                     else
                        aIvm[ nPos, 2 ] += nImpIvm
                     end

                  end

               end

            end

         end

         SysRefresh()

         ( dbfFacRecL )->( dbSkip() )

      end

   else

      oTree:Select( oTree:Add( "Factura rectificativa cliente : " + rtrim( pFactura ) + " factura sin artículos.", 0 ) )

      lErrorFound := .T.

   end






   for n := 1 to Len( aVentas )
      nRestaDescuentoVenta( @aVentas[ n, 3 ], nDtoEsp )
      nRestaDescuentoVenta( @aVentas[ n, 3 ], nDpp )
      nRestaDescuentoVenta( @aVentas[ n, 3 ], nDtoUno )
      nRestaDescuentoVenta( @aVentas[ n, 3 ], nDtoDos )
   next





   if ( ( dbfFacRecT )->nManObr <> 0 )

      cSubCtaTrn     := uFieldEmpresa( "cCtaGas")

      nPos           := aScan( aVentas, {|x| x[ 1 ] == cSubCtaTrn .AND. x[ 2 ] == ( dbfFacRecT )->nIvaMan } )
      if nPos == 0
         aAdd( aVentas, { cSubCtaTrn, ( dbfFacRecT )->nIvaMan, ( dbfFacRecT )->nManObr, 0, 0, 0, .F. } )
      else
         aVentas[ nPos, 3 ]   += ( dbfFacRecT )->nManObr
      end

   end





   for n := 1 to Len( aVentas )
      aVentas[ n, 3 ]   += aVentas[ n, 4 ]
   next





   for each uIva in newIva

      if isNum( hGet( uIva, "porcentajeiva" ) )





         if isIVAComunidadEconomicaEuropea( dbfFacRecT )
            cSubCtaIva  := cCuentaVentaIVARepercutidoUE()

            hSet( uIva, "porcentajeiva", 0 )

            hSet( uIva, "cSubCtaIva", cSubCtaIva )
         elseif isIVAExportacionFueraUE( dbfFacRecT )
            cSubCtaIva  := cCuentaVentaIVARepercutidoFueraUE()

            hSet( uIva, "porcentajeiva", 0 )

            hSet( uIva, "cSubCtaIva", cSubCtaIva )
         else

            hSet( uIva, "cSubCtaIva", cSubCuentaIva( hGet( uIva, "porcentajeiva" ), ( dbfFacRecT )->lRecargo, cRuta, cCodEmp, dbfIva ) )

            hSet( uIva, "cSubCuentaRecargo", cSubCuentaRecargo( hGet( uIva, "porcentajeiva" ), ( dbfFacRecT )->lRecargo, cRuta, cCodEmp, dbfIva ) )

            hSet( uIva, "cSubCuentaIvaNRe", cSubCuentaIva( hGet( uIva, "porcentajeiva" ), .F., cRuta, cCodEmp, dbfIva ) )
         end

      end

   next






   if ( dbfFacRecT )->lContab
      oTree:Select( oTree:Add( "Factura rectificativa cliente : " + rtrim( pFactura ) + " contabilizada.", 0 ) )
      lErrorFound    := .T.
   end

   if !ChkSubcuenta( cRuta, cCodEmp, cCtaCli, , .F., .F. )
      oTree:Select( oTree:Add( "Factura rectificativa cliente : " + rtrim( pFactura ) + " subcuenta " + cCtaCli + " no encontada.", 0 ) )
      lErrorFound    := .T.
   end

   if ptaRet <> 0
      if !ChkSubcuenta( cRuta, cCodEmp, cCtaRet(), , .F., .F. )
         oTree:Select( oTree:Add( "Factura rectificativa cliente : " + rtrim( cFactura ) + " subcuenta " + cCtaRet() + " no encontada.", 0 ) )
         lErrorFound := .T.
      end
   end






   for each uIva in newIva

      if isNum( hGet( uIva, "porcentajeiva" ) )

         if !ChkSubcuenta( cRutCnt(), cCodEmp, hGet( uIva, "cSubCtaIva" ), , .F., .F. )
            oTree:Select( oTree:Add( "Factura rectificativa cliente : " + rtrim( pFactura ) + " subcuenta " + hGet( uIva, "cSubCtaIva" ) + " no encontada.", 0 ) )
            lErrorFound := .T.
         end

         if lRecargo .AND. !ChkSubcuenta( cRutCnt(), cCodEmp, hGet( uIva, "cSubCuentaRecargo" ), , .F., .F. )
            oTree:Select( oTree:Add( "Factura rectificativa cliente : " + rtrim( pFactura ) + " subcuenta " + hGet( uIva, "cSubCuentaRecargo" ) + " no encontada.", 0 ) )
            lErrorFound := .T.
         end

      end

   next

   for n := 1 to len( aVentas )
      if !ChkSubcuenta( cRuta, cCodEmp, aVentas[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura rectificativa cliente : " + rtrim( pFactura ) + " subcuenta " + aVentas[ n, 1 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end
   next

   for n := 1 to len( aIvm )
      if !lSimula .AND. !ChkSubcuenta( cRuta, cCodEmp, aIvm[ n, 1 ], , .F., .F. )
         oTree:Add( "Factura rectificativa cliente : " + rtrim( nFactura ) + " subcuenta " + aIvm[ n, 1 ] + " no encontada.", 0 )
         lErrorFound := .T.
      end
   next






   for n := 1 to len( aTrn )
      if !ChkSubcuenta( cRuta, cCodEmp, aTrn[ n, 1 ], , .F., .F. )
         oTree:Select( oTree:Add( "Factura rectificativa cliente : " + rtrim( pFactura ) + " subcuenta " + aTrn[ n, 1 ] + " no encontada.", 0 ) )
         lErrorFound := .T.
      end
   next





   if nTotAnt <> 0 .AND. !ChkSubcuenta( cRuta, cCodEmp, cCtaAnticipo, , .F., .F. )
      oTree:Select( oTree:Add( "Factura rectificativa cliente : " + rtrim( pFactura ) + " subcuenta de anticipo " + cCtaAnticipo + " no encontada.", 0 ) )
      lErrorFound := .T.
   end






   cConcepto      := "N/Rect. N." + pFactura
   cPago          := "C/Rect. N." + pFactura






   nTotDebe          += Round( ptaDebe, nRouDiv )

   for n := 1 to len( aVentas )

      if lIvaInc

         nCalculo    := Round( aVentas[ n, 3 ], nRouDiv )

         if aVentas[ n, 2 ] <> 0
            nCalculo -= Round( aVentas[ n, 3 ] / ( 100 / aVentas[ n, 2 ] + 1 ), nRouDiv )
         end

      else

         nCalculo    := Round( aVentas[ n, 3 ], nRouDiv )

      end

      nTotHaber      += nCalculo

   next

   nTotDebe          += ptaRet
   nTotDebe          += nAcuAnt

   for n := 1 to Len( aIvm )
      nTotHaber      += Round( aIvm[ n, 2 ], nRouDiv )
   next

   for n := 1 to Len( aTrn )
      nTotHaber      += Round( aTrn[ n, 2 ], nRouDiv )
   next

   for each uIva in newIva

      if isNum( hGet( uIva, "impiva" ) )
         nTotHaber   += hGet( uIva, "impiva" )
      end

      if lRecargo .AND. isNum( hGet( uIva, "impre" ) )
         nTotHaber   += hGet( uIva, "impre" )
      end

   next

   nTotDebe          := Round( nTotDebe, nRouDiv )
   nTotHaber         := Round( nTotHaber, nRouDiv )






   if lSimula .OR. !lErrorFound

      if lOpenDiario .OR. OpenDiario( , cCodEmp )
         nAsiento    := contaplusUltimoAsiento()
      else
         oTree:Select( oTree:Add( "Factura rectificativa cliente : " + rtrim( pFactura ) + " imposible abrir ficheros de contaplus.", 0 ) )
         Return .F.
      end

      setAsientoIntraComunitario( isIVAComunidadEconomicaEuropea( dbfFacRecT ) )





      if lAplicacionContaplus()





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv, dFecha, cCtaCli, , Round( ptaDebe, nRouDiv ), cConcepto, , cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      else
















         EnlaceA3():getInstance():Add( {  "Empresa"               => cEmpCnt( ( dbfFacRecT )->cSerie ), "Fecha"                 => dFecha , "TipoRegistro"          => "1", "Cuenta"                => cCtaCli, "DescripcionCuenta"     => cTerNom, "TipoFactura"           => "1", "NumeroFactura"         => cFactura, "DescripcionApunte"     => cConcepto, "Importe"               => Round( ptaDebe, nRouDiv ), "Nif"                   => cTerNif, "NombreCliente"         => cTerNom, "CodigoPostal"          => ( dbfFacRecT )->cPosCli, "FechaOperacion"        => dFecha, "FechaFactura"          => dFecha, "Moneda"                => "E", "Render"                => "CabeceraFactura" } )

      end






      for n := 1 to Len( aVentas )

         nCalculo       := Round( aVentas[ n, 3 ], nRouDiv )

         if lIvaInc

            nPctIva     := aVentas[ n, 2 ]

            if ( lRecargo .AND. aVentas[ n, 7 ] )
               nPctIva  += nPReq( dbfIva, aVentas[ n, 2 ] )
            end

            if aVentas[ n, 2 ] <> 0
               nCalculo -= Round( aVentas[ n, 3 ] / ( 100 / nPctIva + 1 ), nRouDiv )
            end

         end

         if lAplicacionContaplus()





















            aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aVentas[ n, 1 ], , , cConcepto, nCalculo, cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

         else



















            EnlaceA3():getInstance():Add( {  "Empresa"               => cEmpCnt( ( dbfFacRecT )->cSerie ), "Fecha"                 => dFecha , "TipoRegistro"          => "9", "Cuenta"                => aVentas[ n, 1 ], "DescripcionCuenta"     => "", "TipoImporte"           => "C", "NumeroFactura"         => cFactura, "DescripcionApunte"     => cConcepto, "SubtipoFactura"        => if( isIVAComunidadEconomicaEuropea( dbfFacRecT ), "02", "01" ), "BaseImponible"         => nCalculo, "PorcentajeIVA"         => aVentas[ n, 2 ], "PorcentajeRecargo"     => if( ( dbfFacRecT )->lRecargo, nPReq( dbfIva, aVentas[ n, 2 ] ), 0 ), "PorcentajeRetencion"   => 0, "Impreso"               => "01", "SujetaIVA"             => if( aVentas[ n, 2 ] <> 0, "S", "N" ), "Modelo415"             => " ", "Analitico"             => " ", "Moneda"                => "E", "Render"                => "VentaFactura" } )

         end

      next





      if lAplicacionContaplus() .AND. ptaRet <> 0





















         aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, cCtaRet(), , ptaRet, cConcepto, , cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      end






      if lAplicacionContaplus() .AND. nTotAnt <> 0





















         aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, cCtaAnticipo, , nAcuAnt, cConcepto, , cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      end






      for n := 1 to Len( aIvm )



















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aIvm[ n, 1 ], , , cConcepto, Round( aIvm[ n, 2 ], nRouDiv ), cFactura, , , , , cProyecto, cClave, , , , lSimula ) )

      next






      for n := 1 to Len( aTrn )





















         aadd( aSimula, MkAsiento(  nAsiento,  cCodDiv,  dFecha,  aTrn[ n, 1 ], , , cConcepto, Round( aTrn[ n, 2 ], nRouDiv ), cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

      next






      for each uIva in newIva

         if ( len( uIva ) >= 12 )

            nBaseImp    := hGet( uIva, "neto" )

            if uFieldEmpresa( "lIvaImpEsp" )
               nBaseImp += hGet( uIva, "nivmh" )
            end
























            aAsiento    := MkAsiento(  nAsiento,  cCodDiv,  dFecha,  hGet( uIva, "cSubCtaIva" ), cCtaCli, , cConcepto, hGet( uIva, "impiva" ), cFactura, nBaseImp, hGet( uIva, "porcentajeiva" ), if( lRecargo, hGet( uIva, "porcentajere" ), 0 ), , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom, , , .T. )

            aAdd( aSimula, aAsiento )



            aAsientoSII := MkAsientoSII( aAsiento, 5 )

            if !empty( aAsientoSII )
               aadd( aAsientosSII, aAsientoSII )
            end

         end






         if ( lRecargo .AND. len( uIva ) >= 13 .AND. hGet( uIva, "impre" ) <> 0 )





















            aadd( aSimula, MkAsiento(  nAsiento, cCodDiv, dFecha, hGet( uIva, "cSubCuentaRecargo" ), , , cConcepto, hGet( uIva, "impre" ), cFactura, , , , , cProyecto, cClave, , , , lSimula, cTerNif, cTerNom ) )

         end
































      next

   end






   if lPago .AND. !lErrorFound .AND. ( dbfFacCliP )->( dbSeek( nFactura ) )

      while ( ( dbfFacCliP )->cSerie + str( ( dbfFacCliP )->nNumFac ) + ( dbfFacCliP )->cSufFac == nFactura ) .AND. !( dbfFacCliP )->( eof() )

         ContabilizaReciboCliente( oBrw, oTree, .T., aSimula, dbfFacRecT, dbfFacCliP, dbfFPago, dbfCli, dbfDiv, .T., nAsiento )

         ( dbfFacCliP )->( dbSkip() )

      end

   end





   if lSimula

      if lMessage



         lReturn  := msgTblCon( aSimula, cCodDiv, dbfDiv, !lErrorFound, pFactura, {||   aWriteAsiento( aSimula, cCodDiv, lMessage, oTree, pFactura, nAsiento ), aWriteAsientoSII( aAsientosSII ), lContabilizaFacturaRectificativa( nFactura, pFactura, nAsiento, aSimula, lPago, oTree, dbfFacRecT, dbfFacCliP ) } )
      end

   else

      if !lErrorFound
         aWriteAsiento( aSimula, cCodDiv, lMessage, oTree, pFactura, nAsiento )
         aWriteAsientoSII( aAsientosSII )
         lReturn  := lContabilizaFacturaRectificativa( nFactura, pFactura, nAsiento, aSimula, lPago, oTree, dbfFacRecT )
      end

   end





   if !lOpenDiario
      CloseDiario()
   end

   setAsientoIntraComunitario( .F. )

   if !Empty( oBrw )
      oBrw:Refresh()
   end

RETURN ( lReturn )
