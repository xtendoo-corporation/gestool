#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 36 ".\.\Prg\ConfImpTiket.prg"
static oWndBrw
static dbfImpTik
static bEdit         := { |aTmp, aGet, dbfImpTik, oBrw, bWhen, bValid, nMode | EdtRec( aTmp, aGet, dbfImpTik, oBrw, bWhen, bValid, nMode ) }






STATIC FUNCTION OpenFiles()

   local lOpen       := .T.
   local oBlock      := ErrorBlock( {| oError | ApoloBreak( oError ) } )

   BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "IMPTIK.DBF" ), ( cCheckArea( "IMPTIK", @dbfImpTik ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatDat() + "IMPTIK.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   RECOVER

      msgStop( "Imposible abrir todas las bases de datos" )
      CloseFiles()
      lOpen          := .F.

   end

   ErrorBlock( oBlock )

RETURN ( lOpen )






STATIC FUNCTION CloseFiles()

   if dbfImpTik <> nil
      ( dbfImpTik )->( dbCloseArea() )
   end

   dbfImpTik  := nil
   oWndBrw    := nil

RETURN .T.






FUNCTION ConfImpTiket( oMenuItem, oWnd )

   local nLevel

   If( oMenuItem == nil, oMenuItem := "01090", ) ;
   If( oWnd == nil, oWnd := oWnd(), ) ;

   if oWndBrw == NIL





      nLevel            := Auth():Level( oMenuItem )

      if nAnd( nLevel, 1 ) == 0
         msgStop( "Acceso no permitido." )
         return nil
      end





      if oWnd <> nil
         SysRefresh(); oWnd:CloseAll(); SysRefresh()
      end





      if !OpenFiles()
         return Nil
      end





      AddMnuNext( "Balanzas", ProcName() )














   oWndBrw := TShell():New( 2, 10, 18, 70, "Balanzas",, oWnd,,, .F.,,, ( dbfImpTik ),,,,, {"Código", "Descripción"}, {||( WinAppRec( oWndBrw:oBrw, bEdit, dbfImpTik ) )}, {||( WinEdtRec( oWndBrw:oBrw, bEdit, dbfImpTik ) )}, {||( WinDelRec( oWndBrw:oBrw, dbfImpTik ) )}, {||( WinDupRec( oWndBrw:oBrw, bEdit, dbfImpTik ) )}, nil, nLevel, "gc_balance_16", ( 164 + ( 55 * 256 ) + ( 58 * 65536 ) ),,, .T. )

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodImp"
         :bEditValue       := {|| ( dbfImpTik )->cCodImp }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Descripción"
         :cSortOrder       := "cNomImp"
         :bEditValue       := {|| ( dbfImpTik )->cNomImp }
         :nWidth           := 280
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      oWndBrw:CreateXFromCode()





      oWndBrw:NewAt( "BUS",,, {||( oWndBrw:SearchSetFocus() )}, "(B)uscar", "B",,,,, .F. )

      oWndBrw:AddSeaBar()








      oWndBrw:NewAt( "NEW",,, {||( oWndBrw:RecAdd() )}, "(A)ñadir", "A",,, 2,, .F. )







      oWndBrw:NewAt( "DUP",,, {||( oWndBrw:RecDup() )}, "(D)uplicar", "D",,, 2,, .F. )







      oWndBrw:NewAt( "EDIT",,, {||( oWndBrw:RecEdit() )}, "(M)odificar", "M",,, 4,, .F. )







        oWndBrw:NewAt( "ZOOM",,, {||( WinZooRec( oWndBrw:oBrw, bEdit, dbfImpTik ) )}, "(Z)oom", "Z",,, 8,, .F. )







        oWndBrw:NewAt( "DEL",,, {||( oWndBrw:RecDel() )}, "(E)liminar", "E",,, 16,, .F. )





      oWndBrw:NewAt( "END",,, {||( oWndBrw:end() )}, "(S)alir", "S",,,,, .F. )

        oWndBrw:Activate(, oWndBrw:bLClicked, oWndBrw:bRClicked, oWndBrw:bMoved, oWndBrw:bResized, oWndBrw:bPainted, oWndBrw:bKeyDown, oWndBrw:bInit,,,,,,,,, {|| ( CloseFiles() )},, oWndBrw:bLButtonUp, .F. )

   else

        oWndBrw:SetFocus()

   end

RETURN NIL






STATIC FUNCTION EdtRec( aTmp, aGet, dbfImpTik, oBrw, bWhen, bValid, nMode )

   local oDlg
   local oPort
   local cPort
   local oBitsSec
   local oBitsParada
   local oBitsDatos
   local oBitsParidad
   local cBitsSec
   local cBitsParada
   local cBitsDatos
   local cBitsParidad
   local aBitsSec       := { "2400", "4800", "9600", "19200", "38400", "57600", "115200", "203400", "460800", "921600" }
   local aBitsParada    := { "0", "1", "2" }
   local aBitsDatos     := { "7", "8" }
   local aBitsParidad   := { "Sin paridad", "Paridad par", "Paridad impar" }
   local aPort          := { "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9", "COM10", "COM11", "COM12", "COM13", "COM14", "COM15", "COM16", "COM17", "COM18" }
   local oBmpGeneral

   if nMode == 1
      cPort             := "COM1"
      cBitsSec          := "9600"
      cBitsParada       := "0"
      cBitsDatos        := "8"
      cBitsParidad      := "Sin paridad"
   else
      cPort             := aTmp[ ( dbfImpTik )->( FieldPos( "cPort" ) ) ]
      cBitsSec          := Str( aTmp[ ( dbfImpTik )->( FieldPos( "nBitsSec" ) ) ] )
      cBitsParada       := Str( aTmp[ ( dbfImpTik )->( FieldPos( "nBitsPara" ) ) ] )
      cBitsDatos        := Str( aTmp[ ( dbfImpTik )->( FieldPos( "nBitsDatos" ) ) ] )
      cBitsParidad      := aTmp[ ( dbfImpTik )->( FieldPos( "cBitsPari" ) ) ]
   end



   oDlg = TDialog():New(,,,, LblTitle( nMode ) + " balanzas", "balanza_sql",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )







      oBmpGeneral := TBitmap():ReDefine( 900, "gc_balance_48",, oDlg,,, .F., .F.,,, .F.,,, .T. )








      aGet[ ( dbfImpTik )->( FieldPos( "cCodImp" ) ) ] := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ ( dbfImpTik )->( FieldPos( "cCodImp" ) ) ], aTmp[ ( dbfImpTik )->( FieldPos( "cCodImp" ) ) ]:= u ) }, oDlg,, "@!", {||    ( NotValid( aGet[ ( dbfImpTik )->( FieldPos( "cCodImp" ) ) ], dbfImpTik, .T., "0" ) )},,,,,, .T., {||     ( nMode == 1 .OR. nMode == 4 )},, .F., .F.,,,,,, nil,,, )





      aGet[ ( dbfImpTik )->( FieldPos( "cNomImp" ) ) ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ ( dbfImpTik )->( FieldPos( "cNomImp" ) ) ], aTmp[ ( dbfImpTik )->( FieldPos( "cNomImp" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )






      oPort := TComboBox():ReDefine( 120, { | u | If( PCount()==0, cPort, cPort:= u ) }, aPort, oDlg,,, {|Self|( oDlg:aEvalWhen() )},,,, .F., {||     ( nMode <> 3 )},,,,,, "oPort",,,,,,, )





      oBitsSec := TComboBox():ReDefine( 130, { | u | If( PCount()==0, cBitsSec, cBitsSec:= u ) }, aBitsSec, oDlg,,,,,,, .F., {||     ( nMode <> 3 )},,,,,, "oBitsSec",,,,,,, )





      oBitsParada := TComboBox():ReDefine( 140, { | u | If( PCount()==0, cBitsParada, cBitsParada:= u ) }, aBitsParada, oDlg,,,,,,, .F., {||     ( nMode <> 3 )},,,,,, "oBitsParada",,,,,,, )





      oBitsDatos := TComboBox():ReDefine( 150, { | u | If( PCount()==0, cBitsDatos, cBitsDatos:= u ) }, aBitsDatos, oDlg,,,,,,, .F., {||     ( nMode <> 3 )},,,,,, "oBitsDatos",,,,,,, )





      oBitsParidad := TComboBox():ReDefine( 160, { | u | If( PCount()==0, cBitsParidad, cBitsParidad:= u ) }, aBitsParidad, oDlg,,,,,,, .F., {||     ( nMode <> 3 )},,,,,, "oBitsParidad",,,,,,, )




      TButton():ReDefine( 210, {||( TestBalanza( cBitsSec, cBitsDatos, cBitsParada, cBitsParidad, cPort ) )}, oDlg,,, .F.,,,, .F. )







      TButton():ReDefine( 220, {||( lDefecto( aGet, oPort, oBitsSec, oBitsParada, oBitsDatos, oBitsParidad ) )}, oDlg,,, .F., {||         ( nMode <> 3 )},,, .F. )







      TButton():ReDefine( 1, {||( EndTrans( aTmp, aGet, dbfImpTik, oBrw, nMode, oDlg, cPort, cBitsSec, cBitsParada, cBitsDatos, cBitsParidad ) )}, oDlg,,, .F., {||         ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )



   if nMode <> 3
      oDlg:AddFastKey( 116, {|| EndTrans( aTmp, aGet, dbfImpTik, oBrw, nMode, oDlg, cPort, cBitsSec, cBitsParada, cBitsDatos, cBitsParidad ) } )
   end

   oDlg:bStart    := {|| aGet[ ( dbfImpTik )->( FieldPos( "cCodImp" ) ) ]:SetFocus() }

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if !empty( oBmpGeneral )
      oBmpGeneral:End()
   end

RETURN ( oDlg:nResult == 1 )






STATIC FUNCTION EndTrans( aTmp, aGet, dbfImpTik, oBrw, nMode, oDlg, cPort, cBitsSec, cBitsParada, cBitsDatos, cBitsParidad )



   if nMode == 1 .OR. nMode == 4

      if Empty( aTmp[ ( dbfImpTik )->( FieldPos( "cCodImp" ) ) ] )
         MsgStop( "El código de la balanza no puede estar vacío" )
         aGet[ ( dbfImpTik )->( FieldPos( "cCodImp" ) ) ]:SetFocus()
         Return nil
      end

      if dbSeekInOrd( aTmp[ ( dbfImpTik )->( FieldPos( "cCodImp" ) ) ], "CCODIMP", dbfImpTik )
         msgStop( "Código existente" )
         return nil
      end

   end



   if Empty( aTmp[ ( dbfImpTik )->( FieldPos( "cNomImp" ) ) ] )
      MsgStop( "El nombre de la balanza no puede estar vacío" )
      aGet[ ( dbfImpTik )->( FieldPos( "cNomImp" ) ) ]:SetFocus()
      Return .F.
   end



   aTmp[ ( dbfImpTik )->( FieldPos( "cPort" ) ) ]      := cPort
   aTmp[ ( dbfImpTik )->( FieldPos( "nBitsSec" ) ) ]   := Val( cBitsSec )
   aTmp[ ( dbfImpTik )->( FieldPos( "nBitsPara" ) ) ]  := Val( cBitsParada )
   aTmp[ ( dbfImpTik )->( FieldPos( "nBitsDatos" ) ) ] := Val( cBitsDatos )
   aTmp[ ( dbfImpTik )->( FieldPos( "cBitsPari" ) ) ]  := cBitsParidad



   WinGather( aTmp, aGet, dbfImpTik, oBrw, nMode )

RETURN ( oDlg:end( 1 ) )






FUNCTION mkImpTik( cPath, lAppend, cPathOld, oMeter )

   local oImpTik

   If( cPath == nil, cPath := cPatDat(), ) ;
    If( lAppend == nil, lAppend := .F., ) ;

   oImpTik := DbfServer( "IMPTIK.DBF", ):New( "IMPTIK.DBF", "IMPTIK", ( cDriver() ), "Impresoras de tickets", ( cPath ) )

      oImpTik:AddField( "CCODIMP", "C", 3, 0,,,,, "Código de la impresora de ticket", .F.,, .F., {} )
      oImpTik:AddField( "CNOMIMP", "C", 35, 0,,,,, "Nombre de la impresora de ticket", .F.,, .F., {} )
      oImpTik:AddField( "LWIN", "L", 1, 0,,,,, "Lógico para utilizar driver de windows", .F.,, .F., {} )
      oImpTik:AddField( "CNOMPRN", "C", 254, 0,,,,, "Nombre de la impresora seleccionada", .F.,, .F., {} )
      oImpTik:AddField( "CPORT", "C", 50, 0,,,,, "Puerto de la impresora", .F.,, .F., {} )
      oImpTik:AddField( "NBITSSEC", "N", 6, 0,,,,, "Bit segundos", .F.,, .F., {} )
      oImpTik:AddField( "NBITSPARA", "N", 1, 0,,,,, "Bit de parada", .F.,, .F., {} )
      oImpTik:AddField( "NBITSDATOS", "N", 1, 0,,,,, "Bit de datos", .F.,, .F., {} )
      oImpTik:AddField( "CBITSPARI", "C", 50, 0,,,,, "Bit de paridad", .F.,, .F., {} )
      oImpTik:AddField( "CACTCENTR", "C", 50, 0,,,,, "Activar centrado", .F.,, .F., {} )
      oImpTik:AddField( "CDESCENTR", "C", 50, 0,,,,, "Desactivar centrado", .F.,, .F., {} )
      oImpTik:AddField( "CACTNEGR", "C", 50, 0,,,,, "Activar negrita", .F.,, .F., {} )
      oImpTik:AddField( "CDESNEGR", "C", 50, 0,,,,, "Desactivar negrita", .F.,, .F., {} )
      oImpTik:AddField( "CACTEXP", "C", 50, 0,,,,, "Activar expandida", .F.,, .F., {} )
      oImpTik:AddField( "CDESEXP", "C", 50, 0,,,,, "Desactivar expandida", .F.,, .F., {} )
      oImpTik:AddField( "CACTCOLOR", "C", 50, 0,,,,, "Activar color", .F.,, .F., {} )
      oImpTik:AddField( "CDESCOLOR", "C", 50, 0,,,,, "Desactivar color", .F.,, .F., {} )
      oImpTik:AddField( "CSALTO", "C", 50, 0,,,,, "Salto de página", .F.,, .F., {} )
      oImpTik:AddField( "CCORTE", "C", 50, 0,,,,, "Corte del papel", .F.,, .F., {} )
      oImpTik:AddField( "NRETARDO", "N", 4, 2, "@E 9.99",,,, "Tiempo de retardo", .F.,, .F., {} )
      oImpTik:AddField( "LOPENREAD", "L", 1, 0,,,,, "Lógico abrir el puerto cada lectura", .F.,, .F., {} )
      oImpTik:AddField( "CENTUB", "C", 1, 0,,,,, "Entubamiento", .F.,, .F., {} )
      oImpTik:AddField( "NBUFER", "N", 3, 0,,,,, "Bufer de lectura", .F.,, .F., {} )

      oImpTik:AddIndex( "CCODIMP", "IMPTIK.CDX", "CCODIMP",,, .F., .F.,,,, .T., .F. )



   oImpTik:Activate( .F., .F. )

   if lAppend .AND. !Empty( cPathOld ) .AND. lExistTable( cPathOld + "IMPTIK.DBF" )
      oImpTik:AppendFrom( cPathOld + "IMPTIK.DBF" )
   end

   oImpTik:end()

RETURN .T.



function aItmImpTik()

   local aItm  := {}

   aAdd( aItm, { "CCODIMP"   , "C",  3 , 0, "Código de la impresora de ticket"       } )
   aAdd( aItm, { "CNOMIMP"   , "C", 35 , 0, "Nombre de la impresora de ticket"       } )
   aAdd( aItm, { "LWIN"      , "L",  1 , 0, "Lógico para utilizar driver de windows" } )
   aAdd( aItm, { "CNOMPRN"   , "C", 254, 0, "Nombre de la impresora seleccionada"    } )
   aAdd( aItm, { "CPORT"     , "C", 50 , 0, "Puerto de la impresora"                 } )
   aAdd( aItm, { "NBITSSEC"  , "N",  6 , 0, "Bit segundos"                           } )
   aAdd( aItm, { "NBITSPARA" , "N",  1 , 0, "Bit de parada"                          } )
   aAdd( aItm, { "NBITSDATOS", "N",  1 , 0, "Bit de datos"                           } )
   aAdd( aItm, { "CBITSPARI" , "C", 50 , 0, "Bit de paridad"                         } )
   aAdd( aItm, { "CACTCENTR" , "C", 50 , 0, "Activar centrado"                       } )
   aAdd( aItm, { "CDESCENTR" , "C", 50 , 0, "Desactivar centrado"                    } )
   aAdd( aItm, { "CACTNEGR"  , "C", 50 , 0, "Activar negrita"                        } )
   aAdd( aItm, { "CDESNEGR"  , "C", 50 , 0, "Desactivar negrita"                     } )
   aAdd( aItm, { "CACTEXP"   , "C", 50 , 0, "Activar expandida"                      } )
   aAdd( aItm, { "CDESEXP"   , "C", 50 , 0, "Desactivar expandida"                   } )
   aAdd( aItm, { "CACTCOLOR" , "C", 50 , 0, "Activar color"                          } )
   aAdd( aItm, { "CDESCOLOR" , "C", 50 , 0, "Desactivar color"                       } )
   aAdd( aItm, { "CSALTO"    , "C", 50 , 0, "Salto de página"                        } )
   aAdd( aItm, { "CCORTE"    , "C", 50 , 0, "Corte del papel"                        } )
   aAdd( aItm, { "NRETARDO"  , "N",  4 , 2, "Tiempo de retardo"                      } )
   aAdd( aItm, { "LOPENREAD" , "L",  1 , 0, "Lógico abrir el puerto cada lectura"    } )
   aAdd( aItm, { "CENTUB"    , "C",  1 , 0, "Entubamiento"                           } )
   aAdd( aItm, { "NBUFER"    , "N",  3 , 0, "Bufer de lectura"                       } )

RETURN aItm





FUNCTION rxImpTik( cPath, oMeter )

   local dbfImpTik

   If( cPath == nil, cPath := cPatDat(), ) ;

   if !lExistTable( cPath + "IMPTIK.DBF" )
      mkImpTik( cPath )
   end

   if lExistIndex( cPath + "IMPTIK.CDX" )
      fErase( cPath + "IMPTIK.CDX" )
   end

   if lExistTable( cPath + "IMPTIK.DBF" )

      dbUseArea( .T., cDriver(), cPath + "IMPTIK.DBF", cCheckArea( "IMPTIK", @dbfImpTik ), .F. )

      if !( dbfImpTik )->( neterr() )

         ( dbfImpTik )->( __dbPack() )

         ( dbfImpTik )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
         ( dbfImpTik )->( ordCreate( cPath + "IMPTIK.CDX", "CCODIMP", "Field->cCodImp", {|| Field->cCodImp } ) )

         ( dbfImpTik )->( dbCloseArea() )

      else

         msgStop( "Imposible abrir en modo exclusivo impresoras de tickets" )

      end

   end

Return nil



Static Function lDefecto( aGet, oPort, oBitsSec, oBitsParada, oBitsDatos, oBitsParidad )



   oPort:oGet:cText(       "COM1" )
   oBitsSec:oGet:cText(    "9600" )
   oBitsParada:oGet:cText( "0" )
   oBitsDatos:oGet:cText(  "8" )
   oBitsParidad:oGet:cText("Sin paridad" )

Return .T.






Static Function TestBalanza( cBitsSec, cBitsDatos, cBitsPara, cBitsPari, cPuerto )

   local oPrn
   local n

   oPrn   := TCommPort():New( cPuerto, cBitsSec, cBitsPara, cBitsDatos, cBitsPari )

   if oPrn <> nil

      oPrn:OpenPort()







      msgInfo( "Puerto  : " + cPuerto                        + Chr(13)+Chr(10) + "Bit     : " + cBitsSec                       + Chr(13)+Chr(10) + "Parada  : " + cBitsPara                      + Chr(13)+Chr(10) + "Dato    : " + cBitsDatos                     + Chr(13)+Chr(10) + "Paridad : " + cBitsPari                      + Chr(13)+Chr(10) + "Peso    : " + Str( oPrn:getPeso() ), "Puerto creado" )

      oPrn:ClosePort()
      oPrn:End()

   end

Return .T.






FUNCTION BrwBalanza( oGet, oGet2 )

    local oDlg
    local oBrw
    local oGet1
    local cGet1
    local oCbxOrd
   local aCbxOrd        := { "Código" }
   local cCbxOrd        := "Código"
   local nLevel         := Auth():Level( "01090" )

   if !OpenFiles()
      Return .F.
   end

   oDlg = TDialog():New(,,,, "Seleccionar balanzas", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )






   oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,, {||    ( OrdClearScope( oBrw, dbfImpTik ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, dbfImpTik ) ) }, .F., .F.,,,,,, nil, "FIND",, )






   oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,, {|Self|( ( dbfImpTik )->( OrdSetFocus( oCbxOrd:nAt ) ), oBrw:Refresh(), oGet1:SetFocus() )},,,, .F.,,,,,,, "oCbxOrd",,,,,,, )

   oBrw                 := IXBrowse():New( oDlg )

   oBrw:nMarqueeStyle   := 5
   oBrw:lHScroll        := .F.
   oBrw:cAlias          := dbfImpTik

   oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
   oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }
   oBrw:bLDblClick      := {|| oDlg:end( 1 ) }

   oBrw:CreateFromResource( 105 )

   with object ( oBrw:AddCol() )
      :cHeader          := "Código"
      :cSortOrder       := "cCodImp"
      :bEditValue       := {|| ( dbfImpTik )->cCodImp }
      :nWidth           := 80
      :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
   end

   with object ( oBrw:AddCol() )
      :cHeader          := "Descripción"
      :cSortOrder       := "cNomImp"
      :bEditValue       := {|| ( dbfImpTik )->cNomImp }
      :nWidth           := 280
      :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
   end





   TButton():ReDefine( 500, {||( WinAppRec( oBrw, bEdit, dbfImpTik ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 2 ) <> 0 )},,, .F. )





   TButton():ReDefine( 501, {||( WinEdtRec( oBrw, bEdit, dbfImpTik ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 4 ) <> 0 )},,, .F. )




   TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

   oDlg:AddFastKey( 113,       {|| if( nAnd( nLevel, 2 ) <> 0, WinAppRec( oBrw, bEdit, dbfImpTik ), ) } )
   oDlg:AddFastKey( 114,       {|| if( nAnd( nLevel, 4 ) <> 0, WinEdtRec( oBrw, bEdit, dbfImpTik ), ) } )
   oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )
   oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if oDlg:nResult == 1

      oGet:cText( ( dbfImpTik )->cCodImp )
      oGet:lValid()

      if ValType( oGet2 ) == "O"
         oGet2:cText( ( dbfImpTik )->cNomImp )
      end

   end

   DestroyFastFilter( dbfImpTik )

   CloseFiles()

   oGet:SetFocus()

RETURN ( .T. )




FUNCTION cBalanza( oGet, dbfImpTik, oGet2 )

   local lValid   := .F.
   local xValor   := oGet:VarGet()

   if Empty( oGet2 ) .AND. !Empty( oGet:oHelpText )
      oGet2       := oGet:oHelpText
   end

   if Empty( xValor )
      if( oGet2 <> nil, oGet2:cText( "" ), )
      return .T.
   else
      xValor   := RJustObj( oGet, "0" )
   end

   do case
      case Valtype( dbfImpTik ) == "C"

         if ( dbfImpTik )->( dbSeek( xValor ) )
            oGet:cText( ( dbfImpTik )->cCodImp )
            if( oGet2 <> nil, oGet2:cText( ( dbfImpTik )->cNomImp ), )
            lValid   := .T.
         else
            oGet:Refresh()
            msgStop( "Balanza no encontrada" )
         end

      case Valtype( dbfImpTik ) == "O"

         if dbfImpTik:Seek( xValor )
            oGet:cText( dbfImpTik:cCodImp )
            if( oGet2 <> nil, oGet2:cText( dbfImpTik:cNomImp ), )
            lValid   := .T.
         else
            oGet:Refresh()
            msgStop( "Balanza no encontrada" )
         end

   end

RETURN lValid







_HB_CLASS TCommPort ; function TCommPort ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TCommPort", iif( .F., { }, { @HBObject() } ), @TCommPort() ) ) ;

   _HB_MEMBER { nPort } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nPort"}, .F. )
   _HB_MEMBER { cPort } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cPort"}, .F. )
   _HB_MEMBER { AS LOGIC lCreated } ; oClass:AddMultiData( "LOGIC", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lCreated"}, .F. )
   _HB_MEMBER { AS LOGIC lOpen } ; oClass:AddMultiData( "LOGIC", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lOpen"}, .F. )
   _HB_MEMBER { AS NUMERIC nHComm } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nHComm"}, .F. )
   _HB_MEMBER { cLastError } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cLastError"}, .F. )
   _HB_MEMBER { nBitsSec } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBitsSec"}, .F. )
   _HB_MEMBER { nBitsParada } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBitsParada"}, .F. )
   _HB_MEMBER { nBitsDatos } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBitsDatos"}, .F. )
   _HB_MEMBER { nBitsParidad } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBitsParidad"}, .F. )
   _HB_MEMBER { AS LOGIC lOpenToRead } ; oClass:AddMultiData( "LOGIC", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lOpenToRead"}, .F. )
   _HB_MEMBER { nTimeOut } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nTimeOut"}, .F. )

   _HB_MEMBER { nHandleConexion } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nHandleConexion"}, .F. )

   _HB_MEMBER New( cPort, nBitsSec, nBitsParada, nBitsDatos, nBitsParidad, lOpenToRead) AS CLASS TCommPort; oClass:AddMethod( "New", @TCommPort_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Create( cCodBalanaza); oClass:AddMethod( "Create", @TCommPort_Create(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER OpenPort(); oClass:AddMethod( "OpenPort", @TCommPort_OpenPort(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ClosePort(); oClass:AddMethod( "ClosePort", @TCommPort_ClosePort(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER OpenCommError(); oClass:AddMethod( "OpenCommError", @TCommPort_OpenCommError(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Write( cTexto); oClass:AddMethod( "Write", @TCommPort_Write(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Read(); oClass:AddMethod( "Read", @TCommPort_Read(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Flush(); oClass:AddMethod( "Flush", @TCommPort_Flush(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Close(); oClass:AddMethod( "Close", @TCommPort_Close(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER End(); oClass:AddInline( "End", {|Self | ( ( Self ) ), ( ::Flush(), ::Close() ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER SetBitsSec( nBitsSec); oClass:AddMethod( "SetBitsSec", @TCommPort_SetBitsSec(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetBitsParada( nBitsParada); oClass:AddMethod( "SetBitsParada", @TCommPort_SetBitsParada(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetBitsDatos( nBitsDatos); oClass:AddMethod( "SetBitsDatos", @TCommPort_SetBitsDatos(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetBitsParidad( cBitsParidad); oClass:AddMethod( "SetBitsParidad", @TCommPort_SetBitsParidad(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Inicializa(); oClass:AddMethod( "Inicializa", @TCommPort_Inicializa(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER nKilos(); oClass:AddMethod( "nKilos", @TCommPort_nKilos(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER nGramos(); oClass:AddMethod( "nGramos", @TCommPort_nGramos(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER cPeso(); oClass:AddMethod( "cPeso", @TCommPort_cPeso(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getPeso( nPrecio); oClass:AddMethod( "getPeso", @TCommPort_getPeso(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER checksumXor( cString); oClass:AddMethod( "checksumXor", @TCommPort_checksumXor(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getFormatPrecio( nPrecio); oClass:AddMethod( "getFormatPrecio", @TCommPort_getFormatPrecio(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getFormatPeso( cString); oClass:AddMethod( "getFormatPeso", @TCommPort_getFormatPeso(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ClearString( cString); oClass:AddMethod( "ClearString", @TCommPort_ClearString(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER OpenConexion(); oClass:AddMethod( "OpenConexion", @TCommPort_OpenConexion(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER CloseConexion(); oClass:AddInline( "CloseConexion", {|Self | ( ( Self ) ), ( CLOSECOMM( ::nHandleConexion ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER AddPort(); oClass:AddMethod( "AddPort", @TCommPort_AddPort(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ReadPort(); oClass:AddMethod( "ReadPort", @TCommPort_ReadPort(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TCommPort ;



static FUNCTION TCommPort_New( cPort, nBitsSec, nBitsParada, nBitsDatos, cBitsParidad, cEntubamiento, nBufer ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   If( cPort == nil, cPort := "COM1", ) ;
   If( nBitsSec == nil, nBitsSec := "9600", ) ;
   If( nBitsParada == nil, nBitsParada := "1", ) ;
   If( nBitsDatos == nil, nBitsDatos := "8", ) ;
   If( cBitsParidad == nil, cBitsParidad := "Sin paridad", ) ;

   ::nTimeOut              := 500

   ::lCreated              := .T.





   ::cPort                 := Rtrim( cPort )





   ::SetBitsSec( nBitsSec )





   ::SetBitsParada( nBitsParada )





   ::SetBitsDatos( nBitsDatos )





   ::SetBitsParidad( cBitsParidad )

RETURN Self



static FUNCTION TCommPort_Create( cCodBalanza ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local oBlock
   local oError

   local dbfImpTik

   oBlock                     := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "IMPTIK.DBF" ), ( cCheckArea( "IMPTIK", @dbfImpTik ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatDat() + "IMPTIK.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      if !Empty( cCodBalanza ) .AND. ( dbfImpTik )->( dbSeek( cCodBalanza ) )

         ::cPort              := Rtrim( ( dbfImpTik )->cPort )

         ::SetBitsSec(        ( dbfImpTik )->nBitsSec )
         ::SetBitsParada(     ( dbfImpTik )->nBitsPara )
         ::SetBitsDatos(      ( dbfImpTik )->nBitsDatos )
         ::SetBitsParidad(    ( dbfImpTik )->cBitsPari )

      else

         ::cPort              := "COM1"
         ::nBitsSec           := "9600"
         ::nBitsParada        := "1"
         ::nBitsDatos         := "8"
         ::nBitsParidad       := "Sin paridad"

      end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if !Empty( dbfImpTik )
      ( dbfImpTik )->( dbCloseArea() )
   end

   dbfImpTik                  := nil

RETURN ( Self )



static FUNCTION TCommPort_OpenPort( ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   ::lCreated    := .T.
   ::lOpen       := .T.
   ::nPort       := 1

   if ! Empty( ::cPort )
      hb_comSetDevice( ::nPort, ::cPort )
   end

   if ! hb_comOpen( ::nPort )

      ::lCreated    := .F.

   else

      if ! hb_comInit( ::nPort, ::nBitsSec, ::nBitsParidad, ::nBitsDatos, ::nBitsParada )

         ::lOpen    := .F.

      end

   end

Return ( ::lCreated .AND. ::lOpen )



static FUNCTION TCommPort_ClosePort( ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   hb_comClose( ::nPort )

Return Self



























































static FUNCTION TCommPort_OpenCommError( ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   if ( ::nHComm >= 0 )
      ::cLastError         := "No error"
    else
        do case
         case ::nHComm == -1
            ::cLastError   := "ID: Inválido o no soportado"
         case ::nHComm == -12
            ::cLastError   := "BAUDIOS: No soportado"
         case ::nHComm == -11
            ::cLastError   := "BYTE: Tamaño no válido"
         case ::nHComm == -5
            ::cLastError   := "Valores por defecto son erroneos"
         case ::nHComm == -10
            ::cLastError   := "HARDWARE: No presente"
         case ::nHComm == -4
            ::cLastError   := "MEMORIA: Insuficiente"
         case ::nHComm == -3
            ::cLastError   := "HARDWARE: Dispositivo no abierto"
         case ::nHComm == -2
            ::cLastError   := "HARDWARE: Dispositivo ya abierto"
            otherwise
            ::cLastError   := "Error no determinado"
        endcase
    endif

Return ( ::nHComm )



static FUNCTION TCommPort_checksumXor( cString ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local cResult

   cResult :=  nXor( asc( substr( cString , 1 ,1 ) ), asc( substr( cString , 2 ,1 ) ) )
   cResult :=  nXor( cResult, asc( substr( cString , 3 ,1 ) ) )
   cResult :=  nXor( cResult, asc( substr( cString , 4 ,1 ) ) )
   cResult :=  nXor( cResult, asc( substr( cString , 5 ,1 ) ) )
   cResult :=  nXor( cResult, asc( substr( cString , 6 ,1 ) ) )
   cResult :=  nXor( cResult, asc( substr( cString , 7 ,1 ) ) )
   cResult :=  chr( cResult )

Return ( cResult )



static FUNCTION TCommPort_getPeso( nPrecio ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   If( nPrecio == nil, nPrecio := 0, ) ;

   ::Write( nPrecio )

return ( ::Read() )



static FUNCTION TCommPort_Write( nPrecio ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local cString
   local nResult

   If( nPrecio == nil, nPrecio := 0, ) ;

   cString := "98"
   cString += ::getFormatPrecio( nPrecio )
   cString += ::checksumXor( cString )
   cString += Chr( 13 )
   cString += Chr( 10 )

   hb_comSend( ::nPort, cString )

return ( nil )



static FUNCTION TCommPort_Read( ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local cString  := Space( 50 )
   local nResult

   msgWait( "Lectura de la balanza", "", 0.3 )

   nResult  := hb_comRecv( ::nPort, @cString, hb_BLen( cString ), ::nTimeOut )

Return ::getFormatPeso( cString )



static FUNCTION TCommPort_getFormatPrecio( nPrecio ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local cResult

   cResult  := Trans( nPrecio, "999.99" )
   cResult  := StrTran( cResult, ".", "" )
   cResult  := val( cResult )
   cResult  := strZero( cResult, 5 )

Return cResult



static FUNCTION TCommPort_getFormatPeso( cString ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local cPeso
   local nPeso    := 0

   cPeso          := substr( cString, 4, 2 ) + "." + substr( cString, 6, 3 )
   nPeso          := val( cPeso )

Return nPeso



static FUNCTION TCommPort_ClearString( cString ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local nPos           := 0
   local cClearString   := ""





   if SubStr( cString, 1, 1 ) == ::cEntubamiento
      cClearString      := SubStr( cString, 2 )
   else
      cClearString      := cString
   end





   nPos                 :=  At( ::cEntubamiento, cClearString )

   if nPos <> 0
      cClearString      := SubStr( cString, 1, nPos )
   end

return cClearString



static FUNCTION TCommPort_Flush( ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   if FlushComm( ::nHComm, 0 ) <> 0
      MsgStop( "Error vaciando el puerto : " + Str( GetCommError( ::nHComm ) ) )
   endif

RETURN ( Self )



static FUNCTION TCommPort_Close( ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   if !Empty( ::nHComm ) .AND. !CloseComm( ::nHComm )
      MsgStop( "Error cerrando el puerto : " + Str( GetCommError( ::nHComm ) ) )
   endif

RETURN ( Self )



static FUNCTION TCommPort_SetBitsSec( nBitsSec ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   if ValType( nBitsSec ) <> "N"
      ::nBitsSec        := Val( nBitsSec )
   else
      ::nBitsSec        := nBitsSec
   end

RETURN ( ::nBitsSec )



static FUNCTION TCommPort_SetBitsParada( nBitsParada ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   if ValType( nBitsParada ) <> "N"
      ::nBitsParada     := Val( nBitsParada )
   else
      ::nBitsParada     := nBitsParada
   end

RETURN ( ::nBitsParada )



static FUNCTION TCommPort_SetBitsDatos( nBitsDatos ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   if ValType( nBitsDatos ) <> "N"
      ::nBitsDatos      := Val( nBitsDatos )
   else
      ::nBitsDatos      := nBitsDatos
   end

RETURN ( ::nBitsDatos )



static FUNCTION TCommPort_SetBitsParidad( cBitsParidad ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   do case
      case Rtrim( cBitsParidad ) == "Sin paridad"
         ::nBitsParidad := "n"
      case Rtrim( cBitsParidad ) == "Paridad par"
         ::nBitsParidad := "p"
      case Rtrim( cBitsParidad ) == "Paridad impar"
         ::nBitsParidad := "i"
   end

RETURN ( ::nBitsParidad )



static FUNCTION TCommPort_Inicializa( ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local nWrite

   nWrite            := ::Write( "98000001" + Chr( 13 ) + Chr( 10 ) + Chr( 13 ) + Chr( 10 )  )

   if nWrite <= 0
      MsgInfo( "Error realizando la petición a la báscula : " + Str( GetCommError( ::nHComm ) ) )
   end

RETURN ( Self )



static FUNCTION TCommPort_nKilos( ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local nKilos      := 0

   ::Read()

   if !Empty( ::cBuffer )
      nKilos         := Val( Substr( ::cBuffer, 4, 2 ) )
   end

RETURN ( nKilos )



static FUNCTION TCommPort_nGramos( ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local nGramos     := 0

   ::Read()

   if !Empty( ::cBuffer )
      nGramos        := Val( Substr( ::cBuffer, 6, 3 ) )
   end

RETURN ( nGramos )



static FUNCTION TCommPort_cPeso( ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local cPeso       := "0.000"

   ::Read()

   if !Empty( ::cBuffer )
      cPeso          := Substr( ::cBuffer, 4, 2 ) + "." + Substr( ::cBuffer, 6, 3 )
   end

RETURN ( cPeso )



static FUNCTION TCommPort_OpenConexion( ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local i
   local nCom
   local cConteudo

   ::AddPort()

   cConteudo := "98" + strZero( 1995, 6 )
   cConteudo += AllTrim( Str( nXor( cConteudo ) ) )
   cConteudo += chr(13)
   cConteudo += chr(10)

   for i = 1 to len( cConteudo )
      WRITECOMM( ::nHandleConexion, Substr( cConteudo, i, 1 ) )
   next

Return self



static FUNCTION TCommPort_AddPort( ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local cDcb

    BEGIN SEQUENCE

      ::nHandleConexion = OPENCOMM( ::cPort, 16384, 16384 )

      IF ::nHandleConexion < 0
        MsgStop( "Error al crear el puerto." )
        BREAK
      ENDIF

      BUILDCOMMDCB( AllTrim( ::cPort ) + ":" + AllTrim( Str( ::nBitsSec ) ) + "," + ::nBitsParidad + "," + AllTrim( Str( ::nBitsDatos ) ) + "," + AllTrim( Str( ::nBitsParada ) ), @cDcb )

      IF !SETCOMMSTATE( ::nHandleConexion, cDcb )
        MsgStop( "Error al crear el puerto." )
        BREAK
      ENDIF

      ENABLECOMMNOTIFICATION( ::nHandleConexion, 0, 1, -1 )

    RECOVER

      ::nHandleConexion = -1

    end

RETURN self



static FUNCTION TCommPort_ReadPort( ) ; local Self AS CLASS TCommPort := QSelf() AS CLASS TCommPort

   local cBuf := SPACE(100)

   READCOMM( ::nHandleConexion, @cBuf )

RETURN LEFT( cBuf, READCOMM( ::nHandleConexion, @cBuf ) )







































































































































































































Static Function OpenConexion( cBitsSec, cBitsDatos, cBitsPara, cBitsPari, cPuerto )

   local i
   local nCom
   local cConteudo

   nCom := OpenPort( cBitsSec, cBitsDatos, cBitsPara, cBitsPari, cPuerto )

   cConteudo := "98" + strZero( 1995, 6 )
   cConteudo += AllTrim( Str( nXor( cConteudo ) ) )
   cConteudo += chr(13)
   cConteudo += chr(10)

   for i = 1 to len( cConteudo )
      SENDSTR( nCom, Substr( cConteudo, i, 1 ) )
   next

Return nCom



Static Function CloseConexion( nCom )

   CLOSECOMM( nCom )

return nil



STATIC FUNCTION OpenPort( cBitsSec, cBitsDatos, cBitsPara, cBitsPari, cPuerto )

 LOCAL nCom, cDcb

    BEGIN SEQUENCE

      nCom = OPENCOMM( cPuerto, 16384, 16384 )

      IF nCom < 0
        MsgStop( "Error al crear el puerto." )
        BREAK
      ENDIF

      BUILDCOMMDCB( AllTrim( cPuerto ) + ":" + AllTrim( cBitsSec ) + "," + if( AllTrim( cBitsPari ) == "Sin paridad", "N", "S" ) + "," + AllTrim( cBitsDatos ) + "," + AllTrim( cBitsPara ), @cDcb )

      IF !SETCOMMSTATE( nCom, cDcb )
        MsgStop( "Error al crear el puerto." )
        BREAK
      ENDIF

      Connect( nCom )

    RECOVER
      nCom = -1
    end

 RETURN nCom



STATIC FUNCTION SENDSTR( nCom, cString )

   local nBytes := WRITECOMM( nCom, cString )

RETURN nBytes = LEN( cString )



FUNCTION RECEIVESTR( nCom )

   local cBuf := SPACE( 7 )

 RETURN LEFT( cBuf, READCOMM( nCom, @cBuf ) )



 STATIC FUNCTION CONNECT( nCom )

   local cStr

   ENABLECOMMNOTIFICATION( nCom, 0, 1, -1 )

   cStr = RECEIVESTR( nCom )
   cStr = STRTRAN( cStr, CHR( 13 ), "" )
   cStr = STRTRAN( cStr, CHR( 10 ), Chr(13)+Chr(10) )

 RETURN NIL
