#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 6 ".\.\Prg\Edm.prg"
static dbfRuta
static oTipArt



_HB_CLASS TEdm ; function TEdm ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TEdm", iif( .F., { }, { @HBObject() } ), @TEdm() ) ) ;

   _HB_MEMBER { oDlg } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oDlg"}, .F. )
   _HB_MEMBER { oFld } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oFld"}, .F. )
   _HB_MEMBER { oBrwRuta } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oBrwRuta"}, .F. )
   _HB_MEMBER { oBrwTipo } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oBrwTipo"}, .F. )
   _HB_MEMBER { oMetUno } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oMetUno"}, .F. )
   _HB_MEMBER { nMetUno } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nMetUno"}, .F. )
   _HB_MEMBER { oMetDos } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oMetDos"}, .F. )
   _HB_MEMBER { nMetDos } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nMetDos"}, .F. )
   _HB_MEMBER { oPath } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oPath"}, .F. )
   _HB_MEMBER { cPath } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cPath"}, .F. )
   _HB_MEMBER { oPathOrg } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oPathOrg"}, .F. )
   _HB_MEMBER { cPathOrg } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cPathOrg"}, .F. )
   _HB_MEMBER { lDelFiles } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lDelFiles"}, .F. )
   _HB_MEMBER { oSerie } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oSerie"}, .F. )
   _HB_MEMBER { cSerie } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cSerie"}, .F. )
   _HB_MEMBER { oCodPgo } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oCodPgo"}, .F. )
   _HB_MEMBER { cCodPgo } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cCodPgo"}, .F. )

   _HB_MEMBER OpenFiles(); oClass:AddMethod( "OpenFiles", @TEdm_OpenFiles(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER CloseFiles(); oClass:AddMethod( "CloseFiles", @TEdm_CloseFiles(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Activate( oWnd); oClass:AddMethod( "Activate", @TEdm_Activate(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SelRuta( lSel); oClass:AddMethod( "SelRuta", @TEdm_SelRuta(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SelAllRuta( lSel); oClass:AddMethod( "SelAllRuta", @TEdm_SelAllRuta(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER MkSndEdm(); oClass:AddMethod( "MkSndEdm", @TEdm_MkSndEdm(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER MkRecEdm(); oClass:AddMethod( "MkRecEdm", @TEdm_MkRecEdm(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TEdm ;



static FUNCTION TEdm_OpenFiles( cPatEmp ) ; local Self AS CLASS TEdm := QSelf() AS CLASS TEdm

   local lOpen       := .T.
   local oBlock      := ErrorBlock( {| oError | ApoloBreak( oError ) } )

   If( cPatEmp == nil, cPatEmp := cPatEmp(), ) ;

   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RUTA.DBF" ), ( cCheckArea( "RUTA", @dbfRuta ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "RUTA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   oTipArt           := TTipArt():New( cPatEmp() )
   oTipArt:OpenFiles()

   RECOVER

      msgStop( "Imposible abrir todas las bases de datos" )
      ::CloseFiles()
      lOpen       := .F.

   end

   ErrorBlock( oBlock )

RETURN lOpen



static FUNCTION TEdm_CloseFiles( ) ; local Self AS CLASS TEdm := QSelf() AS CLASS TEdm

   ( dbfRuta )->( dbCloseArea() )

   if !Empty( oTipArt )
      oTipArt:end()
   end

RETURN self



static FUNCTION TEdm_Activate( oMenuItem, oWnd ) ; local Self AS CLASS TEdm := QSelf() AS CLASS TEdm

   local oSayPgo
   local cSayPgo
   local oStru

   local nLevel      := Auth():Level( oMenuItem )
   if nAnd( nLevel, 1 ) == 0
      msgStop( "Acceso no permitido." )
      return ( nil )
   end

   if !::OpenFiles()
      Return nil
   end

   oTipArt:SelectAll( .F. )

   ::SelAllRuta( .F. )

   ::nMetUno     := 0
   ::nMetDos     := 0
   ::cPath       := FullCurDir() + "PSION\"
   ::cPathOrg    := FullCurDir() + "PSION\"
   ::lDelFiles   := .T.
   ::cCodPgo     := cDefFpg()





   ::oDlg = TDialog():New(,,,,, "SND_EDM",, .F.,,,,, oWnd(), .F.,,,,,, .F.,, "::oDlg", nil, )







   ::oFld := TFolder():ReDefine( 500, {"&Exportar", "&Importar"}, { "SND_EDM1","SND_EDM2" }, ::oDlg,,,,, .F., )

   ::oBrwTipo                 := IXBrowse():New( ::oFld:aDialogs[ 1 ] )

   oTipArt:oDbf:SetBrowse( ::oBrwTipo, .F. )

   ::oBrwTipo:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
   ::oBrwTipo:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

   ::oBrwTipo:nMarqueeStyle   := 5

   ::oBrwTipo:CreateFromResource( 90 )

   with object ( ::oBrwTipo:addCol() )
      :cHeader       := "Se. Seleccionada"
      :bStrData      := {|| "" }
      :bEditValue    := {|| oTipArt:oDbf:lSelect }
      :nWidth        := 20
      :SetCheck( { "Sel16", "Nil16" } )
   end

   with object ( ::oBrwTipo:addCol() )
      :cHeader       := "Código"
      :bEditValue    := {|| oTipArt:oDbf:cCodTip }
      :nWidth        := 50
   end

   with object ( ::oBrwTipo:addCol() )
      :cHeader       := "Descripción"
      :bEditValue    := {|| oTipArt:oDbf:cNomTip }
      :nWidth        := 200
   end

   ::oBrwTipo:bLDblClick := {|| oTipArt:InvSelect( ::oBrwTipo ) }




   TButton():ReDefine( 561, {||( oTipArt:InvSelect( ::oBrwTipo ) )}, ::oFld:aDialogs[ 1 ],,, .F.,,,, .F. )




   TButton():ReDefine( 562, {||( oTipArt:SelectAll( .T., ::oBrwTipo ) )}, ::oFld:aDialogs[ 1 ],,, .F.,,,, .F. )




   TButton():ReDefine( 563, {||( oTipArt:SelectAll( .F., ::oBrwTipo ) )}, ::oFld:aDialogs[ 1 ],,, .F.,,,, .F. )





   ::oBrwRuta                 := IXBrowse():New( ::oFld:aDialogs[ 1 ] )

   ::oBrwRuta:cAlias          := dbfRuta

   ::oBrwRuta:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
   ::oBrwRuta:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

   ::oBrwRuta:nMarqueeStyle   := 5

   ::oBrwRuta:CreateFromResource( 100 )

   with object ( ::oBrwRuta:addCol() )
      :cHeader       := "Se. Seleccionada"
      :bStrData      := {|| "" }
      :bEditValue    := {|| ( dbfRuta )->lSelRut }
      :nWidth        := 20
      :SetCheck( { "Sel16", "Nil16" } )
   end

   with object ( ::oBrwRuta:addCol() )
      :cHeader       := "Código"
      :bEditValue    := {|| ( dbfRuta )->cCodRut }
      :nWidth        := 50
   end

   with object ( ::oBrwRuta:addCol() )
      :cHeader       := "Descripción"
      :bEditValue    := {|| ( dbfRuta )->cDesRut }
      :nWidth        := 200
   end

   ::oBrwRuta:bLDblClick := {|| ::SelRuta() }





   ::oPath := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, ::cPath, ::cPath:= u ) }, ::oFld:aDialogs[ 1 ],,,,,,,,, .F.,,, .F., .F.,,,,,, nil, "FOLDER",, )

   ::oPath:bHelp  := {|| ::oPath:cText( cGetDir32( "Seleccione destino" ) ) }




   TButton():ReDefine( 514, {||( ::SelRuta() )}, ::oFld:aDialogs[ 1 ],,, .F.,,,, .F. )




   TButton():ReDefine( 516, {||( ::SelAllRuta( .T. ) )}, ::oFld:aDialogs[ 1 ],,, .F.,,,, .F. )




   TButton():ReDefine( 517, {||( ::SelAllRuta( .F. ) )}, ::oFld:aDialogs[ 1 ],,, .F.,,,, .F. )






   ::oMetUno := TApoloMeter():ReDefine( 120, { | u | If( PCount()==0, ::nMetUno, ::nMetUno:= u ) }, 100, ::oFld:aDialogs[ 1 ], .F.,, "Progreso", .F.,,,, )










   ::oPathOrg := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, ::cPathOrg, ::cPathOrg:= u ) }, ::oFld:aDialogs[ 2 ],,,, "N/W*",,,,, .F.,,, .F., .F.,,,,, {|Self|( ::oPathOrg:cText( cGetDir( "Seleccione destino" ) ) )}, nil, "FOLDER",, )



   TCheckBox():ReDefine( 120, { | u | If( PCount()==0, ::lDelFiles, ::lDelFiles:= u ) }, ::oFld:aDialogs[ 2 ],,,,,,, .F.,, .F. )





   ::oCodPgo := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, ::cCodPgo, ::cCodPgo:= u ) }, ::oFld:aDialogs[ 2 ],, "@!",,,,,,, .F.,,, .F., .F.,,,,,, nil, "LUPA",, )

      ::oCodPgo:bValid  := {|| cFPago( ::oCodPgo, , oSayPgo ) }
      ::oCodPgo:bHelp   := {|| BrwFPago( ::oCodPgo, oSayPgo ) }




   oSayPgo := TGetHlp():ReDefine( 141, { | u | If( PCount()==0, cSayPgo, cSayPgo:= u ) }, ::oFld:aDialogs[ 2 ],,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,, nil,,, )






   ::oMetDos := TApoloMeter():ReDefine( 140, { | u | If( PCount()==0, ::nMetDos, ::nMetDos:= u ) }, 100, ::oFld:aDialogs[ 2 ], .F.,, "Progreso", .F.,,,, )








   TButton():ReDefine( 1, {||( if( ::oFld:nOption == 1, ::MkSndEdm(), ::MkRecEdm() ) )}, ::oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 2, {||( ::oDlg:end() )}, ::oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 9, {||( ChmHelp( "ExportarDatos" ) )}, ::oDlg,,, .F.,,,, .F. )

   ::oDlg:AddFastKey( 116, {|| if( ::oFld:nOption == 1, ::MkSndEdm(), ::MkRecEdm() ) } )
   ::oDlg:AddFastKey( 112, {|| ChmHelp( "ExportarDatos" ) } )

   ::oDlg:Activate( ::oDlg:bLClicked, ::oDlg:bMoved, ::oDlg:bPainted, .T.,,,, ::oDlg:bRClicked,,, )

   ::CloseFiles()

RETURN NIL



static FUNCTION TEdm_SelRuta( lSel ) ; local Self AS CLASS TEdm := QSelf() AS CLASS TEdm

   If( lSel == nil, lSel := !( dbfRuta )->lSelRut, ) ;

   if dbDialogLock( dbfRuta )
      ( dbfRuta )->lSelRut := lSel
      ( dbfRuta )->( dbUnlock() )
   end

   ::oBrwRuta:Refresh()

return nil



static FUNCTION TEdm_SelAllRuta( lSel ) ; local Self AS CLASS TEdm := QSelf() AS CLASS TEdm

   local nRec  := ( dbfRuta )->( Recno() )

   ( dbfRuta )->( dbGoTop() )
   while !( dbfRuta )->( eof() )

      if dbDialogLock( dbfRuta )
         ( dbfRuta )->lSelRut := lSel
         ( dbfRuta )->( dbUnlock() )
      end

      ( dbfRuta )->( dbSkip() )
   end

   ( dbfRuta )->( dbGoTo( nRec ) )

   if !Empty( ::oBrwRuta )
      ::oBrwRuta:Refresh()
   end

return nil






static FUNCTION TEdm_MkSndEdm( ) ; local Self AS CLASS TEdm := QSelf() AS CLASS TEdm





   local lRut  := .F.
   local nRec  := ( dbfRuta )->( Recno() )





   ::oFld:aDialogs[ 1 ]:Disable()





   aEval( directory( "PSION\*.*" ), {|aFiles| fErase( "PSION\" + aFiles[1] ) } )

   ( dbfRuta )->( dbGoTop() )
   while !( dbfRuta )->( eof() )

      if ( dbfRuta )->lSelRut



         EdmArt( ( dbfRuta )->cCodRut, ::cPath, Self, oTipArt )



         EdmCli( ( dbfRuta )->cCodRut, ::cPath, Self, oTipArt )



         EdmRutCli( ( dbfRuta )->cCodRut, ::cPath, Self, oTipArt )



         EdmOfe( ( dbfRuta )->cCodRut, ::cPath, Self )

         ::oMetUno:Set( 0 )

         lRut  := .T.

      end

      ( dbfRuta )->( dbSkip() )

   end

   ( dbfRuta )->( dbGoTo( nRec ) )

   if lRut

      MsgInfo( "Proceso de exportación finalizado con exito." )

   else

      msgStop( "Debe seleccionar al menos una ruta." )

   end



















   ::oFld:aDialogs[ 1 ]:Enable()

return nil






static FUNCTION TEdm_MkRecEdm( ) ; local Self AS CLASS TEdm := QSelf() AS CLASS TEdm

   local aSucces  := {}

   if Empty( ::cCodPgo )
      msgStop( "Es necesario introducir una forma de pago" )
      return .F.
   end

   if ( dbfRuta )->( LastRec() ) == 0
      msgStop( "No hay rutas para importar" )
      return .F.
   end





   ::oFld:aDialogs[ 2 ]:Disable()

   ( dbfRuta )->( dbGoTop() )
   while !( dbfRuta )->( eof() )





      EdmPedCli( ( dbfRuta )->cCodRut, ::cPathOrg, Self, aSucces )

      ::oMetDos:Set( 0 )





      EdmAlbCli( ( dbfRuta )->cCodRut, ::cPathOrg, Self, aSucces )
      SynAlbCli()

      ::oMetDos:Set( 0 )





      EdmFacCli( ( dbfRuta )->cCodRut, ::cPathOrg, Self, aSucces )
      SynFacCli()

      ::oMetDos:Set( 0 )

      ( dbfRuta )->( dbSkip() )

   end





   if !Empty( aSucces )
      Visor( aSucces )
   end

   if ::lDelFiles
      aEval( Directory( ::cPath + "*.PSI" ), {|aFiles| fErase( ::cPath + aFiles[1] ) } )
   end

   ::oFld:aDialogs[ 2 ]:Enable()

return nil



function EdmSubStr( cChar, nStart, nEnd, lSep )

   If( lSep == nil, lSep := .T., ) ;
   If( nStart == nil, nStart := 1, ) ;
   If( nEnd == nil, nEnd := len( cChar ), ) ;

   cChar          := cValToChar( cChar )
   cChar          := Upper( AllTrim( SubStr( StrTran( cChar, ",", "" ), nStart, nEnd ) ) ) + if( lSep, ",", "" )





   cChar          := StrTran( cChar, "Á", "A" )
   cChar          := StrTran( cChar, "É", "E" )
   cChar          := StrTran( cChar, "Í", "I" )
   cChar          := StrTran( cChar, "Ó", "O" )
   cChar          := StrTran( cChar, "Ú", "U" )

RETURN ( cChar )



function EdmLogicSN( lLogic, lSep )

   If( lSep == nil, lSep := .T., ) ;

return ( If( lLogic, "S", "N" ) + if( lSep, ",", "" ) )



function EdmLocig12( lLogic, lSep )

   If( lSep == nil, lSep := .T., ) ;

return ( If( lLogic, "1", "2" ) + if( lSep, ",", "" ) )



function EdmRjust( cChar, cSep, nLen, lSep )

   If( cSep == nil, cSep := " ", ) ;
   If( nLen == nil, nLen := Len( cChar ), ) ;
   If( lSep == nil, lSep := .T., ) ;

return ( Rjust( cChar, cSep, nLen ) + if( lSep, ",", "" ) )







FUNCTION EdmCli( cCodRut, cPathTo, oStru )

   local n           := 0
   local cChr
   local fTar
   local cFilEdm
   local cFilOdb
   local nWrote
   local nRead
   local oError
   local oBlock
   local dbfClient

   If( cCodRut == nil, cCodRut := "001", ) ;
   If( cPathTo == nil, cPathTo := "C:\INTERS~1\", ) ;

   cCodRut           := SubStr( cCodRut, -3 )

   cFilEdm           := cPathTo + "ECLIE" + cCodRut + ".TXT"
   cFilOdb           := cPathTo + "ECLIE" + cCodRut + ".ODB"





   IF file( cFilEdm )
      fErase( cFilEdm )
   end

   fTar              := fCreate( cFilEdm )





   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "CLIENT.DBF" ), ( cCheckArea( "CLIENT", @dbfClient ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "CLIENT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   oStru:oMetUno:cText   := "Clientes"
   oStru:oMetUno:SetTotal( ( dbfClient )->( LastRec() ) )

   WHILE !(dbfClient)->( eof() )

      cChr  := "+"
      cChr  += Rjust( (dbfClient)->COD, "0", 7 ) + ","

      if !empty( (dbfClient)->NBREST )
      cChr  += EdmSubStr( (dbfClient)->NBREST, 1, 35 )
      else
      cChr  += EdmSubStr( (dbfClient)->TITULO, 1, 35 )
      end

      cChr  += EdmSubStr( (dbfClient)->TITULO, 1, 35 )
      cChr  += EdmSubStr( (dbfClient)->DOMICILIO, 1, 35 )
      cChr  += EdmSubStr( (dbfClient)->POBLACION, 1, 25 )
      cChr  += EdmSubStr( (dbfClient)->NIF, 1, 14 )
      cChr  += EdmLogicSN( (dbfClient)->LREQ )
      cChr  += EdmLocig12( (dbfClient)->LMAYORISTA )
      cChr  += EdmSubStr( "S" )
      cChr  += EdmSubStr( Trans( (dbfClient)->NDTOESP, "@ 99.99" ), 1, 5 )
      cChr  += EdmSubStr( "0" )
      cChr  += EdmSubStr( Trans( (dbfClient)->RIESGO, "@ 9999.99" ), 1, 7 )
      cChr  += EdmSubStr( Trans( (dbfClient)->NDPP, "@ 99.99" ), 1, 5 )
      cChr  += EdmSubStr( "S", 1, 1, .F. )

      cChr  += Chr(13)+Chr(10)

      nWrote:= fwrite( fTar, cChr, nRead )

      oStru:oMetUno:Set( ++n )







      (dbfClient)->( dbSkip() )

   end

   RECOVER USING oError

      msgStop( ErrorMessage( oError ), "Imposible abrir todas las bases de datos" )

   end
   ErrorBlock( oBlock )

   ( dbfClient )->( dbCloseArea() )
   fClose( fTar )





   if file( FullCurDir() + "CONVER.EXE" )
      WinExec( FullCurDir() + "CONVER.EXE " + cFilEdm + " " + cFilOdb + " 44 -x", 6 )
   end

RETURN NIL







FUNCTION EdmRutCli( cCodRut, cPathTo, oStru )

   local n           := 0
   local cChr
   local fTar
   local nWrote
   local nRead
   local cFilEdm
   local cFilOdb
   local cRutCli
   local dbfClient

   If( cCodRut == nil, cCodRut := "001", ) ;
   If( cPathTo == nil, cPathTo := "C:\INTERS~1\", ) ;

   cRutCli           := cCodRut

   cCodRut           := SubStr( cCodRut, -3 )

   cFilEdm           := cPathTo + "ERUTA" + cCodRut + ".TXT"
   cFilOdb           := cPathTo + "ERUTA" + cCodRut + ".ODB"





   if file( cFilEdm )
      fErase( cFilEdm )
   end

   fTar              := fCreate( cFilEdm )





   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "CLIENT.DBF" ), ( cCheckArea( "CLIENT", @dbfClient ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "CLIENT.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   oStru:oMetUno:cText   := "Rutas"
   oStru:oMetUno:SetTotal( ( dbfClient )->( LastRec() ) )

   WHILE !(dbfClient)->( eof() )

      if ( dbfClient )->cCodRut == cRutCli

         cChr  := Right( cCodRut, 1 )
         cChr  += Rjust( (dbfClient)->COD, "0", 7 )
         cChr  += Chr(13)+Chr(10)

         nWrote:= fwrite( fTar, cChr, nRead )

      end

      oStru:oMetUno:Set( ++n )







      ( dbfClient )->( dbSkip() )

   end

   ( dbfClient )->( dbCloseArea() )
   fClose( fTar )

   if file( FullCurDir() + "CONVER.EXE" )
      WinExec( FullCurDir() + "CONVER.EXE " + cFilEdm + " " + cFilOdb + " 44 -x", 6 )
   end

RETURN NIL
