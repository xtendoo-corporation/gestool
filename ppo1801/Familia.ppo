#line 91 "\fwh1801\include\FiveWin.ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 70 ".\.\Prg\Familia.prg"
static oWndBrw

static nview
static lOpenFiles    :=.F.

static dbfPrv
static dbfArticulo

static tmpProveedor
static tmpLenguaje

static oGrpFam
static oFraPub
static oComentarios

static oDetCamposExtra

static cFileProveedor
static cFileLenguaje

static oComercio

static oLenguajes

static bEdit         := { |aTmp, aGet, dbfFam, oBrw, bWhen, bValid, nMode | EdtRec( aTmp, aGet, dbfFam, oBrw, bWhen, bValid, nMode ) }
static bEdit2        := { |aTmp, aGet, tmpProveedor, oBrw, bWhen, bValid, nMode | EdtDet( aTmp, aGet, tmpProveedor, oBrw, bWhen, bValid, nMode ) }
static bEditLenguaje := { |aTmp, aGet, dbf, oBrw, bWhen, bValid, nMode, aTmpArt | EditLenguaje( aTmp, aGet, dbf, oBrw, bWhen, bValid, nMode, aTmpArt ) }

static dbfFamPrv

static oTreePadre

static oBtnAceptarActualizarWeb








FUNCTION BrwFamilia( oGet, oGet2, lAdd )

    local oDlg
    local oBrw
   local cCod     := Space( 16 )
    local oGet1
    local cGet1
   local nOrd     := GetBrwOpt( "BrwFamilia" )
    local oCbxOrd
   local aCbxOrd  := { "Código", "Nombre" }
   local cCbxOrd
   local nLevel   := Auth():Level( "01012" )
   local lOpen    := .F.

   If( lAdd == nil, lAdd := .T., ) ;

   nOrd           := Min( Max( nOrd, 1 ), len( aCbxOrd ) )
   cCbxOrd        := aCbxOrd[ nOrd ]

   if !OpenFiles( .T. )
      RETURN nil
   end

   nOrd           := ( D():Familias( nView ) )->( OrdSetFocus( nOrd ) )

   ( D():Familias( nView ) )->( dbgotop() )

   oDlg = TDialog():New(,,,, "Familias de artículos", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )






        oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,, {||    ( OrdClearScope( oBrw, D():Familias( nView ) ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, D():Familias( nView ) ) ) }, .F., .F.,,,,,, nil, "FIND",, )






        oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,, {|Self|( ( D():Familias( nView ) )->( OrdSetFocus( oCbxOrd:nAt ) ), oBrw:refresh(), oGet1:SetFocus() )},,,, .F.,,,,,,, "oCbxOrd",,,,,,, )

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:cAlias          := D():Familias( nView )
      oBrw:nMarqueeStyle   := 5
      oBrw:cName           := "Browse.Familias"

      with object ( oBrw:AddCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodFam"
         :bEditValue       := {|| ( D():Familias( nView ) )->cCodFam }
         :nWidth           := 120
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cNomFam"
         :bEditValue       := {|| ( D():Familias( nView ) )->cNomFam }
         :nWidth           := 260
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }
      oBrw:bRClicked       := {| nRow, nCol, nFlags | oBrw:RButtonDown( nRow, nCol, nFlags ) }

      oBrw:CreateFromResource( 105 )




        TButton():ReDefine( 1, {||( oDlg:end(1) )}, oDlg,,, .F.,,,, .F. )




        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )





        TButton():ReDefine( 500, {||( WinAppRec( oBrw, bEdit, D():Familias( nView ) ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 2 ) <> 0 .AND. !IsReport() .AND. lAdd )},,, .F. )





        TButton():ReDefine( 501, {||( WinEdtRec( oBrw, bEdit, D():Familias( nView ) ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 4 ) <> 0 .AND. !IsReport() .AND. lAdd )},,, .F. )

   if nAnd( nLevel, 2 ) <> 0 .AND. !IsReport()
      oDlg:AddFastKey( 113,    {|| WinAppRec( oBrw, bEdit, D():Familias( nView ) ) } )
   end

   if nAnd( nLevel, 4 ) <> 0 .AND. !IsReport()
      oDlg:AddFastKey( 114,    {|| WinEdtRec( oBrw, bEdit, D():Familias( nView ) ) } )
   end

   oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )
   oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   DestroyFastFilter( D():Familias( nView ) )

   SetBrwOpt( "BrwFamilia", ( D():Familias( nView ) )->( OrdNumber() ) )

   if oDlg:nResult == 1

      cCod                 := ( D():Familias( nView ) )->cCodFam

      if !empty( oGet )
         oGet:cText( cCod )
      end

      if !empty( oGet2 )
         oGet2:cText( ( D():Familias( nView ) )->cNomFam )
      end

   end

   CloseFiles()

   if !empty( oGet )
      oGet:SetFocus()
   end

RETURN ( cCod )



STATIC FUNCTION OpenFiles()

   local lOpen       := .T.
   local oError
   local oBlock

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      DisableAcceso()

      nView          := D():CreateView()

      lOpenFiles     := .T.

      D():Familias( nView )

      D():FamiliasLenguajes( nView )

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FamPrv.Dbf" ), ( cCheckArea( "FAMPRV", @dbfFamPrv ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "FamPrv.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "Provee.Dbf" ), ( cCheckArea( "PROVEE", @dbfPrv ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "Provee.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "Articulo.Dbf" ), ( cCheckArea( "ARTICULO", @dbfArticulo ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "Articulo.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end
      ( dbfArticulo )->( OrdSetFocus( "cFamCod" ) )

      oGrpFam           := TGrpFam():Create( cPatEmp() )
      oGrpFam:OpenFiles()

      oFraPub           := TFrasesPublicitarias():Create( cPatEmp() )
      oFraPub:OpenFiles()

      oComentarios      := TComentarios():Create( cPatEmp() )
      oComentarios:OpenFiles()

      oDetCamposExtra   := TDetCamposExtra():New()
      if !empty( oDetCamposExtra )
         oDetCamposExtra:OpenFiles()
         oDetCamposExtra:SetTipoDocumento( "Familias" )
         oDetCamposExtra:setbId( {|| D():FamiliasId( nView ) } )
      end

      oLenguajes        := TLenguaje():Create( cPatDat() )
      if !oLenguajes:OpenFiles()
         lOpenFiles     := .F.
      end

      oComercio         := TComercioConfig()

      if !Empty( oComercio )
         oComercio:getInstance():loadJSON()
      end

   RECOVER USING oError

      msgStop( ErrorMessage( oError ), "Imposible abrir todas las bases de datos de familias" )

      CloseFiles()

      lOpen          := .F.

   end

   ErrorBlock( oBlock )

RETURN ( lOpen )



STATIC FUNCTION CloseFiles()

   ( dbfFamPrv    )->( dbCloseArea() )
   ( dbfArticulo  )->( dbCloseArea() )
   ( dbfPrv       )->( dbCloseArea() )

   if !empty( oGrpFam )
      oGrpFam:End()
   end

   if !empty( oFraPub )
      oFraPub:End()
   end

   if !empty( oComentarios )
      oComentarios:End()
   end

   if !empty( oDetCamposExtra )
      oDetCamposExtra:CloseFiles()
   end

   if !empty( oLenguajes )
      oLenguajes:End()
   end

   if !Empty( oComercio )
      oComercio:DestroyInstance()
   end

   D():DeleteView( nView )

   oWndBrw        := nil

   dbfArticulo    := nil
   dbfPrv         := nil
   oComentarios   := nil
   oLenguajes     := nil

RETURN .T.



FUNCTION Familia( oMenuItem, oWnd )

   local oSnd
   local nLevel

   If( oMenuItem == nil, oMenuItem := "01012", ) ;
   If( oWnd == nil, oWnd := oWnd(), ) ;

   if oWndBrw == NIL





      nLevel            := Auth():Level( oMenuItem )

      if nAnd( nLevel, 1 ) == 0
         msgStop( "Acceso no permitido." )
         RETURN nil
      end





      if oWnd <> nil
         SysRefresh(); oWnd:CloseAll(); SysRefresh()
      end

      if !OpenFiles()
         RETURN nil
      end





      AddMnuNext( "Familias de artículos", ProcName() )















      oWndBrw := TShell():New( 0, 0, 22, 80, "Familias de artículos",, oWnd,,, .F.,,, ( D():Familias( nView ) ),,,,, {"Código", "Nombre", "Posición"}, {||( WinAppRec( oWndBrw:oBrw, bEdit, D():Familias( nView ) ) )}, {||( WinEdtRec( oWndBrw:oBrw, bEdit, D():Familias( nView ) ) )}, {||( WinDelRec( oWndBrw:oBrw, D():Familias( nView ), {|| DeleteFamiliaProveedores() } ) )}, {||( WinDupRec( oWndBrw:oBrw, bEdit, D():Familias( nView ) ) )}, nil, nLevel, "gc_cubes_16", ( 104 + ( 0 * 256 ) + ( 63 * 65536 ) ),,, .T. )



      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Envio"
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( D():Familias( nView ) )->lSelDoc }
         :nWidth           := 20
         :SetCheck( { "gc_mail2_12", "Nil16" } )
         :nHeadBmpNo       := 3
         :AddResource( "gc_mail2_16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Táctil"
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( D():Familias( nView ) )->lIncTpv }
         :nWidth           := 20
         :SetCheck( { "Sel16", "Nil16" } )
         :nHeadBmpNo       := 3
         :AddResource( "Tactil16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Código"
         :nHeadBmpNo       := 1
         :cSortOrder       := "CCODFAM"
         :bEditValue       := {|| ( D():Familias( nView ) )->cCodFam }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
         :AddResource( "Sel16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "CNOMFAM"
         :bEditValue       := {|| ( D():Familias( nView ) )->cNomFam }
         :nWidth           := 260
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Grupo"
         :bStrData         := {|| ( D():Familias( nView ) )->cCodGrp }
         :nWidth           := 60
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Prop. 1"
         :bStrData         := {|| ( D():Familias( nView ) )->cCodPrp1 }
         :nWidth           := 60
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Prop. 2"
         :bStrData         := {|| ( D():Familias( nView ) )->cCodPrp2 }
         :nWidth           := 60
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Posición"
         :cSortOrder       := "nPosTpv"
         :bEditValue       := {|| if( ( D():Familias( nView ) )->lIncTpv, Trans( ( D():Familias( nView ) )->nPosTpv, "99" ), "" ) }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Familia padre"
         :bStrData         := {|| ( D():Familias( nView ) )->cFamCmb }
         :nWidth           := 60
         :lHide            := .T.
      end

      oWndBrw:cHtmlHelp    := "Familias"

      oWndBrw:CreateXFromCode()





      oWndBrw:NewAt( "BUS",,, {||( oWndBrw:SearchSetFocus() )}, "(B)uscar", "B",,,,, .F. )

      oWndBrw:AddSeaBar()








      oWndBrw:NewAt( "NEW",,, {||( oWndBrw:RecAdd() )}, "(A)ñadir", "A",,, 2,, .F. )







        oWndBrw:NewAt( "DUP",,, {||( oWndBrw:RecDup() )}, "(D)uplicar", "D",,, 2,, .F. )






        oWndBrw:NewAt( "EDIT",,, {||( oWndBrw:RecEdit() )}, "(M)odificar", "M",,, 4,, .F. )






        oWndBrw:NewAt( "ZOOM",,, {||( WinZooRec( oWndBrw:oBrw, bEdit, D():Familias( nView ) ) )}, "(Z)oom", "Z",,, 8,, .F. )






        oWndBrw:NewAt( "DEL",,, {||( oWndBrw:RecDel() )}, "(E)liminar", "E",,, 16,, .F. )






      oWndBrw:NewAt( "IMP",,, {||( TListadoFamilias():New( "Listado de Familias" ):Play() )}, "(L)istado", "L",,, 4,, .F. )








      oSnd := oWndBrw:NewAt( "Lbl",, "Seleccionar registros para ser enviados", {||IncEnvio()}, "En(v)iar", "V",, {|This|This:Toggle()}, 4,, .F. )







         oWndBrw:NewAt( "Lbl",,, {||( lSelectAll( oWndBrw, D():Familias( nView ), "lSelDoc", .T., .T., .T. ) )}, "Todos",,,, 4, oSnd, .F. )







         oWndBrw:NewAt( "Lbl",,, {||( lSelectAll( oWndBrw, D():Familias( nView ), "lSelDoc", .F., .T., .T. ) )}, "Ninguno",,,, 4, oSnd, .F. )






      oWndBrw:NewAt( "TACTIL",,, {||( IncTactil() )}, "(T)áctil", "T",,, 4,, .F. )






      oWndBrw:NewAt( "Up",,, {||( ChangePosition( .F. ), oWndBrw:Select() )}, "S(u)bir posición", "U",,, 32,, .F. )






      oWndBrw:NewAt( "Down",,, {||( ChangePosition( .T. ), oWndBrw:Select() )}, "Ba(j)ar posición", "J",,, 32,, .F. )





      oWndBrw:NewAt( "End",,, {||( oWndBrw:End() )}, "(S)alir", "S",,,,, .F. )

      oWndBrw:Activate(, oWndBrw:bLClicked, oWndBrw:bRClicked, oWndBrw:bMoved, oWndBrw:bResized, oWndBrw:bPainted, oWndBrw:bKeyDown, oWndBrw:bInit,,,,,,,,, {|| ( CloseFiles() )},, oWndBrw:bLButtonUp, .F. )

    ELSE

        oWndBrw:SetFocus()

    end

RETURN NIL



STATIC FUNCTION EdtRec( aTmp, aGet, cFamilia, oBrw, bWhen, bValid, nMode )

    local oDlg
   local oFld
   local oBlock
   local oError
   local oBrwPrv
   local oBrwLenguaje
   local oSayGrp
   local cSayGrp
   local oSayTComandas
   local cSayTComandas
   local oSayPrpUno
   local cSayPrpUno     := ""
   local oSayPrpDos
   local cSayPrpDos     := ""
   local bmpImage
   local oBmpGeneral
   local oBmpPropiedades
   local oBmpProveedores
   local oBmpIdiomas

   oBlock               := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      BeginTrans( aTmp, nMode )

      if empty( aTmp[ 23 ] )
         aTmp[ 23 ]  := GetSysColor( 15 )
      end

      if nMode == 4
         aTmp[ 1 ]  := NextKey( aTmp[ 1 ], D():Familias( nView ) )
      end

      if nMode == 1
         aTmp[ 36 ]  := 1
      end

      oDlg = TDialog():New(,,,, LblTitle( nMode ) + "familias de artículos", "FAMILIA",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )











      oFld := TFolder():ReDefine( 100, {"&General", "&Propiedades", "&Proveedores", "Lenguajes"}, { "FAMILIA_01","FAMILIA_04","FAMILIA_02","FAMILIA_03" }, oDlg,,,,, .F., )





         oBmpGeneral := TBitmap():ReDefine( 900, "gc_cubes_48",, oFld:aDialogs[1],,, .F., .F.,,, .F.,,, .T. )





         oBmpPropiedades := TBitmap():ReDefine( 900, "gc_bookmarks_48",, oFld:aDialogs[2],,, .F., .F.,,, .F.,,, .T. )





         oBmpProveedores := TBitmap():ReDefine( 900, "gc_businessman_48",, oFld:aDialogs[3],,, .F., .F.,,, .F.,,, .T. )





         oBmpIdiomas := TBitmap():ReDefine( 900, "gc_user_message_48",, oFld:aDialogs[4],,, .F., .F.,,, .F.,,, .T. )













         aGet[ 1 ] := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ 1 ], aTmp[ 1 ]:= u ) }, oFld:aDialogs[1],, "@!", {||    ( notValid( aGet[ 1 ], D():Familias( nView ) ) )},,,,,, .F., {||     ( nMode == 1 .OR. nMode == 4 )},, .F., .F.,,,,, {|Self|( aGet[ 1 ]:cText( NextKey( aTmp[ 1 ], D():Familias( nView ) ) ) )}, nil, "BOT",, )




         aGet[ 2 ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ 2 ], aTmp[ 2 ]:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )







         aGet[ 5 ] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[ 5 ], aTmp[ 5 ]:= u ) }, oFld:aDialogs[1],,, {||    ( oSayGrp:cText( RetFld( aTmp[ 5 ], oGrpFam:GetAlias() ) ), .T. )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( oGrpFam:Buscar( aGet[ 5 ], "cCodGrp" ) )}, nil, "LUPA",, )





         oSayGrp := TGetHlp():ReDefine( 121, { | u | If( PCount()==0, cSayGrp, cSayGrp:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( .F. )},, .F., .T.,,,,,, nil,,, )








         aGet[ 3 ] := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, aTmp[ 3 ], aTmp[ 3 ]:= u ) }, oFld:aDialogs[1],, "@!", {||    cProp( aGet[ 3 ], oSayPrpUno )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|brwProp( aGet[ 3 ], oSayPrpUno )}, nil, "LUPA",, )




         oSayPrpUno := TGetHlp():ReDefine( 131, { | u | If( PCount()==0, cSayPrpUno, cSayPrpUno:= u ) }, oFld:aDialogs[1],,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )








         aGet[ 4 ] := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, aTmp[ 4 ], aTmp[ 4 ]:= u ) }, oFld:aDialogs[1],, "@!", {||    cProp( aGet[ 4 ], oSayPrpDos )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|brwProp( aGet[ 4 ], oSayPrpDos )}, nil, "LUPA",, )




         oSayPrpDos := TGetHlp():ReDefine( 141, { | u | If( PCount()==0, cSayPrpDos, cSayPrpDos:= u ) }, oFld:aDialogs[ 1 ],,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )





         oTreePadre                     := TTreeView():Redefine( 200, oFld:aDialogs[1] )
         oTreePadre:bItemSelectChanged  := {|| ChangeTreeState() }








         TCheckBox():ReDefine( 116, { | u | If( PCount()==0, aTmp[ 37 ], aTmp[ 37 ]:= u ) }, oFld:aDialogs[2],,,,,,, .F., {||     ( nMode <> 3 )}, .F. )






         aGet[ 23 ] := TGetHlp():ReDefine( 290, { | u | If( PCount()==0, aTmp[ 23 ], aTmp[ 23 ]:= u ) }, oFld:aDialogs[2],,,, aTmp[ 23 ], aTmp[ 23 ],,,, .F.,,, .F., .F.,,,,, {|Self|( ColorFam( aGet[ 23 ] ) )}, nil, "gc_photographic_filters_16",, )







         aGet[ 24 ] := TGetHlp():ReDefine( 300, { | u | If( PCount()==0, aTmp[ 24 ], aTmp[ 24 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( nMode <> 3 )}, {|nKey,nFlags,Self| ( ChgBmp( aGet[ 24 ], bmpImage ) ) }, .F., .F.,,,,, {|Self|( GetBmp( aGet[ 24 ], bmpImage ) )}, nil, "FOLDER",, )












         aGet[ 38 ] := TGetHlp():ReDefine( 430, { | u | If( PCount()==0, aTmp[ 38 ], aTmp[ 38 ]:= u ) }, oFld:aDialogs[2],,, {||    ( oComentarios:Existe( aGet[ 38 ], aGet[ 38 ]:oHelpText, "cDescri" ) )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,, {|Self|( oComentarios:Buscar( aGet[ 38 ] ) )}, nil, "LUPA",, 431 )






         aGet[ 20 ] := TGetHlp():ReDefine( 320, { | u | If( PCount()==0, aTmp[ 20 ], aTmp[ 20 ]:= u ) }, oFld:aDialogs[2],, "@E 99.99",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )









         aGet[ 36 ] := TGetHlp():ReDefine( 180, { | u | If( PCount()==0, aTmp[ 36 ], aTmp[ 36 ]:= u ) }, oFld:aDialogs[2],, "999", {||    ( aTmp[ 36 ] >= 1 .AND. aTmp[ 36 ] <= 999 )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,, {||      ( 1 )}, {||      ( 999 )},, nil,,, )






         aGet[ 21 ] := TGetHlp():ReDefine( 310, { | u | If( PCount()==0, aTmp[ 21 ], aTmp[ 21 ]:= u ) }, oFld:aDialogs[2],, "@E 99.99",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )




         TCheckBox():ReDefine( 315, { | u | If( PCount()==0, aTmp[ 26 ], aTmp[ 26 ]:= u ) }, oFld:aDialogs[2],,,,,,, .F., {||     ( nMode <> 3 )}, .F. )





         TCheckBox():ReDefine( 150, { | u | If( PCount()==0, aTmp[ 6 ], aTmp[ 6 ]:= u ) }, oFld:aDialogs[2],, {||( if( nMode <> 1, IncTactil( aTmp[ 6 ] ), .T. ) )},,,,, .F., {||     ( nMode <> 3 )}, .F. )




         TCheckBox():ReDefine( 160, { | u | If( PCount()==0, aTmp[ 32 ], aTmp[ 32 ]:= u ) }, oFld:aDialogs[2],,,,,,, .F., {||     ( nMode <> 3 )}, .F. )




         aGet[ 33 ] := TCheckBox():ReDefine( 170, { | u | If( PCount()==0, aTmp[ 33 ], aTmp[ 33 ]:= u ) }, oFld:aDialogs[2],,,,,,, .F., {||     ( nMode <> 3 )}, .F. )









         aGet[ 30 ] := TGetHlp():ReDefine( 330, { | u | If( PCount()==0, aTmp[ 30 ], aTmp[ 30 ]:= u ) }, oFld:aDialogs[2],, "99", {||    ( aTmp[ 30 ] >= 1 .AND. aTmp[ 30 ] <= 99 )},,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,, {||      ( 1 )}, {||      ( 99 )},, nil,,, )






         aGet[ 39 ] := TGetHlp():ReDefine( 340, { | u | If( PCount()==0, aTmp[ 39 ], aTmp[ 39 ]:= u ) }, oFld:aDialogs[2],, "@!",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )






         aGet[ 41 ] := TMultiGet():ReDefine( 130, { | u | If( PCount()==0, aTmp[ 41 ], aTmp[ 41 ]:= u ) }, oFld:aDialogs[2],,,,,,, .F., {||     ( nMode <> 3 )}, .F.,, )









         aGet[ 40 ] := TGetHlp():ReDefine( 360, { | u | If( PCount()==0, aTmp[ 40 ], aTmp[ 40 ]:= u ) }, oFld:aDialogs[2],, "999999",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,, {||      ( 1 )}, {||      ( 999999 )},, nil,,, )






         aGet[ 28 ] := TComboBox():ReDefine( 370, { | u | If( PCount()==0, aTmp[ 28 ], aTmp[ 28 ]:= u ) }, { "", "Root", "Start" }, oFld:aDialogs[2],,,,,,, .F., {||     ( nMode <> 3 )},,,,,, "aGet[ 28 ]",,,,,,, )





         aGet[ 42 ] := TGetHlp():ReDefine( 410, { | u | If( PCount()==0, aTmp[ 42 ], aTmp[ 42 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





         aGet[ 43 ] := TGetHlp():ReDefine( 420, { | u | If( PCount()==0, aTmp[ 43 ], aTmp[ 43 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





         aGet[ 44 ] := TGetHlp():ReDefine( 440, { | u | If( PCount()==0, aTmp[ 44 ], aTmp[ 44 ]:= u ) }, oFld:aDialogs[2],,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )



         oBrwPrv                 := IXBrowse():New( oFld:aDialogs[ 3 ] )

         oBrwPrv:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
         oBrwPrv:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

         oBrwPrv:cAlias          := tmpProveedor
         oBrwPrv:nMarqueeStyle   := 6

            with object ( oBrwPrv:AddCol() )
               :cHeader          := "Proveedor"
               :bEditValue       := {|| Rtrim( ( tmpProveedor )->cCodPrv ) + Space( 1 ) + retFld( ( tmpProveedor )->cCodPrv, dbfPrv, "Titulo" ) }
               :nWidth           := 220
            end

            with object ( oBrwPrv:AddCol() )
               :cHeader          := "Familia"
               :bEditValue       := {|| ( tmpProveedor )->cFamPrv }
               :nWidth           := 140
            end

            if nMode <> 3
               oBrwPrv:bLDblClick   := {|| WinEdtRec( oBrwPrv, bEdit2, tmpProveedor ) }
            end

            oBrwPrv:CreateFromResource( 530 )







         TButton():ReDefine( 500, {||( WinAppRec( oBrwLenguaje, bEditLenguaje, tmpLenguaje ) )}, oFld:aDialogs[ 4 ],,, .F., {||     ( nMode <> 3 )},,, .F. )





         TButton():ReDefine( 510, {||( WinEdtRec( oBrwLenguaje, bEditLenguaje, tmpLenguaje ) )}, oFld:aDialogs[ 4 ],,, .F., {||     ( nMode <> 3 )},,, .F. )





         TButton():ReDefine( 520, {||( dbDelRec( oBrwLenguaje, tmpLenguaje ) )}, oFld:aDialogs[ 4 ],,, .F., {||     ( nMode <> 3 )},,, .F. )

         oBrwLenguaje                  := IXBrowse():New( oFld:aDialogs[ 4 ] )

         oBrwLenguaje:bClrSel          := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
         oBrwLenguaje:bClrSelFocus     := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

         oBrwLenguaje:cAlias           := tmpLenguaje
         oBrwLenguaje:nMarqueeStyle    := 6

            with object ( oBrwLenguaje:AddCol() )
               :cHeader                := "Lenguaje"
               :bEditValue             := {|| alltrim( ( tmpLenguaje )->cCodLen ) }
               :nWidth                 := 220
            end

            with object ( oBrwLenguaje:AddCol() )
               :cHeader                := "Descripción"
               :bEditValue             := {|| ( tmpLenguaje )->cDesFam }
               :nWidth                 := 400
            end

            if nMode <> 3
               oBrwLenguaje:bLDblClick   := {|| WinEdtRec( oBrwLenguaje, bEditLenguaje, tmpLenguaje ) }
            end

            oBrwLenguaje:CreateFromResource( 530 )







         TButton():ReDefine( 500, {||( WinAppRec( oBrwPrv, bEdit2, tmpProveedor ) )}, oFld:aDialogs[3],,, .F., {||     ( nMode <> 3 )},,, .F. )





         TButton():ReDefine( 510, {||( WinEdtRec( oBrwPrv, bEdit2, tmpProveedor ) )}, oFld:aDialogs[3],,, .F., {||     ( nMode <> 3 )},,, .F. )





         TButton():ReDefine( 520, {||( dbDelRec( oBrwPrv, tmpProveedor ) )}, oFld:aDialogs[3],,, .F., {||     ( nMode <> 3 )},,, .F. )







         oBtnAceptarActualizarWeb := TButton():ReDefine( 3, {||( EndTrans( aTmp, aGet, nMode, oBrwPrv, oDlg, .T. ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





         TButton():ReDefine( 1, {||( EndTrans( aTmp, aGet, nMode, oBrwPrv, oDlg ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





         TButton():ReDefine( 2, {||( KillTrans(), oDlg:end() )}, oDlg,,, .F.,,,, .T. )

      if nMode <> 3

         oFld:aDialogs[2]:AddFastKey( 113, {|| WinAppRec( oBrwPrv, bEdit2, tmpProveedor ) } )
         oFld:aDialogs[2]:AddFastKey( 114, {|| WinEdtRec( oBrwPrv, bEdit2, tmpProveedor ) } )
         oFld:aDialogs[2]:AddFastKey( 115, {|| dbDelRec( oBrwPrv, tmpProveedor ) } )

         oDlg:AddFastKey( 116, {|| EndTrans( aTmp, aGet, nMode, oBrwPrv, oDlg ) } )

         if ( TComercioConfig():getInstance():isRealTimeConexion() )
            oDlg:AddFastKey( 117, {|| EndTrans( aTmp, aGet, nMode, oBrwPrv, oDlg, .T. ) } )
         end

         oDlg:AddFastKey( 120, {|| oDetCamposExtra:Play( space(1) ) } )

      end

      oDlg:bStart    := {|| StartEdtRec( aGet, aTmp, bmpImage ) }



      oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|( EdtRecMenu( oDlg, aTmp ) )}, oDlg:bRClicked,,, )
   RECOVER USING oError

      msgStop( "Imposible abrir dialogo de familias." + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if !empty( oBrwPrv )
      oBrwPrv:End()
   end

   if !empty( oBmpGeneral )
      oBmpGeneral:End()
   end

   if !empty( oBmpPropiedades )
      oBmpPropiedades:End()
   end

   if !empty( oBmpProveedores )
      oBmpProveedores:End()
   end

   if !empty( oBmpIdiomas )
      oBmpIdiomas:End()
   end





   KillTrans()

RETURN ( oDlg:nResult == 1 )



STATIC FUNCTION EdtRecMenu( oDlg, aTmp )

   local oMenu

   oMenu := MenuBegin( .F.,,, .F., .F.,,,,,,,,,, .F.,, .F., .F., .F., .T.,, ,,,,,, .F.,, .F., .F.,,,,,,,,,, .F.,,,,,, )

      MenuAddItem( "&1. Rotor",, .F.,,,,,,,,, .F.,,, .F., ,.F., .F.,,,,,,,,,, .F., .F.,,,,,,, ,, .F., .F., .F.,,,,, .F., .F., .F. )

         MenuBegin( .F.,,, .F., .F.,,,,,,,,,, .F.,, .F., .F., .F., .F.,, ,,,,,, .F.,, .F., .F.,,,,,,,,,, .F.,,,,,, )




            MenuAddItem( "&1. Campos extra [F9]", "Mostramos y rellenamos los campos extra para la familia", .F.,, {|oMenuItem|( oDetCamposExtra:Play( Space(1) ) )},, "gc_form_plus2_16",,,,, .F.,,, .F., ,.F., .F.,,,,,,,,,, .F., .F.,,,,,,, ,, .F., .F., .F.,,,,, .F., .F., .F. )

         MenuEnd()

   MenuEnd()

   oDlg:SetMenu( oMenu )

RETURN ( oMenu )



STATIC FUNCTION StartEdtRec( aGet, aTmp, bmpImage )

   aGet[ 5  ]:lValid()
   aGet[ 38  ]:lValid()
   aGet[ 3 ]:lValid()
   aGet[ 4 ]:lValid()

   aGet[ 1 ]:SetFocus()

   LoadTree()

   SetTreeState( , , aTmp[ 29 ] )

   ChgBmp( aGet[ 24 ], bmpImage )



   if TComercioConfig():getInstance():isRealTimeConexion()
      oBtnAceptarActualizarWeb:Show()
   else
      oBtnAceptarActualizarWeb:Hide()
   end

RETURN .T.



STATIC FUNCTION LoadTree( oTree, cCodFam )

   local nRec
   local nOrd
   local oNode

   if empty( cCodFam )

      cCodFam        := Space( 16 )
   end

   If( oTree == nil, oTree := oTreePadre, ) ;

   CursorWait()

   nRec              := ( D():Familias( nView ) )->( Recno() )
   nOrd              := ( D():Familias( nView ) )->( OrdSetFocus( "cFamCmb" ) )

   if ( D():Familias( nView ) )->( dbSeek( cCodFam ) )

      while ( ( D():Familias( nView ) )->cFamCmb == cCodFam .AND. !( D():Familias( nView ) )->( eof() ) )

         oNode       := oTree:Add( Alltrim( ( D():Familias( nView ) )->cNomFam ) )
         oNode:Cargo := ( D():Familias( nView ) )->cCodFam

         LoadTree( oNode, ( D():Familias( nView ) )->cCodFam )

         ( D():Familias( nView ) )->( dbSkip() )

         SysRefresh()

      end

   end

   ( D():Familias( nView ) )->( OrdSetFocus( nOrd ) )
   ( D():Familias( nView ) )->( dbGoTo( nRec ) )

   CursorWE()

   oTree:Expand()

RETURN ( .T. )



FUNCTION getHashFamilias()

   local aFamilias   := {}

   ( D():Familias( nView ) )->( dbgotop() )

   while !( D():Familias( nView ) )->( eof() )

      aadd( aFamilias, { ( D():Familias( nView ) )->cCodFam, ( D():Familias( nView ) )->cNomFam, LoadText( alltrim( upper( ( D():Familias( nView ) )->cNomFam ) ), ( D():Familias( nView ) )->cFamCmb ) } )

      ( D():Familias( nView ) )->( dbSkip() )

      SysRefresh()

   end

RETURN ( aFamilias )



STATIC FUNCTION LoadText( cText, cCodFam )

   local nRec
   local nOrd

   if empty( cCodFam )
      cCodFam        := Space( 16 )
   end

   CursorWait()

   nRec              := ( D():Familias( nView ) )->( Recno() )
   nOrd              := ( D():Familias( nView ) )->( OrdSetFocus( "cCodFam" ) )

   if ( D():Familias( nView ) )->( dbSeek( cCodFam ) )

      cText          := alltrim( upper( ( D():Familias( nView ) )->cNomFam ) ) + ", " + cText

      LoadText( @cText, ( D():Familias( nView ) )->cFamCmb )

      SysRefresh()

   end

   ( D():Familias( nView ) )->( OrdSetFocus( nOrd ) )
   ( D():Familias( nView ) )->( dbGoTo( nRec ) )

   CursorWE()

RETURN ( cText )



STATIC FUNCTION SetTreeState( oTree, aItems, cCodFam )

   local oItem

   If( oTree == nil, oTree := oTreePadre, ) ;

   if empty( aItems )
      aItems      := oTree:aItems
   end

   for each oItem in aItems

      if ( cCodFam == oItem:Cargo )

         oTree:Select( oItem )
         oTree:SetCheck( oItem, .T. )

         SysRefresh()

      end

      if len( oItem:aItems ) > 0
         SetTreeState( oTree, oItem:aItems, cCodFam )
      end

   next

RETURN ( .T. )



STATIC FUNCTION ChangeTreeState( oTree, aItems )

   local oItem

   If( oTree == nil, oTree := oTreePadre, ) ;

   if empty( aItems )
      aItems      := oTree:aItems
   end

   for each oItem in aItems

      SysRefresh()



      oTree:SetCheck( oItem, .F. )

      if len( oItem:aItems ) > 0
         ChangeTreeState( oTree, oItem:aItems )
      end

   next

RETURN ( .T. )



STATIC FUNCTION GetTreeState( aTmp, oTree, aItems )

   local oItem

   If( oTree == nil, oTree := oTreePadre, ) ;

   if empty( aItems )
      aItems                  := oTree:aItems
   end

   for each oItem in aItems


      if oTree:GetCheck( oItem )
         aTmp[ 29 ]     := oItem:Cargo
      end

      if len( oItem:aItems ) > 0
         GetTreeState( aTmp, oTree, oItem:aItems )
      end

   next

RETURN ( aTmp )



STATIC FUNCTION aChildTree( cCodFamilia, aChild )

   local nRec
   local nOrd

   if empty( aChild )
      aChild   := {}
   end

   CursorWait()

   nRec        := ( D():Familias( nView ) )->( Recno() )
   nOrd        := ( D():Familias( nView ) )->( OrdSetFocus( "cFamCmb" ) )

   if ( D():Familias( nView ) )->( dbSeek( cCodFamilia ) )

      while ( ( D():Familias( nView ) )->cFamCmb == cCodFamilia .AND. !( D():Familias( nView ) )->( Eof() ) )

         aAdd( aChild, ( D():Familias( nView ) )->cCodFam )

         aChildTree( ( D():Familias( nView ) )->cCodFam, aChild )

         ( D():Familias( nView ) )->( dbSkip() )

      end

   end

   ( D():Familias( nView ) )->( OrdSetFocus( nOrd ) )
   ( D():Familias( nView ) )->( dbGoTo( nRec ) )

   CursorWE()

RETURN ( aChild )



STATIC FUNCTION BeginTrans( aTmp, nMode )

   local cCodFam     := aTmp[ 1 ]

   cFileProveedor    := cGetNewFileName( cPatTmp() + "FamPrvl" )
   cFileLenguaje     := cGetNewFileName( cPatTmp() + "FamLeng" )





   dbCreate( cFileProveedor, aSqlStruct( aItmFamPrv() ), cLocalDriver() )
   dbUseArea( .T., cLocalDriver(), cFileProveedor, cCheckArea( "FamPrvl", @tmpProveedor ), .F. )

   if !( tmpProveedor )->( neterr() )

      ( tmpProveedor )->( ordcondset( "!Deleted()", {|| !Deleted() } ) )
      ( tmpProveedor )->( ordcreate( cFileProveedor, "cPrvFam", "cCodPrv + cFamPrv", {|| Field->cCodPrv + Field->cFamPrv } ) )





      if ( dbfFamPrv )->( dbSeek( cCodFam ) )
         while ( ( dbfFamPrv )->cCodFam == cCodFam .AND. !( dbfFamPrv )->( Eof() ) )
            dbPass( dbfFamPrv, tmpProveedor, .T. )
            ( dbfFamPrv )->( dbSkip() )
         end
      end

      ( tmpProveedor )->( dbgotop() )

   end





   dbCreate( cFileLenguaje, aSqlStruct( aItmFamiliaLenguajes() ), cLocalDriver() )
   dbUseArea( .T., cLocalDriver(), cFileLenguaje, cCheckArea( "FamLeng", @tmpLenguaje ), .F. )

   if !( tmpLenguaje )->( neterr() )

      ( tmpLenguaje )->( ordcondset( "!Deleted()", {|| !Deleted() } ) )
      ( tmpLenguaje )->( ordcreate( cFileLenguaje, "cPrvFam", "cCodFam + cCodLen", {|| Field->cCodFam + Field->cCodLen } ) )

      if ( D():FamiliasLenguajes( nView ) )->( dbSeek( cCodFam ) )
         while ( ( D():FamiliasLenguajes( nView ) )->cCodFam == cCodFam .AND. !( D():FamiliasLenguajes( nView ) )->( Eof() ) )
            dbPass( D():FamiliasLenguajes( nView ), tmpLenguaje, .T. )
            ( D():FamiliasLenguajes( nView ) )->( dbSkip() )
         end
      end

      ( tmpLenguaje )->( dbgotop() )

   end

   oDetCamposExtra:SetTemporal( aTmp[ 1 ], "", nMode )

RETURN Nil



STATIC FUNCTION EndTrans( aTmp, aGet, nMode, oBrw, oDlg, lActualizaWeb )

   local oError
   local oBlock
   local cCodFam           := aTmp[ 1 ]
   local aGrp

   If( lActualizaWeb == nil, lActualizaWeb := .F., ) ;



   if nMode == 1 .OR. nMode == 4

      if empty( cCodFam )
         MsgStop( "Código no puede estar vacío" )
         aGet[ 1 ]:SetFocus()
         RETURN nil
      end

      if dbSeekInOrd( cCodFam, "cCodFam", D():Familias( nView ) )
         MsgStop( "Código ya existe " + Rtrim( cCodFam ) )
         RETURN nil
      end

   end

   if empty( aTmp[ 2 ] )
      MsgStop( "Nombre no puede estar vacío" )
      aGet[ 2 ]:SetFocus()
      RETURN nil
   end

   do case
      case !empty( aTmp[ 4 ] ) .AND. empty( aTmp[ 3 ] )
         MsgStop( "Para informar la propiedad 2 no puede dejar vacía la propiedad 1." )
         RETURN nil
      case aTmp[ 3 ] == aTmp[ 4 ] .AND. !empty( aTmp[ 3 ] ) .AND. !empty( aTmp[ 4 ] )
         MsgStop( "No puede repetir las propiedades." )
         RETURN nil
   end

   aTmp[ 29 ]        := ""

   GetTreeState( aTmp )

   if ( aTmp[ 29 ] == aTmp[ 1 ] )
      MsgStop( "Familia padre no puede ser el mismo" )
      oTreePadre:SetFocus()
      RETURN nil
   end

   aGrp  := aChildTree( aTmp[ 1 ] )
   if aScan( aGrp, aTmp[ 29 ] ) <> 0
      MsgStop( "Familia padre contiene referencia circular" )
      oTreePadre:SetFocus()
      RETURN nil
   end

   aTmp[ 25 ]  := .T.





   CursorWait()

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      BeginTransaction()





      while ( dbfFamPrv )->( dbSeek( cCodFam ) ) .AND. !( dbfFamPrv )->( Eof() )
         if dbLock( dbfFamPrv )
            ( dbfFamPrv )->( dbDelete() )
            ( dbfFamPrv )->( dbUnLock() )
         end
      end

      while ( D():FamiliasLenguajes( nView ) )->( dbSeek( cCodFam ) ) .AND. !( D():FamiliasLenguajes( nView ) )->( Eof() )
         if dbLock( D():FamiliasLenguajes( nView ) )
            ( D():FamiliasLenguajes( nView ) )->( dbDelete() )
            ( D():FamiliasLenguajes( nView ) )->( dbUnLock() )
         end
      end





      ( tmpProveedor )->( dbgotop() )
      while !( tmpProveedor )->( eof() )
         dbPass( tmpProveedor, dbfFamPrv, .T., cCodFam )
         ( tmpProveedor )->( dbSkip() )
      end

      ( tmpLenguaje )->( dbgotop() )
      while !( tmpLenguaje )->( eof() )
         dbPass( tmpLenguaje, D():FamiliasLenguajes( nView ), .T., cCodFam )
         ( tmpLenguaje )->( dbSkip() )
      end



      oDetCamposExtra:saveExtraField( cCodFam, "" )



      WinGather( aTmp, aGet, D():Familias( nView ), oBrw, nMode )

      CommitTransaction()



      if lActualizaWeb
         actualizaWeb( cCodFam )
      end

   RECOVER USING oError

      RollBackTransaction()

      msgStop( ErrorMessage( oError ), "Imposible almacenar artículo" )

   end

   ErrorBlock( oBlock )

   CursorWe()

   oDlg:end( 1 )



RETURN NIL






STATIC FUNCTION KillTrans()

   if ( tmpProveedor )->( Used() )
      ( tmpProveedor )->( dbCloseArea() )
   end

   dbfErase( cFileProveedor )

   if ( tmpLenguaje )->( Used() )
      ( tmpLenguaje )->( dbCloseArea() )
   end

   dbfErase( cFileLenguaje )

RETURN .T.



STATIC FUNCTION EditLenguaje( aTmp, aGet, tmpLenguaje, oBrwLenguaje, bWhen, bValid, nMode )

   local oDlg
   local oBmp

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "descripciones por lenguaje", "FAMILIA_LENGUAJE",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )





   oBmp := TBitmap():ReDefine( 600, "gc_user_message_48",, oDlg,,, .F., .F.,,, .F.,,, .T. )








   aGet[ ( tmpLenguaje )->( fieldpos( "cCodLen" ) ) ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ ( tmpLenguaje )->( fieldpos( "cCodLen" ) ) ], aTmp[ ( tmpLenguaje )->( fieldpos( "cCodLen" ) ) ]:= u ) }, oDlg,,, {||       ( oLenguajes:Existe( aGet[ ( tmpLenguaje )->( fieldpos( "cCodLen" ) ) ], aGet[ ( tmpLenguaje )->( fieldpos( "cCodLen" ) ) ]:oHelpText, "cNomLen" ) )},,,,,, .F.,,, .F., .F.,,,,, {|Self|( oLenguajes:Buscar( aGet[ ( tmpLenguaje )->( fieldpos( "cCodLen" ) ) ] ) )}, nil, "LUPA",, 111 )




   aGet[ ( tmpLenguaje )->( fieldpos( "cDesFam" ) ) ] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[ ( tmpLenguaje )->( fieldpos( "cDesFam" ) ) ], aTmp[ ( tmpLenguaje )->( fieldpos( "cDesFam" ) ) ]:= u ) }, oDlg,,,,,,,,, .F.,,, .F., .F.,,,,,, nil,,, )






   aGet[ ( tmpLenguaje )->( fieldpos( "mLngDes" ) ) ] := TMultiGet():ReDefine( 130, { | u | If( PCount()==0, aTmp[ ( tmpLenguaje )->( fieldpos( "mLngDes" ) ) ], aTmp[ ( tmpLenguaje )->( fieldpos( "mLngDes" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||        ( nMode <> 3 )}, .F.,, )




   TButton():ReDefine( 1, {||( endEditLenguaje( aGet, aTmp, nMode, oBrwLenguaje, oDlg ) )}, oDlg,,, .F.,,,, .F. )





   TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   if nMode <> 1
      oDlg:AddFastKey( 116, {|| endEditLenguaje( aGet, aTmp, nMode, oBrwLenguaje, oDlg ) } )
   end

   oDlg:bStart    := {|| aGet[ ( tmpLenguaje )->( fieldpos( "cCodLen" ) ) ]:lValid() }

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if !empty( oBmp )
      oBmp:End()
   end

RETURN ( oDlg:nResult == 1 )



static function endEditLenguaje( aGet, aTmp, nMode, oBrwLenguaje, oDlg )

   if empty( aTmp[ ( tmpLenguaje )->( FieldPos( "cCodLen" ) ) ] )
      msgStop( "Código de lenguaje no puede estar vacío." )
      aGet[ ( tmpLenguaje )->( FieldPos( "cCodLen" ) ) ]:SetFocus()
      Return .F.
   end

   if empty( aTmp[ ( tmpLenguaje )->( FieldPos( "cDesFam" ) ) ] )
      msgStop( "Tiene que introducir al menos una descripción." )
      aGet[ ( tmpLenguaje )->( FieldPos( "cDesFam" ) ) ]:SetFocus()
      Return .F.
   end



   WinGather( aTmp, aGet, tmpLenguaje, oBrwLenguaje, nMode )

   oDlg:End( 1 )

Return ( .T. )



STATIC FUNCTION actualizaWeb( cCodigoFamilia )

   local TComercio   := TComercio():New( nView )
   local aChildTree  := {}

   aChildTree        := aChildTree( cCodigoFamilia, aChildTree )

   aadd( aChildTree, cCodigoFamilia )

   aeval( aChildTree, {|cCodigoFamilia| TComercio:controllerExportOneCategoryToPrestashop( cCodigoFamilia ) } )

RETURN ( nil )



STATIC FUNCTION EdtDet( aTmp, aGet, tmpProveedor, oBrw, bWhen, bValid, nMode )

    local oDlg
    local oGet
   local oGet2
    local oGetTxt
    local cGetTxt

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "familias de proveedores", "LFAMPRV",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )









      oGet := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ ( tmpProveedor )->( FieldPos( "cCodPrv" ) ) ], aTmp[ ( tmpProveedor )->( FieldPos( "cCodPrv" ) ) ]:= u ) }, oDlg,, ( RetPicCodPrvEmp() ), {||    ( cProvee( oGet, dbfPrv, oGetTxt ) )},,,,,, .F., {||     ( nMode == 1 )},, .F., .F.,,,,, {|Self|( BrwProvee( oGet ) )}, nil, "LUPA",, )




        oGetTxt := TGetHlp():ReDefine( 101, { | u | If( PCount()==0, cGetTxt, cGetTxt:= u ) }, oDlg,,,,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )




      oGet2 := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ ( tmpProveedor )->( FieldPos( "cFamPrv" ) ) ], aTmp[ ( tmpProveedor )->( FieldPos( "cFamPrv" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      TButton():ReDefine( 1, {||(  EndDetalle( aTmp, aGet, tmpProveedor, oBrw, nMode, oDlg, oGet, oGet2 ) )}, oDlg,,, .F., {||         (     nMode <> 3 )},,, .F. )




        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| EndDetalle( aTmp, aGet, tmpProveedor, oBrw, nMode, oDlg, oGet, oGet2 ) } )
   end

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted := {|hDC,cPS|( oGet:lValid() )}, .T.,,,, oDlg:bRClicked,,, )

RETURN ( oDlg:nResult == 1 )



STATIC FUNCTION EndDetalle( aTmp, aGet, tmpProveedor, oBrw, nMode, oDlg, oGet, oGet2 )

   if nMode == 1

      if empty( aTmp[ ( tmpProveedor )->( FieldPos( "cCodPrv" ) ) ] )
         MsgStop( "Código no puede estar vacío" )
         oGet:SetFocus()
         RETURN nil
      end

   end

   if empty( aTmp[ ( tmpProveedor )->( FieldPos( "cFamPrv" ) ) ] )
      MsgStop( "Código de la familia no puede estar vacío" )
      oGet2:SetFocus()
      RETURN nil
   end

   if dbSeekFamilia( aTmp, tmpProveedor )
      msgStop( "Código de familia existente" )
      RETURN nil
   end

   WinGather( aTmp, aGet, tmpProveedor, oBrw, nMode )

RETURN ( oDlg:end() )



STATIC FUNCTION dbSeekFamilia( aTmp, tmpProveedor )

   local lSeek    := .F.
   local nOrdAnt  := ( tmpProveedor )->( OrdSetFocus( "cPrvFam" ) )

   if ( tmpProveedor )->( dbSeek( aTmp[ ( tmpProveedor )->( FieldPos( "cCodPrv" ) ) ] + aTmp[ ( tmpProveedor )->( FieldPos( "cFamPrv" ) ) ] ) )
      lSeek    := .T.
   end

   ( tmpProveedor )->( OrdSetFocus( nOrdAnt ) )

RETURN ( lSeek )



FUNCTION EdtFamilia( cCodFam, lOpenBrowse )

   local lEdit          := .F.
   local nLevel         := Auth():Level( "01012" )

   If( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) == 0 .OR. nAnd( nLevel, 4 ) == 0
      msgStop( "Acceso no permitido." )
      RETURN .F.
   end

   if lOpenBrowse

      if Familia()
         if dbSeekInOrd( cCodFam, "cCodFam", D():Familias( nView ) )
            lEdit       := oWndBrw:RecEdit()
         else
            MsgStop( "No se encuentra familia" )
         end
      end

   else

      if !empty( cCodFam )

         if OpenFiles( .T. )
            if dbSeekInOrd( cCodFam, "cCodFam", D():Familias( nView ) )
               lEdit    := WinEdtRec( oWndBrw, bEdit, D():Familias( nView ) )
            else
               MsgStop( "No se encuentra familia" )
            end
            CloseFiles()
         end

      end

   end

RETURN ( lEdit )






FUNCTION nPreFamilia( cCodFam, aMes, lAno, cFamilia )

   local nPreFam  := 0

   if dbSeekInOrd( cCodFam, "cCodFam", cFamilia )

      if lAno

         nPreFam  := ( cFamilia )->NVALANU

      else

         if aMes[ 1]
            nPreFam  += ( cFamilia )->NENE
         end

         if aMes[ 2]
            nPreFam  += ( cFamilia )->NFEB
         end

         if aMes[ 3]
            nPreFam  += ( cFamilia )->NMAR
         end

         if aMes[ 4]
            nPreFam  += ( cFamilia )->NABR
         end

         if aMes[ 5]
            nPreFam  += ( cFamilia )->NMAY
         end

         if aMes[ 6]
            nPreFam  += ( cFamilia )->NJUN
         end

         if aMes[ 7]
            nPreFam  += ( cFamilia )->NJUL
         end

         if aMes[ 8]
            nPreFam  += ( cFamilia )->NAGO
         end

         if aMes[ 9]
            nPreFam  += ( cFamilia )->NSEP
         end

         if aMes[10]
            nPreFam  += ( cFamilia )->NOCT
         end

         if aMes[11]
            nPreFam  += ( cFamilia )->NNOV
         end

         if aMes[12]
            nPreFam  += ( cFamilia )->NDIC
         end

      end

   end

RETURN ( nPreFam )



FUNCTION lFamInTpv( cFamilia )

   local lFamInTpv   := .F.

   ( cFamilia )->( dbgotop() )
   while !( cFamilia )->( eof() )
      if ( cFamilia )->lIncTpv
         lFamInTpv   := .T.
         exit
      end
      ( cFamilia )->( dbSkip() )
   end

RETURN ( lFamInTpv )



STATIC FUNCTION IncEnvio( aTmp )

   local nRec

   for each nRec in ( oWndBrw:oBrw:aSelected )

      ( D():Familias( nView ) )->( dbGoTo( nRec ) )

      if dbLock( D():Familias( nView ) )
         ( D():Familias( nView ) )->lSelDoc := !( D():Familias( nView ) )->lSelDoc
         ( D():Familias( nView ) )->( dbUnLock() )
      end

   next

   oWndBrw:Refresh()

RETURN ( nil )



STATIC FUNCTION IncTactil( lIncTactil )

   If( lIncTactil == nil, lIncTactil := !( D():Familias( nView ) )->lIncTpv, ) ;

   if dbLock( D():Familias( nView ) )
      ( D():Familias( nView ) )->lIncTpv := lIncTactil
      ( D():Familias( nView ) )->( dbUnLock() )
      if oWndBrw <> nil
         oWndBrw:Refresh()
      end
   end





   if apoloMsgNoYes( "¿Desea " + if( lIncTactil, "seleccionar", "deseleccionar" ) + " todos los artículos de esta familia," + Chr(13)+Chr(10) + "para que sean " + if( lIncTactil, "incluidos en el", "excluidos del" ) + " TPV táctil ?", ( D():Familias( nView ) )->cCodFam + Space( 1 ) + ( D():Familias( nView ) )->cNomFam )

      if ( dbfArticulo )->( dbSeek( ( D():Familias( nView ) )->cCodFam ) )

         while ( dbfArticulo )->Familia == ( D():Familias( nView ) )->cCodFam

            if dbLock( dbfArticulo )
               ( dbfArticulo )->lIncTcl := lIncTactil
               ( dbfArticulo )->( dbUnLock() )
            end

            ( dbfArticulo )->( dbSkip() )

         end

      end

   end

RETURN ( nil )



FUNCTION aFamPrp( cCodFam, dbfFami )

   local aPrp     := aFill( Array( 2 ), "" )





   if ( dbfFami )->( dbSeek( cCodFam ) )
      aPrp[ 1 ]   := ( dbfFami )->CCODPRP1
      aPrp[ 2 ]   := ( dbfFami )->CCODPRP2
   end

RETURN ( aPrp )



FUNCTION cCodFam( cCodFam, oDbfFam )

   local cCod     := ""

   if oDbfFam:Seek( cCodFam )
      cCod        := oDbfFam:Familia
   end

RETURN cCod



FUNCTION cNomFam( cCodFam, oDbfFam )

   local cNom     := ""

   if oDbfFam:SeekInOrd( cCodFam, "cCodFam" )
      cNom        := oDbfFam:cNomFam
   end

RETURN ( cNom )



FUNCTION cCodFamPrv( cCodPrv, cFamPrv, dbfFamPrv )

   local cCodFam  := ""
   local nOrdAnt  := ( dbfFamPrv )->( OrdSetFocus( "cFamPrv" ) )

   if ( dbfFamPrv )->( dbSeek( cCodPrv + cFamPrv ) )
      cCodFam     := ( dbfFamPrv )->cCodFam
   end

   ( dbfFamPrv )->( OrdSetFocus( nOrdAnt ) )

RETURN ( cCodFam )



STATIC FUNCTION DeleteFamiliaProveedores()

   local cCodFam        := ( D():Familias( nView ) )->cCodFam

   CursorWait()

   while ( dbfFamPrv )->( dbSeek( cCodFam ) ) .AND. !( dbfFamPrv )->( Eof() )
      if( dbLock( dbfFamPrv ), ( ( dbfFamPrv )->( dbDelete() ), ( dbfFamPrv )->( dbUnLock() ) ), )
   end

   CursorWE()

RETURN ( .T. )



FUNCTION lPermitirVentaSinValorar( cCodArt, dbfArticulo, cFamilia )

   local lPermitir   := .T.

   if dbSeekInOrd( cCodArt, "Codigo", dbfArticulo )
      if dbSeekInOrd( ( dbfArticulo )->Familia, "cCodFam", cFamilia )
         lPermitir   := ( cFamilia )->lPreEsp
      end
   end

RETURN ( lPermitir )



_HB_CLASS TFamiliaSenderReciver ; function TFamiliaSenderReciver ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TFamiliaSenderReciver", iif( .T., { @TSenderReciverItem() }, { @HBObject() } ), @TFamiliaSenderReciver() ) ) ;

   _HB_MEMBER { cFileName } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cFileName"}, .F. )

   _HB_MEMBER CreateData(); oClass:AddMethod( "CreateData", @TFamiliaSenderReciver_CreateData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER RestoreData(); oClass:AddMethod( "RestoreData", @TFamiliaSenderReciver_RestoreData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SendData(); oClass:AddMethod( "SendData", @TFamiliaSenderReciver_SendData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ReciveData(); oClass:AddMethod( "ReciveData", @TFamiliaSenderReciver_ReciveData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Process(); oClass:AddMethod( "Process", @TFamiliaSenderReciver_Process(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TFamiliaSenderReciver ;



static FUNCTION TFamiliaSenderReciver_CreateData( ) ; local Self AS CLASS TFamiliaSenderReciver := QSelf() AS CLASS TFamiliaSenderReciver

   local oBlock
   local oError
   local dbfFam
   local tmpFam
   local lSndFam     := .F.

   if ::oSender:lServer
      ::cFileName      := "Fam" + win_uuidcreatestring() + ".All"
   else
      ::cFileName      := "Fam" + win_uuidcreatestring() + "." + RetSufEmp()
   end

   ::oSender:SetText( "Seleccionando familias" )

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "Familias.Dbf" ), ( cCheckArea( "FAMILIAS", @dbfFam ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "Familias.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

   mkFamilia( cPatSnd() )

   dbUseArea( .T., ( cLocalDriver() ), ( cPatSnd() + "Familias.Dbf" ), ( cCheckArea( "FAMILIAS", @tmpFam ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
   if !lAIS() ; ordListAdd( ( cPatSnd() + "Familias.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

   if !empty( ::oSender:oMtr )
      ::oSender:oMtr:nTotal := ( dbfFam )->( lastrec() )
   end

   while !( dbfFam )->( eof() )

      if ( dbfFam )->lSelDoc
         ::oSender:SetText( AllTrim( ( dbfFam )->cCodFam ) + "; " + AllTrim( ( dbfFam )->cNomFam ) )
         lSndFam  := .T.
         dbPass( dbfFam, tmpFam, .T. )
      end

      ( dbfFam )->( dbSkip() )

      if !empty( ::oSender:oMtr )
         ::oSender:oMtr:Set( ( dbfFam )->( OrdKeyNo() ) )
      end

      SysRefresh()

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   ( dbfFam  )->( dbCloseArea() )
   ( tmpFam  )->( dbCloseArea() )

   if lSndFam

      ::oSender:SetText( "Comprimiendo familias" )

      if ::oSender:lZipData( ::cFileName )
         ::oSender:SetText( "Ficheros comprimidos" )
      else
         ::oSender:SetText( "ERROR al crear fichero comprimido" )
      end

   else

      ::oSender:SetText( "No hay familias para enviar" )

   end

RETURN ( Self )



static FUNCTION TFamiliaSenderReciver_RestoreData( ) ; local Self AS CLASS TFamiliaSenderReciver := QSelf() AS CLASS TFamiliaSenderReciver

   local oBlock
   local oError
   local cFamilia

   if ::lSuccesfullSend





      oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
      BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "Familias.Dbf" ), ( cCheckArea( "FAMILIAS", @cFamilia ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "Familias.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      while !( cFamilia )->( eof() )
         if ( cFamilia )->lSelDoc .AND. ( cFamilia )->( dbRLock() )
            ( cFamilia )->lSelDoc := .F.
            ( cFamilia )->( dbRUnlock() )
         end
         ( cFamilia )->( dbSkip() )
      end

      RECOVER USING oError

         msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

      end

      ErrorBlock( oBlock )

      ( cFamilia  )->( dbCloseArea() )

   end

RETURN ( Self )



static FUNCTION TFamiliaSenderReciver_SendData( ) ; local Self AS CLASS TFamiliaSenderReciver := QSelf() AS CLASS TFamiliaSenderReciver

   if File( cPatOut() + ::cFileName )

      if ::oSender:SendFiles( cPatOut() + ::cFileName, ::cFileName )
         ::lSuccesfullSend := .T.
         ::oSender:SetText( "Ficheros de familias enviados " + ::cFileName )
      else
         ::oSender:SetText( "ERROR fichero de familias no enviado" )
      end

   end

RETURN ( Self )



static FUNCTION TFamiliaSenderReciver_ReciveData( ) ; local Self AS CLASS TFamiliaSenderReciver := QSelf() AS CLASS TFamiliaSenderReciver

   local n
   local aExt

   if ::oSender:lServer
      aExt              := aRetDlgEmp()
   else
      aExt              := { "All" }
   end

   ::oSender:SetText( "Recibiendo familias" )

   for n := 1 to len( aExt )
      if IsChar( aExt[ n ] )
         ::oSender:GetFiles( "Fam*." + aExt[ n ], cPatIn() )
      end
   next

   ::oSender:SetText( "Familias recibidas" )

RETURN ( Self )



static FUNCTION TFamiliaSenderReciver_Process( ) ; local Self AS CLASS TFamiliaSenderReciver := QSelf() AS CLASS TFamiliaSenderReciver

   local m
   local aFiles
   local tmpFam
   local dbfFam
   local oBlock
   local oError





   aFiles                     := Directory( cPatIn() + "Fam*.*" )

   for m := 1 to len( aFiles )

      ::oSender:SetText( "Procesando fichero : " + aFiles[ m, 1 ] )

      oBlock                  := ErrorBlock( {| oError | ApoloBreak( oError ) } )
      BEGIN SEQUENCE





         if ::oSender:lUnZipData( cPatIn() + aFiles[ m, 1 ] )

            if file( cPatSnd() + "Familias.Dbf" )

               dbUseArea( .T., ( cLocalDriver() ), ( cPatSnd() + "Familias.Dbf" ), ( cCheckArea( "FAMILIAS", @tmpFam ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
               if !lAIS() ; ordListAdd( ( cPatSnd() + "Familias.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

               dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "Familias.Dbf" ), ( cCheckArea( "FAMILIAS", @dbfFam ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
               if !lAIS() ; ordListAdd( ( cPatEmp() + "Familias.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

               if !empty( ::oSender:oMtr )
                  ::oSender:oMtr:nTotal := ( tmpFam )->( lastrec() )
               end

               ( tmpFam )->( ordsetfocus( 0 ) )
               ( tmpFam )->( dbgotop() )

               while !( tmpFam )->( eof() )

                  if ( dbfFam )->( dbSeek( ( tmpFam )->cCodFam ) )

                     if !::oSender:lServer

                        dbPass( tmpFam, dbfFam )

                        if dbLock( dbfFam )
                           ( dbfFam )->lSelDoc := .F.
                           ( dbfFam )->( dbUnLock() )
                        end

                        ::oSender:SetText( "Reemplazado : " + AllTrim( ( dbfFam )->cCodFam ) + "; " + AllTrim( ( dbfFam )->cNomFam ) )

                     else

                        ::oSender:SetText( "Desestimado : " + AllTrim( ( dbfFam )->cCodFam ) + "; " + AllTrim( ( dbfFam )->cNomFam ) )

                     end

                  else

                        dbPass( tmpFam, dbfFam, .T. )

                        if dbLock( dbfFam )
                           ( dbfFam )->lSelDoc := .F.
                           ( dbfFam )->( dbUnLock() )
                        end

                        ::oSender:SetText( "Añadido     : " + AllTrim( ( dbfFam )->cCodFam ) + "; " + AllTrim( ( dbfFam )->cNomFam ) )

                  end

                  ( tmpFam )->( dbSkip() )

                  if !empty( ::oSender:oMtr )
                     ::oSender:oMtr:Set( ( tmpFam )->( OrdKeyNo() ) )
                  end

                  SysRefresh()

               end

               if !empty( ::oSender:oMtr )
                  ::oSender:oMtr:nTotal := ( tmpFam )->( LastRec() )
               end

               ( tmpFam )->( dbCloseArea() )
               ( dbfFam )->( dbCloseArea() )

               ::oSender:AppendFileRecive( aFiles[ m, 1 ] )

            end

         end

      RECOVER USING oError

         ( tmpFam )->( dbCloseArea() )
         ( dbfFam )->( dbCloseArea() )

         ::oSender:SetText( "Error procesando fichero " + aFiles[ m, 1 ] )
         ::oSender:SetText( ErrorMessage( oError ) )

      end

      ErrorBlock( oBlock )

   next

RETURN ( Self )



STATIC FUNCTION lSelFam( lSel, oBrw, dbf )

   If( lSel == nil, lSel := !( dbf )->lSelDoc, ) ;

   if dbLock( dbf )
      ( dbf )->lSelDoc  := lSel
      ( dbf )->( dbUnlock() )
   end

   if oBrw <> nil
      oBrw:Refresh()
      oBrw:SetFocus()
   end

RETURN NIL



FUNCTION SetHeadDiv( lEur, oWndBrw, cChrSea )

   local n

   If( cChrSea == nil, cChrSea := "Precio", ) ;

   for n := 1 to len( oWndBrw:oBrw:aHeaders )

      if cChrSea $ oWndBrw:oBrw:aHeaders[ n ]
         if lEur
            oWndBrw:oBrw:aHeaders[ n ] := SubStr( oWndBrw:oBrw:aHeaders[ n ], 1, len( oWndBrw:oBrw:aHeaders[ n ] ) - 4 ) + Space( 1 ) + cDivChg()
         else
            oWndBrw:oBrw:aHeaders[ n ] := SubStr( oWndBrw:oBrw:aHeaders[ n ], 1, len( oWndBrw:oBrw:aHeaders[ n ] ) - 4 ) + Space( 1 ) + cDivEmp()
         end
      end
   next

   oWndBrw:Refresh()
   oWndBrw:SetFocus()

RETURN nil



_HB_CLASS TListadoFamilias ; function TListadoFamilias ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TListadoFamilias", iif( .T., { @TInfGen() }, { @HBObject() } ), @TListadoFamilias() ) ) ;

   _HB_MEMBER Create(); oClass:AddMethod( "Create", @TListadoFamilias_Create(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER lResource( cFld); oClass:AddMethod( "lResource", @TListadoFamilias_lResource(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER lGenerate(); oClass:AddMethod( "lGenerate", @TListadoFamilias_lGenerate(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TListadoFamilias ;



static FUNCTION TListadoFamilias_Create( ) ; local Self AS CLASS TListadoFamilias := QSelf() AS CLASS TListadoFamilias

   ::AddField( "CCODFAM",    "C",  16, 0, {|| "" },    "Código",                 .T., "Código de familia",                   16, .F. )
   ::AddField( "CNOMFAM",    "C",  40, 0, {|| "" },    "Nombre",                 .T., "Nombre de familia",                   40, .F. )
   ::AddField( "CCODPRP1",   "C",  10, 0, {|| "" },    "Prp1",                   .F., "Primera propiedad de la familia",      5, .F. )
   ::AddField( "CCODPRP2",   "C",  10, 0, {|| "" },    "Prp2",                   .F., "Segunda propiedad de la familia",      5, .F. )
   ::AddField( "CCODGRP",    "C",   3, 0, {|| "" },    "Cod. grupo",             .T., "Código de grupo",                      5, .F. )
   ::AddField( "NVALANU",    "N",  16, 6, {|| "" },    "Anual",                  .T., "Previsiones anual",                   20, .F. )
   ::AddField( "NENE",       "N",  16, 6, {|| "" },    "Enero",                  .F., "Previsiones Enero",                   20, .F. )
   ::AddField( "NFEB",       "N",  16, 6, {|| "" },    "Febrero",                .F., "Previsiones Febrero",                 20, .F. )
   ::AddField( "NMAR",       "N",  16, 6, {|| "" },    "Marzo",                  .F., "Previsiones Marzo",                   20, .F. )
   ::AddField( "NABR",       "N",  16, 6, {|| "" },    "Abril",                  .F., "Previsiones Abril",                   20, .F. )
   ::AddField( "NMAY",       "N",  16, 6, {|| "" },    "Mayo",                   .F., "Previsiones Mayo",                    20, .F. )
   ::AddField( "NJUN",       "N",  16, 6, {|| "" },    "Junio",                  .F., "Previsiones Junio",                   20, .F. )
   ::AddField( "NJUL",       "N",  16, 6, {|| "" },    "Julio",                  .F., "Previsiones Julio",                   20, .F. )
   ::AddField( "NAGO",       "N",  16, 6, {|| "" },    "Agosto",                 .F., "Previsiones Agosto",                  20, .F. )
   ::AddField( "NSEP",       "N",  16, 6, {|| "" },    "Septiembre",             .F., "Previsiones Septiembre",              20, .F. )
   ::AddField( "NOCT",       "N",  16, 6, {|| "" },    "Octubre",                .F., "Previsiones Octubre",                 20, .F. )
   ::AddField( "NNOV",       "N",  16, 6, {|| "" },    "Noviembre",              .F., "Previsiones Noviembre",               20, .F. )
   ::AddField( "NDIC",       "N",  16, 6, {|| "" },    "Diciembre",              .F., "Previsiones Diciembre",               20, .F. )
   ::AddField( "NPCTRPL",    "N",   6, 2, {|| "" },    "Rapels",                 .F., "Porcentaje de rapels",                10, .F. )

   ::lDefFecInf   := .F.
   ::lDefSerInf   := .F.
   ::lDefDivInf   := .F.

RETURN ( Self )



static FUNCTION TListadoFamilias_lResource( cFld ) ; local Self AS CLASS TListadoFamilias := QSelf() AS CLASS TListadoFamilias

   if !::StdResource( "INF_FAM01" )
      RETURN .F.
   end

   ::lDefFamInf( 110, 120, 130, 140, 600 )

   ::CreateFilter( aItmFam(), ::oDbfFam )

   ::oMtrInf:SetTotal( ::oDbfFam:Lastrec() )

RETURN ( .T. )






static FUNCTION TListadoFamilias_lGenerate( ) ; local Self AS CLASS TListadoFamilias := QSelf() AS CLASS TListadoFamilias

   local cExpHead := ""

   ::oDlg:Disable()
   ::oBtnCancel:Enable()
   ::oDbf:Zap()


   ::aHeader      := {  {|| "Fecha    : " + Dtoc( Date() ) }, {|| "Familias : " + if( ::lAllFam, "Todas", AllTrim( ::cFamOrg ) + " > " + AllTrim( ::cFamDes ) ) } }

   if !empty( ::oFilter:cExpresionFilter )
      cExpHead       := ::oFilter:cExpresionFilter
   else
      cExpHead       := ".t."
   end

   ::oDbfFam:OrdSetFocus( "cCodFam" )
   ::oDbfFam:GoTop()

   while !::lBreak .AND. !::oDbfFam:Eof()



      if ::oDbfFam:cCodFam >= ::cFamOrg                      .AND. ::oDbfFam:cCodFam <= ::cFamDes                      .AND. ::EvalFilter()

         ::oDbf:Append()

         ::oDbf:cCodFam     := ::oDbfFam:cCodFam
         ::oDbf:cNomFam     := ::oDbfFam:cNomFam
         ::oDbf:cCodPrp1    := ::oDbfFam:cCodPrp1
         ::oDbf:cCodPrp2    := ::oDbfFam:cCodPrp2
         ::oDbf:cCodGrp     := ::oDbfFam:cCodGrp
         ::oDbf:nValAnu     := ::oDbfFam:nValAnu
         ::oDbf:nEne        := ::oDbfFam:nEne
         ::oDbf:nFeb        := ::oDbfFam:nFeb
         ::oDbf:nMar        := ::oDbfFam:nMar
         ::oDbf:nAbr        := ::oDbfFam:nAbr
         ::oDbf:nMay        := ::oDbfFam:nMay
         ::oDbf:nJun        := ::oDbfFam:nJun
         ::oDbf:nJul        := ::oDbfFam:nJul
         ::oDbf:nAgo        := ::oDbfFam:nAgo
         ::oDbf:nSep        := ::oDbfFam:nSep
         ::oDbf:nOct        := ::oDbfFam:nOct
         ::oDbf:nNov        := ::oDbfFam:nNov
         ::oDbf:nDic        := ::oDbfFam:nDic
         ::oDbf:nPctRpl     := ::oDbfFam:nPctRpl

         ::oDbf:Save()

      end

      ::oDbfFam:Skip()

      ::oMtrInf:AutoInc( ::oDbfFam:OrdKeyNo() )

   end

   ::oMtrInf:AutoInc( ::oDbfFam:LastRec() )

   ::oDlg:Enable()

RETURN ( ::oDbf:LastRec() > 0 )



FUNCTION mkFamilia( cPath, lAppend, cPathOld )

    local cFamilia

    If( lAppend == nil, lAppend := .F., ) ;
   If( cPath == nil, cPath := cPatEmp(), ) ;

   if lExistTable( cPath + "Familias.Dbf", cLocalDriver() )
      fEraseTable( cPath + "Familias.dbf" )
   end

   if lExistTable( cPath + "FamPrv.Dbf", cLocalDriver() )
      fEraseTable( cPath + "FamPrv.Dbf" )
   end

   if lExistTable( cPath + "FamLeng.Dbf", cLocalDriver() )
      fEraseTable( cPath + "FamLeng.Dbf" )
   end

   dbCreate( cPath + "Familias.Dbf", aSqlStruct( aItmFam() ), cLocalDriver() )

   if lAppend .AND. cPathOld <> nil .AND. lIsDir( cPathOld )
      dbUseArea( .T., cDriver(), cPath + "Familias.Dbf", cCheckArea( "Familias", @cFamilia ), .F. )
      if !( cFamilia )->( neterr() )
         ( cFamilia )->( __dbApp( cPathOld + "Familias.Dbf" ) )
         ( cFamilia )->( dbCloseArea() )
      end
   end

   dbCreate( cPath + "FamPrv.Dbf", aSqlStruct( aItmFamPrv() ), cLocalDriver() )

   if lAppend .AND. cPathOld <> nil .AND. lIsDir( cPathOld )
      dbUseArea( .T., cDriver(), cPath + "FamPrv.Dbf", cCheckArea( "FamPrv", @cFamilia ), .F. )
      if !( cFamilia )->( neterr() )
         ( cFamilia )->( __dbApp( cPathOld + "FamPrv.Dbf" ) )
         ( cFamilia )->( dbCloseArea() )
      end
   end

   dbCreate( cPath + "FamLeng.Dbf", aSqlStruct( aItmFamiliaLenguajes() ), cLocalDriver() )

   if lAppend .AND. cPathOld <> nil .AND. lIsDir( cPathOld )
      dbUseArea( .T., cDriver(), cPath + "FamLeng.Dbf", cCheckArea( "FamLeng", @cFamilia ), .F. )
      if !( cFamilia )->( neterr() )
         ( cFamilia )->( __dbApp( cPathOld + "FamLeng.Dbf" ) )
         ( cFamilia )->( dbCloseArea() )
      end
   end

   rxFamilia( cPath, cLocalDriver() )

RETURN .T.



FUNCTION rxFamilia( cPath, cDriver )

    local cFamilia

   If( cPath == nil, cPath := cPatEmp(), ) ;
   If( cDriver == nil, cDriver := cDriver(), ) ;

   if !lExistTable( cPath + "Familias.Dbf", cDriver )
      dbCreate( cPath + "Familias.Dbf", aSqlStruct( aItmFam() ), cDriver )
   end

   fEraseIndex(  cPath + "Familias.Cdx" )

   if !lExistTable( cPath + "FamPrv.Dbf", cDriver )
      dbCreate( cPath + "FamPrv.Dbf", aSqlStruct( aItmFamPrv() ), cDriver )
   end

   fEraseIndex(  cPath + "FamPrv.Cdx" )

   if !lExistTable( cPath + "FamLeng.Dbf", cDriver )
      dbCreate( cPath + "FamLeng.Dbf", aSqlStruct( aItmFamiliaLenguajes() ), cDriver )
   end

   fEraseIndex(  cPath + "FamLeng.Cdx" )

   dbUseArea( .T., cDriver, cPath + "Familias.Dbf", cCheckArea( "FAMILIAS", @cFamilia ), .F. )
   if !( cFamilia )->( neterr() )
      ( cFamilia )->( __dbPack() )

      ( cFamilia )->( ordcondset( "!Deleted()", {|| !Deleted() } ) )
      ( cFamilia )->( ordcreate( cPath + "Familias.Cdx", "cCodFam", "Field->cCodFam", {|| Field->cCodFam }, ) )

      ( cFamilia )->( ordcondset( "!Deleted()", {|| !Deleted() } ) )
      ( cFamilia )->( ordcreate( cPath + "Familias.Cdx", "cNomFam", "Upper( Field->cNomFam )", {|| Upper( Field->cNomFam ) } ) )

      ( cFamilia )->( ordcondset("!Deleted().and. lIncTpv", {|| !Deleted() .AND. Field->lIncTpv } ) )
      ( cFamilia )->( ordcreate( cPath + "Familias.Cdx", "nPosTpv", "Str( Field->nPosTpv )", {|| Str( Field->nPosTpv ) } ) )

      ( cFamilia )->( ordcondset("!Deleted() .and. lIncTpv", {|| !Deleted() .AND. Field->lIncTpv }  ) )
      ( cFamilia )->( ordcreate( cPath + "Familias.Cdx", "lIncTpv", "Upper( cNomFam )", {|| Upper( Field->cNomFam ) } ) )

      ( cFamilia )->( ordcondset( "!Deleted()", {|| !Deleted() } ) )
      ( cFamilia )->( ordcreate( cPath + "Familias.Cdx", "lSelDoc", "lSelDoc", {|| Field->lSelDoc } ) )

      ( cFamilia )->( ordcondset( "!Deleted()", {|| !Deleted() } ) )
      ( cFamilia )->( ordcreate( cPath + "Familias.Cdx", "cType", "cType", {|| Field->cType } ) )

      ( cFamilia )->( ordcondset( "!Deleted()", {|| !Deleted() } ) )
      ( cFamilia )->( ordcreate( cPath + "Familias.Cdx", "cFamCmb", "cFamCmb", {|| Field->cFamCmb } ) )

      ( cFamilia )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de familias" )
   end

   dbUseArea( .T., cDriver, cPath + "FamPrv.Dbf", cCheckArea( "FAMPRV", @cFamilia ), .F. )
   if !( cFamilia )->( neterr() )
      ( cFamilia )->( __dbPack() )

      ( cFamilia )->( ordcondset( "!Deleted()", {||!Deleted()}  ) )
      ( cFamilia )->( ordcreate( cPath + "FamPrv.Cdx", "cCodFam", "cCodFam", {|| Field->cCodFam }, ) )

      ( cFamilia )->( ordcondset( "!Deleted()", {||!Deleted()}  ) )
      ( cFamilia )->( ordcreate( cPath + "FamPrv.Cdx", "cFamPrv", "cCodPrv + cFamPrv", {|| Field->cCodPrv + Field->cFamPrv } ) )

      ( cFamilia )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de familias" )
   end

   dbUseArea( .T., cDriver, cPath + "FamLeng.Dbf", cCheckArea( "FamLeng", @cFamilia ), .F. )
   if !( cFamilia )->( neterr() )
      ( cFamilia )->( __dbPack() )

      ( cFamilia )->( ordcondset( "!Deleted()", {||!Deleted()}  ) )
      ( cFamilia )->( ordcreate( cPath + "FamLeng.Cdx", "cCodFam", "cCodFam", {|| Field->cCodFam }, ) )

      ( cFamilia )->( ordcondset( "!Deleted()", {||!Deleted()}  ) )
      ( cFamilia )->( ordcreate( cPath + "FamLeng.Cdx", "cCodLen", "cCodFam + cCodLen", {|| Field->cCodFam + Field->cCodLen } ) )


      ( cFamilia )->( dbCloseArea() )
   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de lenguajes de familias" )
   end

RETURN NIL



FUNCTION aItmFamPrv()



   local aBase := {  {"CCODFAM",    "C",    16,    0, "Código de familia" }, {"CCODPRV",    "C",    12,    0, "Código de proveedor" }, {"CFAMPRV",    "C",    20,    0, "Código de familia del proveedor" } }

RETURN ( aBase )



FUNCTION aItmFam()













































   local aBase := {  {"cCodFam",    "C",    16,    0, "Código de familia" }, {"cNomFam",    "C",   100,    0, "Nombre de familia" }, {"cCodPrp1",   "C",    10,    0, "Primera propiedad de la familia" }, {"cCodPrp2",   "C",    10,    0, "Segunda propiedad de la familia" }, {"cCodGrp",    "C",     3,    0, "Código de grupo" }, {"lIncTpv",    "L",     1,    0, "Incluir en TPV táctil" }, {"nValAnu",    "N",    16,    6, "Previsiones anual" }, {"nEne",       "N",    16,    6, "Previsiones Enero" }, {"nFeb",       "N",    16,    6, "Previsiones Febrero" }, {"nMar",       "N",    16,    6, "Previsiones Marzo" }, {"nAbr",       "N",    16,    6, "Previsiones Abril" }, {"nMay",       "N",    16,    6, "Previsiones Mayo" }, {"nJun",       "N",    16,    6, "Previsiones Junio" }, {"nJul",       "N",    16,    6, "Previsiones Julio" }, {"nAgo",       "N",    16,    6, "Previsiones Agosto" }, {"nSep",       "N",    16,    6, "Previsiones Septiembre" }, {"nOct",       "N",    16,    6, "Previsiones Octubre" }, {"nNov",       "N",    16,    6, "Previsiones Noviembre" }, {"nDic",       "N",    16,    6, "Previsiones Diciembre" }, {"nDtoLin",    "N",     6,    2, "Porcentaje de descuento por familia" }, {"nPctRpl",    "N",     6,    2, "Porcentaje de rapels" }, {"lPubInt",    "L",     1,    0, "Publicar esta familia en internet" }, {"nColBtn",    "N",    10,    0, "Color del botón" }, {"cImgBtn",    "C",   250,    0, "Imagen del botón" }, {"lSelDoc",    "L",     1,    0, "Lógico para seleccionado" }, {"lPreEsp",    "L",     1,    0, "Lógico para permitir precios especiales" }, {"cCodFra",    "C",     3,    0, "Código de frases publiciarias" }, {"cType",      "C",     6,    0, "Tipo especial de familia" }, {"cFamCmb",    "C",    16,    0, "Familia para combinar" }, {"nPosTpv",    "N",     4,    1, "Posición para mostrar en TPV" }, {"cCodWeb",    "N",    11,    0, "Código para la web" }, {"lAcum",      "L",     1,    0, "Lógico para acumular árticulos" }, {"lMostrar",   "L",     1,    0, "Lógico para mostrar ventana de comentarios" }, {"cCodImp",    "C",     3,    0, "Codigo del orden de impresion comanda" }, {"cNomImp",    "C",    50,    0, "Nombre del orden de impresion comanda" }, {"nPosInt",    "N",     3,    0, "Posición para mostrar en internet" }, {"lFamInt",    "L",     1,    0, "Añade la familia junto con la descripción en internet" }, {"cComFam",    "C",     3,    0, "Comentario por defecto para la familia" }, {"cDesWeb",    "C",   250,    0, "Descripción para la web" }, {"nDiaGrt",    "N",     6,    0, "Días de garantía" }, {"mLngDes",    "M",    10,    0, "Descripción extendida" }, {"cTitSeo",    "C",    70,    0, "Meta-título" }, {"cDesSeo",    "C",   160,    0, "Meta-descripcion" }, {"cKeySeo",    "C",   160,    0, "Meta-keywords" }, {"cIdWP",      "C",    40,    0, "Id relación con WordPress" } }

RETURN ( aBase )



FUNCTION aItmFamiliaLenguajes()

   local aBase := {}

   aAdd( aBase, { "cCodFam",   "C",    16,  0, "Código de la familia" } )
   aAdd( aBase, { "cCodLen",   "C",     4,  0, "Código del lenguaje" } )
   aAdd( aBase, { "cDesFam",   "C",   200,  0, "Descripción familia" } )
   aAdd( aBase, { "mLngDes",   "M",    10,  0, "Descripción extendida" } )

RETURN ( aBase )



FUNCTION lPressCol( nCol, oBrw, oCmbOrd, aCbxOrd, cDbf )

   local nPos
   local cHeader

   if !empty( nCol ) .AND. nCol <= len( oBrw:aHeaders )

      cHeader     := oBrw:aHeaders[ nCol ]
      nPos        := aScan( aCbxOrd, cHeader )

      if nPos <> 0

         oCmbOrd:Set( cHeader )

         ( cDbf )->( OrdSetFocus( oCmbOrd:nAt ) )

         oBrw:Refresh()

      end

   end

RETURN nil



FUNCTION nDescuentoFamilia( cCodFam, oDbfFam )

   local nDescuentoFamilia := 0

   if ValType( oDbfFam ) == "O"
      if oDbfFam:SeekInOrd( cCodFam, "cCodFam" )
         nDescuentoFamilia := oDbfFam:nDtoLin
      end
   else
      if dbSeekInOrd( cCodFam, "cCodFam", oDbfFam )
         nDescuentoFamilia := ( oDbfFam )->nDtoLin
      end
   end

RETURN ( nDescuentoFamilia )



FUNCTION cCodFra( cCodFam, oDbfFam )

   local cCodFra  := ""

   if ValType( oDbfFam ) == "O"
      if oDbfFam:SeekInOrd( cCodFam, "cCodFam" )
         cCodFra  := oDbfFam:cCodFra
      end
   else
      if dbSeekInOrd( cCodFam, "cCodFam", oDbfFam )
         cCodFra  := ( oDbfFam )->cCodFra
      end
   end

RETURN ( cCodFra )



STATIC FUNCTION lValidFamiliaCombinado( aTmp )

   local lValid   := .T.

   if !empty( aTmp[ 1 ] ) .AND. !empty( aTmp[ 29 ] ) .AND. ( aTmp[ 1 ] == aTmp[ 29 ] )

      lValid      := .F.

      MsgStop( "Código de familia no puede ser igual al combinado" )

   end

RETURN ( lValid )



FUNCTION retFamilia( cCodFam, uFamilia )

   local oBlock
   local oError
   local lClose   := .F.
    local cTemp        := Space( 30 )

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if empty( uFamilia )
      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FAMILIAS.DBF" ), ( cCheckArea( "FAMILIAS", @uFamilia ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "Familias.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClose      := .T.
   end

   do case
   case ValType( uFamilia ) == "C"

      if ( uFamilia )->( dbSeek( cCodFam ) )
         cTemp    := ( uFamilia )->cNomFam
      end

   case ValType( uFamilia ) == "O"

      if uFamilia:Seek( cCodFam )
         cTemp    := uFamilia:cNomFam
      end

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClose
      ( uFamilia )->( dbCloseArea() )
   end

RETURN cTemp



FUNCTION cFamilia( oGet, cFamilia, oGet2, lMessage, oGetPrp1, oGetPrp2 )

   local nRec
   local oBlock
   local oError
   local lValid      := .F.
   local lClose      := .F.
   local xValor      := oGet:varGet()

   If( lMessage == nil, lMessage := .T., ) ;

   if empty( xValor ) .OR. ( xValor == Replicate( "Z", 16 ) )
      RETURN .T.
   end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if empty( cFamilia )
      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "FAMILIAS.DBF" ), ( cCheckArea( "FAMILIAS", @cFamilia ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "Familias.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClose         := .T.
   else
      nRec           := ( cFamilia )->( Recno() )
   end

   if dbSeekInOrd( xValor, "cCodFam", cFamilia )

      if !empty( oGet )
         oGet:cText( ( cFamilia )->cCodFam )
      end

      if !empty( oGet2 )
         oGet2:cText( ( cFamilia )->cNomFam )
      end

      if !empty( oGetPrp1 ) .AND. empty( oGetPrp1:VarGet() )
         oGetPrp1:cText( ( cFamilia )->cCodPrp1 )
         oGetPrp1:lValid()
      end

      if !empty( oGetPrp2 ) .AND. empty( oGetPrp2:VarGet() )
         oGetPrp2:cText( ( cFamilia )->cCodPrp2 )
         oGetPrp2:lValid()
      end

      lValid         := .T.

    ELSE

      if lMessage
         msgStop( "Familia no encontrada", "Aviso del sistema" )
      end

    end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClose
      ( cFamilia )->( dbCloseArea() )
   else
      ( cFamilia )->( dbGoTo( nRec ) )
   end

RETURN lValid



STATIC FUNCTION ChangePosition( lInc )

   local aPos
   local nPos     := 1
   local aRec     := {}
   local nRec     := ( D():Familias( nView ) )->( Recno() )
   local nOrd     := ( D():Familias( nView ) )->( OrdSetFocus( "nPosTpv" ) )

   CursorWait()

   do case
      case IsTrue( lInc )

         if ( D():Familias( nView ) )->( dbRLock() )
            ( D():Familias( nView ) )->nPosTpv   := ( D():Familias( nView ) )->nPosTpv + 1.5
         end
         ( D():Familias( nView ) )->( dbUnLock() )

      case IsFalse( lInc )

         if ( D():Familias( nView ) )->( dbRLock() )
            ( D():Familias( nView ) )->nPosTpv   := ( D():Familias( nView ) )->nPosTpv - 1.5
         end
         ( D():Familias( nView ) )->( dbUnLock() )

   end



   ( D():Familias( nView ) )->( dbgotop() )
   while !( D():Familias( nView ) )->( eof() )

      if ( D():Familias( nView ) )->lIncTpv
         aAdd( aRec, { ( D():Familias( nView ) )->( Recno() ), nPos++ } )
      end

      ( D():Familias( nView ) )->( dbSkip() )

   end



   for each aPos in aRec

      ( D():Familias( nView ) )->( dbGoTo( aPos[ 1 ] ) )

      if ( D():Familias( nView ) )->( dbRLock() )
         ( D():Familias( nView ) )->nPosTpv      := aPos[ 2 ]
         ( D():Familias( nView ) )->( dbUnLock() )
      end

   next



   CursorWE()

   ( D():Familias( nView ) )->( dbGoTo( nRec ) )
   ( D():Familias( nView ) )->( OrdSetFocus( nOrd ) )

RETURN ( nil )



FUNCTION ColorFam( oGetColor )

   local oDlg
   local oBmpGeneral
   local oImgColores

   oDlg = TDialog():New(,,,,, "COLORFAM",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )

      oImgColores             := C5ImageView():Redefine( 200, oDlg )
      oImgColores:nWItem      := 131
      oImgColores:nHItem      := 75
      oImgColores:lVScroll    := .F.
      oImgColores:nAlignText  := nOr( 0x00000000, 0x00000001 )
      oImgColores:lTitle      := .T.
      oImgColores:nHTitle     := 12
      oImgColores:lShowOption := .T.
      oImgColores:aTextMargin := { 0, 0, 0, 0 }
      oImgColores:nClrTextSel := ( 0 + ( 0 * 256 ) + ( 0 * 65536 ) )
      oImgColores:bAction     := {|| SeleccionaColor( oImgColores, oGetColor, oDlg ) }

      oImgColores:nOption     := 0

      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Amarillo pastel",   ( 255 + ( 255 * 256 ) + ( 149 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Amarillo señales",  ( 255 + ( 204 * 256 ) + ( 0 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Amarillo miel",     ( 201 + ( 135 * 256 ) + ( 33 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Amarillo ocre",     ( 196 + ( 181 * 256 ) + ( 134 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Pardo verdoso",     ( 143 + ( 141 * 256 ) + ( 97 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Rosa lavanda",      ( 235 + ( 205 * 256 ) + ( 245 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Rosa claro",        ( 232 + ( 156 * 256 ) + ( 181 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Violeta pastel",    ( 172 + ( 134 * 256 ) + ( 164 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Biscuit",           ( 249 + ( 228 * 256 ) + ( 202 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Rojo beige",        ( 204 + ( 130 * 256 ) + ( 115 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Rojo anaranjado",   ( 224 + ( 94 * 256 ) + ( 31 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Verde amarillento", ( 165 + ( 226 * 256 ) + ( 135 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Verde mayo",        ( 88 + ( 186 * 256 ) + ( 78 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Verde oliva",       ( 69 + ( 182 * 256 ) + ( 159 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Cian",              ( 180 + ( 243 * 256 ) + ( 243 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Azul pastel",       ( 196 + ( 215 * 256 ) + ( 225 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Azul luminoso",     ( 50 + ( 134 * 256 ) + ( 209 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Gris ceniza",       ( 226 + ( 224 * 256 ) + ( 228 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Aluminio blanco",   ( 172 + ( 172 * 256 ) + ( 181 * 65536 ) ) ) )
      aAdd( oImgColores:aItems, C5ImageViewItem():New( , "Gris piedra",       ( 145 + ( 145 * 256 ) + ( 135 * 65536 ) ) ) )





      oBmpGeneral := TBitmap():ReDefine( 500, "gc_photographic_filters_48",, oDlg,,, .F., .F.,,, .F.,,, .T. )




     TButton():ReDefine( 2, {||( oDlg:End() )}, oDlg,,, .F.,,,, .F. )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

RETURN .T.



FUNCTION SeleccionaColor( oImgColores, oGetColor, oDlg )

   local nOpt  := oImgColores:nOption

   if empty( nOpt )
      MsgStop( "Seleccione un color" )
      RETURN .F.
   end

   nOpt        := Max( Min( nOpt, len( oImgColores:aItems ) ), 1 )

   if nOpt > 0 .AND. nOpt <= len( oImgColores:aItems )
      oGetColor:cText( oImgColores:aItems[ nOpt ]:nClrPane )
      oGetColor:SetColor( oImgColores:aItems[ nOpt ]:nClrPane, oImgColores:aItems[ nOpt ]:nClrPane )
    end

   oDlg:End()

RETURN .T.



FUNCTION AppFamilia( lOpenBrowse )

   local oBlock
   local oError
   local nLevel         := Auth():Level( "01012" )

   If( lOpenBrowse == nil, lOpenBrowse := .F., ) ;

   if nAnd( nLevel, 1 ) == 0 .OR. nAnd( nLevel, 2 ) == 0
      msgStop( "Acceso no permitido." )
      RETURN .T.
   end

   oBlock               := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      if lOpenBrowse

         if Familia()
            oWndBrw:RecAdd()
         end

      else

         if OpenFiles( .T. )
            WinAppRec( oWndBrw, bEdit, D():Familias( nView ) )
            CloseFiles()
         end

      end

   RECOVER USING oError

      msgStop( ErrorMessage( oError ), "Error añadiendo artículo" )

   end

   ErrorBlock( oBlock )

RETURN .T.






FUNCTION BrwFamiliaCombinada( oGet, cFamilia, oGet2 )

   local oDlg
   local oBrw
   local nRec
   local oGet1
   local cGet1
   local nOrd     := GetBrwOpt( "BrwFamilia" )
   local oCbxOrd
   local aCbxOrd  := { "Código", "Nombre" }
   local cCbxOrd
   local nLevel   := Auth():Level( "01012" )
   local lOpen    := .F.

   nRec           := ( cFamilia )->( RecNo() )

   nOrd           := Min( Max( nOrd, 1 ), len( aCbxOrd ) )
   cCbxOrd        := aCbxOrd[ nOrd ]

   nOrd           := ( cFamilia )->( OrdSetFocus( nOrd ) )

   ( cFamilia )->( dbgotop() )

   oDlg = TDialog():New(,,,, "Familias de artículos", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )






      oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,, {||    ( OrdClearScope( oBrw, cFamilia ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, cFamilia ) ) }, .F., .F.,,,,,, nil, "FIND",, )






      oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,, {|Self|( ( cFamilia )->( OrdSetFocus( oCbxOrd:nAt ) ), oBrw:refresh(), oGet1:SetFocus() )},,,, .F.,,,,,,, "oCbxOrd",,,,,,, )













      oBrw := XbrowseNew( oDlg, 0, 0,,, { {||  ( cFamilia )->cCodFam}, {|| ( cFamilia )->cNomFam} }, {"Código", "Nombre"}, {60 , 200},,,,,,,,, .F., ( cFamilia ),, .F.,, .F., 105, .F., .F. ,,,,, .F., .F., .F., .F.,,,,, .F., .F., "oBrw", )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }

      oBrw:nMarqueeStyle   := 5




      TButton():ReDefine( 1, {||( oDlg:end(1) )}, oDlg,,, .F.,,,, .F. )




      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )





      TButton():ReDefine( 500, {||( nil )}, oDlg,,, .F., {||     ( .F. )},,, .F. )





      TButton():ReDefine( 501, {||( nil )}, oDlg,,, .F., {||     ( .F. )},,, .F. )

   oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )
   oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   DestroyFastFilter( cFamilia )

   SetBrwOpt( "BrwFamilia", ( cFamilia )->( OrdNumber() ) )

   if oDlg:nResult == 1

      oGet:cText( ( cFamilia )->cCodFam )

      if oGet2 <> NIL
         oGet2:cText( ( cFamilia )->cNomFam )
      end

   end

   oGet:SetFocus()

   ( cFamilia )->( dbGoTo( nRec ) )

RETURN ( oDlg:nResult == 1 )



static function sortHashBrowseFamilia( nOrd, oBrw, oCbxOrd, aFamilias )

   if Empty( oBrw )
      Return .T.
   end

   if !Empty( oCbxOrd )
      oCbxOrd:Select( nOrd )
   end

   asort( aFamilias, , , {|x,y| x[nOrd] < y[nOrd] })

   oBrw:Select(0)
   oBrw:Select(1)
   oBrw:Refresh()

RETURN ( .T. )



static function searchHashBrowseFamilia( nPos, oBrw, cGet1, aFamiliasOriginal, aFamilias )

   local aArray

   if Empty( oBrw )
      return .T.
   end

   if Empty( cGet1 )

      aFamilias         := aFamiliasOriginal

      oBrw:setArray( aFamilias, , , .F. )
      oBrw:Select(0)
      oBrw:Select(1)
      oBrw:Refresh()

      return .T.

   end

   aFamilias   := {}

   for each aArray in aFamiliasOriginal

      if AllTrim( Upper( cGet1 ) ) $ AllTrim( Upper( aArray[nPos] ) )
         aAdd( aFamilias, aArray )
      end

   next

   oBrw:setArray( aFamilias, , , .F. )
   oBrw:Select(0)
   oBrw:Select(1)
   oBrw:Refresh()

RETURN ( .T. )



FUNCTION browseHashFamilia( oGet )

   local oDlg
   local oBrw
   local cCod     := Space( 16 )
   local oGet1
   local cGet1
   local nOrd     := GetBrwOpt( "BrwHashFamilia" )
   local oCbxOrd
   local aCbxOrd  := { "Código", "Nombre", "Ruta" }
   local cCbxOrd
   local aFamilias
   local aFamiliasOriginal

   nOrd           := Min( Max( nOrd, 1 ), len( aCbxOrd ) )
   cCbxOrd        := aCbxOrd[ nOrd ]

   if !OpenFiles( .T. )
      RETURN nil
   end

   aFamiliasOriginal    := getHashFamilias()
   aFamilias            := aFamiliasOriginal

   oDlg = TDialog():New(,,,, "Familias de artículos", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )




      oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,,,,,,,, .F.,,, .F., .F.,,,,,, nil, "FIND",, )

         oGet1:bHelp    := {|| searchHashBrowseFamilia( oCbxOrd:nAt, oBrw, cGet1, aFamiliasOriginal, @aFamilias ) }
         oGet1:bValid   := {|| searchHashBrowseFamilia( oCbxOrd:nAt, oBrw, cGet1, aFamiliasOriginal, @aFamilias ) }
         oGet1:bChange  := {|| searchHashBrowseFamilia( oCbxOrd:nAt, oBrw, cGet1, aFamiliasOriginal, @aFamilias ) }






      oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,, {|Self|( sortHashBrowseFamilia( aScan( aCbxOrd, cCbxOrd ), oBrw, oCbxOrd, @aFamilias ) )},,,, .F.,,,,,,, "oCbxOrd",,,,,,, )

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:nMarqueeStyle   := 5
      oBrw:cName           := "Browse.Hash.Familias"

      oBrw:setArray( aFamilias, , , .F. )

      with object ( oBrw:AddCol() )
         :cHeader          := "Código"
         :cSortOrder       := "Código"
         :bEditValue       := {|| aFamilias[ oBrw:nArrayAt, 1 ] }
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | sortHashBrowseFamilia( aScan( aCbxOrd, oCol:cSortOrder ), oBrw, oCbxOrd, @aFamilias ) }
         :bEditValue       := {|| aFamilias[ oBrw:nArrayAt, 1 ] }
         :nWidth           := 120
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "Nombre"
         :bEditValue       := {|| aFamilias[ oBrw:nArrayAt, 2 ] }
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | sortHashBrowseFamilia( aScan( aCbxOrd, oCol:cSortOrder ), oBrw, oCbxOrd, @aFamilias ) }
         :nWidth           := 115
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Ruta"
         :cSortOrder       := "Ruta"
         :bEditValue       := {|| aFamilias[ oBrw:nArrayAt, 3 ] }
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | sortHashBrowseFamilia( aScan( aCbxOrd, oCol:cSortOrder ), oBrw, oCbxOrd, @aFamilias ) }
         :nWidth           := 590
      end

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }
      oBrw:bRClicked       := {| nRow, nCol, nFlags | oBrw:RButtonDown( nRow, nCol, nFlags ) }

      oBrw:CreateFromResource( 105 )




      TButton():ReDefine( 1, {||( oDlg:end(1) )}, oDlg,,, .F.,,,, .F. )




      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )





      TButton():ReDefine( 500, {||.T.}, oDlg,,, .F., {||     .F.},,, .F. )





      TButton():ReDefine( 501, {||.T.}, oDlg,,, .F., {||     .F.},,, .F. )

   oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )
   oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )



   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|( sortHashBrowseFamilia( aScan( aCbxOrd, cCbxOrd ), oBrw, oCbxOrd, @aFamilias ) )}, oDlg:bRClicked,,, )

   if oDlg:nResult == 1

      if !Empty( oGet ) .AND. len( aFamilias ) > 0
         oGet:cText( aFamilias[ oBrw:nArrayAt, 1 ] )
      end

   end

   CloseFiles()

   SetBrwOpt( "BrwHashFamilia", oCbxOrd:nAt )

   if !empty( oGet )
      oGet:SetFocus()
   end

RETURN ( cCod )



FUNCTION nLevelInTree( cCodFam )

   local nCount   := 0

   if OpenFiles()

      nCount   := -1

      nRecursiveLevelInTree( @nCount, cCodFam, D():Familias( nView ) )

      CloseFiles()

   end

Return nCount



static function nRecursiveLevelInTree( nCount, cCodFam, dbfFamilia )

   local nRec
   local nOrd

   if empty( cCodFam )
      cCodFam        := Space( 16 )
   end

   CursorWait()

   nRec              := ( dbfFamilia )->( Recno() )
   nOrd              := ( dbfFamilia )->( OrdSetFocus( "cCodFam" ) )

   if ( dbfFamilia )->( dbSeek( cCodFam ) )

      nCount++

      nRecursiveLevelInTree( @nCount, ( dbfFamilia )->cFamCmb, dbfFamilia )

      SysRefresh()

   end

   ( dbfFamilia )->( OrdSetFocus( nOrd ) )
   ( dbfFamilia )->( dbGoTo( nRec ) )

   CursorWE()

RETURN ( nCount )
