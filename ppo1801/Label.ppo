#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 19 ".\.\Prg\Label.prg"
_HB_CLASS TLabel ; function TLabel ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TLabel", iif( .F., { }, { @HBObject() } ), @TLabel() ) ) ;

      _HB_MEMBER { oDevice, oLblWnd, oBrush, oPenHorz } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oDevice", "oLblWnd", "oBrush", "oPenHorz"}, .F. )
      _HB_MEMBER { aFont, aData, aPen, aDataHeight, aClrText } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aFont", "aData", "aPen", "aDataHeight", "aClrText"}, .F. )


      _HB_MEMBER { bFor, bWhile, bInit, bEnd, bStartLine, bEndLine, bStartLabel, bEndLabel, bStartPage, bEndPage, bSkip, bStdFont, bPreview, bChange } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bFor", "bWhile", "bInit", "bEnd", "bStartLine", "bEndLine", "bStartLabel", "bEndLabel", "bStartPage", "bEndPage", "bSkip", "bStdFont", "bPreview", "bChange"}, .F. )
      _HB_MEMBER { cLblFile, cResName, cFile, cName } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cLblFile", "cResName", "cFile", "cName"}, .F. )



      _HB_MEMBER { nWidth, nHeight, nMargin, nRow, nStartRow, nHSeparator, nVSeparator, nLeftMargin, nRightMargin, nTopMargin, nDnMargin, nBottomRow, nStdLineHeight, nLogPixX, nLogPixY, nFirstdrow, nLastdrow, nCounter, nPageWidth, nPage } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nWidth", "nHeight", "nMargin", "nRow", "nStartRow", "nHSeparator", "nVSeparator", "nLeftMargin", "nRightMargin", "nTopMargin", "nDnMargin", "nBottomRow", "nStdLineHeight", "nLogPixX", "nLogPixY", "nFirstdrow", "nLastdrow", "nCounter", "nPageWidth", "nPage"}, .F. )

      _HB_MEMBER { lFinish, lStable, lPrinter, lScreen, lFirstRow, lCreated, lPreview, lBreak, lSpanish, lShadow, lGrid } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lFinish", "lStable", "lPrinter", "lScreen", "lFirstRow", "lCreated", "lPreview", "lBreak", "lSpanish", "lShadow", "lGrid"}, .F. )
      _HB_MEMBER { cargo, nOnLineNow, nItemNow } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cargo", "nOnLineNow", "nItemNow"}, .F. )
      _HB_MEMBER { hOldRes } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hOldRes"}, .F. )
      _HB_MEMBER { nLblHeight, nLblOnLine, nLblWidth, nItems, aoItems, aColumnStart } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nLblHeight", "nLblOnLine", "nLblWidth", "nItems", "aoItems", "aColumnStart"}, .F. )
      _HB_MEMBER { lNoEnd } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lNoEnd"}, .F. )
     _HB_MEMBER { nLblCurrent } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nLblCurrent"}, .F. )




      _HB_MEMBER New( nLblWidth, nLblHeight, nHSeparator, nVSeparator, nLblOnLine, aFont, aPen, cLblFile, cResName, lPrinter, lScreen, cFile, oDevice, cName, lNoEnd) AS CLASS TLabel; oClass:AddMethod( "New", @TLabel_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )




      _HB_MEMBER AddItem(); oClass:AddInline( "AddItem", {|Self, oItem | ( ( Self ) ), Aadd(::aoItems, oItem ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


      _HB_MEMBER DelItem(); oClass:AddInline( "DelItem", {|Self, nItem | ( ( Self ) ), Adel(::aoItem, nItem ) , Asize(::aoItems, len(::aoItems) - 1 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



      _HB_MEMBER InsItem(); oClass:AddInline( "InsItem", {|Self, oItem , nItem | ( ( Self ) ), Ains(::aoItems, nItem ) , ::aoItems[nItem]:= oItem }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER Stabilize(); oClass:AddMethod( "Stabilize", @TLabel_Stabilize(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Skip( n); oClass:AddMethod( "Skip", @TLabel_Skip(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

     _HB_MEMBER Init(); oClass:AddMethod( "Init", @TLabel_Init(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
     _HB_MEMBER End(); oClass:AddMethod( "End", @TLabel_End(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER StartLabel( nOnLineNow); oClass:AddMethod( "StartLabel", @TLabel_StartLabel(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER EndLabel( nOnLineNow); oClass:AddMethod( "EndLabel", @TLabel_EndLabel(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER StartLine( nHeight); oClass:AddMethod( "StartLine", @TLabel_StartLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER EndLine( nHeight); oClass:AddMethod( "EndLine", @TLabel_EndLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER StartPage(); oClass:AddMethod( "StartPage", @TLabel_StartPage(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER EndPage(); oClass:AddMethod( "EndPage", @TLabel_EndPage(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER NeedNewPage(); oClass:AddInline( "NeedNewPage", {|Self | ( ( Self ) ), ( !::lNoEnd .AND. ( ::nRow >= ::nBottomRow ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


      _HB_MEMBER NewLabel(); oClass:AddInline( "NewLabel", {|Self, nHeight | ( ( Self ) ), ::StartLine(nHeight) ,    iif(!::lFirstRow, ::EndLabel(nHeight), ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


     _HB_MEMBER BackLine(); oClass:AddInline( "BackLine", {|Self, nLine | ( ( Self ) ), ::nRow -= ::nStdLineHeight*     iif(nLine == Nil,1 ,nLine ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


     _HB_MEMBER NewLine(); oClass:AddInline( "NewLine", {|Self, nLine | ( ( Self ) ), ::nRow += ::nStdLineHeight*     iif(nLine == Nil,1 ,nLine ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


     _HB_MEMBER Activate( bFor, bWhile, bInit, bEnd, bStartPage,     bEndPage, bStartLine, bEndLine, bChange); oClass:AddMethod( "Activate", @TLabel_Activate(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

     _HB_MEMBER Play(); oClass:AddMethod( "Play", @TLabel_Play(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

     _HB_MEMBER Margin( nValue,nType,nScale); oClass:AddMethod( "Margin", @TLabel_Margin(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

     _HB_MEMBER Say( nCol, xText, nFont, nPad, nRow); oClass:AddMethod( "Say", @TLabel_Say(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

     _HB_MEMBER SayBitmap( nRow, nCol, cBitmap, nWidth, nHeight, nScale); oClass:AddMethod( "SayBitmap", @TLabel_SayBitmap(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Box( nRow, nCol, nBottom, nRight, nPen, nScale); oClass:AddMethod( "Box", @TLabel_Box(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

     _HB_MEMBER Line( nTop, nLeft, nBottom, nRight, nPen, nScale); oClass:AddMethod( "Line", @TLabel_Line(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
     _HB_MEMBER Shadow( nHeight); oClass:AddMethod( "Shadow", @TLabel_Shadow(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Grid( nHeight, nItem, nLblOnLine); oClass:AddMethod( "Grid", @TLabel_Grid(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER Column(); oClass:AddInline( "Column", {|Self | ( ( Self ) ), ( ::aColumnStart[::nOnLineNow] ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER PhyWidth( nValue, nScale); oClass:AddMethod( "PhyWidth", @TLabel_PhyWidth(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER PhyHeight( nValue, nScale); oClass:AddMethod( "PhyHeight", @TLabel_PhyHeight(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )





      _HB_MEMBER SetTxtColor(); oClass:AddInline( "SetTxtColor", {|Self, nColor,nFont | ( ( Self ) ), (iif(nColor <> NIL .AND.                           nFont   > 0   .AND.                           nFont   < len(::aClrText)                   , ::aClrText[nFont] := nColor, ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER SetPenColor( nColor); oClass:AddMethod( "SetPenColor", @TLabel_SetPenColor(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TLabel ;




static FUNCTION TLabel_New( nLblWidth, nLblHeight, nHSeparator, nVSeparator, nLblOnLine, aFont, aPen, cLblFile, cResName, lPrinter, lScreen, cFile, oDevice, cName, lNoEnd ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel


     LOCAL lFontDefined := .T. , lPenDefined  := .T.











      If( nLblHeight == nil, nLblHeight := 20, ) ; If( nLblWidth == nil, nLblWidth := 120, ); If( nLblOnLine == nil, nLblOnLine := 2, ); If( nHSeparator == nil, nHSeparator := 10, ); If( nVSeparator == nil, nVSeparator := 5, ); If( cResName == nil, cResName := "", ); If( lPrinter == nil, lPrinter := .F., ); If( lScreen == nil, lScreen := .F., ); If( cFile == nil, cFile := "", ); If( cName == nil, cName := "FiveWin Labels", ); If( lNoEnd == nil, lNoEnd := .F., );

      ::cLblFile      = cLblFile
      ::cResName      = cResName
      ::lStable       = .F.
      ::nRow          = 0
      ::nStartRow     = 0
      ::nPage         = 0
      ::nPageWidth    = 0
     ::nLblCurrent   = 1
      ::nLblOnLine    = nLblOnLine
     ::aoItems       = {}
      ::aColumnStart  = {}
      ::nCounter      = 0
      ::nOnLineNow    = 0
     ::nItemNow      = 0
      ::bStdFont      = {|| 1 }
      ::bPreview      = {|oDevice| rPreview(oDevice) }
      ::lPrinter      = lPrinter
     ::lScreen       = lScreen
     ::lFirstRow     = .T.
     ::lCreated      = .F.
      ::lPreview      = .F.
     ::lSpanish      = (GetProfString("intl", "sLanguage") == "esp")
     ::lBreak        = .F.
     ::lShadow       = .F.
     ::cFile         = cFile
      ::cName         = cName
      ::lNoEnd            = lNoEnd





     IF oDevice <> NIL
          ::oDevice := oDevice
     ELSEIF ::lPrinter
             ::oDevice := TPrinter():New(cName,.F.)
      ELSEIF ::lScreen
             ::lPreview := .T.
             ::oDevice := TPrinter():New(cName,.F.,.T.)
     ELSEIF !empty(::cFile)
          ::oDevice := TRFile():New(::cFile)
     ELSE
          ::oDevice := TPrinter():New(cName,.T.)
     ENDIF





     IF empty(::oDevice:hDC)
          RETU NIL
     ELSE
          ::lCreated := .T.
     ENDIF





     ::nWidth  := ::oDevice:nHorzRes()
     ::nHeight := ::oDevice:nVertRes()





      ::nLblHeight    = ::PhyHeight( nLblHeight, 3 )
      ::nLblWidth     = ::PhyWidth( nLblWidth, 3 )





      ::nVSeparator   = ::PhyHeight( nVSeparator, 3 )
      ::nHSeparator   = ::PhyWidth( nHSeparator, 3 )










     ::nLogPixX := Round(::nWidth/(::oDevice:nHorzSize()/25.4),0)
     ::nLogPixY := Round(::nHeight/(::oDevice:nVertSize()/25.4),0)





     IF len(aFont) == 0
          lFontDefined := .F.
          Asize(aFont,1)
          aFont[1] := TFont():New( "Arial", 0, -10,,,,,,,,,,,,,, )
     ENDIF








     ::oPenHorz := TPen():New( 0, Int(1*::nLogPixX/72), 0, )





     IF len(aPen) == 0
          lPenDefined := .F.
          Asize(aPen,1)
          aPen[1] := TPen():New( 0, 1, 0, )
     ENDIF






     ::aFont := Array(len(aFont))

















     Aeval(aFont                                       , {|val,elem|                                    ::aFont[elem]:= TFont():New(val:cFaceName    , Int(val:nWidth*::nLogPixX/72)                , Int(val:nHeight*::nLogPixY/72)               , .F.                                          , val:lBold                                    , val:nEscapement                              , val:nOrientation                             , val:nWeight                                  , val:lItalic                                  , val:lUnderline                               , val:lStrikeOut                               , val:nCharSet                                 , val:nOutPrecision                            , val:nClipPrecision                           , val:nQuality) })

     IF !lFontDefined
          aFont[1]:end()
     ENDIF





     ::aPen := Array(len(aPen))




     Aeval(aPen, {|val,elem|                              ::aPen[elem] := Tpen():New( val:nStyle , Int(val:nWidth*::nLogPixX/72)          , val:nColor)} )

     IF !lPenDefined
          aPen[1]:end()
     ENDIF





     ::aClrText := Array(len(::aFont))

     Aeval(::aClrText,{|val,elem| ::aClrText[elem] := 0 })





     ::nLeftMargin  := Int(::nLogPixX*0.2)
     ::nRightMargin := Int(::nLogPixX*0.2)
     ::nTopMargin   := Int(::nLogPixY*0.2)
     ::nDnMargin    := Int(::nLogPixY*0.2)

RETURN Self



static FUNCTION TLabel_Margin( nValue, nType, nScale ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel



     If( nValue == nil, nValue := .2, ) ; If( nType == nil, nType := 1, ); If( nScale == nil, nScale := 3, );

     IF nScale == 2
             nValue := nValue/2.54
      ELSEIF nScale == 3
             nValue := nValue/25.4
      ENDIF

     DO CASE
     CASE nType == 4
          ::nTopMargin   := Int(::nLogPixY*nValue)
     CASE nType == 5
          ::nDnMargin    := Int(::nLogPixY*nValue)
     CASE nType == 1
          ::nLeftMargin  := Int(::nLogPixX*nValue)
     CASE nType == 2
          ::nRightMargin := Int(::nLogPixX*nValue)
     ENDCASE

     ::lStable := .F.

RETURN Self



static FUNCTION TLabel_Say( nRow, nCol, xText, nFont, nPad ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

     LOCAL nFor
     LOCAL nStartCol
     LOCAL cText
     LOCAL nWidth
     LOCAL cLine
     LOCAL nMemLine





     If( nCol == nil, nCol := 1, ) ; If( nFont == nil, nFont := 1, ); If( xText == nil, xText := "", ); If( nRow == nil, nRow := ::nRow, ); If( nPad == nil, nPad := 1, );

      IF nCol <1 .OR. nCol > len(::aColumnStart)
             nCol := 1
      ENDIF

     IF nFont <1 .OR. nFont > len(::aFont)
          nFont := 1
     ENDIF

     cText  := cValToChar(xText)
     nWidth := ::oDevice:GetTextWidth(cText,::aFont[nFont])

     DO CASE

          CASE nPad == 1
                    nStartCol := ::aColumnStart[nCol]

          CASE nPad == 2
               nStartCol := ::aColumnStart[nCol] + ::aoItems[nCol]:nWidth - nWidth

          CASE nPad == 3
               nStartCol := ::aColumnStart[nCol] + Int( ::aoItems[nCol]:nWidth / 2 ) - Int( nWidth / 2 )
             OTHERWISE
                    nStartCol := ::aColumnStart[nCol]
      ENDCASE

     ::oDevice:Say(nRow, nStartCol, cLine, ::aFont[nFont], nil, ::aClrText[nFont] )

RETURN Self



static FUNCTION TLabel_SayBitmap( nRow, nCol, cBitmap, nWidth, nHeight, nScale ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

     LOCAL nPixRow, nPixCol, nPixWidth, nPixHeight





     If( nRow == nil, nRow := .2, ) ; If( nCol == nil, nCol := .2, ); If( nWidth == nil, nWidth := 1, ); If( nHeight == nil, nHeight := 1, ); If( nScale == nil, nScale := 1, );

     IF nScale == 2
          nRow := Int(nRow/2.54)
          nCol := Int(nCol/2.54)
          nWidth := Int(nWidth/2.54)
             nHeight := Int(nHeight/2.54)
      ELSEIF nScale == 3
             nRow := Int(nRow/25.4)
             nCol := Int(nCol/25.4)
             nWidth := Int(nWidth/25.4)
             nHeight := Int(nHeight/25.4)
      ENDIF

     nPixRow    := Int(::nLogPixY*nRow)
     nPixCol    := Int(::nLogPixX*nCol)
     nPixWidth  := Int(::nLogPixX*nWidth)
     nPixHeight := Int(::nLogPixY*nHeight)

     ::oDevice:SayBitmap(nPixRow, nPixCol, cBitmap, nPixWidth, nPixHeight)

RETURN Self



static FUNCTION TLabel_Box( nRow, nCol, nBottom, nRight, nPen, nScale ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

     LOCAL nPixRow, nPixCol, nPixBottom, nPixRight






     If( nRow == nil, nRow := .2, ) ; If( nCol == nil, nCol := .2, ); If( nBottom == nil, nBottom := 5, ); If( nRight == nil, nRight := 5, ); If( nPen == nil, nPen := 1, ); If( nScale == nil, nScale := 1, );

     IF nScale == 2
          nRow    := Int(nRow/2.54)
          nCol    := Int(nCol/2.54)
          nBottom := Int(nBottom/2.54)
             nRight  := Int(nRight/2.54)
      ELSEIF nScale == 3
             nRow := Int(nRow/25.4)
             nCol := Int(nCol/25.4)
             nBottom := Int(nBottom/25.4)
             nRight  := Int(nRight/25.4)
      ENDIF

      nPixRow    := Int(::nLogPixY*nRow)
      nPixCol    := Int(::nLogPixX*nCol)
      nPixBottom := Int(::nLogPixY*nBottom)
      nPixRight  := Int(::nLogPixX*nRight)

     ::oDevice:Box(nPixRow, nPixCol, nPixBottom, nPixRight, ::aPen[nPen])

RETURN Self



static FUNCTION TLabel_Line( nTop, nLeft, nBottom, nRight, nPen, nScale ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

      LOCAL nPixTop, nPixLeft, nPixBottom, nPixRight






     If( nTop == nil, nTop := .2, ) ; If( nLeft == nil, nLeft := .2, ); If( nBottom == nil, nBottom := 5, ); If( nRight == nil, nRight := 5, ); If( nPen == nil, nPen := 1, ); If( nScale == nil, nScale := 1, );

     IF nScale == 2
          nTop    := Int(nTop/2.54)
          nLeft   := Int(nLeft/2.54)
          nBottom := Int(nBottom/2.54)
             nRight  := Int(nRight/2.54)
      ELSEIF nScale == 3
             nTop    := Int(nTop/25.4)
             nLeft   := Int(nLeft/25.4)
             nBottom := Int(nBottom/25.4)
             nRight  := Int(nRight/25.4)
      ENDIF

     nPixTop    := Int(::nLogPixY*nTop)
     nPixLeft   := Int(::nLogPixX*nLeft)
     nPixBottom := Int(::nLogPixY*nBottom)
     nPixRight  := Int(::nLogPixX*nRight)

     ::oDevice:Line(nPixTop, nPixLeft, nPixBottom, nPixRight, ::aPen[nPen])

RETURN Self



static FUNCTION TLabel_Shadow( nHeight, nItem, nLblOnLine ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

      IF ::oBrush == NIL
          ::oBrush := TBrush():New(, 12632256,,,, )
     ENDIF





      ::oDevice:FillRect({::nRow            , ::aColumnStart[nLblOnLine]   , ::nRow+nHeight               , ::aColumnStart[nLblOnLine]+::aoItems[nItem]:nWidth} , ::oBrush)

RETURN Self



static FUNCTION TLabel_Grid( nHeight, nItem, nLblOnLine ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel





        ::oDevice:line(::nRow + nHeight ,    ::aColumnStart[nLblOnLine] ,    ::nRow + nHeight ,    ::aColumnStart[nLblOnLine] + ::aoItems[nItem]:nWidth ,    ::aPen[ ::aoItems[nItem]:nPen ] )

RETURN Self





static FUNCTION TLabel_Activate( bFor, bWhile, bInit, bEnd, bStartPage,  bEndPage, bStartLabel, bEndLabel, bStartLine,  bEndLine, bChange ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

      LOCAL oPagina


     If( bFor == nil, bFor := {|| .T.    }, ) ; If( bWhile == nil, bWhile := {|| !eof() }, );







     ::bFor        = bFor
     ::bWhile      = bWhile
     ::bInit       = bInit
     ::bEnd        = bEnd
     ::bStartPage  = bStartPage
     ::bEndPage    = bEndPage
      ::bStartLabel = bStartLabel
      ::bEndLabel   = bEndLabel
      ::bStartLine  = bStartLine
      ::bEndLine    = bEndLine
     ::bChange     = bChange





     IF !::lCreated
            ::End()
            RETU NIL
      ENDIF

     ::Stabilize()

     IF !::lStable
             ::End()
          RETU NIL
     ENDIF





    IF !::lPreview

        ::oLblWnd = TDialog():New(,,,, ::cName, "PRINT_PROC",, .F.,,,,,, .F.,,,,,, .F.,, "::oLblWnd", nil, )


        TButton():ReDefine( 2, {||(::lBreak := .T., ::oLblWnd:End())}, ::oLblWnd,,, .F.,,,, .F. )

        oPagina := TSay():ReDefine( 101, {|| ::nPage}, ::oLblWnd,,,, .F.,, .F., .F., )

        ::oLblWnd:bPainted := {|| iif(::nPage>0,oPagina:Refresh(), )}

        ::oLblWnd:bStart := {|| ::Play(),::oLblWnd:End()}

        ::oLblWnd:Activate( ::oLblWnd:bLClicked, ::oLblWnd:bMoved, ::oLblWnd:bPainted, .T.,,,, ::oLblWnd:bRClicked,,, )

   ELSE

        ::oLblWnd = TDialog():New(,,,, ::cName, "PREVIEW_PROC",, .F.,,,,,, .F.,,,,,, .F.,, "::oLblWnd", nil, )


        TButton():ReDefine( 2, {||(::lBreak := .T., ::oLblWnd:End())}, ::oLblWnd,,, .F.,,,, .F. )

        oPagina := TSay():ReDefine( 101, {|| ::nPage}, ::oLblWnd,,,, .F.,, .F., .F., )

        ::oLblWnd:bPainted := {|| iif(::nPage>0,oPagina:Refresh(), )}

        ::oLblWnd:bStart := {|| ::Play(),::oLblWnd:End()}

        ::oLblWnd:Activate( ::oLblWnd:bLClicked, ::oLblWnd:bMoved, ::oLblWnd:bPainted, .T.,,,, ::oLblWnd:bRClicked,,, )

      Eval(::bPreview,::oDevice)

   ENDIF

RETURN Self



static FUNCTION TLabel_Play( ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

   local n := 0
   LOCAL nItems, nFor





   nItems    := len(::aoItems)





   ::StartPage()

   ::Init()





   while !::lBreak .AND. eval(::bWhile)





      if eval(::bFor)





         ::nRow := ::nStartRow





         ::StartLabel( ::nLblCurrent )






         for nFor := 1 to ::nItems

            if ::aoItems[nFor]:lGrid
               ::Grid( ::aoItems[nFor]:nDataHeight, nFor, ::nLblCurrent )
            endif

            if ::aoItems[nFor]:lShadow
               ::Shadow( ::aoItems[nFor]:nDataHeight, nFor, ::nLblCurrent )
            endif

            ::aoItems[nFor]:SayData( ::nRow, ::aColumnStart[::nLblCurrent] )

            ::EndLine( ::aoItems[nFor]:nDataHeight, nFor )

         next





         ::EndLabel(::nLblCurrent)

         ::nLblCurrent++

         if ::nLblCurrent > ::nLblOnLine

            ::nLblCurrent  := 1





            ::nRow      := ::nStartRow + ::nLblHeight + ::nVSeparator






            ::nStartRow := ::nRow





            if ::NeedNewPage()
               ::EndPage()
            end

         end

      end





      SysRefresh()





      ::Skip(1)

   ENDDO

   ::End()

RETURN Self



static FUNCTION TLabel_Stabilize( ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

   LOCAL nFor1, nMaxHeight, nPrnWidth, nColStart

   nMaxHeight := 0

   ::nItems   := len(::aoItems)

   IF ::nItems == 0
        ::lCreated := .F.
        Retu (NIL)
   ENDIF





   ::nStdLineHeight := ::oDevice:GetTextHeight("B",::aFont[eval(::bStdFont)])





   Asend(::aoItems, "Stabilize")





   AEval( ::aoItems, {|val| nMaxHeight += val:nDataHeight } )







   FOR nFor1 := 1 TO ::nItems

      IF ::aoItems[nFor1]:nWidth > ::nLblWidth
         ::aoItems[nFor1]:nWidth := ::nLblWidth
      end

   NEXT





   ::lShadow := .F.
   aeval(::aoItems, {|Val| iif(Val:lShadow,::lShadow := .T. ,NIL ) })





   ::lGrid := .F.
   AEval(::aoItems, {|Val| iif(Val:lGrid,::lGrid := .T. ,NIL ) })





   aeval(::aoItems, {|Val| ::nPageWidth += Val:nWidth + ::nHSeparator })

   ::nPageWidth -= ::nHSeparator

   ::nWidth := min(::nPageWidth, ::nWidth)





    nPrnWidth := ::nWidth - ::nLeftMargin - ::nRightMargin
    ::nMargin := max( Int( (nPrnWidth - ::nPageWidth) /2 ), 0) + ::nLeftMargin





    nColStart := ::nMargin

    FOR nFor1 := 1 TO ::nLblOnLine

        Aadd( ::aColumnStart, nColStart )
        nColStart += ( ::nLblWidth + ::nHSeparator )

    NEXT





   Aeval(::aoItems, {|val| nMaxHeight := Max( nMaxHeight, val:nDataHeight) })






    ::nBottomRow := ::nHeight - ::nDnMargin

    ::nFirstdRow := ::nTopMargin
    ::nLastdRow  := ::nDnMargin





    ::lStable := .T.
    ::lFinish := .F.

RETURN (NIL)



static FUNCTION TLabel_Init( ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

     IF ::bInit <> nil
          Eval( ::bInit )
     ENDIF

RETURN Self



static FUNCTION TLabel_End( ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

     ::lFinish := .T.

      IF !::lCreated .OR. !::lStable

        IF ::oBrush <> NIL
            ::oBrush:end()
        ENDIF
        Asend(::aFont,"End")
        Asend(::aPen,"End")

        if ::oPenHorz <> nil
           ::oPenHorz:End()
        endif

        ::oDevice:End()





        RETU NIL

      ENDIF

     IF !::lBreak .AND. ::bEnd <> nil
          Eval( ::bEnd )
     ENDIF

     ::EndPage()

      SetResources(::hOldRes)

     IF !::lPreview
          ::oDevice:End()
     ENDIF

     IF ::oBrush <> NIL
          ::oBrush:end()
     ENDIF

     Asend(::aFont,"End")
     Asend(::aPen,"End")

     ::oPenHorz:End()

RETURN Self



static FUNCTION TLabel_Skip( n ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

     STATIC lRunning := .F.

     ::nCounter++

     IF ::bChange <> nil .AND. !lRunning
          lRunning := .T.
          Eval( ::bChange )
          lRunning := .F.
     ENDIF

     IF ::bSkip <> nil
             retu Eval( ::bSkip, n )
      ENDIF

RETURN DbSkip( n )



static FUNCTION TLabel_StartPage( ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

     STATIC lRunning := .F.

     ::oDevice:StartPage()





      ::nRow :=    ::nStartRow := ::nTopMargin





     ::nPage++

      ::oLblWnd:Refresh()

     IF ::bStartPage <> nil .AND. !lRunning
          lRunning := .T.
          Eval( ::bStartPage )
          lRunning := .F.
     ENDIF

      ::lFirstRow := .T.

RETURN Self



static FUNCTION TLabel_EndPage( ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

     STATIC lRunning := .F.

     IF ::bEndPage <> nil .AND. !lRunning
          lRunning := .T.
          Eval( ::bEndPage )
          lRunning := .F.
     ENDIF

      ::oDevice:EndPage()

      IF !(::lFinish)
          ::StartPage()
     ENDIF

RETURN Self



static FUNCTION TLabel_StartLine( nHeight ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

     STATIC lRunning := .F.

     If( nHeight == nil, nHeight := ::nStdLineHeight, ) ;

      IF !::lNoEnd .AND. ( ( nHeight + ::nRow ) >= ::nBottomRow )
             ::EndPage()
      ENDIF

     IF ::bStartLine <> nil .AND. !lRunning
          lRunning := .T.
          Eval( ::bStartLine)
          lRunning := .F.
     ENDIF

RETURN Self



static FUNCTION TLabel_EndLine( nHeight, nItem ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

     STATIC lRunning := .F.

     If( nHeight == nil, nHeight := ::nStdLineHeight, ) ;





      ::nRow      += nHeight






      ::nItemNow := nItem

      IF ::bEndLine <> nil .AND. !lRunning
             lRunning := .T.
          Eval( ::bEndLine)
          lRunning := .F.
     ENDIF

      ::lFirstRow := .F.

RETURN Self



static FUNCTION TLabel_StartLabel( nOnLineNow ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

     STATIC lRunning := .F.





      ::nOnLineNow := nOnLineNow

      IF ::bStartLabel <> nil .AND. !lRunning
             lRunning := .T.
             Eval( ::bStartLabel)
          lRunning := .F.
     ENDIF

RETURN Self



static FUNCTION TLabel_EndLabel( nOnLineNow ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

      STATIC lRunning := .F.





      ::nOnLineNow := nOnLineNow

      IF ::bEndLabel <> nil .AND. !lRunning
             lRunning := .T.
             Eval( ::bEndLabel)
             lRunning := .F.
      ENDIF

      ::lFirstRow := .F.

RETURN Self



static FUNCTION TLabel_PhyWidth( nValue, nScale ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

        LOCAL nHorzSize := ( ::oDevice:nHorzRes() / ::oDevice:nHorzSize() )
        LOCAL nRetValue := 0

        If( nValue == nil, nValue := 1, ) ;
        If( nScale == nil, nScale := 3, ) ;

        IF nScale == 1

             nRetValue := nValue * nHorzSize * 25.4

        ELSEIF nScale == 2

             nRetValue := nValue * nHorzSize * 10

        ELSEIF nScale == 3

             nRetValue := nValue * nHorzSize

        end

RETURN Round( nRetValue, 0 )



static FUNCTION TLabel_PhyHeight( nValue, nScale ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

        LOCAL nVertSize := ( ::oDevice:nVertRes() / ::oDevice:nVertSize() )
        LOCAL nRetValue := 0

        If( nValue == nil, nValue := 1, ) ;
        If( nScale == nil, nScale := 3, ) ;

        IF nScale == 1

             nRetValue := nValue * nVertSize * 25.4

        ELSEIF nScale == 2

             nRetValue := nValue * nVertSize * 10

        ELSEIF nScale == 3

             nRetValue := nValue * nVertSize

        end

RETURN Round( nRetValue, 0 )



static FUNCTION TLabel_SetPenColor( nColor ) ; local Self AS CLASS TLabel := QSelf() AS CLASS TLabel

     IF nColor == NIL
          RETU NIL
     ENDIF

     ::oPenHorz:End()




     ::oPenHorz := TPen():New( 0, Int(1*::nLogPixX/72), nColor, )

RETURN Self
