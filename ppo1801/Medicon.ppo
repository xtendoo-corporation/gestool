#line 91 "\fwh1801\include\FiveWin.ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 9 ".\.\Prg\Medicon.prg"
static cFullCurDir

static oMeter
static nMeter  := 0

static oText
static cText   := ""














static hRoles  := { "Fiscal"                => "01", "Oficina contable"      => "01", "Receptor"              => "02", "Organo gestor"         => "02", "Tercero"               => "03", "Pagador"               => "03", "Unidad tramitadora"    => "03", "Comprador"             => "04", "Organo proponente"     => "04", "Cobrador"              => "05", "Vendedor"              => "06", "Receptor del pago"     => "07", "Receptor del cobro"    => "08", "Emisor"                => "09" }






















































































































































































































































static hPaises := { "Afganistán" => "AFG", "Albania" => "ALB", "Alemania" => "DEU", "Algeria" => "DZA", "Andorra" => "AND", "Angola" => "AGO", "Anguila" => "AIA", "Antártida" => "ATA", "Antigua y Barbuda" => "ATG", "Antillas Neerlandesas" => "ANT", "Arabia Saudita" => "SAU", "Argentina" => "ARG", "Armenia" => "ARM", "Aruba" => "ABW", "Australia" => "AUS", "Austria" => "AUT", "Azerbayán" => "AZE", "Bélgica" => "BEL", "Bahamas" => "BHS", "Bahrein" => "BHR", "Bangladesh" => "BGD", "Barbados" => "BRB", "Belice" => "BLZ", "Benín" => "BEN", "Bhután" => "BTN", "Bielorrusia" => "BLR", "Birmania" => "MMR", "Bolivia" => "BOL", "Bosnia y Herzegovina" => "BIH", "Botsuana" => "BWA", "Brasil" => "BRA", "Brunéi" => "BRN", "Bulgaria" => "BGR", "Burkina Faso" => "BFA", "Burundi" => "BDI", "Cabo Verde" => "CPV", "Camboya" => "KHM", "Camerún" => "CMR", "Canadá" => "CAN", "Chad" => "TCD", "Chile" => "CHL", "China" => "CHN", "Chipre" => "CYP", "Ciudad del Vaticano" => "VAT", "Colombia" => "COL", "Comoras" => "COM", "Congo" => "COG", "Congo" => "COD", "Corea del Norte" => "PRK", "Corea del Sur" => "KOR", "Costa de Marfil" => "CIV", "Costa Rica" => "CRI", "Croacia" => "HRV", "Cuba" => "CUB", "Dinamarca" => "DNK", "Dominica" => "DMA", "Ecuador" => "ECU", "Egipto" => "EGY", "El Salvador" => "SLV", "Emiratos Árabes Unidos" => "ARE", "Eritrea" => "ERI", "Eslovaquia" => "SVK", "Eslovenia" => "SVN", "España" => "ESP", "Estados Unidos de América" => "USA", "Estonia" => "EST", "Etiopía" => "ETH", "Filipinas" => "PHL", "Finlandia" => "FIN", "Fiyi" => "FJI", "Francia" => "FRA", "Gabón" => "GAB", "Gambia" => "GMB", "Georgia" => "GEO", "Ghana" => "GHA", "Gibraltar" => "GIB", "Granada" => "GRD", "Grecia" => "GRC", "Groenlandia" => "GRL", "Guadalupe" => "GLP", "Guam" => "GUM", "Guatemala" => "GTM", "Guayana Francesa" => "GUF", "Guernsey" => "GGY", "Guinea" => "GIN", "Guinea Ecuatorial" => "GNQ", "Guinea-Bissau" => "GNB", "Guyana" => "GUY", "Haití" => "HTI", "Honduras" => "HND", "Hong kong" => "HKG", "Hungría" => "HUN", "India" => "IND", "Indonesia" => "IDN", "Irán" => "IRN", "Irak" => "IRQ", "Irlanda" => "IRL", "Isla Bouvet" => "BVT", "Isla de Man" => "IMN", "Isla de Navidad" => "CXR", "Isla Norfolk" => "NFK", "Islandia" => "ISL", "Islas Bermudas" => "BMU", "Islas Caimán" => "CYM", "Islas Cocos (Keeling)" => "CCK", "Islas Cook" => "COK", "Islas de Åland" => "ALA", "Islas Feroe" => "FRO", "Islas Georgias del Sur y Sandwich del Sur" => "SGS", "Islas Heard y McDonald" => "HMD", "Islas Maldivas" => "MDV", "Islas Malvinas" => "FLK", "Islas Marianas del Norte" => "MNP", "Islas Marshall" => "MHL", "Islas Pitcairn" => "PCN", "Islas Salomón" => "SLB", "Islas Turcas y Caicos" => "TCA", "Islas Ultramarinas Menores de Estados Unidos" => "UMI", "Islas Vírgenes Británicas" => "VG", "Islas Vírgenes de los Estados Unidos" => "VIR", "Israel" => "ISR", "Italia" => "ITA", "Jamaica" => "JAM", "Japón" => "JPN", "Jersey" => "JEY", "Jordania" => "JOR", "Kazajistán" => "KAZ", "Kenia" => "KEN", "Kirgizstán" => "KGZ", "Kiribati" => "KIR", "Kuwait" => "KWT", "Líbano" => "LBN", "Laos" => "LAO", "Lesoto" => "LSO", "Letonia" => "LVA", "Liberia" => "LBR", "Libia" => "LBY", "Liechtenstein" => "LIE", "Lituania" => "LTU", "Luxemburgo" => "LUX", "México" => "MEX", "Mónaco" => "MCO", "Macao" => "MAC", "Macedônia" => "MKD", "Madagascar" => "MDG", "Malasia" => "MYS", "Malawi" => "MWI", "Mali" => "MLI", "Malta" => "MLT", "Marruecos" => "MAR", "Martinica" => "MTQ", "Mauricio" => "MUS", "Mauritania" => "MRT", "Mayotte" => "MYT", "Micronesia" => "FSM", "Moldavia" => "MDA", "Mongolia" => "MNG", "Montenegro" => "MNE", "Montserrat" => "MSR", "Mozambique" => "MOZ", "Namibia" => "NAM", "Nauru" => "NRU", "Nepal" => "NPL", "Nicaragua" => "NIC", "Niger" => "NER", "Nigeria" => "NGA", "Niue" => "NIU", "Noruega" => "NOR", "Nueva Caledonia" => "NCL", "Nueva Zelanda" => "NZL", "Omán" => "OMN", "Países Bajos" => "NLD", "Pakistán" => "PAK", "Palau" => "PLW", "Palestina" => "PSE", "Panamá" => "PAN", "Papúa Nueva Guinea" => "PNG", "Paraguay" => "PRY", "Perú" => "PER", "Polinesia Francesa" => "PYF", "Polonia" => "POL", "Portugal" => "PRT", "Puerto Rico" => "PRI", "Qatar" => "QAT", "Reino Unido" => "GBR", "República Centroafricana" => "CAF", "República Checa" => "CZE", "República Dominicana" => "DOM", "Reunión" => "REU", "Ruanda" => "RWA", "Rumanía" => "ROU", "Rusia" => "RUS", "Sahara Occidental" => "ESH", "Samoa" => "WSM", "Samoa Americana" => "ASM", "San Bartolomé" => "BLM", "San Cristóbal y Nieves" => "KNA", "San Marino" => "SMR", "San Martín (Francia)" => "MAF", "San Pedro y Miquelón" => "SPM", "San Vicente y las Granadinas" => "VCT", "Santa Elena" => "SHN", "Santa Lucía" => "LCA", "Santo Tomé y Príncipe" => "STP", "Senegal" => "SEN", "Serbia" => "SRB", "Seychelles" => "SYC", "Sierra Leona" => "SLE", "Singapur" => "SGP", "Siria" => "SYR", "Somalia" => "SOM", "Sri lanka" => "LKA", "Sudáfrica" => "ZAF", "Sudán" => "SDN", "Suecia" => "SWE", "Suiza" => "CHE", "Surinám" => "SUR", "Svalbard y Jan Mayen" => "SJM", "Swazilandia" => "SWZ", "Tadjikistán" => "TJK", "Tailandia" => "THA", "Taiwán" => "TWN", "Tanzania" => "TZA", "Territorio Británico del Océano Índico" => "IOT", "Territorios Australes y Antárticas Franceses" => "ATF", "Timor Oriental" => "TLS", "Togo" => "TGO", "Tokelau" => "TKL", "Tonga" => "TON", "Trinidad y Tobago" => "TTO", "Tunez" => "TUN", "Turkmenistán" => "TKM", "Turquía" => "TUR", "Tuvalu" => "TUV", "Ucrania" => "UKR", "Uganda" => "UGA", "Uruguay" => "URY", "Uzbekistán" => "UZB", "Vanuatu" => "VUT", "Venezuela" => "VEN", "Vietnam" => "VNM", "Wallis y Futuna" => "WLF", "Yemen" => "YEM", "Yibuti" => "DJI", "Zambia" => "ZMB", "Zimbabue" => "ZWE" }



Function aRolesValues()

Return hGetKeys( hRoles )



Function getRolCode( cRolName )

   local cRolCode := ""

   if empty( cRolName )
      Return ( cRolCode )
   end

   cRolName       := alltrim( cRolName )

   if hHasKey( hRoles, cRolName )
      cRolCode    := hGet( hRoles, cRolName )
   end

Return ( cRolCode )



Function aPaisesValues()

Return hGetKeys( hPaises )



Function getPaisCode( cPaisName )

   local cPaisCode := ""

   if empty( cPaisName )
      Return ( cPaisCode )
   end

   cPaisName       := alltrim( cPaisName )

   if hHasKey( hPaises, cPaisName )
      cPaisCode    := hGet( hPaises, cPaisName )
   end

Return ( cPaisCode )










FUNCTION LJust( cCadena, cChar, nLen )

    If( cChar == nil, cChar := " ", ) ;
    If( nLen == nil, nLen := Len( cCadena ), ) ;

    IF ValType( cCadena ) == "N"
        cCadena := Str( Int( cCadena ) )
    end

RETURN PadR( AllTrim( cCadena ), nLen, cChar )







FUNCTION cHoy( dFecha )

    local cMes











    local aMeses := { "Enero",    "Febrero",    "Marzo",    "Abril",    "Mayo",    "Junio",    "Julio",    "Agosto",    "Septiembre",    "Octubre",    "Noviembre",    "Diciembre" }

    If( dFecha == nil, dFecha := DATE(), ) ;

    cMes    := aMeses[ month( dFecha ) ]

RETURN ( Str(Day(dFecha)) + " de " +  cMes + " de " + str(year(dFecha)) )








FUNCTION Compile( cExpression )

    local bExpression

   if !Empty( cExpression ) .AND. Type( cExpression ) <> "UE" .AND. Type( cExpression ) <> "UI"
      bExpression    := &( "{|| " + Rtrim( cExpression ) + " } " )
   else
      bExpression    := nil
   end

RETURN ( bExpression )



FUNCTION CompileParam( cExpression )

   local lError
   local oError
   local oBlock
   local bExpression

   lError            := .F.

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      bExpression    := &( "{| uParam | " + Rtrim( cExpression ) + " } " )

   RECOVER USING oError

      lError         := .T.

   end

   ErrorBlock( oBlock )

   if lError

      msgStop( "Expresión incorrecta " + cExpression + Chr(13)+Chr(10) + ErrorMessage( oError ), cExpression )

      bExpression    := nil

   end

RETURN ( bExpression )






FUNCTION FullCurDir()

   if empty( cFullCurDir )

      cFullCurDir    := hb_curdrive()

      if isalpha( cFullCurDir ) .AND. ( cFullCurDir <> "A" )
         cFullCurDir += ":\"
      else
         cFullCurDir := "\"
      end

      cFullCurDir    += curdir() + if( !empty( curdir() ), "\", "" )

   end

RETURN ( cFullCurDir )



FUNCTION FullQrDir()

    local cCurDir   := FullCurDir() + "QRBmp"

    if !isDirectory( cCurDir )
       Makedir( cCurDir )
    end

RETURN ( cCurDir + "\" )



FUNCTION EaseQrFiles()

    EraseFilesInDirectory( FullQrDir() )

Return nil







FUNCTION nlen( xVar, xPicture )

   LOCAL nLen  := 0
   LOCAL cTipo := ValType( xVar )

   do case
      case ( cTipo == "N" ) .AND. ( xPicture == NIL )
            nLen := len( str( xVar ) )

      case ( cTipo == "N" ) .AND. ( xPicture <> NIL )
            nLen := len( Transform( xVar, xPicture ) )

      case ( cTipo == "C" ) .AND. ( xPicture == NIL )
            nLen := len( xVar )

      case ( cTipo == "C" ) .AND. ( xPicture <> NIL )
            nLen := len( Transform( xVar, xPicture ) )

      case ( cTipo == "D" )
             nLen := len( dtoc( xVar ) )

      case ( cTipo == "L" )
             nLen := 1

      case ( cTipo == "A" )
             nLen := Len( xVar )

      case ( cTipo == "B" )
          nLen := nLen( Eval( xVar ) )

   end

RETURN nLen



FUNCTION nPadR( cText, nSize, oFont, nCol, oInf )

    local nStartCol
    local nWidth

    nWidth         := oInf:oDevice:GetTextWidth( cText, oFont ) / oInf:nLogPixX
    nSize            := oInf:oDevice:GetTextWidth( Replicate( "B", nSize),    oFont ) / oInf:nLogPixX

   nStartCol   := nCol - nWidth + nSize

RETURN nStartCol



FUNCTION nPadC( cText, nSize, oFont, nCol, oInf )

    local nStartCol
    local nWidth

    nWidth         := oInf:oDevice:GetTextWidth( cText, oFont ) / oInf:nLogPixX
    nSize            := oInf:oDevice:GetTextWidth( Replicate( "B", nSize),    oFont ) / oInf:nLogPixX

    nStartCol    := nCol + ( ( nWidth - nSize ) / 2 )

RETURN nStartCol



FUNCTION cDayToStr( dDate )

RETURN ( { "Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado" }[ DoW( dDate ) ] )



FUNCTION cMonthToStr( dDate )


RETURN ( {  "Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre" }[ Month( dDate ) ] )





function aPrinterInfo( cPrnName )

   local aInfo    := {}

return ( aInfo )



Function GoWeb( cUrl )

   If( cUrl == nil, cUrl := "http://www.gestool.es", ) ;

   IF !IsWinNt()
      WinExec("start urlto:"+cURL,0)
   ELSE
      WinExec("rundll32.exe url.dll,FileProtocolHandler " + cURL)
   ENDIF

Return NIL



Function GoHelp( cUrl )

   IF !IsWinNt()
      WinExec( "start urlto:" + "http://www.gestool.es/ayuda/Index.html" , 0 )
   ELSE
      WinExec( "rundll32.exe url.dll,FileProtocolHandler " + "http://www.gestool.es/ayuda/Index.html" )
   ENDIF

Return NIL



Static Function DecodeUrlHelp( cUrl )

   cUrl     := StrTran( cUrl, " ", "_" )
   cUrl     := StrTran( cUrl, "ñ", "%C3%B1" )
   cUrl     := StrTran( cUrl, "Ñ", "%C3%91" )
   cUrl     := StrTran( cUrl, "á", "%C3%A1" )
   cUrl     := StrTran( cUrl, "é", "%C3%A9" )
   cUrl     := StrTran( cUrl, "í", "%C3%AD" )
   cUrl     := StrTran( cUrl, "ó", "%C3%B3" )
   cUrl     := StrTran( cUrl, "ú", "%C3%BA" )
   cUrl     := StrTran( cUrl, "Á", "%C3%81" )
   cUrl     := StrTran( cUrl, "É", "%C3%89" )
   cUrl     := StrTran( cUrl, "Í", "%C3%8D" )
   cUrl     := StrTran( cUrl, "Ó", "%C3%93" )
   cUrl     := StrTran( cUrl, "Ú", "%C3%9A" )

Return ( cUrl )






Function cNamePath( cFile )

   local nPos     := 0
   local cPath    := ""

   if ( nPos := rat( "\", cFile ) ) <> 0
      cPath       := ( substr( cFile, 1, nPos - 1 ) )
   endif

Return( cPath )



FUNCTION RJustObj( oGet, cChar, nLen )

   local cCadena  := oGet:varGet()

   If( cChar == nil, cChar := " ", ) ;
   If( nLen == nil, nLen := Len( cCadena ), ) ;

   cCadena        := RJust( cCadena, cChar, nLen )

    oGet:varPut( cCadena )
    oGet:refresh()

RETURN cCadena



FUNCTION PntReplace( oGet, cChar, nLen )

   local cCadena     := ""
   local nPointPos

   if !hb_isobject( oGet )
      RETURN cCadena
   end

   cCadena           := oGet:varGet()

   If( cChar == nil, cChar := "0", ) ;
   If( nLen == nil, nLen := len( cCadena ), ) ;

   nPointPos         := at( ".", cCadena )

    if nPointPos <> 0

      cCadena        := strtran( cCadena, ".", "0" )

        while len( alltrim( cCadena ) ) < nLen
            cCadena     := substr( cCadena, 1, nPointPos - 1 ) + cChar + substr( cCadena, nPointPos )
        end

        oGet:cText( cCadena )

    end

RETURN cCadena








FUNCTION RJust( cCadena, cChar, nLen )

    If( cChar == nil, cChar := "0", ) ;
    If( nLen == nil, nLen := Len( cCadena ), ) ;

    IF ValType( cCadena ) == "N"
        cCadena    := Str( Int( cCadena ) )
    end

RETURN PadL( AllTrim( cCadena ), nLen, cChar )



FUNCTION nextDocumentNumber( cNumero, nLen )

   local nAt
   local cSerie     := ""
   local nNumero

   If( cNumero == nil, cNumero := "0", ) ;
   If( nLen == nil, nLen := 50, ) ;

   if ValType( cNumero ) == "N"
      cNumero       := str( cNumero )
   end

   cNumero          := alltrim( cNumero )

   nAt              := rat( "/", cNumero )
   if nAt == 0
      nNumero       := val( cNumero ) + 1
      RETURN ( padr( rjust( nNumero, "0", 6 ), nLen ) )
   end

   cSerie           := substr( cNumero, 1, nAt  )
   nNumero          := val( substr( cNumero, nAt + 1 ) ) + 1

RETURN ( padr( cSerie + rjust( nNumero, "0", 6 ), nLen ) )



Function GetSubArray( aArray, nPos )

   local a
   local aKeys    := {}

   for each a in aArray
      if !empty(a[ nPos ])
         aAdd( aKeys, a[ nPos ] )
      end
   next

RETURN ( aKeys )



FUNCTION cGetValue( xVal, cType )

   local cTemp    := ""

   If( cType == nil, cType := ValType( xVal ), ) ;

   xVal           := IsCharBlock( xVal )

   do case
      case cType == "C" .OR. cType == "M"

         if !Empty( xVal )
            xVal  := Rtrim( xVal )
         end

         if ( '"' $ xVal ) .OR. ( "'" $ xVal )
            cTemp := Rtrim( cValToChar( xVal ) )
         else
            cTemp := '"' + Rtrim( cValToChar( xVal ) ) + '"'
         end

      case cType == "N"
         cTemp    := cValToChar( xVal )

      case cType == "D"

         cTemp    := 'Ctod( "' + Rtrim( cValToChar( xVal ) ) + '" )'

      case cType == "L"
         if "S" $ Rtrim( Upper( xVal ) )
            cTemp := ".t."
         else
            cTemp := ".f."
         end

   end

RETURN ( Rtrim( cTemp ) )



Static Function IsCharBlock( xVal )

   if IsChar( xVal )

      xVal           := AllTrim( xVal )

      if left( xVal, 1 ) == "{" .AND. right( xVal, 1 ) == "}"
         xVal        := StrTran( xVal, "{", "" )
         xVal        := StrTran( xVal, "}", "" )
         xVal        := c2Block( xVal )
         if IsBlock( xVal )
            xVal     := Eval( xVal )
         end

      end

   end

Return ( xVal )



Function ReplaceCreator( oShell, cDbf, aStructure, cType )

   local oReplaceDialog

   oReplaceDialog       := TReplaceCreator():Init( oShell )

   if !Empty( oReplaceDialog )
      oReplaceDialog:SetFields( aStructure )
      oReplaceDialog:SetFilterType( cType )
      oReplaceDialog:SetDatabaseToReplace( cDbf )
      oReplaceDialog:Dialog()
      oReplaceDialog:End()
   end

RETURN ( nil )



Function AutoMeterDialog( oDialog )

   oDialog:Disable()

   oMeter   := TMeter():New( 0, 0, {| u | if( pCount() == 0, nMeter, nMeter := u ) }, 100, oDialog, oDialog:nWidth, 4, .T., .T., , "", .T., , ,( 128 + ( 255 * 256 ) + ( 0 * 65536 ) ) )

RETURN ( oMeter )



Function SetTotalAutoMeterDialog( nSet )

   if !empty(oMeter)
      oMeter:SetTotal( nSet )
   end

RETURN ( oMeter )



Function SetAutoMeterDialog( nSet )

   if !empty(oMeter)
      oMeter:Set( nSet )
   end

RETURN ( oMeter )



Function EndAutoMeterDialog( oDialog )

   if !empty( oMeter )
      oMeter:Hide()
      oMeter:End()
   end

   oMeter   := nil

   oDialog:Enable()

RETURN ( nil )



Function GetAutoMeterDialog( nSet )

RETURN ( oMeter )



Function autoTextDialog( oDialog, textColor, backgroundColor )

   If( textColor == nil, textColor := ( 0 + ( 0 * 256 ) + ( 0 * 65536 ) ), ) ;
   If( backgroundColor == nil, backgroundColor := ( 239 + ( 228 * 256 ) + ( 176 * 65536 ) ), ) ;

   oText                    := TSay():New( 2, 0, {||cText}, oDialog, , , .T., .F., .F., .T., textColor, backgroundColor, oDialog:nWidth, 16, .F., .T., .F., .F., .F. )

RETURN ( oText )



Function SetAutoTextDialog( cText, oDialog, textColor, backgroundColor )

   If( textColor == nil, textColor := ( 0 + ( 0 * 256 ) + ( 0 * 65536 ) ), ) ;
   If( backgroundColor == nil, backgroundColor := ( 239 + ( 228 * 256 ) + ( 176 * 65536 ) ), ) ;

   if empty(oText) .AND. !empty(oDialog)
      autoTextDialog( oDialog, textColor, backgroundColor )
   end

   if !empty(oText)
      oText:SetText( cText )
   end

   sysRefresh()

RETURN ( oText )



Function setAlertTextDialog( cText, oDialog )

Return ( setAutoTextDialog( cText, oDialog, ( 255 + ( 255 * 256 ) + ( 255 * 65536 ) ), ( 234 + ( 67 * 256 ) + ( 53 * 65536 ) ) ) )



Function HideAutoTextDialog()

   if !empty(oText)
      oText:Hide()
   end

RETURN ( oText )



Function EndAutoTextDialog()

   HideAutoTextDialog()

   if !empty(oText)
      oText:End()
      oText   := nil
   end

RETURN ( nil )



Function GetAutoTextDialog()

RETURN ( oText )
