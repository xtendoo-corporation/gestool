#line 20 ".\.\Prg\MsTable.prg"
function TMyTable( cCls )
return( MyGenClass( cCls, TVMyTable() ) )




_HB_CLASS TVMyTable ; function TVMyTable ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TVMyTable", iif( .T., { @TMSTable() }, { @HBObject() } ), @TVMyTable() ) ) ;

    _HB_MEMBER { lGenDataField } ; oClass:AddMultiData(, .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lGenDataField"}, .F. )

    _HB_MEMBER Open(); oClass:AddMethod( "Open", @TVMyTable_Open(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TVMyTable ;




static FUNCTION TVMyTable_Open( ) ; local Self AS CLASS TVMyTable := QSelf() AS CLASS TVMyTable

    local lRet := ::Super:Open()

    if lRet .AND. ::lGenDataField
        MyGenDataField( Self )
        ::lGenDataField := .F.
    endif

return( lRet )







_HB_CLASS TMSTable ; function TMSTable ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TMSTable", iif( .T., { @TMSQuery() }, { @HBObject() } ), @TMSTable() ) ) ;

    _HB_MEMBER { cName } ; oClass:AddMultiData(, "", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cName"}, .F. )
    _HB_MEMBER { cWhere } ; oClass:AddMultiData(, "", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cWhere"}, .F. )
    _HB_MEMBER { cHaving } ; oClass:AddMultiData(, "", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cHaving"}, .F. )
    _HB_MEMBER { cOrderBy } ; oClass:AddMultiData(, "", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cOrderBy"}, .F. )
    _HB_MEMBER { lOpenTable } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lOpenTable"}, .F. )
    _HB_MEMBER { aBuffer } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aBuffer"}, .F. )

    _HB_MEMBER { aKey } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aKey"}, .F. )
    _HB_MEMBER { nColAutoInc } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nColAutoInc"}, .F. )

    _HB_MEMBER { nLimit } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nLimit"}, .F. )

    _HB_MEMBER New( oDbCon, cName, cWhere, cHaving, cOrderBy, nLimit) AS CLASS TMSTable; oClass:AddMethod( "New", @TMSTable_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Open(); oClass:AddMethod( "Open", @TMSTable_Open(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER CreateTable( aStruct, cType, lTemporary, lNotExists); oClass:AddMethod( "CreateTable", @TMSTable_CreateTable(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER Insert( lRefresh); oClass:AddMethod( "Insert", @TMSTable_Insert(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Update( lRefresh, nLimit); oClass:AddMethod( "Update", @TMSTable_Update(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Delete( lRefresh, nLimit); oClass:AddMethod( "Delete", @TMSTable_Delete(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER CreateIndex( cIndex, xCol, lUnique); oClass:AddMethod( "CreateIndex", @TMSTable_CreateIndex(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER DropIndex( cIndex); oClass:AddMethod( "DropIndex", @TMSTable_DropIndex(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER CreatePrimaryKey( xCol); oClass:AddMethod( "CreatePrimaryKey", @TMSTable_CreatePrimaryKey(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER AlterEngine( cNewType); oClass:AddMethod( "AlterEngine", @TMSTable_AlterEngine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Load(); oClass:AddMethod( "Load", @TMSTable_Load(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Blank(); oClass:AddMethod( "Blank", @TMSTable_Blank(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER GetBuffer( n); oClass:AddMethod( "GetBuffer", @TMSTable_GetBuffer(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER SetBuffer( n, Val); oClass:AddMethod( "SetBuffer", @TMSTable_SetBuffer(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER FieldPut( n, Val); oClass:AddMethod( "FieldPut", @TMSTable_SetBuffer(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER GenSelect(); oClass:AddMethod( "GenSelect", @TMSTable_GenSelect(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER GenWhere(); oClass:AddMethod( "GenWhere", @TMSTable_GenWhere(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER SetWhere( cWhere, lRefresh); oClass:AddMethod( "SetWhere", @TMSTable_SetWhere(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER SetHaving( cHaving, lRefresh); oClass:AddMethod( "SetHaving", @TMSTable_SetHaving(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER SetOrderBy( cOrderBy, lDesc, lRefresh); oClass:AddMethod( "SetOrderBy", @TMSTable_SetOrderBy(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER SetLimit( nLimit, lRefresh); oClass:AddMethod( "SetLimit", @TMSTable_SetLimit(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER SetSelect( cWhere, cHaving, cOrderBy, nLimit, lRefresh); oClass:AddMethod( "SetSelect", @TMSTable_SetSelect(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )




    _HB_MEMBER Lock() ; oClass:AddVirtual( "Lock" )
    _HB_MEMBER UnLock() ; oClass:AddVirtual( "UnLock" )



    _HB_MEMBER ShowCreate(); oClass:AddMethod( "ShowCreate", @TMSTable_ShowCreate(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ImportData(); oClass:AddMethod( "ImportData", @TMSTable_ImportData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TMSTable ;




static FUNCTION TMSTable_New( oDbCon, cName, cWhere, cHaving, cOrderBy, nLimit ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    ::Super:New( oDbCon )

    if ::lInit

        ::cName         := cName
        if ValType( cWhere ) == "C"
            ::cWhere    := cWhere
        endif
        if ValType( cHaving ) == "C"
            ::cHaving   := cHaving
        endif
        if ValType( cOrderBy ) == "N"
            cOrderBy    := LTrim( Str( cOrderBy ) )
        endif
        if ValType( cOrderBy ) == "C"
            ::cOrderBy  := cOrderBy
        endif
        if ValType( nLimit ) == "N"
            ::nLimit    := nLimit
        endif

        ::GenSelect()

    endif

    ::SetIName( "Table" )

return( Self )




static FUNCTION TMSTable_Open( ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local lRet             := ::Super:Open()



    if lRet .AND. !::lOpenTable
        ::lOpenTable     := .T.
        ::aBuffer         := Array( ::FieldCount() )
        ::nColAutoInc     := E1FieldAutoInc( ::hMySQL )
        ::aKey             := E1ListKey( ::hMySQL )
    endif

return( lRet )




static FUNCTION TMSTable_CreateTable( aStruct, cType, lTemporary, lNotExists ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local n, nLen, cStmt, lAutoInc
    local lRet := .F.

    if ::lInit
        if ValType( aStruct ) == "A"

            if ValType( lTemporary ) == "L" .AND. lTemporary
                cStmt := "CREATE TEMPORARY TABLE "
            else
                cStmt := "CREATE TABLE "
            endif

            if ValType( lNotExists ) == "L" .AND. lNotExists
                cStmt += "IF NOT EXISTS "
            endif

            cStmt += ::cName + " ( "

            nLen := len( aStruct )

            for n := 1 to nLen

                if len( aStruct[ n ] ) == 5 .AND.  ValType( aStruct[ n, 5 ] ) == "L"
                    lAutoInc := aStruct[ n, 5 ]
                else
                    lAutoInc := .F.
                endif



                cStmt += aStruct[ n, 1 ] + " " +  _ColDefine( aStruct[ n, 2 ],  aStruct[ n, 3 ],  aStruct[ n, 4 ], lAutoInc ) + ", "
            next

            cStmt := ChgAtEnd( cStmt, " )", 2 )

            if ValType( cType ) == "C"
                cType := upper( cType )















                if  cType == "ARCHIVE" .OR.  cType == "CSV" .OR.  cType == "EXAMPLE" .OR.  cType == "FEDERATED" .OR.  cType == "HEAP" .OR.  cType == "ISAM" .OR.  cType == "INNODB" .OR.  cType == "MEMORY" .OR.  cType == "MERGE" .OR.  cType == "MYISAM" .OR.  cType == "NDBCLUSTER" .OR.  cType == "BDB" .OR.  cType == "GEMINI" .OR.  cType == "MRG_MYISAM" .OR.  cType == "BLACKHOLE"
                    cStmt += " TYPE = " + cType
                endif
            endif
            lRet := ::oCmd:ExecDirect( cStmt )
        else
            ::oError:Say( "La estructura debe ser un array...", .F. )
        endif
    endif

return( lRet )




static FUNCTION TMSTable_CreateIndex( cIndex, xCol, lUnique ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local nLen, i
    local cStmt := "CREATE "

    if ValType( lUnique ) == "L" .AND. lUnique
        cStmt += "UNIQUE "
    endif

    cStmt += "INDEX " + cIndex + " ON " + ::cName + " ( "

    if ValType( xCol ) == "A"
        nLen := len( xCol )
        for i := 1 to nLen
            cStmt += xCol[ i ] + ", "
        next
        cStmt := ChgAtEnd( cStmt, " )", 2 )
    else
        cStmt += xCol + " )"
    endif

return( ::oCmd:ExecDirect( cStmt ) )




static FUNCTION TMSTable_DropIndex( cIndex ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable
return( ::oCmd:ExecDirect( "DROP INDEX " + cIndex + " ON " + ::cName ) )




static FUNCTION TMSTable_CreatePrimaryKey( xCol ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local nLen, i
    local cStmt := "ALTER TABLE " + ::cName + " ADD PRIMARY KEY ( "

    if ValType( xCol ) == "A"
        nLen := len( xCol )
        for i := 1 to nLen
            cStmt += xCol[ i ] + ", "
        next
        cStmt := ChgAtEnd( cStmt, " )", 2 )
    else
        cStmt += xCol + " )"
    endif

return( ::oCmd:ExecDirect( cStmt ) )



static FUNCTION TMSTable_ShowCreate( ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local cRet
    local oQry := TMSQuery():New( ::oConnect )

    if oQry:Open( "SHOW CREATE TABLE "+ ::cName )
        cRet := oQry:FieldGet( 2 )
    else
        cRet := ""
    endif

    oQry:Free()

return( cRet )




static FUNCTION TMSTable_GenSelect( lRefresh ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local lRet

    ::cStatement := "SELECT * FROM " + ::cName
    ::cStatement += if( empty( ::cWhere ), "", " WHERE " + ::cWhere )
    ::cStatement += if( empty( ::cHaving ), "", " HAVING " + ::cHaving )
    ::cStatement += if( empty( ::cOrderBy ), "", " ORDER BY " + ::cOrderBy )
    ::cStatement += if( empty( ::nLimit ), "", " LIMIT " + LTrim( str( ::nLimit ) ) )

    if ValType( lRefresh ) = "L" .AND. lRefresh
        lRet := ::Refresh()
    else
        lRet := .T.
    endif

return( lRet )




static FUNCTION TMSTable_SetWhere( cWhere, lRefresh ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local lRet := ( ValType( cWhere ) == "C" )

    if lRet
        ::cWhere := cWhere
        lRet := ::GenSelect( lRefresh )
    endif

return( lRet )




static FUNCTION TMSTable_SetHaving( cHaving, lRefresh ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local lRet := ( ValType( cHaving ) == "C" )

    if lRet
        ::cHaving := cHaving
        lRet := ::GenSelect( lRefresh )
    endif

return( lRet )




static FUNCTION TMSTable_SetOrderBy( cOrderBy, lDesc, lRefresh ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local lRet
    local cType := ValType( cOrderBy )

    if cType == "N" .AND. ( cOrderBy > 0 .AND. cOrderBy <= ::FieldCount() )
        cOrderBy := LTrim( str( cOrderBy ) )
    else
        ::oError:Say( "No es un numero de columna valido", .T. )
    endif

    if ValType( cOrderBy ) == "C"
        if ValType( lDesc ) == "L" .AND. lDesc
            cOrderBy += " DESC"
        endif
        ::cOrderBy := cOrderBy
        lRet := ::GenSelect( lRefresh )
    else
        lRet := .F.
    endif

return( lRet )




static FUNCTION TMSTable_SetLimit( nLimit, lRefresh ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local lRet := ( ValType( nLimit ) == "N" )

    if lRet
        ::nLimit := nLimit
        lRet := ::GenSelect( lRefresh )
    endif

return( lRet )




static FUNCTION TMSTable_SetSelect( cWhere, cHaving, cOrderBy, nLimit, lRefresh ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    if ValType( cWhere ) == "C"; ::cWhere := cWhere; endif
    if ValType( cHaving ) == "C"; ::cHaving := cHaving; endif
    if ValType( cOrderBy ) == "N"
        cOrderBy := LTrim( str( cOrderBy ) )
    endif
    if ValType( cOrderBy ) == "C"; ::cOrderBy := cOrderBy; endif
    if ValType( nLimit ) == "N"; ::nLimit := nLimit; endif

return( ::GenSelect( lRefresh ) )





static FUNCTION TMSTable_Insert( lRefresh ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local n, lRet
    local nLen := ::FieldCount()
    local aBuffer := ::ImportData()
    local cStmt := "INSERT INTO " + ::cName + " VALUES ( "

    for n := 1 to nLen





        cStmt += if( !( aBuffer[ n ] == nil ) .AND.  !E1IsAutoInc( ::hMySQL, n ),  if( !E1IsNumeric( ::hMySQL, n ),  ( '"' + aBuffer[ n ] + '", ' ),  ( aBuffer[ n ] + ", " ) ),  "NULL, " )
    next

    cStmt := ChgAtEnd( cStmt, " )", 2 )

    lRet := ::oCmd:ExecDirect( cStmt )

    if lRet .AND. ValType( lRefresh ) = "L" .AND. lRefresh
        ::Refresh()
    endif

return( lRet )





static FUNCTION TMSTable_Delete( lRefresh, nLimit ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local lRet
    local cStmt := "DELETE FROM " + ::cName + ::GenWhere()


    cStmt += if( ValType( nLimit ) == "N" .AND. nLimit > 0,  " LIMIT " + LTrim( str( nLimit ) ), "" )

    lRet := ::oCmd:ExecDirect( cStmt )

    if lRet .AND. ValType( lRefresh ) = "L" .AND. lRefresh
        ::Refresh()
    endif

return( lRet )





static FUNCTION TMSTable_Update( lRefresh, nLimit ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local n, lRet
    local nLen := ::FieldCount()
    local aBuffer := ::ImportData()
    local cStmt := "UPDATE " + ::cName + " SET "

    for n := 1 to nLen


        cStmt += ::ColName( n ) + " = " + if( !( aBuffer[ n ] == nil ),  ( + "'" + aBuffer[ n ] + "', " ),  ( " NULL, " ) )
    next

    cStmt := ChgAtEnd( cStmt, "  ", 2 )

    cStmt += ::GenWhere()

    cStmt += if( ValType( nLimit ) == "N" .AND. nLimit > 0,  " LIMIT " + LTrim( str( nLimit ) ), "" )

    lRet := ::oCmd:ExecDirect( cStmt )

    if lRet .AND. ValType( lRefresh ) = "L" .AND. lRefresh
        ::Refresh()
    endif

return( lRet )




static FUNCTION TMSTable_Load( ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    E1Load( ::hMySQL, ::aBuffer )

return( Self )





static FUNCTION TMSTable_ImportData( ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable
return( E1ImportData( ::hMySQL, ::aBuffer ) )




static FUNCTION TMSTable_Blank( ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    E1SetBlank( ::hMySQL, ::aBuffer )

return( Self )




static FUNCTION TMSTable_GetBuffer( n ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

   local uBuffer

   if Valtype( n ) == "C"
      n        := ::FieldPos( n )
   end

   if ( n > 0 .AND. n <= len( ::aBuffer ) )
      uBuffer  := ::aBuffer[ n ]
   end

return( uBuffer )




static FUNCTION TMSTable_SetBuffer( n, Val ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable
return( ::aBuffer[ n ] := Val )




static FUNCTION TMSTable_AlterEngine( cNewType ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

return( ValType( cNewType ) == "C" .AND.  ::oCmd:ExecDirect( "ALTER TABLE " + ::cName + " ENGINE = " + cNewType ) )









static FUNCTION TMSTable_GenWhere( ) ; local Self AS CLASS TMSTable := QSelf() AS CLASS TMSTable

    local cWhere := " WHERE "
    local nFld, n, i, cFldGet

    if ( n := ::nColAutoInc ) > 0
        cWhere += ::ColName( n ) + " = " + ::ColRead( n )
    elseif ( nFld := len( ::aKey ) ) > 0
        FOR i := 1 TO nFld
            n := ::aKey[ i ]
            cFldGet := ::ColRead( n )



            cWhere += if( ValType( cFldGet ) == "C", if( ::ColIsNumeric( n ),  ( ::ColName( n ) + " = "  + cFldGet +  " AND " ),  ( ::ColName( n ) + ' = "' + cFldGet + '" AND ' ) ),  ::ColName( n ) + " IS NULL AND " )
        NEXT
        cWhere := ChgAtEnd( cWhere, "", 4 )
    else
        nFld := ::FieldCount()
        FOR n := 1 TO nFld
            cFldGet := ::ColRead( n )



            cWhere += if( ValType( cFldGet ) == "C", if( ::ColIsNumeric( n ),  ( ::ColName( n ) + " = "  + cFldGet +  " AND " ),  ( ::ColName( n ) + ' = "' + cFldGet + '" AND ' ) ),  ::ColName( n ) + " IS NULL AND " )
        NEXT
        cWhere := ChgAtEnd( cWhere, "", 4 )
    endif

return( cWhere )






static function _ColDefine( cType, nLen, nDec, lAutoInc )

    local cRet

    SWITCH cType
        CASE "C"
            cRet := "char( " + LTrim( str( nLen ) ) + " )"
            EXIT
        CASE "N"
            if nDec > 0

                cRet := "decimal( " + LTrim( str( nLen ) ) + ", " +  LTrim( str( nDec ) ) + " )"
            else
                DO CASE
                CASE nLen <= 4
                    cRet := "smallint( " + LTrim( str( nLen ) ) + " )"
                CASE nLen <= 6
                    cRet := "mediumint( " + LTrim( str( nLen ) ) + " )"
                CASE nLen <= 9
                    cRet := "int( " + LTrim( str( nLen ) ) + " )"
                OTHERWISE
                    cRet := "bigint( " + LTrim( str( nLen ) ) + " )"
                ENDCASE
            endif
            if lAutoInc
                cRet += " not null auto_increment unique"
            endif
            EXIT
        CASE "D"
            cRet := "date"
            EXIT
        CASE "L"
            cRet := "tinyint( 1 ) unsigned zerofill"
            EXIT
        CASE "M"
            cRet := "text"
            EXIT
        OTHERWISE
            cRet := "char( " + LTrim( str( nLen ) ) + " )"
    END

return( cRet )
