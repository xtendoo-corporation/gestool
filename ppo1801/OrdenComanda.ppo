#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 7 ".\.\Prg\OrdenComanda.prg"
_HB_CLASS TOrdenComanda ; function TOrdenComanda ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TOrdenComanda", iif( .T., { @TMant() }, { @HBObject() } ), @TOrdenComanda() ) ) ;

   _HB_MEMBER { oDlg } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oDlg"}, .F. )
   _HB_MEMBER { oNomOrd } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oNomOrd"}, .F. )
   _HB_MEMBER { oCodOrd } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oCodOrd"}, .F. )

   _HB_MEMBER { cBitmap } ; oClass:AddMultiData(, ( 164 + ( 55 * 256 ) + ( 58 * 65536 ) ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cBitmap"}, .F. )

   _HB_MEMBER Create( cPath) AS CLASS TOrdenComanda; oClass:AddMethod( "Create", @TOrdenComanda_Create(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER New( cPath, oWndParent, oMenuItem) AS CLASS TOrdenComanda; oClass:AddMethod( "New", @TOrdenComanda_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Activate(); oClass:AddMethod( "Activate", @TOrdenComanda_Activate(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER OpenFiles( lExclusive); oClass:AddMethod( "OpenFiles", @TOrdenComanda_OpenFiles(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER OpenService( lExclusive); oClass:AddMethod( "OpenService", @TOrdenComanda_OpenFiles(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER DefineFiles(); oClass:AddMethod( "DefineFiles", @TOrdenComanda_DefineFiles(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Resource( nMode); oClass:AddMethod( "Resource", @TOrdenComanda_Resource(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER cNombre( cCodOrd); oClass:AddMethod( "cNombre", @TOrdenComanda_cNombre(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER cCodigoOrden( cOrdOrd); oClass:AddMethod( "cCodigoOrden", @TOrdenComanda_cCodigoOrden(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER cOrden( cNombre); oClass:AddMethod( "cOrden", @TOrdenComanda_cOrden(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER lPreSave( nMode); oClass:AddMethod( "lPreSave", @TOrdenComanda_lPreSave(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SubirOrden(); oClass:AddMethod( "SubirOrden", @TOrdenComanda_SubirOrden(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER BajarOrden(); oClass:AddMethod( "BajarOrden", @TOrdenComanda_BajarOrden(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER aNombreOrdenComanda(); oClass:AddMethod( "aNombreOrdenComanda", @TOrdenComanda_aNombreOrdenComanda(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER EmptyOrdenComanda(); oClass:AddInline( "EmptyOrdenComanda", {|Self | ( ( Self ) ), ( if( !Empty( ::oDbf ) .AND. ::oDbf:Used(), !( ::oDbf:OrdKeyCount() > 0 ), .T. ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Selector(); oClass:AddMethod( "Selector", @TOrdenComanda_Selector(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getFirstOrderId(); oClass:AddMethod( "getFirstOrderId", @TOrdenComanda_getFirstOrderId(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TOrdenComanda ;



static FUNCTION TOrdenComanda_Create( cPath ) ; local Self AS CLASS TOrdenComanda := QSelf() AS CLASS TOrdenComanda

   If( cPath == nil, cPath := cPatEmp(), ) ;

   ::cPath              := cPath
   ::oDbf               := nil

RETURN ( Self )



static FUNCTION TOrdenComanda_New( cPath, oWndParent, oMenuItem ) ; local Self AS CLASS TOrdenComanda := QSelf() AS CLASS TOrdenComanda

   If( cPath == nil, cPath := cPatEmp(), ) ;
   If( oWndParent == nil, oWndParent := GetWndFrame(), ) ;

   if oMenuItem <> nil
      ::nLevel          := Auth():Level( oMenuItem )
   else
      ::nLevel          := Auth():Level( "01093" )
   end

   ::cPath              := cPath
   ::oWndParent         := oWndParent

   ::oDbf               := nil

   ::cMru               := "gc_sort_az_descending_16"

   ::cBitmap            := ( 164 + ( 55 * 256 ) + ( 58 * 65536 ) )

   ::lCreateShell       := .F.

RETURN ( Self )



static FUNCTION TOrdenComanda_Activate( ) ; local Self AS CLASS TOrdenComanda := QSelf() AS CLASS TOrdenComanda

   if nAnd( ::nLevel, 1 ) == 0
      msgStop( "Acceso no permitido." )
      Return ( Self )
   end





   if ::oWndParent <> nil
      ::oWndParent:CloseAll()
   end

   if Empty( ::oDbf ) .OR. !::oDbf:Used()
      ::lOpenFiles      := ::OpenFiles()
   end





   if ::lOpenFiles

      if !::lCreateShell
         ::CreateShell( ::nLevel )
      end

      ::oWndBrw:GralButtons( Self )






      ::oWndBrw:NewAt( "Up",,, {||( ::SubirOrden() )}, "S(u)bir", "U",,, 4,, .F. )






      ::oWndBrw:NewAt( "Down",,, {||( ::BajarOrden() )}, "Ba(j)ar", "J",,, 4,, .F. )

      ::oWndBrw:EndButtons( Self )

      if ::cHtmlHelp <> nil
         ::oWndBrw:cHtmlHelp  := ::cHtmlHelp
      end

      ::oWndBrw:Activate( nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, {|| ::CloseFiles() } )

   end

RETURN ( Self )



static FUNCTION TOrdenComanda_OpenFiles( lExclusive, cPath ) ; local Self AS CLASS TOrdenComanda := QSelf() AS CLASS TOrdenComanda

   local lOpen          := .T.
   local oBlock

   If( lExclusive == nil, lExclusive := .F., ) ;
   If( cPath == nil, cPath := ::cPath, ) ;

   oBlock               := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      if Empty( ::oDbf )
         ::DefineFiles( cPath )
      end

      ::oDbf:Activate( .F., !( lExclusive ) )

   RECOVER

      lOpen             := .F.

      ::CloseFiles()

      msgStop( "Imposible abrir las bases de datos ordenes de comanda" )

   end

   ErrorBlock( oBlock )

RETURN ( lOpen )



static FUNCTION TOrdenComanda_DefineFiles( cPath, cDriver ) ; local Self AS CLASS TOrdenComanda := QSelf() AS CLASS TOrdenComanda

   If( cPath == nil, cPath := ::cPath, ) ;
   If( cDriver == nil, cDriver := cDriver(), ) ;

   ::oDbf := DbfServer( "OrdenComanda.Dbf", "OrdenComanda" ):New( "OrdenComanda.Dbf", "OrdenComanda", ( cDriver ), "Orden Comanda", ( cPath ) )

      ::oDbf:AddField( "cCodOrd", "C", 2, 0,,,,, "Código", .F., 60, .F., {} )
      ::oDbf:AddField( "cNomOrd", "C", 30, 0,,,,, "Nombre", .F., 300, .F., {} )
      ::oDbf:AddField( "cOrdOrd", "C", 2, 0,,,,, "Posición", .T., 80, .F., {} )

      ::oDbf:AddIndex( "cCodOrd", "OrdenComanda.Cdx", "cCodOrd",,, .F., .F., "Código",,, .T., .F. )
      ::oDbf:AddIndex( "cNomOrd", "OrdenComanda.Cdx", "cNomOrd",,, .F., .F., "Nombre",,, .T., .F. )
      ::oDbf:AddIndex( "cOrdOrd", "OrdenComanda.Cdx", "cOrdOrd",,, .F., .F., "Posición",,, .T., .F. )



RETURN ( ::oDbf )



static FUNCTION TOrdenComanda_Resource( nMode ) ; local Self AS CLASS TOrdenComanda := QSelf() AS CLASS TOrdenComanda

   ::oDlg = TDialog():New(,,,, LblTitle( nMode ) + "orden de comanda", "OrdenComanda",, .F.,,,,,, .F.,,,,,, .F.,, "::oDlg", nil, )







      ::oCodOrd := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, ::oDbf:cCodOrd, ::oDbf:cCodOrd:= u ) }, ::oDlg,,, {||          NotValid( ::oCodOrd, ::oDbf:cAlias, .T., "0" )},,,,,, .T., {||           ( nMode == 1 )},, .F., .F.,,,,,, nil,,, )







      ::oNomOrd := TGetHlp():ReDefine( 101, { | u | If( PCount()==0, ::oDbf:cNomOrd, ::oDbf:cNomOrd:= u ) }, ::oDlg,, "@!",,,,,,, .T., {||           ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      TButton():ReDefine( 1, {||( ::lPreSave( nMode ) )}, ::oDlg,,, .F., {||           ( nMode <> 3 )},,, .F. )





        TButton():ReDefine( 2, {||( ::oDlg:end() )}, ::oDlg,,, .F.,,,, .T. )

      if nMode <> 3
         ::oDlg:AddFastKey( 116, {|| ::lPreSave( nMode ) } )
      end

   ::oDlg:Activate( ::oDlg:bLClicked, ::oDlg:bMoved, ::oDlg:bPainted, .T.,,,, ::oDlg:bRClicked,,, )

RETURN ( ::oDlg:nResult == 1 )



static FUNCTION TOrdenComanda_lPreSave( nMode ) ; local Self AS CLASS TOrdenComanda := QSelf() AS CLASS TOrdenComanda

   if Empty( ::oCodOrd:VarGet() )
      MsgStop( "Códido de orden de comanda no puede estar vacío." )
      ::oCodOrd:SetFocus()
      Return .F.
   end

   if Empty( ::oNomOrd:VarGet() )
      MsgStop( "Orden de comanda no puede estar vacío." )
      ::oNomOrd:SetFocus()
      Return .F.
   end

   if ( nMode == 1 .OR. nMode == 4 )
      ::oDbf:cOrdOrd    := Str( ::oDbf:RecCount() + 1, 2 )
   end

RETURN ( ::oDlg:end( 1 ) )



static FUNCTION TOrdenComanda_cCodigoOrden( cOrdOrd ) ; local Self AS CLASS TOrdenComanda := QSelf() AS CLASS TOrdenComanda

   local cCodOrden   := ""

   if ::oDbf:SeekInOrd( cOrdOrd, "cOrdOrd" )
      cCodOrden      := ::oDbf:cCodOrd
   end

RETURN ( cCodOrden )



static FUNCTION TOrdenComanda_cNombre( cCodOrd ) ; local Self AS CLASS TOrdenComanda := QSelf() AS CLASS TOrdenComanda

   local cNombre        := ""

   ::oDbf:GetStatus()

   if ::oDbf:SeekInOrd( cCodOrd, "cCodOrd" )
      cNombre           := alltrim( ::oDbf:cNomOrd )
   end

   ::oDbf:SetStatus()

RETURN ( cNombre )



static FUNCTION TOrdenComanda_cOrden( cNomOrd ) ; local Self AS CLASS TOrdenComanda := QSelf() AS CLASS TOrdenComanda

   local cCodigo        := ""

   ::oDbf:GetStatus()

   if !Empty( cNomOrd ) .AND. ::oDbf:SeekInOrd( cNomOrd, "cNomOrd" )
      cCodigo           := ::oDbf:cOrdOrd
   end

   ::oDbf:SetStatus()

RETURN ( cCodigo )



static FUNCTION TOrdenComanda_SubirOrden( ) ; local Self AS CLASS TOrdenComanda := QSelf() AS CLASS TOrdenComanda

   local nRecno      := ::oDbf:Recno()

   if ( ::oDbf:OrdSetFocus() <> Upper( "cOrdOrd" ) )
      msgStop( "La tabla debe estar ordenada por posición" )
      Return ( Self )
   end

   if ( ::oDbf:OrdKeyNo() == 1 )
      msgStop( "Este orden ya está en la primera posición" )
      Return ( Self )
   end

   CursorWait()

   ::oDbf:Skip( -1 )

   ::oDbf:FieldPutByName( "cOrdOrd", Str( Val( ::oDbf:cOrdOrd ) + 1, 2 ) )

   ::oDbf:GoTo( nRecno )

   ::oDbf:FieldPutByName( "cOrdOrd", Str( Val( ::oDbf:cOrdOrd ) - 1, 2 ) )

   ::oWndBrw:oBrw:Refresh()
   ::oWndBrw:oBrw:SelectOne()

   CursorWE()

Return ( Self )



static FUNCTION TOrdenComanda_BajarOrden( ) ; local Self AS CLASS TOrdenComanda := QSelf() AS CLASS TOrdenComanda

   local nRecno      := ::oDbf:Recno()

   if ( ::oDbf:OrdSetFocus() <> Upper( "cOrdOrd" ) )
      msgStop( "La tabla debe estar ordenada por posición" )
      Return ( Self )
   end

   if ( ::oDbf:Eof() )
      msgStop( "Este orden ya está en la última posición" )
      Return ( Self )
   end

   CursorWait()

   ::oDbf:Skip( 1 )

   ::oDbf:FieldPutByName( "cOrdOrd", Str( Val( ::oDbf:cOrdOrd ) - 1, 2 ) )

   ::oDbf:GoTo( nRecno )

   ::oDbf:FieldPutByName( "cOrdOrd", Str( Val( ::oDbf:cOrdOrd ) + 1, 2 ) )

   ::oWndBrw:oBrw:Refresh()
   ::oWndBrw:oBrw:SelectOne()

   CursorWE()

Return ( Self )



static FUNCTION TOrdenComanda_aNombreOrdenComanda( ) ; local Self AS CLASS TOrdenComanda := QSelf() AS CLASS TOrdenComanda

   local aNombreOrdenComanda  := { "" }

   if Empty( ::oDbf ) .OR. !( ::oDbf:Used() )
      Return ( aNombreOrdenComanda )
   end

   CursorWait()

   ::oDbf:GetStatus()
   ::oDbf:GoTop()

   while !( ::oDbf:Eof() )
      aAdd( aNombreOrdenComanda, AllTrim( ::oDbf:cNomOrd ) )
      ::oDbf:Skip()
   end

   ::oDbf:SetStatus()

   CursorWE()

Return ( aNombreOrdenComanda )



static FUNCTION TOrdenComanda_Selector( ) ; local Self AS CLASS TOrdenComanda := QSelf() AS CLASS TOrdenComanda

   local oDlg
   local oBrw
   local oFont
   local oBlock
   local oError
   local cReturn

   oBlock                  := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   ::oDbf:GetStatus()
   ::oDbf:GoTop()

   oFont                   := TFont():New( "Segoe UI",  0, 20, .F., .T. )

   oDlg = TDialog():New(,,,, "Ordenes de comanda", "HelpEntryTactilIva",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )

      oBrw                 := IXBrowse():New( oDlg )

      ::oDbf:SetBrowse( oBrw )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:nMarqueeStyle   := 5
      oBrw:nRowHeight      := 48
      oBrw:oFont           := oFont
      oBrw:lHeader         := .F.

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }

      with object ( oBrw:AddCol() )
         :cHeader          := ""
         :bEditValue       := {|| ::oDbf:cNomOrd }
         :nWidth           := 300
      end

      oBrw:CreateFromResource( 105 )





      TButtonBmp():ReDefine( 140, {||( oBrw:GoUp() )}, oDlg,,, .F.,,,, .F., "UP32",,, .F. )





      TButtonBmp():ReDefine( 150, {||( oBrw:GoDown() )}, oDlg,,, .F.,,,, .F., "DOWN32",,, .F. )





      TButtonBmp():ReDefine( 1, {||( oDlg:end(1) )}, oDlg,,, .F.,,,, .F., "gc_check_32",,, .F. )





      TButtonBmp():ReDefine( 2, {||( oDlg:End() )}, oDlg,,, .F.,,,, .F., "Delete_32",,, .F. )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if oDlg:nResult == 1
      cReturn              := ::oDbf:cCodOrd
   end

   RECOVER USING oError

      msgStop( "Imposible abrir ordenes de comandas." + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if !Empty( oFont )
      oFont:End()
   end

Return ( cReturn )



static FUNCTION TOrdenComanda_getFirstOrderId( ) ; local Self AS CLASS TOrdenComanda := QSelf() AS CLASS TOrdenComanda

   local cCodigoOrden

   ::oDbf:getStatus()
   ::oDbf:goTop()

   cCodigoOrden         := ::oDbf:cCodOrd

   ::oDbf:setStatus()

Return ( cCodigoOrden )
