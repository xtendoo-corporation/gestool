#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 6 ".\.\Prg\Pro.prg"
static oWndBrw
static nView
static oMenu
static oDetMenu
static dbfProT
static dbfProL
static dbfTmpProL
static cTmpProLin
static oDetCamposExtra
static oLinDetCamposExtra
static nTipoActualizacionLineas  := 2
static bEdit                     := { |aTmp, aGet, dbf, oBrw, bWhen, bValid, nMode | EdtRec( aTmp, aGet, dbf, oBrw, bWhen, bValid, nMode ) }
static bEdtDet                   := { |aTmp, aGet, dbf, oBrw, bWhen, bValid, nMode, cCodArt | EdtDet( aTmp, aGet, dbf, oBrw, bWhen, bValid, nMode, cCodArt ) }





FUNCTION Prop( oMenuItem, oWnd )

   local nLevel
   local oSnd

   If( oMenuItem == nil, oMenuItem := "01015", ) ;
   If( oWnd == nil, oWnd := oWnd(), ) ;

   IF oWndBrw == NIL





      nLevel            := Auth():Level( oMenuItem )

      if nAnd( nLevel, 1 ) == 0
         msgStop( "Acceso no permitido." )
         return nil
      end





      if oWnd <> nil
         SysRefresh(); oWnd:CloseAll(); SysRefresh()
      end





      if !OpenFiles()
         Return nil
      end





      AddMnuNext( "Propiedades de artículos", ProcName() )














   oWndBrw := TShell():New( 2, 10, 18, 70, "Propiedades de artículos",, oWnd,,, .F.,,, ( dbfProT ),,,,, {"Código", "Nombre"}, {||( WinAppRec( oWndBrw:oBrw, bEdit, dbfProT ) )}, {||( WinEdtRec( oWndBrw:oBrw, bEdit, dbfProT ) )}, {||( WinDelRec( oWndBrw:oBrw, dbfProT, {|| DeletePropiedades( ( dbfProT )->cCodPro ) } ) )}, {||( WinDupRec( oWndBrw:oBrw, bEdit, dbfProT ) )}, nil, nLevel, "gc_coathanger_16", ( 104 + ( 0 * 256 ) + ( 63 * 65536 ) ),,, .T. )

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Envio"
         :nHeadBmpNo       := 3
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( dbfProT )->lSndDoc }
         :nWidth           := 20
         :SetCheck( { "gc_mail2_12", "Nil16" } )
         :AddResource( "gc_mail2_16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Publicar"
         :nHeadBmpNo       := 3
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( dbfProT )->lPubInt }
         :nWidth           := 20
         :SetCheck( { "gc_earth_12", "Nil16" } )
         :AddResource( "gc_earth_16" )
      end


      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodPro"
         :bEditValue       := {|| ( dbfProT )->cCodPro }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cDesPro"
         :bEditValue       := {|| ( dbfProT )->cDesPro }
         :nWidth           := 260
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      oWndBrw:CreateXFromCode()





      oWndBrw:NewAt( "BUS",,, {||( oWndBrw:SearchSetFocus() )}, "(B)uscar", "B",,,,, .F. )

      oWndBrw:AddSeaBar()








      oWndBrw:NewAt( "NEW",,, {||( oWndBrw:RecAdd() )}, "(A)ñadir", "A",,, 2,, .F. )







      oWndBrw:NewAt( "EDIT",,, {||( oWndBrw:RecEdit() )}, "(M)odificar", "M",,, 4,, .F. )







      oWndBrw:NewAt( "ZOOM",,, {||( WinZooRec( oWndBrw:oBrw, bEdit, dbfProT ) )}, "(Z)oom", "Z",,, 8,, .F. )







      oWndBrw:NewAt( "DEL",,, {||( oWndBrw:RecDel() )}, "(E)liminar", "E",,, 16,, .F. )








      oSnd := oWndBrw:NewAt( "Lbl",, "Seleccionar registros para ser enviados", {||ChangelSndDoc()}, "En(v)iar", "V",, {|This|This:Toggle()}, 4,, .F. )






      oWndBrw:NewAt( "SNDINT",,, {||( ChangePublicar() )}, "P(u)blicar", "U",,, 4,, .F. )






      oWndBrw:NewAt( "END",,, {||( oWndBrw:end() )}, "(S)alir", "S",,,,, .F. )

      oWndBrw:Activate(, oWndBrw:bLClicked, oWndBrw:bRClicked, oWndBrw:bMoved, oWndBrw:bResized, oWndBrw:bPainted, oWndBrw:bKeyDown, oWndBrw:bInit,,,,,,,,, {|| ( CloseFiles() )},, oWndBrw:bLButtonUp, .F. )

   ELSE

      oWndBrw:SetFocus()

   end

RETURN NIL



STATIC FUNCTION EdtRec( aTmp, aGet, dbfProT, oWndBrw, cPrp, cKey, nMode )

   local oDlg
   local oBrw

   if !( BeginTrans( aTmp, nMode, ( dbfProT )->cCodPro ) )
      Return .F.
   end

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "propiedades", "PROP",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )








      aGet[ ( dbfProT )->( FieldPos( "cCodPro" ) ) ] := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ ( dbfProT )->( FieldPos( "cCodPro" ) ) ], aTmp[ ( dbfProT )->( FieldPos( "cCodPro" ) ) ]:= u ) }, oDlg,, "@!", {||       ( !Empty( aTmp[ ( dbfProT )->( FieldPos( "cCodPro" ) ) ] ) .AND. NotValid( aGet[ ( dbfProT )->( FieldPos( "cCodPro" ) ) ], dbfProT ) )},,,,,, .T., {||        ( nMode == 1 )},, .F., .F.,,,,,, nil,,, )






      aGet[ ( dbfProT )->( FieldPos( "cDesPro" ) ) ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ ( dbfProT )->( FieldPos( "cDesPro" ) ) ], aTmp[ ( dbfProT )->( FieldPos( "cDesPro" ) ) ]:= u ) }, oDlg,,,,,,,,, .T., {||        ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )






      aGet[ ( dbfProT )->( FieldPos( "cNomInt" ) ) ] := TGetHlp():ReDefine( 160, { | u | If( PCount()==0, aTmp[ ( dbfProT )->( FieldPos( "cNomInt" ) ) ], aTmp[ ( dbfProT )->( FieldPos( "cNomInt" ) ) ]:= u ) }, oDlg,,,,,,,,, .T., {||        ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      TCheckBox():ReDefine( 150, { | u | If( PCount()==0, aTmp[ ( dbfProT )->( FieldPos( "lPubInt" ) ) ], aTmp[ ( dbfProT )->( FieldPos( "lPubInt" ) ) ]:= u ) }, oDlg,, {||( ChangePublicar( aTmp ) )},,,,, .F., {||     ( nMode <> 3 )}, .F. )




      TCheckBox():ReDefine( 200, { | u | If( PCount()==0, aTmp[ ( dbfProT )->( FieldPos( "lColor" ) ) ], aTmp[ ( dbfProT )->( FieldPos( "lColor" ) ) ]:= u ) }, oDlg,,,,,,, .F., {||     ( nMode <> 3 )}, .F. )

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:cAlias          := dbfTmpProL
      oBrw:nMarqueeStyle   := 5

      with object ( oBrw:AddCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodTbl"
         :bEditValue       := {|| ( dbfTmpProL )->cCodTbl }
         :nWidth           := 160
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cDesTbl"
         :bEditValue       := {|| ( dbfTmpProL )->cDesTbl }
         :nWidth           := 250
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Orden"
         :cSortOrder       := "nOrdTbl"
         :bEditValue       := {|| ( dbfTmpProL )->nOrdTbl }
         :cEditPicture     := "9999"
         :nWidth           := 50
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "CB"
         :cSortOrder       := "nBarTbl"
         :bEditValue       := {|| ( dbfTmpProL )->nBarTbl }
         :cEditPicture     := "9999"
         :nWidth           := 50
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
         :lHide            := .T.
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Web"
         :cSortOrder       := "cCodWeb"
         :bEditValue       := {|| ( dbfTmpProL )->cCodWeb }
         :cEditPicture     := "9999"
         :nWidth           := 50
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
         :lHide            := .T.
      end

      oBrw:CreateFromResource( 120 )

      oBrw:bLDblClick      := {|| WinEdtRec( oBrw, bEdtDet, dbfTmpProL, aTmp ) }
      oBrw:bRClicked       := {| nRow, nCol, nFlags | oBrw:RButtonDown( nRow, nCol, nFlags ) }





      TButton():ReDefine( 500, {||( WinAppRec( oBrw, bEdtDet, dbfTmpProL, aTmp ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 501, {||( WinEdtRec( oBrw, bEdtDet, dbfTmpProL, aTmp ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 502, {||( DeleteLinea( oBrw ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 503, {||( UpDet( oBrw ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 504, {||( DownDet( oBrw ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 1, {||( EndTrans( aTmp, aGet, nMode, oDlg ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

      if nMode <> 3

         oDlg:AddFastKey( 113, {|| WinAppRec( oBrw, bEdtDet, dbfTmpProL, aTmp ) } )
         oDlg:AddFastKey( 114, {|| WinEdtRec( oBrw, bEdtDet, dbfTmpProL, aTmp ) } )
         oDlg:AddFastKey( 115, {|| DelDet( oBrw ) } )
         oDlg:AddFastKey( 116, {|| EndTrans( aTmp, aGet, nMode, oDlg ) } )

         if uFieldEmpresa( "lRealWeb" )
            oDlg:AddFastKey( 117, {|| EndTrans( aTmp, aGet, nMode, oDlg, .T. ) } )
         end

         oDlg:AddFastKey( 120, {|| oDetCamposExtra:Play( space(1) ) } )

      end

      oDlg:AddFastKey ( 112, {|| ChmHelp( "Propiedades_de_articulos" ) } )

      oDlg:bStart := {|| StartEdtRec( aGet, cPrp, cKey ) }


   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|( EdtRecMenu( oDlg ) )}, oDlg:bRClicked,,, )

   if !Empty( oMenu )
      oMenu:end()
   end

   KillTrans()

RETURN ( oDlg:nResult == 1 )



Static Function StartEdtRec( aGet, cPrp, cKey )

   if !empty( cKey )
      dbseekinord( cKey, "cCodTbl", dbfTmpProL )
   end

   aGet[ ( dbfProT )->( FieldPos( "cCodPro" ) ) ]:SetFocus()

RETURN ( .T. )



Static Function UpDet( oBrw )

   local nRecno       := ( dbfTmpProL )->( Recno() )
   local nPosition    := ( dbfTmpProL )->nOrdTbl

   if nPosition > 1

      nPosition--

      ( dbfTmpProL )->( __dbLocate( {|| Field->nOrdTbl == nPosition } ) )
      if ( dbfTmpProL )->( Found() )
         ( dbfTmpProL )->nOrdTbl++
      endif

      ( dbfTmpProL )->( dbGoTo( nRecno ) )
      ( dbfTmpProL )->nOrdTbl--

   endif

   oBrw:Refresh()

RETURN ( nil )



Static Function DownDet( oBrw )

   local nRecno      := ( dbfTmpProL )->( Recno() )
   local nPosition      := ( dbfTmpProL )->nOrdTbl

   if nPosition < ( dbfTmpProL )->( LastRec() )

      nPosition++

      ( dbfTmpProL )->( __dbLocate( {|| Field->nOrdTbl == nPosition } ) )
      if ( dbfTmpProL )->( Found() )
         ( dbfTmpProL )->nOrdTbl--
      endif

      ( dbfTmpProL )->( dbGoTo( nRecno ) )
      ( dbfTmpProL )->nOrdTbl++

   endif

   oBrw:Refresh()

RETURN ( nil )



STATIC FUNCTION DeleteLinea( oBrw )

   nTipoActualizacionLineas  := 7

   DelDet( oBrw )

RETURN ( nil )



STATIC FUNCTION BeginTrans( aTmp, nMode, cCodPro )

   local oError
   local oBlock
   local nOrdAnt
   local lCreate     := .T.

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   cTmpProLin        := cGetNewFileName( cPatTmp() + "TmpProLin" )

   dbCreate( cTmpProLin, aSqlStruct( aItmPro() ), cLocalDriver() )

   dbUseArea( .T., cLocalDriver(), cTmpProLin, cCheckArea( "TmpProLin", @dbfTmpProL ), .F. )

   if !( dbfTmpProL )->( neterr() )

      ( dbfTmpProL )->( OrdCondSet( "!Deleted()", {||!Deleted() } ) )
      ( dbfTmpProL )->( OrdCreate( cTmpProLin, "cCodTbl", "Field->cCodTbl", {|| Field->cCodTbl } ) )

      ( dbfTmpProL )->( OrdCondSet( "!Deleted()", {||!Deleted() } ) )
      ( dbfTmpProL )->( OrdCreate( cTmpProLin, "cDesTbl", "Field->cDesTbl", {|| Field->cDesTbl } ) )

      ( dbfTmpProL )->( OrdCondSet( "!Deleted()", {||!Deleted() } ) )
      ( dbfTmpProL )->( OrdCreate( cTmpProLin, "nOrdTbl", "Str( Field->nOrdTbl )", {|| Str( Field->nOrdTbl ) } ) )

      ( dbfTmpProL )->( OrdCondSet( "!Deleted()", {||!Deleted() } ) )
      ( dbfTmpProL )->( OrdCreate( cTmpProLin, "nBarTbl", "Field->nBarTbl", {|| Field->nBarTbl } ) )

      ( dbfTmpProL )->( OrdSetFocus( "cCodTbl" ) )

      nOrdAnt        := ( dbfProL )->( OrdSetFocus( 1 ) )

      oLinDetCamposExtra:initArrayValue()

      if nMode <> 1 .AND. ( dbfProL )->( dbSeek( cCodPro ) )

         while ( dbfProL )->cCodPro == cCodPro .AND. !( dbfProL )->( eof() )

            dbPass( dbfProL, dbfTmpProL, .T. )

            oLinDetCamposExtra:SetTemporalLines( ( dbfTmpProL )->cCodPro + ( dbfTmpProL )->cCodTbl, ( dbfTmpProL )->( OrdKeyNo() ), nMode )

            if empty( ( dbfTmpProL )->nOrdTbl )
               ( dbfTmpProL )->nOrdTbl := ( dbfTmpProL )->( Recno() )
            end

           ( dbfProL )->( dbSkip() )

         end

      end

      ( dbfTmpProL )->( dbGoTop() )

      ( dbfProL )->( OrdSetFocus( nOrdAnt ) )
      ( dbfProL )->( dbGoTop() )

      oDetCamposExtra:SetTemporal( cCodPro, "", nMode )

   end

   RECOVER USING oError

      lCreate        := .F.

      msgStop( "Imposible crear el fichero temporal" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

RETURN ( lCreate )



STATIC FUNCTION EndTrans( aTmp, aGet, nMode, oDlg, lActualizaWeb )

   local oError
   local oBlock
   local nOrdAnt
   local cCodPrp

   If( lActualizaWeb == nil, lActualizaWeb := .F., ) ;





   if nMode == 1

      if Empty( aTmp[ ( dbfProT )->( FieldPos( "cCodPro" ) ) ] )
         MsgStop( "Código no puede estar vacío" )
         aGet[ ( dbfProT )->( FieldPos( "cCodPro" ) ) ]:SetFocus()
         return nil
      end

      if dbSeekInOrd( aTmp[ ( dbfProT )->( FieldPos( "cCodPro" ) ) ], "CCODPRO", dbfProT )
         MsgStop( "Código ya existe " + Rtrim( aTmp[ ( dbfProT )->( FieldPos( "cCodPro" ) ) ] ) )
         return nil
      end

   end

   if Empty( aTmp[ ( dbfProT )->( FieldPos( "cDesPro" ) ) ] )
      msgStop( "Nombre no puede estar vacío" )
      aGet[ ( dbfProT )->( FieldPos( "cDesPro" ) ) ]:SetFocus()
      return nil
   end





   CursorWait()

   cCodPrp     := aTmp[ ( dbfProT )->( FieldPos( "cCodPro" ) ) ]

   aTmp[ ( dbfProT )->( FieldPos( "lSndDoc" ) ) ]   := .T.

   oBlock      := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      BeginTransaction()

      nOrdAnt  := ( dbfProL )->( OrdSetFocus( 2 ) )

      while ( dbfProL )->( dbSeek( aTmp[ ( dbfProL )->( FieldPos( "cCodPro" ) ) ] ) ) .AND. !( dbfProL )->( eof() )
         if dbLock( dbfProL )
            ( dbfProL )->( dbDelete() )
            ( dbfProL )->( dbUnLock() )
         end
      end

      ( dbfProL )->( OrdSetFocus( nOrdAnt ) )
      ( dbfProL )->( dbGoTop() )

      ( dbfTmpProL )->( dbGoTop() )
      while !( dbfTmpProL )->( eof() )
         dbPass( dbfTmpProL, dbfProL, .T., aTmp[ ( dbfProT )->( FieldPos( "cCodPro" ) ) ] )
         oLinDetCamposExtra:saveExtraField( ( dbfTmpProL )->cCodPro + ( dbfTmpProL )->cCodTbl, ( dbfTmpProL )->( OrdKeyNo() ) )
         ( dbfTmpProL )->( dbSkip() )
      end

      oDetCamposExtra:saveExtraField( aTmp[ ( dbfProT )->( FieldPos( "cCodPro" ) ) ], "" )

      WinGather( aTmp, aGet, dbfProT, nil, nMode )





      Actualizaweb( cCodPrp, lActualizaweb )





      CommitTransaction()

   RECOVER USING oError

      RollBackTransaction()
      msgStop( "Imposible completar la transacción" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end
   ErrorBlock( oBlock )

   CursorWe()

RETURN ( oDlg:end( 1 ) )



STATIC FUNCTION KillTrans()

   if !Empty( dbfTmpProL ) .AND. ( dbfTmpProL )->( Used() )
      ( dbfTmpProL )->( dbCloseArea() )
   end

   dbfTmpProL  := nil

   dbfErase( cTmpProLin )

RETURN nil



Static Function EdtRecMenu( oDlg )

   oMenu := MenuBegin( .F.,,, .F., .F.,,,,,,,,,, .F.,, .F., .F., .F., .T.,, ,,,,,, .F.,, .F., .F.,,,,,,,,,, .F.,,,,,, )

      MenuAddItem( "&1. Rotor",, .F.,,,,,,,,, .F.,,, .F., ,.F., .F.,,,,,,,,,, .F., .F.,,,,,,, ,, .F., .F., .F.,,,,, .F., .F., .F. )

         MenuBegin( .F.,,, .F., .F.,,,,,,,,,, .F.,, .F., .F., .F., .F.,, ,,,,,, .F.,, .F., .F.,,,,,,,,,, .F.,,,,,, )




            MenuAddItem( "&1. Campos extra [F9]", "Mostramos y rellenamos los campos extra para propiedades", .F.,, {|oMenuItem|( oDetCamposExtra:Play( Space(1) ) )},, "GC_FORM_PLUS2_16",,,,, .F.,,, .F., ,.F., .F.,,,,,,,,,, .F., .F.,,,,,,, ,, .F., .F., .F.,,,,, .F., .F., .F. )

         MenuEnd()

   MenuEnd()

   oDlg:SetMenu( oMenu )

RETURN ( oMenu )



static Function menuEdtDet( oDlg, nIdLin )

   oDetMenu := MenuBegin( .F.,,, .F., .F.,,,,,,,,,, .F.,, .F., .F., .F., .T.,, ,,,,,, .F.,, .F., .F.,,,,,,,,,, .F.,,,,,, )


      MenuAddItem( "&1. Rotor  ",, .F.,,,, "Rotor16",,,,, .F.,,, .F., ,.F., .F.,,,,,,,,,, .F., .F.,,,,,,, ,, .F., .F., .F.,,,,, .F., .F., .F. )

         MenuBegin( .F.,,, .F., .F.,,,,,,,,,, .F.,, .F., .F., .F., .F.,, ,,,,,, .F.,, .F., .F.,,,,,,,,,, .F.,,,,,, )




            MenuAddItem( "&1. Campos extra [F9]", "Mostramos y rellenamos los campos extra", .F.,, {|oMenuItem|( oLinDetCamposExtra:Play( nIdLin ) )},, "GC_FORM_PLUS2_16",,,,, .F.,,, .F., ,.F., .F.,,,,,,,,,, .F., .F.,,,,,,, ,, .F., .F., .F.,,,,, .F., .F., .F. )

         MenuEnd()

   MenuEnd()

   oDlg:SetMenu( oDetMenu )

RETURN ( oDetMenu )



STATIC FUNCTION EdtDet( aTmp, aGet, dbf, oBrw, aTmpPro, bValid, nMode, cCodArt )

   local oDlg

   nTipoActualizacionLineas  := nMode

   if nMode == 1
      aTmp[ ( dbfProL )->( FieldPos( "nOrdTbl" ) ) ]  := ( dbfTmpProL )->( LastRec() ) + 1
      oLinDetCamposExtra:setTemporalAppend()
   end

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "propiedad", "PRODET",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )







      aGet[ ( dbfProL )->( FieldPos( "cCodTbl" ) ) ] := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ ( dbfProL )->( FieldPos( "cCodTbl" ) ) ], aTmp[ ( dbfProL )->( FieldPos( "cCodTbl" ) ) ]:= u ) }, oDlg,, "@!", {||    ( !Empty( aTmp[ ( dbfTmpProL )->( FieldPos( "cCodTbl" ) ) ] ) )},,,,,, .F., {||     ( nMode == 1 )},, .F., .F.,,,,,, nil,,, )






      aGet[ ( dbfProL )->( FieldPos( "cDesTbl" ) ) ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ ( dbfProL )->( FieldPos( "cDesTbl" ) ) ], aTmp[ ( dbfProL )->( FieldPos( "cDesTbl" ) ) ]:= u ) }, oDlg,, "@!",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )







      aGet[ ( dbfProL )->( FieldPos( "nOrdTbl" ) ) ] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[ ( dbfProL )->( FieldPos( "nOrdTbl" ) ) ], aTmp[ ( dbfProL )->( FieldPos( "nOrdTbl" ) ) ]:= u ) }, oDlg,, "9999",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .T.,,,,,, nil,,, )






      aGet[ ( dbfProL )->( FieldPos( "nBarTbl" ) ) ] := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, aTmp[ ( dbfProL )->( FieldPos( "nBarTbl" ) ) ], aTmp[ ( dbfProL )->( FieldPos( "nBarTbl" ) ) ]:= u ) }, oDlg,, "9999",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )










      aGet[ ( dbfProL )->( FieldPos( "nColor" ) ) ] := TGetHlp():ReDefine( 200, { | u | If( PCount()==0, aTmp[ ( dbfProL )->( FieldPos( "nColor" ) ) ], aTmp[ ( dbfProL )->( FieldPos( "nColor" ) ) ]:= u ) }, oDlg,,,, if( aTmpPro[ ( dbfProT )->( FieldPos( "lColor" ) ) ], aTmp[ ( dbfProL )->( FieldPos( "nColor" ) ) ], "N/W*" ), if( aTmpPro[ ( dbfProT )->( FieldPos( "lColor" ) ) ], aTmp[ ( dbfProL )->( FieldPos( "nColor" ) ) ], "N/W*" ),,,, .F., {||     ( nMode <> 3 .AND. aTmpPro[ ( dbfProT )->( FieldPos( "lColor" ) ) ] )},, .F., .F.,,,,, {|Self|(  aTmp[ ( dbfProL )->( FieldPos( "nColor" ) ) ]  := ChooseColor(), aGet[ ( dbfProL )->( FieldPos( "nColor" ) ) ]:SetColor( aTmp[ ( dbfProL )->( FieldPos( "nColor" ) ) ], aTmp[ ( dbfProL )->( FieldPos( "nColor" ) ) ] ), aGet[ ( dbfProL )->( FieldPos( "nColor" ) ) ]:Refresh() )}, nil, "LUPA",, )





      TButton():ReDefine( 1, {||( SaveEdtDet( aTmp, aGet, oBrw, oDlg, nMode, dbfTmpProL ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )




      TButton():ReDefine( 9, {||( ChmHelp( "Propiedades_de_articulos" ) )}, oDlg,,, .F.,,,, .F. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| SaveEdtDet( aTmp, aGet, oBrw, oDlg, nMode, dbfTmpProL ) } )
      oDlg:AddFastKey( 120, {|| oLinDetCamposExtra:Play( if( nMode == 1, "", Str( ( dbfTmpProL )->( OrdKeyNo() ) ) ) ) } )
   end


   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|( menuEdtDet( oDlg, if( nMode == 1, "", Str( ( dbfTmpProL )->( OrdKeyNo() ) ) ) ) )}, oDlg:bRClicked,,, )

   if !Empty( oDetMenu )
      oDetMenu:End()
   end

RETURN ( oDlg:nResult == 1 )



Static Function SaveEdtDet( aTmp, aGet, oBrw, oDlg, nMode, dbfTmpProL )

   local nRec
   local lErr     := .F.

   nRec           := ( dbfTmpProL )->( Recno() )

   if nMode == 1

      if Empty( aTmp[ ( dbfTmpProL )->( FieldPos( "cCodTbl" ) ) ] )
         MsgStop( "Código de la propiedad no puede estar vacio" )
         lErr     := .T.
      end

      if dbSeekInOrd( aTmp[ ( dbfTmpProL )->( FieldPos( "cCodTbl" ) ) ], "cCodTbl", dbfTmpProL )
         MsgStop( "Código de la propiedad ya existe" )
         lErr     := .T.
      end

   end



   if ( nMode == 1 .OR. ( dbfTmpProL )->nBarTbl <> aTmp[ ( dbfTmpProL )->( FieldPos( "nBarTbl" ) ) ] ) .AND. !Empty( aTmp[ ( dbfTmpProL )->( FieldPos( "nBarTbl" ) ) ] )                                              .AND. dbSeekInOrd( aTmp[ ( dbfTmpProL )->( FieldPos( "nBarTbl" ) ) ], "nBarTbl", dbfTmpProL )
         MsgStop( "Número para código de barras ya existe" )
         lErr     := .T.
   end

   ( dbfTmpProL )->( dbGoTo( nRec ) )

   if !lErr
      WinGather( aTmp, aGet, dbfTmpProL, oBrw, nMode )
      oDlg:end( 1 )
   end

   if nMode == 1
      oLinDetCamposExtra:SaveTemporalAppend( ( dbfTmpProL )->( OrdKeyNo() ) )
   end

Return nil



FUNCTION cProp( oGet, oSay )

   local oBlock
   local oError
   local dbfPro
   local lValid   := .F.
   local cCodPrp  := oGet:VarGet()

   if Empty( cCodPrp )

      if !Empty( oSay )
         oSay:SetText( Space( 3 ) )
      end

      return .T.

   end

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PRO.DBF" ), ( cCheckArea( "PRO", @dbfPro ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "PRO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   if ( dbfPro )->( dbSeek( cCodPrp ) )

      if !Empty( oSay )
         oSay:SetText( ( dbfPro )->cDesPro )
      end

      lValid      := .T.

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end
   ErrorBlock( oBlock )

   ( dbfPro )->( dbCloseArea() )

RETURN lValid



FUNCTION brwProp( oGet, oSay )

   local oDlg
   local oBrw
   local oGetNbr
   local cGetNbr
   local oCbxOrd
   local cCbxOrd
   local nOrd     := GetBrwOpt( "BrwProp" )
   local aCbxOrd  := { "Código", "Nombre" }
   local nLevel   := Auth():Level( "01015" )

   nOrd           := Min( Max( nOrd, 1 ), len( aCbxOrd ) )
   cCbxOrd        := aCbxOrd[ nOrd ]

   if !OpenFiles()
      RETURN ( .F. )
   end

   oDlg = TDialog():New(,,,, "Seleccionar propiedad", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )






      oGetNbr := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGetNbr, cGetNbr:= u ) }, oDlg,,, {||    ( OrdClearScope( oBrw, dbfProT ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, dbfProT ) ) }, .F., .F.,,,,,, nil, "FIND",, )





      oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,,,,,, .F.,,,,,,, "oCbxOrd",,,,,,, )

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:cAlias          := dbfProT
      oBrw:nMarqueeStyle   := 5
      oBrw:cName           := "Browse.Propiedades"

      with object ( oBrw:AddCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodPro"
         :bEditValue       := {|| ( dbfProT )->cCodPro }
         :nWidth           := 60
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cDesPro"
         :bEditValue       := {|| ( dbfProT )->cDesPro }
         :nWidth           := 260
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }
      oBrw:bRClicked       := {| nRow, nCol, nFlags | oBrw:RButtonDown( nRow, nCol, nFlags ) }

      oBrw:CreateFromResource( 105 )




      TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )




      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )





      TButton():ReDefine( 500, {||( WinAppRec( oBrw, bEdit, dbfProT ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 2 ) <> 0 )},,, .F. )





      TButton():ReDefine( 501, {||( WinEdtRec( oBrw, bEdit, dbfProT ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 4 ) <> 0 )},,, .F. )

      oBrw:bLDblClick            := {|| oDlg:end( 1 ) }

      oDlg:AddFastKey( 113,       {|| if( nAnd( nLevel, 2 ) <> 0, WinAppRec( oBrw, bEdit, dbfProT ), ) } )
      oDlg:AddFastKey( 114,       {|| if( nAnd( nLevel, 4 ) <> 0, WinEdtRec( oBrw, bEdit, dbfProT ), ) } )
      oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )
      oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )

      oDlg:bStart := {|| oBrw:Load() }

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   DestroyFastFilter( dbfProT )

   SetBrwOpt( "BrwProp", ( dbfProT )->( OrdNumber() ) )

   if oDlg:nResult == 1

      oGet:cText( ( dbfProT )->cCodPro )

      if ValType( oSay ) == "O"
         oSay:SetText( ( dbfProT )->cDesPro )
      end

   end

   oGet:SetFocus()

   CloseFiles()

RETURN ( oDlg:nResult == 1 )



Static Function DeletePropiedades( cCodPro )

   local nOrdAnt  := ( dbfProL )->( OrdSetFocus( "nOrdPro" ) )

   ( dbfProL )->( dbGoTop() )

   if ( dbfProL )->( dbSeek( cCodPro ) )
      while ( dbfProL )->cCodPro == cCodPro .AND. !( dbfProL )->( eof() )
         if dbLock( dbfProL )
            ( dbfProL )->( dbDelete() )
            ( dbfProL )->( dbUnLock() )
         end
         ( dbfProL )->( dbSkip() )
      end
   end

   ( dbfProL )->( OrdSetFocus( nOrdAnt ) )
   ( dbfProL )->( dbGoTop() )

Return .T.



Static Function DelDet( oBrwLineas )

   dbDelRec( oBrwLineas, dbfTmpProL )

Return .T.



function lIsProp1( cCodArt, dbfFamilia, dbfArticulo )

   local lIsPro   := .F.

   if ( dbfArticulo )->( dbSeek( cCodArt ) )
      lIsPro      := Empty( ( dbfArticulo )->cCodPrp1 )
   end

RETURN ( lIsPro )



function lIsProp2( cCodArt, dbfFamilia, dbfArticulo )

   local lIsPro   := .F.

   if ( dbfArticulo )->( dbSeek( cCodArt ) )
      lIsPro      := Empty( ( dbfArticulo )->cCodPrp2 )
   end

RETURN ( lIsPro )



Function cBarPrp( cCodPrp, cValPrp, dbfTblPro )

   local cBarPro  := ""

   if dbSeekInOrd( cCodPrp + cValPrp, "cCodPro", dbfTblPro )
      cBarPro     := alltrim( ( dbfTblPro )->nBarTbl )
   end

RETURN ( cBarPro )



function lEmptyProp( cCodPrp, dbfTblPro )

   local lEmptyProp  := .T.

   if !Empty( cCodPrp ) .AND. dbSeekInOrd( cCodPrp, "nOrdPro", dbfTblPro )
      lEmptyProp     := .F.
   end

RETURN ( lEmptyProp )



Function cCodPrp( cCodPrp, nBarPrp, dbfTblPro )

   local cBarPro  := Space( 10 )

   if dbSeekInOrd( cCodPrp + nBarPrp, "nBarPro", dbfTblPro )
      cBarPro     := ( dbfTblPro )->cCodTbl
   else
      if dbSeekInOrd( cCodPrp + nBarPrp, "cCodPro", dbfTblPro )
         cBarPro  := ( dbfTblPro )->cCodTbl
      end
   end

RETURN ( cBarPro )



Function aSeekProp( cCodBar, cCodPr1, cCodPr2, dbfArticulo, dbfTblPro )

   local n
   local cCodArt     := cCodBar


   if dbSeekInOrd( padr( cCodBar, 18 ), "Codigo", dbfArticulo ) .OR.  dbSeekInOrd( upper( padr( cCodBar, 18 ) ), "Codigo", dbfArticulo )

      RETURN ( .T. )

   else

      n              := at( ".", cCodBar )

      if n <> 0

         cCodArt     := substr( cCodBar, 1, n - 1 )
         cCodBar     := substr( cCodBar, n + 1 )

         n           := at( ".", cCodBar )

         if n <> 0
            cCodPr1  := substr( cCodBar, 1, n - 1 )
            cCodPr2  := substr( cCodBar, n + 1 )
         else
            cCodPr1  := rtrim( cCodBar )
         end

      end

      if ( dbfArticulo )->( dbSeek( cCodArt ) )

         cCodBar     := ( dbfArticulo )->Codigo
         cCodPr1     := padr( cCodPr1, 20 )
         cCodPr2     := padr( cCodPr2, 20 )

         RETURN ( .T. )

      end

   end

RETURN ( .F. )






Function LoaPrePro( cCodArt, cCodPr1, cValPr1, cCodPr2, cValPr2, nTarPre, lIvaInc, aGet, dbfArtDiv, dbfTarPreL, cCodTar )

   local nPrePro  := nPrePro( cCodArt, cCodPr1, cValPr1, cCodPr2, cValPr2, nTarPre, lIvaInc, dbfArtDiv, dbfTarPreL, cCodTar )

   if nPrePro <> 0
      aGet:cText( nPrePro )
   end

return .T.






Function LoaComPro( cCodArt, cCodPr1, cValPr1, cCodPr2, cValPr2, aGet, dbfArtCom )

   local nPrePro  := nComPro( cCodArt, cCodPr1, cValPr1, cCodPr2, cValPr2, dbfArtCom )

   if nPrePro <> 0
      aGet:cText( nPrePro )
   end

return .T.



Function LoadPropertiesTable( cCodArt, nPrecioCosto, cCodPr1, cCodPr2, oGetUnidades, oGetPre, oBrw, nView )

RETURN ( nil )



Static Function bGenEditText( aTblPrp, oBrwPrp, n )

RETURN ( {|| aTblPrp[ oBrwPrp:nArrayAt, n ]:cText } )



Static Function bGenEditValue( aTblPrp, oBrwPrp, n )

RETURN ( {|| aTblPrp[ oBrwPrp:nArrayAt, n ]:Value } )



Static Function bGenRGBValue( aTblPrp, oBrwPrp, n )

RETURN ( {|| { nRGB( 0, 0, 0), aTblPrp[ oBrwPrp:nArrayAt, n ]:nRgb } } )



Static Function aPropertiesTable( oBrw, nTotalCol )

   local n
   local nAt
   local aRow        := {}

   nAt               := oBrw:nAt

   if nAt == 0
      RETURN ( aRow )
   end

   for n := 1 to nTotalCol
      if oBrw:Cargo[ nAt, n ]:Value == nil
         aAdd( aRow, oBrw:Cargo[ nAt, n ]:cText )
      else
         aAdd( aRow, Trans( oBrw:Cargo[ nAt, n ]:Value, MasUnd() ) )
      end
   next

RETURN ( aRow )



Static Function EditPropertiesTable( oBrw )

   local nRow     := oBrw:nAt
   local nCol     := oBrw:nColAct
   local uVar     := oBrw:Cargo[ nRow, nCol ]:Value

   if nCol <= 1
      return .F.
   end

   if oBrw:lEditCol( nCol, @uVar, MasUnd() )
      oBrw:Cargo[ nRow, nCol ]:Value   := uVar
      oBrw:Refresh()
   end

RETURN .T.



Static Function PutPropertiesTable( oBrw, oGet )

   local nRow
   local nCol
   local uVar

   if !Empty( oBrw ) .AND. !Empty( oBrw:Cargo )

      nRow        := oBrw:nAt
      nCol        := oBrw:nColAct
      uVar        := oBrw:Cargo[ nRow, nCol ]:nPrecioCompra

      if !Empty( oGet )
         oGet:cText( uVar )
      end

   end

RETURN .T.



Static Function validPropertiesTable( oBrw, oGet )

   local nRow
   local nCol
   local uVar
   local oBlock

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      nRow        := oBrw:nAt
      nCol        := oBrw:nColAct
      uVar        := oGet:VarGet()

      if IsArray( oBrw:Cargo )
         oBrw:Cargo[ nRow, nCol ]:nPrecioCompra := uVar
      end

   RECOVER

      msgStop( "Imposible asignar valor a la celda." )

   end

   ErrorBlock( oBlock )

RETURN .T.



Static Function KeyPropertiesTable( nKey, oBrw )

   local nVar     := 0
   local nRow     := oBrw:nAt
   local nCol     := oBrw:nColAct
   local uVar     := Val( Chr( nKey ) )

   if nCol <= 1
      return .F.
   end

   if oBrw:lEditCol( nCol, @nVar, MasUnd(), , , , , , , , {|oGet| oGet:KeyChar( nKey ) } )
      oBrw:Cargo[ nRow, nCol ]:Value   := nVar
      oBrw:GoDown()
      oBrw:Refresh()
   end

Return .T.



Static Function aPropertiesFooter( oBrw, nTotalRow, nTotalCol, oGet )

   local n
   local i
   local nTot  := 0
   local aRow  := AFill( Array( nTotalCol ), 0 )

   for n := 1 to nTotalCol
      for i := 1 to nTotalRow
         if oBrw:Cargo[ i, n ]:Value == nil
            aRow[ n ]   := "Total"
         else
            aRow[ n ]   += oBrw:Cargo[ i, n ]:Value
         end
      next
   next

   for n := 1 to nTotalCol
      if ValType( aRow[ n ] ) == "N"
         nTot           += aRow[ n ]
         aRow[ n ]      := Trans( aRow[ n ], MasUnd() )
      end
   next

   if oGet <> nil
      oGet:cText( nTot )
   end

RETURN ( aRow )



Static Function bPostEditProperties( oCol, xVal, nKey, oBrw, oGetUnidades )

   oBrw:Cargo[ oBrw:nArrayAt, oCol:Cargo ]:Value := xVal

   nTotalProperties( oBrw, oGetUnidades )

RETURN ( .T. )



Static Function nTotalProperties( oBrw, oGet )

   local aRow
   local aCol
   local nTot  := 0

   for each aRow in oBrw:Cargo
      for each aCol in aRow
         if !Empty( aCol )
            if isNum( aCol:Value )
               nTot  += aCol:Value
            end
         end
      next
   next

   if !empty( oGet )
      oGet:cText( nTot )
   end

RETURN ( .T. )



Function SearchProperty( oGetIra, oBrwPrp )

   local n
   local nPos
   local cHeader  := ""
   local cColumn  := ""
   local cGetIra  := Rtrim( oGetIra:cText() )
   local aHeaders := {}

   nPos           := At( ":", cGetIra )
   if nPos <> 0
      cHeader     := Left( cGetIra, nPos - 1)
      cColumn     := SubStr( cGetIra, nPos + 1 )
   else
      cHeader     := cGetIra
   end

   aeval( oBrwPrp:aCols, {|o| aAdd( aHeaders, o:cHeader ) } )

   if !Empty( cColumn )
      for n := 1 to len( oBrwPrp:Cargo )
         if Rtrim( Upper( oBrwPrp:Cargo[ n, 1 ]:cText ) ) == Rtrim( Upper( cColumn ) )
            oBrwPrp:nArrayAt := n
         end
      next
   end

   if !Empty( cHeader )
      nPos        := aScan( aHeaders, {| cH | Rtrim( Upper( cH ) ) == Rtrim( Upper( cHeader ) ) } )
      if nPos <> 0
         oBrwPrp:GoToCol( nPos )
      end
   end

   oGetIra:cText( Space( 20 ) )
   oGetIra:Refresh()

   oBrwPrp:Refresh()
   oBrwPrp:SetFocus()


Return nil



_HB_CLASS TPropertiesItems ; function TPropertiesItems ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TPropertiesItems", iif( .F., { }, { @HBObject() } ), @TPropertiesItems() ) ) ;

   _HB_MEMBER { cText } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cText"}, .F. )
   _HB_MEMBER { cCodigo } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cCodigo"}, .F. )
   _HB_MEMBER { cCodigoPropiedad1 } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cCodigoPropiedad1"}, .F. )
   _HB_MEMBER { cCodigoPropiedad2 } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cCodigoPropiedad2"}, .F. )
   _HB_MEMBER { cValorPropiedad1 } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cValorPropiedad1"}, .F. )
   _HB_MEMBER { cValorPropiedad2 } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cValorPropiedad2"}, .F. )
   _HB_MEMBER { nPrecioCompra } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nPrecioCompra"}, .F. )
   _HB_MEMBER { lColor } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lColor"}, .F. )
   _HB_MEMBER { nRgb } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nRgb"}, .F. )
   _HB_MEMBER { cHead } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cHead"}, .F. )

   _HB_MEMBER { Value } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Value"}, .F. )
   _HB_MEMBER { Uuid } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Uuid"}, .F. )

   _HB_MEMBER New(); oClass:AddMethod( "New", @TPropertiesItems_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER buildOne(); oClass:AddMethod( "buildOne", @TPropertiesItems_buildOne(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER buildTwo(); oClass:AddMethod( "buildTwo", @TPropertiesItems_buildTwo(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER buildUnits(); oClass:AddMethod( "buildUnits", @TPropertiesItems_buildUnits(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER PrecioCompra(); oClass:AddMethod( "PrecioCompra", @TPropertiesItems_PrecioCompra(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ToString(); oClass:AddMethod( "ToString", @TPropertiesItems_ToString(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER FromString(); oClass:AddMethod( "FromString", @TPropertiesItems_FromString(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getHead(); oClass:AddInline( "getHead", {|Self | ( ( Self ) ), ( rtrim( ::cHead ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TPropertiesItems ;



static FUNCTION TPropertiesItems_New( ) ; local Self AS CLASS TPropertiesItems := QSelf() AS CLASS TPropertiesItems

   ::cText              := ""
   ::nPrecioCompra      := 0
   ::cCodigo            := ""
   ::cHead              := ""
   ::cCodigoPropiedad1  := Space( 20 )
   ::cCodigoPropiedad2  := Space( 20 )
   ::cValorPropiedad1   := Space( 40 )
   ::cValorPropiedad2   := Space( 40 )
   ::lColor             := .F.
   ::nRgb               := 0

RETURN ( Self )



static FUNCTION TPropertiesItems_buildOne( hPropertyOne ) ; local Self AS CLASS TPropertiesItems := QSelf() AS CLASS TPropertiesItems

   ::New()

   ::cCodigo            := hPropertyOne[ "CodigoArticulo" ]
   ::cHead              := hPropertyOne[ "TipoPropiedad" ]
   ::cText              := hPropertyOne[ "CabeceraPropiedad" ]
   ::cCodigoPropiedad1  := hPropertyOne[ "CodigoPropiedad" ]
   ::cValorPropiedad1   := hPropertyOne[ "ValorPropiedad" ]
   ::lColor             := hPropertyOne[ "ColorPropiedad" ]
   ::nRgb               := hPropertyOne[ "RgbPropiedad" ]

   if hhaskey( hPropertyOne, "Uuid" )
      ::Uuid            := hPropertyOne[ "Uuid" ]
   end

RETURN ( Self )



static FUNCTION TPropertiesItems_buildTwo( hPropertyOne, aPropertyTable ) ; local Self AS CLASS TPropertiesItems := QSelf() AS CLASS TPropertiesItems

   ::New()

   ::Value               := 0
   ::cHead               := hPropertyOne[ "CabeceraPropiedad" ]
   ::cCodigo             := hPropertyOne[ "CodigoArticulo" ]
   ::cCodigoPropiedad2   := hPropertyOne[ "CodigoPropiedad" ]
   ::cValorPropiedad2    := hPropertyOne[ "ValorPropiedad" ]

   ::cCodigoPropiedad1   := aPropertyTable:cCodigoPropiedad1
   ::cValorPropiedad1    := aPropertyTable:cValorPropiedad1
   ::lColor              := aPropertyTable:lColor
   ::nRgb                := aPropertyTable:nRgb

RETURN ( Self )



static FUNCTION TPropertiesItems_buildUnits( hPropertyOne, aPropertyTable ) ; local Self AS CLASS TPropertiesItems := QSelf() AS CLASS TPropertiesItems

   ::New()

   ::Value                  := 0
   ::cHead                  := "Unidades"
   ::cCodigoPropiedad2      := Space( 40 )
   ::cValorPropiedad2       := Space( 40 )
   ::cCodigo                := aPropertyTable:cCodigoArticulo
   ::cCodigoPropiedad1      := aPropertyTable:cCodigoPropiedad1
   ::cValorPropiedad1       := aPropertyTable:cValorPropiedad1
   ::lColor                 := aPropertyTable:lColor
   ::nRgb                   := aPropertyTable:nRgb

RETURN ( Self )



static FUNCTION TPropertiesItems_PrecioCompra( nPrecioCosto, dbfArtCom ) ; local Self AS CLASS TPropertiesItems := QSelf() AS CLASS TPropertiesItems

   ::nPrecioCompra      := nComPro( ::cCodigo, ::cCodigoPropiedad1, ::cValorPropiedad1, ::cCodigoPropiedad2, ::cValorPropiedad2, dbfArtCom )

   if ::nPrecioCompra == 0
      ::nPrecioCompra   := nPrecioCosto
   end

RETURN ( ::nPrecioCompra )



static FUNCTION TPropertiesItems_ToString( ) ; local Self AS CLASS TPropertiesItems := QSelf() AS CLASS TPropertiesItems

   local cString  := ""

   cString        += "cText : "              + Rtrim( cValToChar( ::cText ) )               + ","
   cString        += "cHead : "              + Rtrim( cValToChar( ::cHead ) )               + ","
   cString        += "Value : "              + Rtrim( cValToChar( ::Value ) )               + ","
   cString        += "cCodigo : "            + Rtrim( cValToChar( ::cCodigo ) )             + ","
   cString        += "cCodigoPropiedad1 : "  + Rtrim( cValToChar( ::cCodigoPropiedad1 ) )   + ","
   cString        += "cCodigoPropiedad2 : "  + Rtrim( cValToChar( ::cCodigoPropiedad2 ) )   + ","
   cString        += "cValorPropiedad1 : "   + Rtrim( cValToChar( ::cValorPropiedad1 ) )    + ","
   cString        += "cValorPropiedad2 : "   + Rtrim( cValToChar( ::cValorPropiedad2 ) )    + ","
   cString        += "nPrecioCompra : "      + Rtrim( cValToChar( ::nPrecioCompra ) )       + ";"

RETURN ( cString )



static FUNCTION TPropertiesItems_FromString( cString ) ; local Self AS CLASS TPropertiesItems := QSelf() AS CLASS TPropertiesItems

   local aTokens        := hb_aTokens( cString, "," )

   ::cText              := aTokens[ 1 ]
   ::cHead              := aTokens[ 2 ]

   if Val( aTokens[ 3 ] ) <> 0
      ::Value           := Val( aTokens[ 3 ] )
   else
      ::Value           := nil
   end

   ::cCodigo            := aTokens[ 4 ]
   ::cCodigoPropiedad1  := aTokens[ 5 ]
   ::cCodigoPropiedad2  := aTokens[ 6 ]
   ::cValorPropiedad1   := aTokens[ 7 ]
   ::cValorPropiedad2   := aTokens[ 8 ]
   ::nPrecioCompra      := Val( aTokens[ 9 ] )

RETURN ( Self )





FUNCTION lPrpAct( cVal, oSay, cPrp, dbfTblPro )

   local lRet     := .F.

   if isObject( cVal ) .AND. Empty( cVal:VarGet() )
      return .T.
   end

   if Empty( cPrp )
      return .T.
   end

   if Empty( dbfprol )

      if !OpenFiles()
         Return .F.
      end

      dbfTblPro      := dbfProL

   end





   if !dbSeekInOrd( cPrp, "CPRO", dbfTblPro )
      Return .T.
   end

   if ValType( cVal ) == "O"
      cVal        := cVal:VarGet()
   end





   if Rtrim( cVal ) == "*"
      if oSay <> nil
         oSay:SetText( "Todos" )
      end
      return .T.
   end

   if dbSeekInOrd( cPrp + cVal, "cCodPro", dbfTblPro ) .OR. dbSeekInOrd( Upper( cPrp + cVal ), "cCodPro", dbfTblPro )

      if oSay <> nil
         oSay:SetText( ( dbfTblPro )->cDesTbl )
      end

      lRet        := .T.

   else

      if oSay <> nil
         oSay:SetText( "" )
      end

      if !Empty( cVal )
         MsgStop( "Valor de la propiedad " + Rtrim( cVal ) + " no encontrado." )
      end

   end

   CloseFiles()

RETURN ( lRet )



FUNCTION brwPrpAct( oGet, oSay, cPrp )

   local oDlg
   local oBrw
   local lRet        := .F.
   local oBlock
   local oError
   local cTitle      := ""
   local oGetNbr
   local cGetNbr
   local oCbxOrd
   local cCbxOrd     := "Código"
   local aCbxOrd     := { "Código", "Nombre" }
   local cTmpBrw
   local nOrdTmp
   local oSayText
   local cSayText    := "Propiedades"
   local dbfTmpBrw

   if Empty( cPrp )
      MsgStop( "No hay propiedades seleccionadas para este artículo." )
      Return .F.
   end

   if !OpenFiles()
      Return .F.
   end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE



   cTitle            := "Seleccionar propiedad : " + retProp( cPrp, dbfProT )



   cTmpBrw           := cGetNewFileName( cPatTmp() + "TmpBrw" )

   dbCreate( cTmpBrw, aSqlStruct( aItmTmpBrw() ), cLocalDriver() )
   dbUseArea( .T., cLocalDriver(), cTmpBrw, cCheckArea( "TmpBrw", @dbfTmpBrw ), .F. )

   if !( dbfTmpBrw )->( neterr() )

      ( dbfTmpBrw )->( OrdCondSet( "!Deleted()", {||!Deleted()}  ) )
      ( dbfTmpBrw )->( OrdCreate( cTmpBrw, "cCodTbl", "cCodTbl", {|| Field->cCodTbl } ) )

      ( dbfTmpBrw )->( OrdCondSet( "!Deleted()", {||!Deleted()}  ) )
      ( dbfTmpBrw )->( OrdCreate( cTmpBrw, "cDesTbl", "cDesTbl", {|| Field->cDesTbl } ) )

   end

   nOrdTmp           := ( dbfProL )->( OrdSetFocus( "nOrdPro" ) )

   ( dbfProL )->( dbGoTop() )

   if ( dbfProL )->( dbSeek( cPrp ) )

      while ( dbfProL )->cCodPro == cPrp .AND. !( dbfProL )->( eof() )

         if dbAppe( dbfTmpBrw )
            ( dbfTmpBrw )->cCodTbl  := ( dbfProL )->cCodTbl
            ( dbfTmpBrw )->cDesTbl  := ( dbfProL )->cDesTbl
            ( dbfTmpBrw )->( dbUnLock() )
         end

         ( dbfProL )->( dbSkip() )

      end

   end

   ( dbfTmpBrw )->( dbGoTop() )

   ( dbfProL )->( OrdSetFocus( nOrdTmp ) )
   ( dbfProL )->( dbGoTop() )



   oDlg = TDialog():New(,,,, cTitle, "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )





      oGetNbr := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGetNbr, cGetNbr:= u ) }, oDlg,,,,,,,,, .F.,, {|nKey,nFlags,Self| autoSeek( nKey, nFlags, Self, oBrw, dbfTmpBrw ) }, .F., .F.,,,,,, nil, "FIND",, )






      oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,, {|Self|( ( dbfTmpBrw )->( OrdSetFocus( oCbxOrd:nAt ) ), ( dbfTmpBrw )->( dbGoTop() ), oBrw:Refresh(), oGetNbr:SetFocus(), oCbxOrd:Refresh() )},,,, .F.,,,,,,, "oCbxOrd",,,,,,, )

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:cAlias          := dbfTmpBrw

      oBrw:nMarqueeStyle   := 5
      oBrw:lHScroll        := .T.

      with object ( oBrw:AddCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodTbl"
         :bEditValue       := {|| ( dbfTmpBrw )->cCodTbl }
         :nWidth           := 180
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ), eval( oCbxOrd:bChange ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cDesTbl"
         :bEditValue       := {|| ( dbfTmpBrw )->cDesTbl }
         :nWidth           := 280
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ), eval( oCbxOrd:bChange ) }
      end

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }

      oBrw:CreateFromResource( 105 )





      TButton():ReDefine( 500, {||nil}, oDlg,,, .F., {||     .F.},,, .F. )





      TButton():ReDefine( 501, {||nil}, oDlg,,, .F., {||     .F.},,, .F. )




      TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )




      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

      oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )
      oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if ( oDlg:nResult == 1 )

      oGet:cText( ( dbfTmpBrw )->cCodTbl )

      if isObject( oSay )
         oSay:SetText( ( dbfTmpBrw )->cDesTbl )
      end

      lRet        := .T.

   end

   RECOVER USING oError

      msgStop( ErrorMessage( oError ), "Imposible mostrar tablas de propiedades" )

   end
   ErrorBlock( oBlock )

   CloseFiles()

   if !Empty( dbfTmpBrw ) .AND. ( dbfTmpBrw )->( Used() )
      ( dbfTmpBrw )->( dbCloseArea() )
   end

   dbfTmpBrw      := nil

   dbfErase( cTmpBrw )

RETURN ( lRet )



FUNCTION brwPropiedadActual( oGet, oSay, cPrp )

   local oDlg
   local oBrw
   local lRet        := .F.
   local cKey        := ""
   local oBlock
   local oError
   local cTitle      := ""
   local oGetNbr
   local cGetNbr
   local oCbxOrd
   local cCbxOrd     := "Código"
   local aCbxOrd     := { "Código", "Nombre" }
   local aIdxOrd     := { "cCodPro", "cCodDes" }

   if Empty( cPrp )
      MsgStop( "No hay propiedades seleccionadas para este artículo." )
      Return .F.
   end

   if !OpenFiles()
      Return .F.
   end



   if !dbSeekInOrd( cPrp, "CPRO", dbfProL )
      MsgStop( "No existen valores para esta propiedad" )
      Return .T.
   end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE



   if !Empty( oGet )
      cKey           := oGet:varget()
   end

   cTitle            := "Seleccionar propiedad : " + retProp( cPrp, dbfProT )



   ( dbfProL )->( ordScope( 0, cPrp ) )
   ( dbfProL )->( ordScope( 1, cPrp ) )
   ( dbfProL )->( dbGoTop() )



   ( dbfProL )->( dbseek( alltrim( cPrp + cKey ), .T. ) )



   oDlg = TDialog():New(,,,, cTitle, "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )







      oGetNbr := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGetNbr, cGetNbr:= u ) }, oDlg,,, {||       ( ( dbfProL )->( ordScope( 0, cPrp ) ), ( dbfProL )->( ordScope( 1, cPrp ) ) )},,,,,, .F.,, {|nKey,nFlags,Self| autoSeek( nKey, nFlags, Self, oBrw, dbfProL, nil, cPrp ) }, .F., .F.,,,,,, nil, "FIND",, )






      oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,, {|Self|( changeComboBrowse( aIdxOrd[ oCbxOrd:nAt ], oBrw, oGetNbr, oCbxOrd, cPrp ) )},,,, .F.,,,,,,, "oCbxOrd",,,,,,, )



      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:cAlias          := dbfProL

      oBrw:nMarqueeStyle   := 5
      oBrw:lHScroll        := .T.

      with object ( oBrw:AddCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodPro"
         :bEditValue       := {|| ( dbfProL )->cCodTbl }
         :nWidth           := 180
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ), changeComboBrowse( "cCodPro", oBrw, oGetNbr, oCbxOrd, cPrp ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cCodDes"
         :bEditValue       := {|| ( dbfProL )->cDesTbl }
         :nWidth           := 280
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ), changeComboBrowse( "cCodDes", oBrw, oGetNbr, oCbxOrd, cPrp ) }
      end

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }

      oBrw:CreateFromResource( 105 )





      TButton():ReDefine( 500, {||( nil )}, oDlg,,, .F., {||     ( .F. )},,, .F. )




      TButton():ReDefine( 501, {||( WinEdtRec( oBrw, bEdit, dbfProT, cPrp, cKey ) )}, oDlg,,, .F.,,,, .F. )




      TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )




      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

      oDlg:AddFastKey( 114,       {|| WinEdtRec( oBrw, bEdit, dbfProT, cPrp, cKey ) } )
      oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )
      oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if ( oDlg:nResult == 1 )

      if !Empty( oGet )
         oGet:cText( ( dbfProL )->cCodTbl )
      end

      if IsObject( oSay )
         oSay:SetText( ( dbfProL )->cDesTbl )
      end

      if Empty( oGet )
         lRet        := ( dbfProL )->cCodTbl
      else
         lRet        := .T.
      end

   end

   RECOVER USING oError

      msgStop( ErrorMessage( oError ), "Imposible mostrar tablas de propiedades" )

   end
   ErrorBlock( oBlock )

   CloseFiles()

RETURN ( lRet )



STATIC FUNCTION changeComboBrowse( orden, oBrw, oGetNbr, oCbxOrd, cPrp )

   OrdClearScope( oBrw, dbfProL )

   ( dbfProL )->( OrdSetFocus( orden ) )

   ( dbfProL )->( ordScope( 0, cPrp ) )
   ( dbfProL )->( ordScope( 1, cPrp ) )

   ( dbfProL )->( dbGoTop() )

   oBrw:Refresh()

   oGetNbr:SetFocus()

   oCbxOrd:Refresh()

RETURN ( .T. )



STATIC FUNCTION OpenFiles()

   local lOpen                         := .T.
   local oBlock                        := ErrorBlock( {| oError | ApoloBreak( oError ) } )

   BEGIN SEQUENCE

      nView                            := D():CreateView()

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PRO.DBF" ), ( cCheckArea( "PRO", @dbfProT ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PRO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "TBLPRO.DBF" ), ( cCheckArea( "TBLPRO", @dbfProL ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "TBLPRO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      oDetCamposExtra                  := TDetCamposExtra():New()
      oDetCamposExtra:OpenFiles()
      oDetCamposExtra:SetTipoDocumento( "Propiedades" )
      oDetCamposExtra:setbId( {|| D():PropiedadesId( nView ) } )

      oLinDetCamposExtra               := TDetCamposExtra():New()
      oLinDetCamposExtra:OpenFiles()
      oLinDetCamposExtra:setTipoDocumento( "Lineas de propiedades" )
      oLinDetCamposExtra:setbId( {|| D():PropiedadesLineasId( nView ) } )

   RECOVER

      msgStop( "Imposible abrir todas las bases de datos" )

      CloseFiles()

      lOpen       := .F.

   end

   ErrorBlock( oBlock )

RETURN ( lOpen )



STATIC FUNCTION CloseFiles()

   if dbfProT <> nil
      ( dbfProT )->( dbCloseArea() )
   end

   if dbfProL <> nil
      ( dbfProL )->( dbCloseArea() )
   end

   if !empty( oDetCamposExtra )
      oDetCamposExtra:CloseFiles()
   end

   if !Empty( oLinDetCamposExtra )
      oLinDetCamposExtra:CloseFiles()
      oLinDetCamposExtra:End()
   end

   D():DeleteView( nView )

   dbfProT              := nil
   dbfProL              := nil
   oDetCamposExtra      := nil
   oLinDetCamposExtra   := nil
   oWndBrw              := nil

RETURN .T.



Static Function aItmTmpBrw()

   local aBase := {}

   aAdd( aBase, { "CCODTBL",  "C", 40, 0, "Código de línea de propiedadades"   } )
   aAdd( aBase, { "CDESTBL",  "C", 30, 0, "Nombre de línea de propiedadades"   } )

RETURN ( aBase )



FUNCTION retProp( cCodPrp, dbfPro )

   local oBlock
   local oError
   local lClo     := .F.
   local cPrp     := ""

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if Empty( dbfPro )
      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "PRO.DBF" ), ( cCheckArea( "PRO", @dbfPro ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "PRO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClo        := .T.
   end

   if ValType( dbfPro ) == "O"
      if dbfPro:Seek( cCodPrp )
         cPrp     := dbfPro:cDesPro
      end
   else
      if ( dbfPro )->( dbSeek( cCodPrp ) )
         cPrp     := ( dbfPro )->cDesPro
      end
   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClo
      ( dbfPro )->( dbCloseArea() )
   end

RETURN ( cPrp )



Function IsPro()


   if !lExistTable( cPatEmp() + "PRO.Dbf" ) .OR. !lExistTable( cPatEmp() + "TBLPRO.Dbf" )
      mkPro( cPatEmp() )
   end


   if !lExistIndex( cPatEmp() + "PRO.Cdx" ) .OR. !lExistIndex( cPatEmp() + "TBLPRO.Cdx" )
      rxPro( cPatEmp() )
   end

RETURN ( .T. )



Function mkPro( cPath, lAppend, cPathOld, oMeter )

   local cDbf

   If( cPath == nil, cPath := cPatEmp(), ) ;
   If( lAppend == nil, lAppend := .F., ) ;

   if !lExistTable( cPath + "Pro.Dbf", cLocalDriver() )
      dbCreate( cPath + "Pro.Dbf", aSqlStruct( aPro() ), cLocalDriver() )
   end

   if lAppend .AND. !Empty( cPathOld ) .AND. lExistTable( cPathOld + "Pro.Dbf" )

      dbUseArea( .T., cLocalDriver(), cPath + "Pro.Dbf", cCheckArea( "Pro", @cDbf ), .F. )

      if !( cDbf )->( neterr() )
         ( cDbf )->( __dbApp( cPathOld + "Pro.Dbf" ) )
         ( cDbf )->( dbCloseArea() )
      end

   end

   if !lExistTable( cPath + "TblPro.Dbf", cLocalDriver() )
      dbCreate( cPath + "TblPro.Dbf", aSqlStruct( aItmPro() ), cLocalDriver() )
   end

   if lAppend .AND. !Empty( cPathOld ) .AND. lExistTable( cPathOld + "TblPro.Dbf" )

      dbUseArea( .T., cLocalDriver(), cPath + "TblPro.Dbf", cCheckArea( "Pro", @cDbf ), .F. )

      if !( cDbf )->( neterr() )
         ( cDbf )->( __dbApp( cPathOld + "TblPro.Dbf" ) )
         ( cDbf )->( dbCloseArea() )
      end

   end

   rxPro( cPath, oMeter )

Return nil



Function rxPro( cPath, oMeter )

   local dbfPro

   If( cPath == nil, cPath := cPatEmp(), ) ;

   if !lExistTable( cPath + "PRO.DBF" ) .OR. !lExistTable( cPath + "TblPro.Dbf" )
      mkPro( cPath )
   end

   if lExistIndex( cPath + "PRO.CDX" )
      fErase( cPath + "PRO.CDX" )
   end

   if lExistIndex( cPath + "TBLPRO.CDX" )
      fErase( cPath + "TBLPRO.CDX" )
   end

   if lExistTable( cPath + "PRO.DBF" )

      dbUseArea( .T., cLocalDriver(), cPath + "PRO.DBF", cCheckArea( "PRO", @dbfPro ), .F. )

      if !( dbfPro )->( neterr() )
         ( dbfPro )->( __dbPack() )

         ( dbfPro )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
         ( dbfPro )->( ordCreate( cPath + "PRO.CDX", "CCODPRO", "Field->CCODPRO", {|| Field->CCODPRO } ) )

         ( dbfPro )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
         ( dbfPro )->( ordCreate( cPath + "PRO.CDX", "CDESPRO", "Field->CDESPRO", {|| Field->CDESPRO } ) )

         ( dbfPro )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
         ( dbfPro )->( ordCreate( cPath + "PRO.CDX", "CCODWEB", "Str( Field->cCodWeb, 11 )", {|| Str( Field->cCodWeb, 11 ) } ) )

         ( dbfPro )->( dbCloseArea() )
      else
         msgStop( "Imposible abrir en modo exclusivo la tabla de propiedades" )
      end

      dbUseArea( .T., cLocalDriver(), cPath + "TBLPRO.DBF", cCheckArea( "TBLPRO", @dbfPro ), .F. )

      if !( dbfPro )->( neterr() )
         ( dbfPro )->( __dbPack() )

         ( dbfPro )->( ordCondSet( "!Deleted()", {|| !Deleted() }  ) )
         ( dbfPro )->( ordCreate( cPath + "TBLPRO.CDX", "cCodPro", "upper( Field->cCodPro ) + upper( Field->cCodTbl )", {|| upper( Field->cCodPro ) + upper(  Field->cCodTbl ) } ) )

         ( dbfPro )->( ordCondSet( "!Deleted()", {|| !Deleted() }  ) )
         ( dbfPro )->( ordCreate( cPath + "TBLPRO.CDX", "CCODDES", "upper( Field->cCodPro ) + upper( Field->cDesTbl )", {|| upper( Field->cCodPro ) + upper( Field->cDesTbl ) } ) )

         ( dbfPro )->( ordCondSet( "!Deleted()", {|| !Deleted() }  ) )
         ( dbfPro )->( ordCreate( cPath + "TBLPRO.CDX", "nOrdPro", "upper( Field->cCodPro ) + Str( Field->nOrdTbl )", {|| upper( Field->cCodPro ) + Str( Field->nOrdTbl ) } ) )

         ( dbfPro )->( ordCondSet( "!Deleted()", {|| !Deleted() }  ) )
         ( dbfPro )->( ordCreate( cPath + "TBLPRO.CDX", "NBARPRO", "upper( Field->cCodPro ) + Field->nBarTbl", {|| upper( Field->cCodPro ) + Field->nBarTbl } ) )

         ( dbfPro )->( ordCondSet( "!Deleted()", {|| !Deleted() }  ) )
         ( dbfPro )->( ordCreate( cPath + "TBLPRO.CDX", "CPRO", "upper( Field->cCodPro )", {|| upper( Field->cCodPro ) } ) )

         ( dbfPro )->( ordCondSet( "!Deleted()", {|| !Deleted() }  ) )
         ( dbfPro )->( ordCreate( cPath + "TBLPRO.CDX", "CCODWEB", "Str( Field->cCodWeb, 11 )", {|| Str( Field->cCodWeb, 11 ) } ) )

         ( dbfPro )->( ordCondSet( "!Deleted()", {|| !Deleted() }  ) )
         ( dbfPro )->( ordCreate( cPath + "TBLPRO.CDX", "CCODTBL", "Field->cCodTbl", {|| Field->cCodTbl } ) )

         ( dbfPro )->( dbCloseArea() )
      else
         msgStop( "Imposible abrir en modo exclusivo la tabla de lineas de propiedades" )
      end

   end

RETURN NIL



Static Function aPro()

   local aBase := {}

   aAdd( aBase, { "cCodPro",   "C", 20, 0, "Código de la propiedad"                 } )
   aAdd( aBase, { "cDesPro",   "C", 30, 0, "Nombre de la propiedad"                 } )
   aAdd( aBase, { "cCodWeb",   "N", 11, 0, "Código de la propiedad en la web"       } )
   aAdd( aBase, { "lPubInt",   "L",  1, 0, "Lógico de propiedad en la web"          } )
   aAdd( aBase, { "lSndDoc",   "L",  1, 0, "Lógico de propiedad para envio"         } )
   aAdd( aBase, { "cNomInt",   "C", 50, 0, "Nombre de la propiedad en la web"       } )
   aAdd( aBase, { "lColor",    "L",  1, 0, "Lógico tipo color"                      } )
   aAdd( aBase, { "cIdWP",     "C", 40, 0, "Id relación con WordPress"              } )

RETURN ( aBase )



Function aItmPro()

   local aBase := {}

   aAdd( aBase, { "cCodPro",   "C", 20, 0, "Código propiedad"                       } )
   aAdd( aBase, { "cCodTbl",   "C", 40, 0, "Código de línea de propiedad"           } )
   aAdd( aBase, { "cDesTbl",   "C", 30, 0, "Nombre de línea de propiedad"           } )
   aAdd( aBase, { "nOrdTbl",   "N",  4, 0, "Número de orden para codigos de barras" } )
   aAdd( aBase, { "nBarTbl",   "C",  4, 0, "Código para codigos de barras"          } )
   aAdd( aBase, { "cCodWeb",   "N", 11, 0, "Código del producto en la web"          } )
   aAdd( aBase, { "nColor",    "N", 10, 0, "Código de color"                        } )
   aAdd( aBase, { "cIdWP",     "C", 40, 0, "Id relación con WordPress"              } )

RETURN ( aBase )



Function nCosPro( cCodArt, cCodPr1, cValPr1, cCodPr2, cValPr2, dbfArtDiv )

   local nPrecioCosto        := 0

   if ( dbfArtDiv )->( dbSeek( cCodArt + cCodPr1 + cCodPr2 + cValPr1 + cValPr2 ) )
      nPrecioCosto           := ( dbfArtDiv )->nPreCom
   end

RETURN ( nPrecioCosto )



Function nPreAlq( cCodArt, nTarPre, lIvaInc, dbfArtDiv )

   local  nPreAlq       := 0

   if ( dbfArtDiv )->( dbSeek( cCodArt ) )

      do case
         case nTarPre == 1
            nPreAlq  := if( lIvaInc, ( dbfArtDiv )->pAlqIva1, ( dbfArtDiv )->pAlq1 )
         case nTarPre == 2
            nPreAlq  := if( lIvaInc, ( dbfArtDiv )->pAlqIva2, ( dbfArtDiv )->pAlq2 )
         case nTarPre == 3
            nPreAlq  := if( lIvaInc, ( dbfArtDiv )->pAlqIva3, ( dbfArtDiv )->pAlq3 )
         case nTarPre == 4
            nPreAlq  := if( lIvaInc, ( dbfArtDiv )->pAlqIva4, ( dbfArtDiv )->pAlq4 )
         case nTarPre == 5
            nPreAlq  := if( lIvaInc, ( dbfArtDiv )->pAlqIva5, ( dbfArtDiv )->pAlq5 )
         case nTarPre == 6
            nPreAlq  := if( lIvaInc, ( dbfArtDiv )->pAlqIva6, ( dbfArtDiv )->pAlq6 )
      end

   end

RETURN ( nPreAlq )



Function nPrecioPorPorpiedades( cCodigoArticulo, cCodPr1, cValPr1, cCodPr2, cValPr2, dbfArtDiv, nTarPre, lIvaInc )

   local nOrden
   local nRecno
   local nPreVta        := 0

   If( nTarPre == nil, nTarPre := 1, ) ;
   If( lIvaInc == nil, lIvaInc := .T., ) ;

   nOrden               := ( dbfArtDiv )->( ordsetfocus() )
   nRecno               := ( dbfArtDiv )->( recno() )

   cCodigoArticulo      := padr( cCodigoArticulo, 18 )
   cCodPr1              := padr( cCodPr1, 20 )
   cValPr1              := padr( cValPr1, 20 )
   cCodPr2              := padr( cCodPr2, 20 )
   cValPr2              := padr( cValPr2, 20 )

   if dbSeekInOrd( cCodigoArticulo + cCodPr1 + cCodPr2 + cValPr1 + cValPr2, "cCodArt", dbfArtDiv )

      do case
         case nTarPre <= 1
            nPreVta     := if( lIvaInc, ( dbfArtDiv )->nPreIva1, ( dbfArtDiv )->nPreVta1 )
         case nTarPre == 2
            nPreVta     := if( lIvaInc, ( dbfArtDiv )->nPreIva2, ( dbfArtDiv )->nPreVta2 )
         case nTarPre == 3
            nPreVta     := if( lIvaInc, ( dbfArtDiv )->nPreIva3, ( dbfArtDiv )->nPreVta3 )
         case nTarPre == 4
            nPreVta     := if( lIvaInc, ( dbfArtDiv )->nPreIva4, ( dbfArtDiv )->nPreVta4 )
         case nTarPre == 5
            nPreVta     := if( lIvaInc, ( dbfArtDiv )->nPreIva5, ( dbfArtDiv )->nPreVta5 )
         case nTarPre == 6
            nPreVta     := if( lIvaInc, ( dbfArtDiv )->nPreIva6, ( dbfArtDiv )->nPreVta6 )
      end

   end

   ( dbfArtDiv )->( ordsetfocus( nOrden ) )
   ( dbfArtDiv )->( dbgoto( nRecno) )

RETURN ( nPreVta )



Function nPrePro( cCodArt, cCodPr1, cValPr1, cCodPr2, cValPr2, nTarPre, lIvaInc, dbfArtDiv, dbfTarPreL, cCodTar )

   local nPreVta     := 0

   If( nTarPre == nil, nTarPre := 1, ) ;
   If( lIvaInc == nil, lIvaInc := .T., ) ;

   if empty( cCodTar )
      nPreVta        := nPrecioPorPorpiedades( cCodArt, cCodPr1, cValPr1, cCodPr2, cValPr2, dbfArtDiv, nTarPre, lIvaInc )
   else
      if !empty( dbfTarPreL )
         nPreVta     := retPrcTar( cCodArt, cCodTar, cCodPr1, cCodPr2, cValPr1, cValPr2, dbfTarPreL, nTarPre )
      end
   end

RETURN ( nPreVta )



FUNCTION retValProp( cCodPrp, dbfPro )

   local oBlock
   local oError
   local lClo        := .F.
   local cPrp        := ""

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if Empty( dbfPro )
      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "TBLPRO.DBF" ), ( cCheckArea( "PROTBL", @dbfPro ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "TBLPRO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClo           := .T.
   end

   do case
      case isObject( dbfPro )
         if dbfPro:Seek( cCodPrp )
            cPrp     := dbfPro:cDesTbl
         end
      case isChar( dbfPro )
         if ( dbfPro )->( dbSeek( cCodPrp ) )
            cPrp     := ( dbfPro )->cDesTbl
         end
   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClo
      ( dbfPro )->( dbCloseArea() )
   end

RETURN ( cCodPrp )



FUNCTION cNombrePropiedad( cCodigoPropiedad, cValorPropiedad, dbfPro )

   local oBlock
   local oError
   local cNombrePropiedad

   oBlock                     := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if isObject( dbfPro )
      if dbfPro:Seek( cCodigoPropiedad + cValorPropiedad )
         cNombrePropiedad     := dbfPro:cDesTbl
      end
   else
      if ( dbfPro )->( dbSeek( cCodigoPropiedad + cValorPropiedad ) )
         cNombrePropiedad     := ( dbfPro )->cDesTbl
      end
   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

RETURN ( cNombrePropiedad )



Static Function ChangelSndDoc( aTmp )

   local nRec

   for each nRec in ( oWndBrw:oBrw:aSelected )

      ( dbfProT )->( dbGoTo( nRec ) )

      if ( dbfProT )->( dbRLock() )
         ( dbfProT )->lSndDoc    := !( dbfProT )->lSndDoc
         ( dbfProT )->( dbCommit() )
         ( dbfProT )->( dbUnLock() )
      end

   next

   oWndBrw:Refresh()

Return nil



Static Function ChangePublicar( aTmp )

   local nRec

   if Empty( aTmp )

      for each nRec in ( oWndBrw:oBrw:aSelected )

         ( dbfProT )->( dbGoTo( nRec ) )

         if ( dbfProT )->( dbRLock() )
            ( dbfProT )->lPubInt   := !( dbfProT )->lPubInt
            ( dbfProT )->lSndDoc   := ( dbfProT )->lPubInt
            ( dbfProT )->( dbCommit() )
            ( dbfProT )->( dbUnLock() )
         end

      next

      oWndBrw:Refresh()

   end

Return nil




Function nComPro( cCodArt, cCodPr1, cValPr1, cCodPr2, cValPr2, dbfArtCom )

   local nPreCom  := 0

   if !empty( cValPr1 ) .OR. !empty( cValPr2 )
      if ( dbfArtCom )->( dbSeek( cCodArt + cCodPr1 + cCodPr2 + cValPr1 + cValPr2 ) )
         nPreCom     := ( dbfArtCom )->nPreCom
      end
   end

RETURN ( nPreCom )





FUNCTION brwSelectPropiedad( cPrp, cVal )

   local oDlg
   local oBrw
   local aVal
   local aData       := {}
   local oBlock
   local oError

   if Empty( cPrp )
      MsgStop( "No hay propiedades seleccionadas para este artículo." )
      Return .F.
   end

   if !OpenFiles()
      Return .F.
   end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   aVal              := hb_atokens( cVal, "," )



   ( dbfProL )->( OrdSetFocus( "nOrdPro" ) )

   if ( dbfProL )->( dbSeek( cPrp ) )

      while ( dbfProL )->cCodPro == cPrp .AND. !( dbfProL )->( eof() )

         aAdd( aData, { aScan( aVal, {|a| Alltrim( ( dbfProL )->cCodTbl ) == a } ) <> 0, ( dbfProL )->cCodTbl, ( dbfProL )->cDesTbl } )

         ( dbfProL )->( dbSkip() )

      end

   end



   oDlg = TDialog():New(,,,, "Seleccionar propiedad : " + retProp( cPrp, dbfProT ), "SelectPropiedad",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )




      TButton():ReDefine( 500, {||( SelectPropiedadDblClick( oBrw, aData ) )}, oDlg,,, .F.,,,, .F. )




      TButton():ReDefine( 501, {||( SelectPropiedadDblClick( oBrw, aData, .T. ) )}, oDlg,,, .F.,,,, .F. )




      TButton():ReDefine( 502, {||( SelectPropiedadDblClick( oBrw, aData, .F. ) )}, oDlg,,, .F.,,,, .F. )

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:SetArray( aData )

      oBrw:nMarqueeStyle   := 5
      oBrw:lHScroll        := .T.

      oBrw:bLDblClick      := {|| SelectPropiedadDblClick( oBrw, aData ) }

      oBrw:CreateFromResource( 100 )

      with object ( oBrw:aCols[ 1 ] )
         :cHeader       := "Sel."
         :bEditValue    := {|| aData[ oBrw:nArrayAt, 1 ] }
         :nWidth        := 20
         :SetCheck( { "Sel16", "Nil16" } )
      end

      with object ( oBrw:aCols[ 2 ] )
         :cHeader       := "Código"
         :bEditValue    := {|| aData[ oBrw:nArrayAt, 2 ] }
         :nWidth        := 180
      end

      with object ( oBrw:aCols[ 3 ] )
         :cHeader       := "Nombre"
         :bEditValue    := {|| aData[ oBrw:nArrayAt, 3 ] }
         :nWidth        := 280
      end




      TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )




      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

      oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )
      oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if ( oDlg:nResult == 1 )
      cVal        := SelectedPropiedadToMemo( aData )
   end

   RECOVER USING oError

      msgStop( ErrorMessage( oError ), "Imposible mostrar tablas de propiedades" )

   end
   ErrorBlock( oBlock )

   CloseFiles()

RETURN ( nil )



Static Function SelectPropiedadDblClick( oBrw, aData, lAllSelected )

   if !Empty( aData )

      do case
         case IsNil( lAllSelected )

            aData[ oBrw:nArrayAt, 1 ]  := !aData[ oBrw:nArrayAt, 1 ]

         case IsTrue( lAllSelected )

            aEval( aData, {|a| a[ 1 ] := .T. } )

         case IsFalse( lAllSelected )

            aEval( aData, {|a| a[ 1 ] := .F. } )

      end


   end

   if !Empty( oBrw )
      oBrw:Refresh()
   end

RETURN ( nil )



Static Function SelectedPropiedadToMemo( aData )

   local cMemo := ""

   aEval( aData, {|aItem| if( aItem[ 1 ], cMemo += Rtrim( aItem[ 2 ] ) + ",", ) } )

RETURN ( cMemo )



Static Function Actualizaweb( cCodPrp, lActualizaweb )

   if lActualizaWeb .AND. uFieldEmpresa( "lRealWeb" )

      if lPubPrp()

         with object ( TComercio():New() )
            :ActualizaPropiedadesPrestashop( cCodPrp, nTipoActualizacionLineas )
         end

      end

   end

Return .T.



Static Function lPubPrp()

   local lPub  := .F.

   if ( dbfProT )->lPubInt
      lPub     := .T.
   else
      if ( dbfProT )->cCodWeb <> 0
         lPub  := .T.
      end
   end

Return lPub



Function hidePropertiesTable( oBrw )

   if !empty( oBrw )
      oBrw:Hide()
      oBrw:Cargo                 := nil
   end

RETURN ( nil )



Function setPropertiesTable( cCodArt, cCodPr1, cCodPr2, nPrecioCosto, oGetUnidades, oBrw, nView )

   local n
   local a
   local o
   local nRow                    := 1
   local nCol                    := 1
   local nTotalRow               := 0
   local nTotalCol               := 0
   local aSizesTable             := {}
   local aHeadersTable           := {}
   local aJustifyTable           := {}
   local hValorPropiedad
   local aPropertiesTable        := {}
   local aPropiedadesArticulo1
   local aPropiedadesArticulo2

   aPropiedadesArticulo1         := aPropiedadesArticulo1( cCodArt, nView )
   nTotalRow                     := len( aPropiedadesArticulo1 )
   if nTotalRow <> 0
      aPropiedadesArticulo2      := aPropiedadesArticulo2( cCodArt, nView )
   else
      aPropiedadesArticulo1      := aPropiedadesGeneral( cCodPr1, nView )
      nTotalRow                  := len( aPropiedadesArticulo1 )
      if nTotalRow <> 0
         aPropiedadesArticulo2   := aPropiedadesGeneral( cCodPr2, nView )
      else
         Return nil
      end
   end



   if len( aPropiedadesArticulo2 ) == 0
      nTotalCol                  := 2
   else
      nTotalCol                  := len( aPropiedadesArticulo2 ) + 1
   end

   aPropertiesTable              := array( nTotalRow, nTotalCol )

   if ( D():Propiedades( nView ) )->( dbSeek( cCodPr1 ) )
      aadd( aHeadersTable, ( D():Propiedades( nView ) )->cDesPro )
      aadd( aSizesTable, 60 )
      aadd( aJustifyTable, .F. )
   end

   for each hValorPropiedad in aPropiedadesArticulo1

      aPropertiesTable[ nRow, nCol ]                        := TPropertiesItems():New()
      aPropertiesTable[ nRow, nCol ]:cCodigo                := cCodArt
      aPropertiesTable[ nRow, nCol ]:cHead                  := hValorPropiedad[ "TipoPropiedad" ]
      aPropertiesTable[ nRow, nCol ]:cText                  := hValorPropiedad[ "CabeceraPropiedad" ]
      aPropertiesTable[ nRow, nCol ]:cCodigoPropiedad1      := hValorPropiedad[ "CodigoPropiedad" ]
      aPropertiesTable[ nRow, nCol ]:cValorPropiedad1       := hValorPropiedad[ "ValorPropiedad" ]
      aPropertiesTable[ nRow, nCol ]:lColor                 := hValorPropiedad[ "ColorPropiedad" ]
      aPropertiesTable[ nRow, nCol ]:nRgb                   := hValorPropiedad[ "RgbPropiedad" ]

      nRow++

   next

   if !empty( cCodPr2 ) .AND. !empty( aPropiedadesArticulo2 )

      for each hValorPropiedad in aPropiedadesArticulo2

         nCol++

         aadd( aHeadersTable, hValorPropiedad[ "CabeceraPropiedad" ] )
         aadd( aSizesTable, 60 )
         aadd( aJustifyTable, .T. )

         for n := 1 to nTotalRow
            aPropertiesTable[ n, nCol ]                     := TPropertiesItems():New()
            aPropertiesTable[ n, nCol ]:Value               := 0
            aPropertiesTable[ n, nCol ]:cHead               := hValorPropiedad[ "CabeceraPropiedad" ]
            aPropertiesTable[ n, nCol ]:cCodigo             := cCodArt
            aPropertiesTable[ n, nCol ]:cCodigoPropiedad1   := aPropertiesTable[ n, 1 ]:cCodigoPropiedad1
            aPropertiesTable[ n, nCol ]:cValorPropiedad1    := aPropertiesTable[ n, 1 ]:cValorPropiedad1
            aPropertiesTable[ n, nCol ]:cCodigoPropiedad2   := hValorPropiedad[ "CodigoPropiedad" ]
            aPropertiesTable[ n, nCol ]:cValorPropiedad2    := hValorPropiedad[ "ValorPropiedad" ]
            aPropertiesTable[ n, nCol ]:lColor              := aPropertiesTable[ n, 1 ]:lColor
            aPropertiesTable[ n, nCol ]:nRgb                := aPropertiesTable[ n, 1 ]:nRgb
         next

      next

   else

      nCol++

      aAdd( aHeadersTable, "Unidades" )
      aAdd( aSizesTable,   60 )
      aAdd( aJustifyTable, .T. )

      for n := 1 to nTotalRow
         aPropertiesTable[ n, nCol ]                        := TPropertiesItems():New()
         aPropertiesTable[ n, nCol ]:Value                  := 0
         aPropertiesTable[ n, nCol ]:cHead                  := "Unidades"
         aPropertiesTable[ n, nCol ]:cCodigo                := cCodArt
         aPropertiesTable[ n, nCol ]:cCodigoPropiedad1      := aPropertiesTable[ n, 1 ]:cCodigoPropiedad1
         aPropertiesTable[ n, nCol ]:cValorPropiedad1       := aPropertiesTable[ n, 1 ]:cValorPropiedad1
         aPropertiesTable[ n, nCol ]:cCodigoPropiedad2      := Space( 20 )
         aPropertiesTable[ n, nCol ]:cValorPropiedad2       := Space( 40 )
         aPropertiesTable[ n, nCol ]:lColor                 := aPropertiesTable[ n, 1 ]:lColor
         aPropertiesTable[ n, nCol ]:nRgb                   := aPropertiesTable[ n, 1 ]:nRgb
      next

   end



   for each a in aPropertiesTable
      for each o in a
         if IsObject( o )
            o:PrecioCompra( nPrecioCosto, D():ArticuloPrecioPropiedades( nView ) )
         end
      next
   next



   if !empty( oBrw )

      oBrw:aCols                 := {}
      oBrw:Cargo                 := aPropertiesTable
      oBrw:nFreeze               := 1

      oBrw:SetArray( aPropertiesTable, .F., 0, .F. )

      for n := 1 to len( aPropertiesTable[ 1 ] )

         if !isNil( aPropertiesTable[ oBrw:nArrayAt, n ] )

            if isNil( aPropertiesTable[ oBrw:nArrayAt, n ]:Value )



               with object ( oBrw:AddCol() )
                  :Adjust()
                  :cHeader          := aPropertiesTable[ oBrw:nArrayAt, n ]:cHead
                  :bEditValue       := bGenEditText( aPropertiesTable, oBrw, n )
                  :nWidth           := 100
                  :bFooter          := {|| "Total" }
               end



               if aPropertiesTable[ oBrw:nArrayAt, n ]:lColor

                  with object ( oBrw:AddCol() )
                     :Adjust()
                     :cHeader       := "Color"
                     :nWidth        := 40
                     :bFooter       := {|| "" }
                     :bStrData      := {|| "" }
                     :nWidth        := 16
                     :bClrStd       := bGenRGBValue( aPropertiesTable, oBrw, n )
                     :bClrSel       := bGenRGBValue( aPropertiesTable, oBrw, n )
                     :bClrSelFocus  := bGenRGBValue( aPropertiesTable, oBrw, n )
                  end

                  oBrw:nFreeze++
                  oBrw:nColOffset++

               end

            else

               with object ( oBrw:AddCol() )
                  :Adjust()
                  :cHeader          := aPropertiesTable[ oBrw:nArrayAt, n ]:cHead
                  :bEditValue       := bGenEditValue( aPropertiesTable, oBrw, n )
                  :cEditPicture     := MasUnd()
                  :nWidth           := 50
                  :setAlign( 1 )
                  :nFooterType      := 1
                  :nEditType        := 1
                  :nHeadStrAlign    := 1
                  :bOnPostEdit      := {| oCol, xVal, nKey | bPostEditProperties( oCol, xVal, nKey, oBrw, oGetUnidades ) }
                  :nFootStyle       := :defStyle( 1, .T. )
                  :Cargo            := n
               end

            end

         end

      next

      oBrw:aCols[ 1 ]:Hide()
      oBrw:Adjust()

      oBrw:nColSel               := oBrw:nFreeze + 1

      oBrw:nRowHeight            := 20
      oBrw:nHeaderHeight         := 20
      oBrw:nFooterHeight         := 20

      oBrw:Show()

   end

RETURN ( aPropertiesTable )



Function setValuesPropertiesTable( dbfLines, oBrw )

   local oProperties
   local aProperties

   for each aProperties in ( oBrw:Cargo )

      for each oProperties in aProperties




         if alltrim( oProperties:cCodigoPropiedad1 ) == alltrim( ( dbfLines )->cCodPr1 )  .AND. alltrim( oProperties:cValorPropiedad1 ) == alltrim( ( dbfLines )->cValPr1 )   .AND. alltrim( oProperties:cCodigoPropiedad2 ) == alltrim( ( dbfLines )->cCodPr2 )  .AND. alltrim( oProperties:cValorPropiedad2 ) == alltrim( ( dbfLines )->cValPr2 )

            oProperties:Value := ( dbfLines )->nUniCaja

         end

      next

   next

RETURN ( nil )



Function aPropiedadesArticulo1( cCodigoArticulo, nView )

RETURN ( aPropiedadesArticulo( cCodigoArticulo, nView, "cCodPr1", "cValPr1" ) )



Function aPropiedadesArticulo2( cCodigoArticulo, nView )

RETURN ( aPropiedadesArticulo( cCodigoArticulo, nView, "cCodPr2", "cValPr2" ) )



Function aPropiedadesArticulo( cCodigoArticulo, nView, cFieldCodigo, cValueCodigo )

   local aValores    := {}

   cCodigoArticulo   := rtrim( cCodigoArticulo )

   D():getInitStatus( "ArtDiv", nView )

   if ( D():ArticuloPrecioPropiedades( nView ) )->( dbSeek( cCodigoArticulo ) )

      while rtrim( ( D():ArticuloPrecioPropiedades( nView ) )->cCodArt ) == cCodigoArticulo .AND. !( D():ArticuloPrecioPropiedades( nView ) )->( eof() )

         if !isValoresPorpiedad( aValores, nView, cFieldCodigo, cValueCodigo )
            addValoresPorpiedad( aValores, nView, cCodigoArticulo, cFieldCodigo, cValueCodigo )
         end

         ( D():ArticuloPrecioPropiedades( nView ) )->( dbskip() )

      end

   end



   asort( aValores, , , {|x,y| x[ "OrdenPropiedad" ] < y[ "OrdenPropiedad" ] } )

   D():setStatus( "ArtDiv", nView )

RETURN ( aValores )



Static Function isValoresPorpiedad( aValores, nView, cFieldCodigo, cValueCodigo )

RETURN ( ascan( aValores, {| hash | rtrim( hash[ "CodigoPropiedad" ] ) == rtrim( ( D():ArticuloPrecioPropiedades( nView ) )->( fieldGetByName( cFieldCodigo ) ) ) .AND. rtrim( hash[ "ValorPropiedad" ] ) == rtrim( ( D():ArticuloPrecioPropiedades( nView ) )->( fieldGetByName( cValueCodigo ) ) ) } ) <> 0 )



Static Function addValoresPorpiedad( aValores, nView, cCodigoArticulo, cFieldCodigo, cValueCodigo )

   local hPropiedad
   local cCodigoPropiedad  := ( D():ArticuloPrecioPropiedades( nView ) )->( fieldGetByName( cFieldCodigo ) )
   local cValorPropiedad   := ( D():ArticuloPrecioPropiedades( nView ) )->( fieldGetByName( cValueCodigo ) )







   hPropiedad  := {  "CodigoPropiedad"    => rtrim( cCodigoPropiedad ), "ValorPropiedad"     => rtrim( cValorPropiedad ), "TipoPropiedad"      => rtrim( retFld( cCodigoPropiedad, D():Propiedades( nView ), "cDesPro" ) ), "ColorPropiedad"     => retFld( cCodigoPropiedad, D():Propiedades( nView ), "lColor" ), "CabeceraPropiedad"  => rtrim( retFld( cCodigoPropiedad + cValorPropiedad, D():PropiedadesLineas( nView ), "cDesTbl" ) ), "RgbPropiedad"       => retFld( cCodigoPropiedad + cValorPropiedad, D():PropiedadesLineas( nView ), "nColor" ), "OrdenPropiedad"     => retFld( cCodigoPropiedad + cValorPropiedad, D():PropiedadesLineas( nView ), "nOrdTbl" ) }

RETURN ( aadd( aValores, hPropiedad ) )



Function aPropiedadesGeneral( cCodigoPropiedad, nView )

   local aPropiedades    := {}

   D():getInitStatus( "TblPro", nView )
   ( D():Get( "TblPro", nView ) )->( ordsetfocus( "nOrdPro" ) )

   if ( D():PropiedadesLineas( nView ) )->( dbSeek( cCodigoPropiedad ) )

      while ( D():PropiedadesLineas( nView ) )->cCodPro == cCodigoPropiedad .AND. !( D():PropiedadesLineas( nView ) )->( eof() )

         addPropiedades( aPropiedades, nView, cCodigoPropiedad )

         ( D():PropiedadesLineas( nView ) )->( dbskip() )

      end

   end

   D():setStatus( "TblPro", nView )

RETURN ( aPropiedades )



Static Function addPropiedades( aPropiedades, nView, cCodigoPropiedad )

   local hPropiedad
   local cValorPropiedad   := ( D():PropiedadesLineas( nView ) )->cCodTbl






   hPropiedad  := {  "CodigoPropiedad"    => rtrim( cCodigoPropiedad ), "ValorPropiedad"     => rtrim( cValorPropiedad ), "TipoPropiedad"      => rtrim( retFld( cCodigoPropiedad, D():Propiedades( nView ), "cDesPro" ) ), "ColorPropiedad"     => retFld( cCodigoPropiedad, D():Propiedades( nView ), "lColor" ), "CabeceraPropiedad"  => rtrim( retFld( cCodigoPropiedad + cValorPropiedad, D():PropiedadesLineas( nView ), "cDesTbl" ) ), "RgbPropiedad"       => retFld( cCodigoPropiedad + cValorPropiedad, D():PropiedadesLineas( nView ), "nColor" ) }

RETURN ( aadd( aPropiedades, hPropiedad ) )



FUNCTION nombrePropiedad( cCodigoPropiedad, cValorPropiedad, nView )

   local cNombrePropiedad  := ""

   if D():gotoIdPropiedadesLineas( cCodigoPropiedad + cValorPropiedad, nView )
      cNombrePropiedad     := ( D():PropiedadesLineas( nView ) )->cDesTbl
   end

RETURN ( cNombrePropiedad )



_HB_CLASS TPropiedadesSenderReciver ; function TPropiedadesSenderReciver ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TPropiedadesSenderReciver", iif( .T., { @TSenderReciverItem() }, { @HBObject() } ), @TPropiedadesSenderReciver() ) ) ;

   _HB_MEMBER { cFileName } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cFileName"}, .F. )

   _HB_MEMBER CreateData(); oClass:AddMethod( "CreateData", @TPropiedadesSenderReciver_CreateData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER RestoreData(); oClass:AddMethod( "RestoreData", @TPropiedadesSenderReciver_RestoreData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SendData(); oClass:AddMethod( "SendData", @TPropiedadesSenderReciver_SendData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ReciveData(); oClass:AddMethod( "ReciveData", @TPropiedadesSenderReciver_ReciveData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Process(); oClass:AddMethod( "Process", @TPropiedadesSenderReciver_Process(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER CleanRelation( cCodArt); oClass:AddMethod( "CleanRelation", @TPropiedadesSenderReciver_CleanRelation(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TPropiedadesSenderReciver ;



static FUNCTION TPropiedadesSenderReciver_CreateData( ) ; local Self AS CLASS TPropiedadesSenderReciver := QSelf() AS CLASS TPropiedadesSenderReciver

   local oBlock
   local oError
   local tmpProT
   local tmpProL
   local lSnd        := .F.

   if ::oSender:lServer
      ::cFileName       := "Pro" + win_uuidcreatestring() + ".All"
   else
      ::cFileName       := "Pro" + win_uuidcreatestring() + "." + RetSufEmp()
   end

   if !OpenFiles( .F. )
      return nil
   end

   ::oSender:SetText( "Seleccionando propiedades" )





   mkPro( cPatSnd() )

   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cLocalDriver() ), ( cPatSnd() + "PRO.DBF" ), ( cCheckArea( "PRO", @tmpProT ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
   if !lAIS() ; ordListAdd( ( cPatSnd() + "PRO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   dbUseArea( .T., ( cLocalDriver() ), ( cPatSnd() + "TBLPRO.DBF" ), ( cCheckArea( "TBLPRO", @tmpProL ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
   if !lAIS() ; ordListAdd( ( cPatSnd() + "TBLPRO.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   if !empty( ::oSender:oMtr )
      ::oSender:oMtr:nTotal := ( dbfProT )->( lastrec() )
   end

   ( dbfProT )->( dbGoTop() )
   while !( dbfProT )->( eof() )

      if ( dbfProT )->lSndDoc

         ::oSender:SetText( alltrim( ( dbfProT )->cCodPro ) + "; " + alltrim( ( dbfProT )->cDesPro ) )

         lSnd     := .T.

         dbPass( dbfProT, tmpProT, .T. )





         if ( dbfProL )->( dbSeek( ( dbfProT )->cCodPro ) )
            while ( dbfProL )->cCodPro == ( dbfProT )->cCodPro .AND. !( dbfProL )->( eof() )
               dbPass( dbfProL, tmpProL, .T. )
               ( dbfProL )->( dbSkip() )
            end
         end

      end

      ( dbfProT )->( dbSkip() )

      if !empty( ::oSender:oMtr )
         ::oSender:oMtr:Set( ( dbfProT )->( ordkeyno() ) )
      end

      SysRefresh()

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos de propiedades" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   ( tmpProT )->( dbCloseArea() )
   ( tmpProL )->( dbCloseArea() )

   CloseFiles()





   if lSnd

      ::oSender:SetText( "Comprimiendo propiedades : " + ::cFileName )

      if ::oSender:lZipData( ::cFileName )
         ::oSender:SetText( "Ficheros comprimidos" )
      else
         ::oSender:SetText( "ERROR al crear fichero comprimido" )
      end

   else

      ::oSender:SetText( "No hay propiedades para enviar" )

   end

RETURN ( Self )



static FUNCTION TPropiedadesSenderReciver_RestoreData( ) ; local Self AS CLASS TPropiedadesSenderReciver := QSelf() AS CLASS TPropiedadesSenderReciver

   local oBlock
   local oError
   local dbfProT
   local dbfProL

   if !( ::lSuccesfullSend )
      return nil
   end

   if !OpenFiles( .F. )
      return nil
   end





   oBlock            := ErrorBlock( { | oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      while !( dbfProT )->( Eof() )

         if ( dbfProT )->lSndDoc .AND. ( dbfProT )->( dbRLock() )
            ( dbfProT )->lSndDoc   := .F.
            ( dbfProT )->( dbRUnlock() )
         end

         ( dbfProT )->( dbSkip() )

      end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos de propiedades" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   CloseFiles()

RETURN ( Self )



static FUNCTION TPropiedadesSenderReciver_SendData( ) ; local Self AS CLASS TPropiedadesSenderReciver := QSelf() AS CLASS TPropiedadesSenderReciver

   if !file( cPatOut() + ::cFileName )
      RETURN ( Self )
   end

   if ::oSender:SendFiles( cPatOut() + ::cFileName, ::cFileName )
      ::lSuccesfullSend := .T.
      ::oSender:SetText( "Ficheros de propiedades enviados " + ::cFileName )
   else
      ::oSender:SetText( "ERROR fichero de propiedades no enviado" )
   end

RETURN ( Self )



static FUNCTION TPropiedadesSenderReciver_ReciveData( ) ; local Self AS CLASS TPropiedadesSenderReciver := QSelf() AS CLASS TPropiedadesSenderReciver

   local cExt
   local aExt

   if ::oSender:lServer
      aExt              := aRetDlgEmp()
   else
      aExt              := { "All" }
   end

   ::oSender:SetText( "Recibiendo propiedades" )

   for each cExt in aExt
      ::oSender:GetFiles( "Pro*." + cExt, cPatIn() )
   next

   ::oSender:SetText( "Propiedades recibidas" )

RETURN ( Self )



static FUNCTION TPropiedadesSenderReciver_Process( ) ; local Self AS CLASS TPropiedadesSenderReciver := QSelf() AS CLASS TPropiedadesSenderReciver

   local cFile
   local aFiles
   local tmpProT
   local tmpProL
   local oBlock
   local oError





   aFiles                     := Directory( cPatIn() + "Pro*.*" )

   for each cFile in aFiles

      oBlock                  := ErrorBlock( { | oError | ApoloBreak( oError ) } )
      BEGIN SEQUENCE





      if ::oSender:lUnZipData( cPatIn() + cFile[ 1 ] )



         if lExistTable( cPatSnd() + "Pro.Dbf", cLocalDriver() )     .AND.  lExistTable( cPatSnd() + "TblPro.Dbf", cLocalDriver() )  .AND.  OpenFiles( .F. )

            dbUseArea( .T., ( cLocalDriver() ), ( cPatSnd() + "Pro.Dbf" ), ( cCheckArea( "PRO", @tmpProT ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
            if !lAIS() ; ordListAdd( ( cPatSnd() + "Pro.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

            dbUseArea( .T., ( cLocalDriver() ), ( cPatSnd() + "TblPro.Dbf" ), ( cCheckArea( "TBLPRO", @tmpProL ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
            if !lAIS() ; ordListAdd( ( cPatSnd() + "TblPro.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

            ::oSender:SetText( "Total de registros recibidos " + alltrim( str( ( tmpProT )->( lastrec() ) ) ) )

            if !Empty( ::oSender:oMtr )
               ::oSender:oMtr:nTotal := ( tmpProT )->( lastrec() )
            end

            ( tmpProT )->( ordsetfocus( 0 ) )
            ( tmpProT )->( dbgotop() )

            while !( tmpProT )->( eof() )

               if ( dbfProT )->( dbSeek( ( tmpProT )->cCodPro ) )

                  if !::oSender:lServer

                     ::cleanRelation( ( tmpProT )->cCodPro )

                     dbPass( tmpProT, dbfProT )






                     ::oSender:SetText( "Reemplazado : " + alltrim( ( dbfProT )->cCodPro ) + "; " + alltrim( ( dbfProT )->cDesPro ) )

                  else

                     ::oSender:SetText( "Desestimado : " + alltrim( ( dbfProT )->cCodPro ) + "; " + alltrim( ( dbfProT )->cDesPro ) )

                  end

               else

                  ::CleanRelation( ( tmpProT )->cCodPro )

                  dbPass( tmpProT, dbfProT, .T. )






                  ::oSender:SetText( "Añadido : " + alltrim( ( dbfProT )->cCodPro ) + "; " + alltrim( ( dbfProT )->cDesPro ) )

               end

               ( tmpProT )->( dbSkip() )

               if !Empty( ::oSender:oMtr )
                  ::oSender:oMtr:Set( ( tmpProT )->( OrdKeyNo() ) )
               end

               SysRefresh()

            end

            if !Empty( ::oSender:oMtr )
               ::oSender:oMtr:nTotal := ( tmpProL )->( LastRec() )
            end

            ( tmpProL )->( ordsetfocus( 0 ) )
            ( tmpProL )->( dbgotop() )

            while !( tmpProL )->( eof() )

               if ( dbfProL )->( dbSeek( ( tmpProL )->cCodPro + ( tmpProL )->cCodTbl ) )
                  if !::oSender:lServer
                     dbPass( tmpProL, dbfProL )
                  end
               else
                  dbPass( tmpProL, dbfProL, .T. )
               end

               ( tmpProL )->( dbSkip() )

               if !Empty( ::oSender:oMtr )
                  ::oSender:oMtr:Set( ( tmpProL )->( recno() ) )
               end

               SysRefresh()

            end

            ( tmpProT )->( dbCloseArea() )
            ( tmpProL )->( dbCloseArea() )

            CloseFiles()

            ::oSender:AppendFileRecive( cFile[ 1 ] )

         else

            ::oSender:SetText( "Faltan ficheros" )

            if !lExistTable( cPatSnd() + "Pro.Dbf"   )
               ::oSender:SetText( "Falta" + cPatSnd() + "Pro.Dbf" )
            end

            if !lExistTable( cPatSnd() + "TblPro.Dbf"    )
               ::oSender:SetText( "Falta" + cPatSnd() + "TblPro.Dbf" )
            end

         end

      else

         ::oSender:SetText( "Error en el fichero comprimido" )

      end

      RECOVER USING oError

         ( tmpProT )->( dbCloseArea() )
         ( tmpProL )->( dbCloseArea() )

         ::oSender:SetText( "Error procesando fichero " + cFile[ 1 ] )
         ::oSender:SetText( ErrorMessage( oError ) )

      end

      ErrorBlock( oBlock )

   next

RETURN ( Self )



static FUNCTION TPropiedadesSenderReciver_CleanRelation( idPropiedad ) ; local Self AS CLASS TPropiedadesSenderReciver := QSelf() AS CLASS TPropiedadesSenderReciver

   while ( dbfProL )->( dbSeek( idPropiedad ) )
      dbDel( dbfProL )
   end

   SysRefresh()

RETURN ( Self )
