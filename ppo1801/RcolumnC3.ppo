#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 21 ".\.\Prg\RcolumnC3.prg"
_HB_CLASS TRColumn ; function TRColumn ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TRColumn", iif( .F., { }, { @HBObject() } ), @TRColumn() ) ) ;

     _HB_MEMBER { oReport } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oReport"}, .F. )
     _HB_MEMBER { aData, aTitle, aPicture } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aData", "aTitle", "aPicture"}, .F. )
     _HB_MEMBER { bDataFont, bTitleFont, bTotalFont, bTotalExpr, bColor } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bDataFont", "bTitleFont", "bTotalFont", "bTotalExpr", "bColor"}, .F. )
     _HB_MEMBER { cTotalPict } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cTotalPict"}, .F. )

     _HB_MEMBER { nWidth, nDataHeight, nTitleHeight, nTotal, nCol, nSize, nPad, nPen, nOrder, nCalCol, nCurLine } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nWidth", "nDataHeight", "nTitleHeight", "nTotal", "nCol", "nSize", "nPad", "nPen", "nOrder", "nCalCol", "nCurLine"}, .F. )

     _HB_MEMBER { lTotal, lShadow, lGrid, lTotalExpr, lUnderline, lDobleUnd, lTextUnd, lSeparator } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lTotal", "lShadow", "lGrid", "lTotalExpr", "lUnderline", "lDobleUnd", "lTextUnd", "lSeparator"}, .F. )
     _HB_MEMBER { Cargo } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Cargo"}, .F. )
     _HB_MEMBER { bStartTotal } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bStartTotal"}, .F. )



     _HB_MEMBER New( aTitle, nCol, aData, nSize, aPicture, bFont, lTotal, bTotalExpr, cFmt, lShadow, lGrid, oReport) AS CLASS TRColumn; oClass:AddMethod( "New", @TRColumn_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

     _HB_MEMBER Stabilize(); oClass:AddMethod( "Stabilize", @TRColumn_Stabilize(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

     _HB_MEMBER SayTitle( nRow, nCol, nLine); oClass:AddMethod( "SayTitle", @TRColumn_SayTitle(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
     _HB_MEMBER SayData( nRow, nCol, nLine); oClass:AddMethod( "SayData", @TRColumn_SayData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
     _HB_MEMBER SayTotal( nRow, nCol); oClass:AddMethod( "SayTotal", @TRColumn_SayTotal(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
     _HB_MEMBER Separator( nDataLine, nRow); oClass:AddMethod( "Separator", @TRColumn_Separator(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
     _HB_MEMBER Underline( lTextLength, lDouble, nDataLine, nRow); oClass:AddMethod( "Underline", @TRColumn_Underline(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
     _HB_MEMBER TitleHeight( nLine); oClass:AddMethod( "TitleHeight", @TRColumn_TitleHeight(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TRColumn ;















static FUNCTION TRColumn_New( aTitle     , nCol       , aData      , nSize      , aPicture   , bFont      , lTotal     , bTotalExpr , cFmt       , lShadow    , lGrid      , nPen       , oReport ) ; local Self AS CLASS TRColumn := QSelf() AS CLASS TRColumn












     If( aTitle == nil, aTitle := {{|| ""} }, ) ; If( aData == nil, aData := {{|| ""} }, ); If( nSize == nil, nSize := 0, ); If( aPicture == nil, aPicture := {""}, ); If( nCol == nil, nCol := 0, ); If( bFont == nil, bFont := {|| 1 }, ); If( nPen == nil, nPen := 1, ); If( lTotal == nil, lTotal := .F., ); If( lShadow == nil, lShadow := .F., ); If( lGrid == nil, lGrid := .F., ); If( cFmt == nil, cFmt := iif(Valtype(Eval(aData[1]))=="N", "RIGHT", "LEFT"), );

     ::aTitle     = aTitle
     ::aData      = aData
     ::nSize      = nSize
     ::aPicture   = aPicture
     ::bDataFont  = bFont
     ::bTitleFont = {|| 1 }
     ::bTotalFont = bFont
     ::lTotal     = lTotal
     ::lShadow    = lShadow
     ::lGrid      = lGrid
     ::lUnderline = .F.
     ::lDobleUnd  = .F.
     ::lSeparator = .T.
     ::lTextUnd   = .F.
     ::nPen       = nPen
     ::nTotal     = 0
     ::oReport    = oReport
     ::bTotalExpr = bTotalExpr
     ::nCol       = nCol
     ::cTotalPict = iif(len(aPicture)>0, aPicture[1], "")
     ::nWidth     = 0
     ::nCalCol    = 0
     ::nOrder     = 0

     ::lTotalExpr = !(bTotalExpr == NIL)

     IF cFmt == "LEFT"
          ::nPad = 1
     ELSEIF cFmt == "RIGHT"
          ::nPad = 2
     ELSEIF cFmt == "CENTER" .OR. cFmt == "CENTERED"
          ::nPad = 3
     ELSE
          ::nPad = 1
     ENDIF

     while len(::aPicture) < len(::aData)
          Aadd(::aPicture,::cTotalPict)
     ENDDO

RETURN Self



static FUNCTION TRColumn_Stabilize( nOrder ) ; local Self AS CLASS TRColumn := QSelf() AS CLASS TRColumn

     LOCAL nFor, nWidth, nLen

     ::nDataHeight  := ::oReport:oDevice:GetTextHeight(::oReport:cCharPattern, ::oReport:aFont[eval(::bDataFont)])
     ::nTitleHeight := ::oReport:oDevice:GetTextHeight(::oReport:cCharPattern, ::oReport:aFont[eval(::bTitleFont)])

     IF !empty(::nSize)
          ::nWidth := ::oReport:oDevice:GetTextWidth(Replicate(::oReport:cCharPattern,::nSize), ::oReport:aFont[eval(::bDataFont)])
          RETU NIL
     ENDIF


     FOR nFor := 1 TO len(::aData)

          nLen      := len(cValtoChar(Transform(eval(::aData[nFor]), ::aPicture[nFor])))

          nWidth    := ::oReport:oDevice:GetTextWidth(Replicate(::oReport:cCharPattern,nLen), ::oReport:aFont[eval(::bDataFont)])
          ::nWidth  := Max(::nWidth,nWidth)
     NEXT

     FOR nFor := 1 TO len(::aTitle)
          nLen      := len(eval(::aTitle[nFor]))

          nWidth    := ::oReport:oDevice:GetTextWidth(Replicate(::oReport:cCharPattern,nLen), ::oReport:aFont[eval(::bTitleFont)])
          ::nWidth  := Max(::nWidth,nWidth)
     NEXT

     ::nOrder := nOrder

RETURN NIL



static FUNCTION TRColumn_SayTitle( nRow, nCol, nLine ) ; local Self AS CLASS TRColumn := QSelf() AS CLASS TRColumn

     LOCAL oFont
     LOCAL cTitle
     LOCAL nFont



     If( nRow == nil, nRow := 0, ) ; If( nCol == nil, nCol := ::nCol, ); If( nLine == nil, nLine := 1, );

     IF nLine > len(::aTitle)
          RETU NIL
     ENDIF

     cTitle := eval(::aTitle[nLine])
     nFont  := eval(::bTitleFont)
     oFont  := ::oReport:aFont[nFont]

     ::nCurLine := nLine


     ::oReport:oDevice:Say(nRow, nCol, cTitle, oFont, ::nWidth, ::oReport:aClrText[nFont],,::nPad-1)

RETURN NIL




static FUNCTION TRColumn_SayData( nRow, nCol, nLine ) ; local Self AS CLASS TRColumn := QSelf() AS CLASS TRColumn

     LOCAL oFont
     LOCAL cText
     LOCAL nWidth, nFont



     If( nRow == nil, nRow := 0, ) ; If( nCol == nil, nCol := ::nCol, ); If( nLine == nil, nLine := 1, );

     IF nLine > len(::aData)
          RETU NIL
     ENDIF

     ::nCurLine := nLine

     nFont  := eval(::bDataFont)
     oFont  := ::oReport:aFont[nFont]
     cText  := Transform(eval(::aData[nLine]),::aPicture[nLine])
     nWidth := ::oReport:oDevice:GetTextWidth(cText, oFont)


     ::oReport:oDevice:Say(nRow, nCol, cText, oFont, ::nWidth, ::oReport:aClrText[nFont],,::nPad-1)

      IF ::lUnderline



          ::Underline(::lTextUnd        , ::lDobleUnd       , nLine             , nRow+::nDataHeight)
      ENDIF

RETURN NIL



static FUNCTION TRColumn_SayTotal( nRow, nCol ) ; local Self AS CLASS TRColumn := QSelf() AS CLASS TRColumn

     LOCAL oFont
     LOCAL cText
     LOCAL nFont


     If( nRow == nil, nRow := 0, ) ; If( nCol == nil, nCol := ::nCol, );

     IF !::lTotal
          RETU NIL
     ENDIF





     IF ::bStartTotal <> nil
          Eval( ::bStartTotal, Self )
     ENDIF





     nFont := Eval(::bTotalFont)
     oFont := ::oReport:aFont[nFont]
     cText := Transform(::nTotal,::cTotalPict)

     ::oReport:oDevice:Say(nRow, nCol, cText, oFont, ::nWidth, ::oReport:aClrText[nFont],,::nPad-1)

RETURN NIL



static FUNCTION TRColumn_TitleHeight( nLine ) ; local Self AS CLASS TRColumn := QSelf() AS CLASS TRColumn

     LOCAL oFontT, oFontD
     LOCAL cText, cChar
     LOCAL nFor, nWidth, nLen, nFontT, nFontD, nLenData

     IF !empty(::nWidth)
          RETU NIL
     ENDIF

     nFontT := eval(::bTitleFont)
     nFontD := eval(::bDataFont)
     oFontT := ::oReport:aFont[nFontT]
     oFontD := ::oReport:aFont[nFontD]
     cChar := ::oReport:cCharPattern

     ::nDataHeight  := len(::aData) * ::oReport:oDevice:GetTextHeight(cChar, oFontD)
     ::nTitleHeight := len(::aTitle) * ::oReport:oDevice:GetTextHeight(cChar, oFontT)

     nLenData := len(::aData)

     FOR nFor := 1 TO nLenData
          cText    := Transform(eval(::aData[nLine]),::aPicture[nLine])
          nLen     := len(cText)
          nWidth   := ::oReport:oDevice:GetTextWidth(Replicate(cChar,nLen), oFontD)
          ::nWidth := Max(::nWidth,nWidth)
     NEXT

RETURN NIL



static FUNCTION TRColumn_Underline( lTextUnd, lDobleUnd, nLine, nRow ) ; local Self AS CLASS TRColumn := QSelf() AS CLASS TRColumn

     LOCAL nLeft, nRight, nWidth




     If( lTextUnd == nil, lTextUnd := ::lTextUnd, ) ; If( lDobleUnd == nil, lDobleUnd := ::lDobleUnd, ); If( nLine == nil, nLine := 1, ); If( nRow == nil, nRow := ::oReport:nRow, );

     DO CASE
     CASE !lTextUnd .AND. ::lGrid
          nLeft  := ::nCalCol  + Int(::oReport:nSeparator/2)
          nRight := nLeft + ::nWidth + Int(::oReport:nSeparator/2)
     CASE lTextUnd


          nWidth := ::oReport:oDevice:GetTextWidth(alltrim( Transform(eval(::aData[nLine]),::aPicture[nLine])), ::oReport:aFont[eval(::bDataFont)])
          DO CASE
               CASE ::nPad == 2
                    nLeft := ::nCalCol+::nWidth-nWidth
               CASE ::nPad == 3
                    nLeft := ::nCalCol+Int(::nWidth/2)-Int(nWidth/2)
               OTHERWISE
                    nLeft := ::nCalCol
          ENDCASE
          nRight := nLeft + nWidth
     OTHERWISE
          nLeft  := ::nCalCol
          nRight := nLeft + ::nWidth
     ENDCASE


     IF lDobleUnd
          nWidth := ::oReport:aPen[::nPen]:nWidth




          ::oReport:oDevice:Line(nRow-nWidth, nLeft, nRow-nWidth, nRight, ::oReport:aPen[::nPen])





          ::oReport:oDevice:Line(nRow+nWidth, nLeft, nRow+nWidth, nRight, ::oReport:aPen[::nPen])
     ELSE




          ::oReport:oDevice:Line(nRow, nLeft, nRow, nRight, ::oReport:aPen[::nPen])
     ENDIF

RETURN NIL



static FUNCTION TRColumn_Separator( nRow, lForced ) ; local Self AS CLASS TRColumn := QSelf() AS CLASS TRColumn

   LOCAL nLeft, nRight, nSep


   If( nRow == nil, nRow := ::oReport:nRow, ) ; If( lForced == nil, lForced := .F., );

   IF !::lSeparator .AND. !lForced
      RETURN NIL
   ENDIF

   nSep   := iif( ::lGrid, Int(::oReport:nSeparator/2), 0)
   nLeft  := ::nCalCol  - nSep
   nRight := nLeft + ::nWidth + (nSep*2)





   ::oReport:oDevice:Line(nRow, nLeft, nRow, nRight, ::oReport:aPen[::nPen])

RETURN NIL
