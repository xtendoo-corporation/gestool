#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 44 ".\.\Prg\ReportC3.prg"
_HB_CLASS TReport ; function TReport ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TReport", iif( .F., { }, { @HBObject() } ), @TReport() ) ) ;

   _HB_MEMBER { oDevice, oTitle, oHeader, oFooter, oRptWnd, oShdBrush, oPenHorz } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oDevice", "oTitle", "oHeader", "oFooter", "oRptWnd", "oShdBrush", "oPenHorz"}, .F. )

   _HB_MEMBER { aGroups, aColumns, aFont, aCols, aText, aData, aPen, aDataHeight, aClrText } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aGroups", "aColumns", "aFont", "aCols", "aText", "aData", "aPen", "aDataHeight", "aClrText"}, .F. )


   _HB_MEMBER { bFor, bWhile, bInit, bEnd, bStartLine, bEndLine, bStartPage, bEndPage, bStartGroup, bEndGroup, bSkip, bStdFont, bPreview, bChange, bPostEnd, bPostPage, bPostGroup, bStartRecord, bEndRecord } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bFor", "bWhile", "bInit", "bEnd", "bStartLine", "bEndLine", "bStartPage", "bEndPage", "bStartGroup", "bEndGroup", "bSkip", "bStdFont", "bPreview", "bChange", "bPostEnd", "bPostPage", "bPostGroup", "bStartRecord", "bEndRecord"}, .F. )

   _HB_MEMBER { cRptFile, cResName, cFile, cName, cPageTotal, cGrandTotal, cCharPattern } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cRptFile", "cResName", "cFile", "cName", "cPageTotal", "cGrandTotal", "cCharPattern"}, .F. )





   _HB_MEMBER { nWidth, nHeight, nMargin, nRow, nPage, nMaxTitle, nMaxData, nSeparator, nLeftMargin, nRightMargin, nTopMargin, nDnMargin, nTitleRow, nBottomRow, nStdLineHeight, nRptWidth, nLogPixX, nLogPixY, nFirstdrow, nLastdrow, nTitleHeight, nCounter, nTotalLine, nGroupLine, nTitleUpLine, nTitleDnLine, nClrShadow, nDataLine } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nWidth", "nHeight", "nMargin", "nRow", "nPage", "nMaxTitle", "nMaxData", "nSeparator", "nLeftMargin", "nRightMargin", "nTopMargin", "nDnMargin", "nTitleRow", "nBottomRow", "nStdLineHeight", "nRptWidth", "nLogPixX", "nLogPixY", "nFirstdrow", "nLastdrow", "nTitleHeight", "nCounter", "nTotalLine", "nGroupLine", "nTitleUpLine", "nTitleDnLine", "nClrShadow", "nDataLine"}, .F. )
   _HB_MEMBER { hOldRes } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hOldRes"}, .F. )


   _HB_MEMBER { lSummary, lTotal, lFinish, lStable, lGroup, lPrinter, lScreen, lFirstRow, lCreated, lBreak, lShadow, lGrid, lJoin, lSeparator, lAutoLand, lIsNarrow, lBoxOnTotal, lNoCancel, lPageTotal } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lSummary", "lTotal", "lFinish", "lStable", "lGroup", "lPrinter", "lScreen", "lFirstRow", "lCreated", "lBreak", "lShadow", "lGrid", "lJoin", "lSeparator", "lAutoLand", "lIsNarrow", "lBoxOnTotal", "lNoCancel", "lPageTotal"}, .F. )
   _HB_MEMBER { Cargo } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Cargo"}, .F. )

   _HB_MEMBER { lOnProcess } ; oClass:AddMultiClsData(,, nScope + iif( .F., 16, 0 ) + iif( .T., 32, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lOnProcess"}, .F. )



   _HB_MEMBER New( aTitle, aHead, aFoot, aFont, lSummary, cRptFile,  cResName, lPrinter, lScreen, cFile, oDevice,  cName, cTFmt, cHFmt, cFFmt) AS CLASS TReport; oClass:AddMethod( "New", @TReport_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )




   _HB_MEMBER AddColumn(); oClass:AddInline( "AddColumn", {|Self, oColumn | ( ( Self ) ), Aadd(::aColumns,oColumn) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER DelColumn(); oClass:AddInline( "DelColumn", {|Self, nColumn | ( ( Self ) ), Adel(::aColumns,nColumn) , Asize(::aColumns,len(::aColumns)-1) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER InsColumn(); oClass:AddInline( "InsColumn", {|Self, oColumn , nColumn | ( ( Self ) ), Ains(::aColumns,nColumn) , ::aColumns[nColumn]:= oColumn }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER AddGroup(); oClass:AddInline( "AddGroup", {|Self, oGroup | ( ( Self ) ), Aadd(::aGroups,oGroup) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER DelGroup(); oClass:AddInline( "DelGroup", {|Self, nGroup | ( ( Self ) ), Adel(::aGroups,nGroup)   , Asize(::aGroups,len(::aGroups)-1) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Stabilize(); oClass:AddMethod( "Stabilize", @TReport_Stabilize(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Skip( n); oClass:AddMethod( "Skip", @TReport_Skip(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Init(); oClass:AddMethod( "Init", @TReport_Init(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER End(); oClass:AddMethod( "End", @TReport_End(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER StartLine( nHeight); oClass:AddMethod( "StartLine", @TReport_StartLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER EndLine( nHeight); oClass:AddMethod( "EndLine", @TReport_EndLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER StartGroup( nGroup); oClass:AddMethod( "StartGroup", @TReport_StartGroup(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER EndGroup( nGroup); oClass:AddMethod( "EndGroup", @TReport_EndGroup(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER StartPage(); oClass:AddMethod( "StartPage", @TReport_StartPage(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER EndPage(); oClass:AddMethod( "EndPage", @TReport_EndPage(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER NeedNewPage(); oClass:AddInline( "NeedNewPage", {|Self | ( ( Self ) ), (::nRow+::nStdLineHeight >= ::nBottomRow) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER NewLine(); oClass:AddInline( "NewLine", {|Self, nHeight | ( ( Self ) ), ( ::StartLine( nHeight ), iif( !::lFirstRow, ::EndLine( nHeight ), ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER BackLine( nLine); oClass:AddMethod( "BackLine", @TReport_BackLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ColTitle(); oClass:AddMethod( "ColTitle", @TReport_ColTitle(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER TotalLine( cChar, nGrid); oClass:AddMethod( "TotalLine", @TReport_TotalLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER PageTotal(); oClass:AddMethod( "PageTotal", @TReport_PageTotal(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER Activate( bFor, bWhile, bInit, bEnd, bStartPage,  bEndPage, bStartGroup, bEndGroup,  bStartLine, bEndLine, bChange); oClass:AddMethod( "Activate", @TReport_Activate(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Play(); oClass:AddMethod( "Play", @TReport_Play(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Margin( nValue,nType,nScale); oClass:AddMethod( "Margin", @TReport_Margin(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Say( nCol, xText, nFont, nPad, nRow); oClass:AddMethod( "Say", @TReport_Say(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SayBitmap( nRow, nCol, cBitmap, nWidth, nHeight, nScale); oClass:AddMethod( "SayBitmap", @TReport_SayBitmap(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Box( nRow, nCol, nBottom, nRight, nPen, nScale); oClass:AddMethod( "Box", @TReport_Box(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Line( nTop, nLeft, nBottom, nRight, nPen, nScale); oClass:AddMethod( "Line", @TReport_Line(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Shadow( nHeight); oClass:AddMethod( "Shadow", @TReport_Shadow(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Grid( nHeight, nRow, cChar); oClass:AddMethod( "Grid", @TReport_Grid(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Separator( nPen, nRow); oClass:AddMethod( "Separator", @TReport_Separator(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )




   _HB_MEMBER CellView(); oClass:AddInline( "CellView", {|Self | ( ( Self ) ), ::lJoin       := .T. , ::lSeparator  := .F. , ::lBoxOnTotal := .T. , Aeval(::aColumns,{|val| val:lGrid := .T.}) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )




   _HB_MEMBER UderLine(); oClass:AddInline( "UderLine", {|Self | ( ( Self ) ), ::lJoin       := .F. , ::lSeparator  := .F. , ::lBoxOnTotal := .F. , Aeval(::aColumns,{|val| val:lUnderLine := .T.}) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )




   _HB_MEMBER PhyWidth(); oClass:AddInline( "PhyWidth", {|Self, nScale | ( ( Self ) ), ( iif(nScale==NIL,nScale:=1 ,), PrnGetSize(::oDevice:hDC)[1] / ::nLogPixX *  iif(nScale==1 ,1 ,2.54)                     ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )




   _HB_MEMBER PhyHeight(); oClass:AddInline( "PhyHeight", {|Self, nScale | ( ( Self ) ), ( iif(nScale==NIL,nScale:=1 ,), PrnGetSize(::oDevice:hDC)[2] / ::nLogPixY *  iif(nScale==1 ,1 ,2.54)                     ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )





   _HB_MEMBER SetTxtColor(); oClass:AddInline( "SetTxtColor", {|Self, nColor,nFont | ( ( Self ) ), (iif(nColor <> NIL .AND.                           nFont   > 0   .AND.                           nFont   <= len(::aClrText)                  , ::aClrText[nFont] := nColor, ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SetShdColor(); oClass:AddInline( "SetShdColor", {|Self, nColor | ( ( Self ) ), ::nClrShadow := nColor }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SetPenColor( nColor); oClass:AddMethod( "SetPenColor", @TReport_SetPenColor(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TReport ;





static FUNCTION TReport_New( aTitle, aHead, aFoot, aFont, aPen, lSummary, cRptFile,  cResName, lPrinter, lScreen, cFile, oDevice, cName, cTFmt, cHFmt, cFFmt ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   LOCAL nTFmt, nHFmt, nFFmt


   LOCAL lFontDefined := .T. , lPenDefined  := .T.


















   If( aTitle == nil, aTitle := {{|| ""} }, ) ; If( aHead == nil, aHead := {{|| ""} }, ); If( aFoot == nil, aFoot := {{|| ""} }, ); If( aFont == nil, aFont := {}, ); If( aPen == nil, aPen := {}, ); If( lSummary == nil, lSummary := .F., ); If( cRptFile == nil, cRptFile := "", ); If( cResName == nil, cResName := "", ); If( lPrinter == nil, lPrinter := .F., ); If( lScreen == nil, lScreen := .F., ); If( cFile == nil, cFile := "", ); If( cTFmt == nil, cTFmt := "CENTER", ); If( cHFmt == nil, cHFmt := "LEFT", ); If( cFFmt == nil, cFFmt := "LEFT", );

   ::aColumns     := {}
   ::aGroups      := {}
   ::bStdFont     := {|| 1 }
   ::bPreview     := {|oDevice| rPreview(oDevice) }
   ::cRptFile     := cRptFile
   ::cResName     := cResName
   ::cPageTotal   := ""
   ::cGrandTotal  := ""
   ::cCharPattern := "B"
   ::cFile        := cFile
   ::cName        := cName
   ::nRow         := 0
   ::nPage        := 0
   ::nSeparator   := 0
   ::nCounter     := 0
   ::nTotalLine   := 2
   ::nGroupLine   := 1
   ::nTitleUpLine := 2
   ::nTitleDnLine := 2
   ::nClrShadow   := 12632256
   ::lSummary     := lSummary
   ::lStable      := .F.
   ::lPrinter     := lPrinter
   ::lScreen      := lScreen
   ::lFirstRow    := .T.
   ::lCreated     := .F.
   ::lBreak       := .F.
   ::lShadow      := .F.
   ::lJoin        := .F.
   ::lSeparator   := .F.
   ::lAutoLand    := .T.
   ::lIsNarrow    := .F.
   ::lBoxOnTotal  := .F.
   ::lNoCancel    := .F.
   ::lPageTotal   := .T.

   IF cTFmt == "LEFT"
      nTFmt = 1
   ELSEIF cTFmt == "RIGHT"
      nTFmt = 2
   ELSEIF cTFmt == "CENTER" .OR. cTFmt == "CENTERED"
      nTFmt = 3
   ELSE
      nTFmt = 3
   ENDIF

   IF cHFmt == "LEFT"
      nHFmt = 1
   ELSEIF cHFmt == "RIGHT"
      nHFmt = 2
   ELSEIF cHFmt == "CENTER" .OR. cHFmt == "CENTERED"
      nHFmt = 3
   ELSE
      nHFmt = 1
   ENDIF

   IF cFFmt == "LEFT"
      nFFmt = 1
   ELSEIF cFFmt == "RIGHT"
      nFFmt = 2
   ELSEIF cFFmt == "CENTER" .OR. cFFmt == "CENTERED"
      nFFmt = 3
   ELSE
      nFFmt = 1
   ENDIF





   IF oDevice <> NIL
      ::oDevice  := oDevice
      ::lScreen  := oDevice:lMeta
      ::lPrinter := !::lScreen
   ELSEIF ::lPrinter
      ::oDevice  := TPrinter():New(cName,.F.)
   ELSEIF ::lScreen
      ::oDevice  := TPrinter():New(cName,.F.,.T.)
   ELSEIF !empty(::cFile)
      ::oDevice  := TRFile():New(::cFile)
      ::lPrinter := .F.
   ELSE
      ::oDevice  := TPrinter():New(cName,.F.)
      ::lPrinter := .T.
   ENDIF





   IF empty(::cName)
     IF !empty(::oDevice:cDocument)
          ::cName := ::oDevice:cDocument
     ELSE
          ::cName := "Printing report"
     ENDIF
   ENDIF





   IF empty(::oDevice:hDC)
      RETURN Self
   ELSE
      ::lCreated := .T.
   ENDIF





   ::nWidth  := ::oDevice:nHorzRes()
   ::nHeight := ::oDevice:nVertRes()





   ::nLogPixX := ::oDevice:nLogPixelX()
   ::nLogPixY := ::oDevice:nLogPixelY()





   IF len(aFont) == 0
      lFontDefined := .F.
      Asize(aFont,1)
      aFont[1] := TFont():New( "Arial", 0, -10,,,,,,,,,,,,,, )
   ENDIF





   IF len(aPen) == 0
      lPenDefined := .F.
      Asize(aPen,1)
      aPen[1] := TPen():New( 0, 1, 0, )
   ENDIF








   ::oPenHorz := TPen():New( aPen[1]:nStyle, aPen[1]:nWidth * ::nLogPixX/72, aPen[1]:nColor, )






   ::aFont := Array(len(aFont))

















   Aeval(aFont                                        , {|val,elem|                                    ::aFont[elem]:= TFont():New(val:cFaceName    , Int(val:nWidth*::nLogPixX/72)                , Int(val:nHeight*::nLogPixY/72)               , .F.                                          , val:lBold                                    , val:nEscapement                              , val:nOrientation                             , val:nWeight                                  , val:lItalic                                  , val:lUnderline                               , val:lStrikeOut                               , val:nCharSet                                 , val:nOutPrecision                            , val:nClipPrecision                           , val:nQuality) })

   IF !lFontDefined
      aFont[1]:end()
   ENDIF





   ::aPen := Array(len(aPen))




   Aeval(aPen, {|val,elem|                              ::aPen[elem] := Tpen():New( val:nStyle , Int(val:nWidth*::nLogPixX/72)          , val:nColor)} )

   IF !lPenDefined
      aPen[1]:end()
   ENDIF





   ::aClrText := Array(len(::aFont))

   Aeval(::aClrText,{|val,elem| ::aClrText[elem] := 0 })





   ::nLeftMargin  := ::nLogPixX*0.2
   ::nRightMargin := ::nLogPixX*0.2
   ::nTopMargin   := ::nLogPixY*0.2
   ::nDnMargin    := ::nLogPixY*0.2





   ::oHeader := TrLine():New(aHead,Self,nHFmt)
   ::oTitle  := TrLine():New(aTitle,Self,nTFmt)
   ::oFooter := TrLine():New(aFoot,Self,nFFmt)

RETURN Self



static FUNCTION TReport_Margin( nValue, nType, nScale ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport




   If( nValue == nil, nValue := .2, ) ; If( nType == nil, nType := 1, ); If( nScale == nil, nScale := 1, );

   IF nScale == 2
      nValue := nValue/2.54
   ENDIF

   DO CASE
   CASE nType == 4
      ::nTopMargin   := ::nLogPixY*nValue
   CASE nType == 5
      ::nDnMargin    := ::nLogPixY*nValue
   CASE nType == 1
      ::nLeftMargin  := ::nLogPixX*nValue
   CASE nType == 2
      ::nRightMargin := ::nLogPixX*nValue
   ENDCASE

   ::lStable := .F.

RETURN Self



static FUNCTION TReport_Say( nCol, xText, nFont, nPad, nRow ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport





   If( nCol == nil, nCol := 1, ) ; If( nFont == nil, nFont := 1, ); If( xText == nil, xText := "", ); If( nRow == nil, nRow := ::nRow, ); If( nPad == nil, nPad := 1, );

   IF nCol <1 .OR. nCol > len(::aCols)
      nCol := 1
   ENDIF

   IF nFont <1 .OR. nFont > len(::aFont)
      nFont := 1
   ENDIF







   ::oDevice:Say(nRow              , ::aCols[nCol]     , cValToChar(xText) , ::aFont[nFont]    , NIL               , ::aClrText[nFont],, nPad-1)

RETURN Self



static FUNCTION TReport_SayBitmap( nRow, nCol, cBitmap, nWidth, nHeight, nScale ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   LOCAL nPixWidth, nPixHeight
   LOCAL aOffset     := Array( 2 )





   If( nRow == nil, nRow := .2, ) ; If( nCol == nil, nCol := .2, ); If( nWidth == nil, nWidth := 1, ); If( nHeight == nil, nHeight := 1, ); If( nScale == nil, nScale := 1, );

   IF nScale == 2
      aOffset := ::oDevice:Cmtr2Pix(nRow, nCol)
      nWidth  := nWidth/2.54
      nHeight := nHeight/2.54
   ELSE
      aOffset := ::oDevice:Inch2Pix(nRow, nCol)
   ENDIF

   nPixWidth  := ::nLogPixY*nWidth
   nPixHeight := ::nLogPixX*nHeight





   ::oDevice:SayBitmap(aOffset[1] , aOffset[2] , cBitmap    , nPixWidth  , nPixHeight)




























   ::oDevice:SayBitmap(aOffset[1] , aOffset[2] , cBitmap    , nPixWidth  , nPixHeight)

RETURN Self



static FUNCTION TReport_Box( nRow, nCol, nBottom, nRight, nPen, nScale ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   LOCAL aStart, aEnd






   If( nRow == nil, nRow := .2, ) ; If( nCol == nil, nCol := .2, ); If( nBottom == nil, nBottom := 5, ); If( nRight == nil, nRight := 5, ); If( nPen == nil, nPen := 1, ); If( nScale == nil, nScale := 1, );

   IF nScale == 2
      aStart := ::oDevice:Cmtr2Pix(nRow, nCol)
      aEnd   := ::oDevice:Cmtr2Pix(nBottom, nRight)
   ELSE
      aStart := ::oDevice:Inch2Pix(nRow, nCol)
      aEnd   := ::oDevice:Inch2Pix(nBottom, nRight)
   ENDIF





   ::oDevice:Box(aStart[1]    , aStart[2]    , aEnd[1]      , aEnd[2]      , ::aPen[nPen])

RETURN Self



static FUNCTION TReport_Line( nRow, nCol, nBottom, nRight, nPen, nScale ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   LOCAL aStart, aEnd






   If( nRow == nil, nRow := .2, ) ; If( nCol == nil, nCol := .2, ); If( nBottom == nil, nBottom := 5, ); If( nRight == nil, nRight := 5, ); If( nPen == nil, nPen := 1, ); If( nScale == nil, nScale := 1, );

   IF nScale == 2
      aStart := ::oDevice:Cmtr2Pix(nRow, nCol)
      aEnd   := ::oDevice:Cmtr2Pix(nBottom, nRight)
   ELSE
      aStart := ::oDevice:Inch2Pix(nRow, nCol)
      aEnd   := ::oDevice:Inch2Pix(nBottom, nRight)
   ENDIF





   ::oDevice:Line(aStart[1]    , aStart[2]    , aEnd[1]      , aEnd[2]      , ::aPen[nPen])

RETURN Self



static FUNCTION TReport_Shadow( nHeight ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   LOCAL nFor, nCols, nGrid

   IF !::lShadow
     RETU NIL
   ENDIF

   nCols := len(::aColumns)

   IF ::oShdBrush == NIL
       ::oShdBrush := TBrush():New(, ::nClrShadow,,,, )
   ENDIF

   FOR nFor := 1 TO nCols
      IF ::aColumns[nFor]:lShadow

         IF ::aColumns[nFor]:lGrid
            nGrid := ::aPen[::aColumns[nFor]:nPen]:nWidth * 2
         ELSE
            nGrid := 0
         ENDIF

         SetbkMode( ::oDevice:hDCOut, 1 )





         ::oDevice:FillRect({::nRow         , ::aCols[nFor] -nGrid  , ::nRow+nHeight  , ::aCols[nFor]+::aColumns[nFor]:nWidth+nGrid} , ::oShdBrush)
      ENDIF
   NEXT

RETURN Self



static FUNCTION TReport_Grid( nHeight, nRow, cChar ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   LOCAL nFor, nCols


   If( nHeight == nil, nHeight := ::nStdLineHeight, ) ; If( nRow == nil, nRow := ::nRow, );

   IF !::lGrid .OR. empty(nHeight)
     RETU NIL
   ENDIF

   nCols := len(::aColumns)

   IF ::lScreen .OR. ::lPrinter

        FOR nFor := 1 TO nCols

           IF ::aColumns[nFor]:lGrid

              SetbkMode( ::oDevice:hDCOut, 1 )





              ::oDevice:line(nRow    , ::aCols[nFor]-(::nSeparator/2)   , nRow+nHeight     , ::aCols[nFor]-(::nSeparator/2), ::aPen[::aColumns[nFor]:nPen])




              ::oDevice:line(nRow    , ::aCols[nFor]+::aColumns[nFor]:nWidth+(::nSeparator/2) , nRow+nHeight     , ::aCols[nFor]+::aColumns[nFor]:nWidth+(::nSeparator/2) , ::aPen[::aColumns[nFor]:nPen])
           ENDIF

        NEXT

     ELSE

        IF cChar == NIL
           cChar := "³"
        ENDIF

        FOR nFor := 1 TO nCols

           IF ::aColumns[nFor]:lGrid





              ::oDevice:Say(nRow    , ::aCols[nFor]-::nSeparator , Replicate(cChar,::nSeparator) , ::aFont[eval(::bStdFont)], ::nSeparator)





              ::oDevice:Say(nRow    , ::aCols[nFor]+::aColumns[nFor]:nWidth , Replicate(cChar,::nSeparator) , ::aFont[eval(::bStdFont)], ::nSeparator)

           ENDIF

        NEXT

     ENDIF

RETURN Self



static FUNCTION TReport_Separator( nPen, nRow ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

     LOCAL oPen
     LOCAL cSeparator
     LOCAL nLeft, nRight


     If( nRow == nil, nRow := ::nRow, ) ; If( nPen == nil, nPen := 1, );

     nLeft  := ::nMargin
     nRight := nLeft

     Aeval(::aColumns, {|v| nRight += v:nWidth } )

     nRight += ((len(::aColumns)-1)*::nSeparator)

     IF !::lPrinter .AND. !::lScreen

          cSeparator := ""

          Aeval(::aColumns, {|val| cSeparator += Replicate("Ä",val:nWidth)+"Å" })
          cSeparator := "Ã"+Substr(cSeparator,1,len(cSeparator)-1)+"´"
          ::oDevice:Say(nRow, nLeft-::nSeparator, cSeparator)
          ::Shadow(::nStdLineHeight)
          ::nRow += ::nStdLineHeight
          RETU NIL

     ENDIF

     IF ::aColumns[1]:lGrid
          nLeft -= Int(::nSeparator/2)
     ENDIF

     IF Atail(::aColumns):lGrid
          nRight += Int(::nSeparator/2)
     ENDIF

     IF nPen <> NIL .AND. nPen > 0 .AND. nPen < len(::aPen)
          oPen := ::aPen[nPen]
     ELSE
          oPen := ::oPenHorz
     ENDIF


     Aeval(::aColumns, {|v| v:Separator(nRow)})
     ::NewLine(oPen:nWidth*4)

RETURN Self



static FUNCTION TReport_SetPenColor( nColor ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   IF nColor == NIL
       RETU NIL
   ENDIF

   ::oPenHorz:End()




   ::oPenHorz := TPen():New( 0, Int(1*::nLogPixX/72), nColor, )

RETURN Self







static FUNCTION TReport_Activate( bFor, bWhile, bInit, bEnd, bStartPage,  bEndPage, bStartGroup, bEndGroup,  bStartLine, bEndLine, bChange,  bPostEnd, bPostPage, bPostGroup ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport


   LOCAL oPagina


   If( bFor == nil, bFor := {|| .T.    }, ) ; If( bWhile == nil, bWhile := {|| !eof() }, );


































   If( ::bFor == nil, ::bFor := bFor, ) ; If( ::bWhile == nil, ::bWhile := bWhile, ); If( ::bInit == nil, ::bInit := bInit, ); If( ::bEnd == nil, ::bEnd := bEnd, ); If( ::bStartPage == nil, ::bStartPage := bStartPage, ); If( ::bEndPage == nil, ::bEndPage := bEndPage, ); If( ::bStartGroup == nil, ::bStartGroup := bStartGroup, ); If( ::bEndGroup == nil, ::bEndGroup := bEndGroup, ); If( ::bStartLine == nil, ::bStartLine := bStartLine, ); If( ::bEndLine == nil, ::bEndLine := bEndLine, ); If( ::bChange == nil, ::bChange := bChange, ); If( ::bPostEnd == nil, ::bPostEnd := bPostEnd, ); If( ::bPostPage == nil, ::bPostPage := bPostPage, ); If( ::bPostGroup == nil, ::bPostGroup := bPostGroup, );






   IF len(::aGroups) > 0
      while eval(::bWhile) .AND. !eval(::bFor)
         SysRefresh()
         ::Skip(1)
      ENDDO
   ENDIF





   IF !::lCreated
       ::End()
       RETU NIL
   ENDIF

   ::Stabilize()

   IF ::lIsNarrow
        ::oDevice:SetLandScape()
        ::nWidth  := ::oDevice:nHorzRes()
        ::nHeight := ::oDevice:nVertRes()
        ::Stabilize()
   ENDIF

   IF !::lStable
       ::End()
       RETU NIL
   ENDIF





   IF !::lScreen

      ::oRptWnd = TDialog():New(,,,, ::cName, "PRINT_PROC",, .F.,,,,,, .F.,,,,,, .F.,, "::oRptWnd", nil, )



      TButton():ReDefine( 2, {||(::lBreak := .T., ::oRptWnd:End())}, ::oRptWnd,,, .F., {|| (!::lNoCancel)},,, .F. )

      oPagina := TSay():ReDefine( 101, {|| ::nPage}, ::oRptWnd,,,, .F.,, .F., .F., )

      ::oRptWnd:bPainted := {|| iif(::nPage>0,oPagina:Refresh(), )}

      ::oRptWnd:bStart := {|| ::Play(), ::oRptWnd:End() }

      ::oRptWnd:Activate( ::oRptWnd:bLClicked, ::oRptWnd:bMoved, ::oRptWnd:bPainted, .T.,,,, ::oRptWnd:bRClicked,,, )

   ELSE

      ::oRptWnd = TDialog():New(,,,, ::cName, "PREVIEW_PROC",, .F.,,,,,, .F.,,,,,, .F.,, "::oRptWnd", nil, )



      TButton():ReDefine( 2, {||(::lBreak := .T., ::oRptWnd:End())}, ::oRptWnd,,, .F., {|| (!::lNoCancel)},,, .F. )

      oPagina := TSay():ReDefine( 101, {|| ::nPage}, ::oRptWnd,,,, .F.,, .F., .F., )

      ::oRptWnd:bPainted := {|| iif(::nPage>0,oPagina:Refresh(), )}

      ::oRptWnd:bStart := {|| ::Play(), ::oRptWnd:End()}

      ::oRptWnd:Activate( ::oRptWnd:bLClicked, ::oRptWnd:bMoved, ::oRptWnd:bPainted, .T.,,,, ::oRptWnd:bRClicked,,, )

      Eval( ::bPreview, ::oDevice )

   ENDIF

RETURN Self



static FUNCTION TReport_Play( ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   LOCAL nColumns, nGroups, nFor1, nFor2, nFor3, nTotalValue
   LOCAL lSeparator





   nColumns   := len(::aColumns)
   nGroups    := len(::aGroups)





   ::StartPage()
   ::Init()








      ASend( ::aGroups, "Reset()" )






   Aeval(::aGroups,{|val,elem| ::StartGroup(elem) })





   while !::lBreak .AND. eval(::bWhile)





      SysRefresh()





      IF !eval(::bFor)
         ::Skip(1)
         LOOP
       ENDIF










         IF ::lGroup
            ASend( ::aGroups, "Evaluate()" )
         ENDIF








      IF ::bStartRecord <> Nil
         Eval(::bStartRecord, Self)
      ENDIF

      FOR nFor1 := 1 TO ::nMaxData

         ::nDataLine := nFor1

         IF !::lSummary


            lSeparator := (::lSeparator .AND.  !::lFirstRow .AND.  nFor1 == 1)
            ::StartLine(::aDataHeight[nFor1], lSeparator)
         ENDIF

         FOR nFor2 := 1 TO nColumns

            IF !::lSummary


                ::aColumns[nFor2]:SayData(::nRow , ::aCols[nFor2] , nFor1)
            ENDIF








            IF ::lTotal                                    .AND.  ::aColumns[nFor2]:lTotal                    .AND.  (!::aColumns[nFor2]:lTotalExpr .OR.                (::aColumns[nFor2]:bTotalExpr <> nil) )

               if ::aColumns[nFor2]:bTotalExpr <> nil
                  nTotalValue := eval(::aColumns[nFor2]:bTotalExpr)
               else
                  nTotalValue := eval(::aData[nFor2][nFor1])
               end

               IF valtype(nTotalValue) == "N"
                    ::aColumns[nFor2]:nTotal += nTotalValue
                    IF ::lGroup
                       FOR nFor3 := 1 TO nGroups
                          ::aGroups[nFor3]:aTotal[nFor2] += nTotalValue
                       NEXT
                    ENDIF
               ENDIF
            ENDIF
         NEXT

         IF !::lSummary
            ::EndLine(::aDataHeight[nFor1])
         ENDIF
      NEXT





      ::Skip(1)



      IF ::bEndRecord <> Nil
         Eval(::bEndRecord, Self)
      ENDIF





      IF ::lGroup

         while eval(::bWhile) .AND. !eval(::bFor)
            SysRefresh()
            ::Skip(1)
         ENDDO

         FOR nFor1 := nGroups TO 1 STEP -1
            IF ::aGroups[nFor1]:Check()
               ::EndGroup(nFor1)
            ENDIF
         NEXT
         FOR nFor1 := 1 TO nGroups
            IF ::aGroups[nFor1]:lNeedStart
               ::StartGroup(nFor1)
            ENDIF
         NEXT

       ENDIF

   ENDDO

   IF ::lGroup
      FOR nFor1 := nGroups TO 1 STEP -1
         IF !Empty(::aGroups[nFor1]:nCounter)
            ::EndGroup(nFor1)
         ENDIF
      NEXT
   ENDIF

   ::End()

RETURN Self



static FUNCTION TReport_Stabilize( ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   LOCAL nColumns, nFor1, nFor2, nMaxHeight, nPrnWidth

   nColumns   := len(::aColumns)
   nMaxHeight := 0

   IF nColumns == 0
      ::lCreated := .F.
      RETU NIL
   ENDIF





   IF empty(::nSeparator)
       ::nSeparator := ::oDevice:GetTextWidth(::cCharPattern,::aFont[eval(::bStdFont)])
   ENDIF





   ::nStdLineHeight := ::oDevice:GetTextHeight(::cCharPattern,::aFont[eval(::bStdFont)])






   ::nMaxTitle := 0
   ::nMaxData  := 0

   AEval( ::aColumns, {|Val| ::nMaxTitle := Max(len(Val:aTitle),::nMaxTitle) } )
   AEval( ::aColumns, {|Val| ::nMaxData  := Max(len(Val:aData),::nMaxData) } )





   ::aText := Array(nColumns,::nMaxTitle)

   FOR nFor1 := 1 TO nColumns
      FOR nFor2 := 1 TO ::nMaxTitle
         IF len(::aColumns[nFor1]:aTitle) < nFor2
               ::aText[nFor1][nFor2] := {|| "" }
         ELSE
               ::aText[nFor1][nFor2] := ::aColumns[nFor1]:aTitle[nFor2]
         ENDIF
      NEXT
   NEXT





   ::aData    := Array(nColumns,::nMaxData)

   FOR nFor1 := 1 TO nColumns
      FOR nFor2 := 1 TO ::nMaxData
         IF len(::aColumns[nFor1]:aData) < nFor2
               ::aData[nFor1][nFor2] := {|| "" }
         ELSE
               ::aData[nFor1][nFor2] := ::aColumns[nFor1]:aData[nFor2]
         ENDIF
      NEXT
   NEXT





   ::lGroup := (len(::aGroups)>0)





   ::oHeader:Stabilize()
   ::oFooter:Stabilize()
   ::oTitle:Stabilize()

   Aeval(::aGroups , {|val,elem| val:Stabilize(elem) })
   Aeval(::aColumns, {|val,elem| val:Stabilize(elem) })





   ::lTotal := .F.
   aeval(::aColumns,{|Val| iif(Val:lTotal,::lTotal := .T. ,NIL ) })












   ::lGrid := .F.
   aeval(::aColumns,{|Val| iif(Val:lGrid,::lGrid := .T. ,NIL ) })





   ::nRptWidth := 0
   aeval(::aColumns,{|Val| ::nRptWidth += Val:nWidth+::nSeparator })

   ::nRptWidth -= ::nSeparator

   ::nRptWidth := max(::nRptWidth,::oTitle:nWidth)
   ::nRptWidth := max(::nRptWidth,::oHeader:nWidth)
   ::nRptWidth := max(::nRptWidth,::oFooter:nWidth)





   IF !::lPrinter .AND. !::lScreen
     ::oDevice:nWidth := ::nRptWidth+ (::nSeparator*10)
     ::nWidth         := ::oDevice:nHorzRes()
   ENDIF





   IF ::nRptWidth > ::nWidth .AND. (::lScreen .OR. ::lPrinter)


      IF  ::lAutoLand .AND.  !::lIsNarrow .AND.  ::oDevice:GetOrientation() == 1

          ::lStable   := .F.
          ::lIsNarrow := .T.
          RETU NIL

      ENDIF






   ENDIF

   ::nRptWidth := min(::nRptWidth,::nWidth)






   nPrnWidth := ::nWidth - ::nLeftMargin - ::nRightMargin
   ::nMargin := max((nPrnWidth-::nRptWidth)/2,0) + ::nLeftMargin





   ::aCols := Array(nColumns)

   ::aCols[1] := iif(::aColumns[1]:nCol<>0, ::aColumns[1]:nCol, ::nMargin)
   ::aColumns[1]:nCalCol := ::aCols[1]

   FOR nFor1 := 2 TO nColumns
      IF ::aColumns[nFor1]:nCol>0
         ::aCols[nFor1] := ::aColumns[nFor1]:nCol
      ELSE


         ::aCols[nFor1] := ::aCols[nFor1-1] +  ::aColumns[nFor1-1]:nWidth +  ::nSeparator
      ENDIF
      ::aColumns[nFor1]:nCalCol := ::aCols[nFor1]
   NEXT





   ::oHeader:Stabilize(::nTopMargin,::nMargin)
   ::oTitle:Stabilize(::oHeader:nHeight+::nTopMargin,::nMargin)
   ::oFooter:Stabilize(::nHeight-::nDnMargin-::oFooter:nHeight,::nMargin)






   Aeval(::aColumns, {|val| nMaxHeight:=Max(nMaxHeight,val:nDataHeight) })

   ::nTitleRow  := ::oHeader:nHeight + ::oTitle:nHeight + ::nTopMargin




   ::nBottomRow := ::nHeight-::oFooter:nHeight-::nDnMargin-  iif(!::lTotal,0,::nStdLineHeight+nMaxHeight) -  iif(!::lTotal .AND. ::lSeparator,::oPenHorz:nWidth*10 ,0 ) -  iif(::lTotal .AND. ::lBoxOnTotal,::nStdLineHeight ,0 )





   nMaxHeight     := 0
   ::nTitleHeight := 0

   FOR nFor1 := 1 TO ::nMaxTitle

      FOR nFor2 := 1 TO nColumns
         nMaxHeight := Max(nMaxHeight, ::aColumns[nFor2]:nTitleHeight)
      NEXT
      ::nTitleHeight += nMaxHeight

   NEXT





   ::aDataHeight := Afill(Array(::nMaxData),0)

   FOR nFor1 := 1 TO ::nMaxData



      Aeval(::aColumns, {|val| ::aDataHeight[nFor1] := Max(::aDataHeight[nFor1], val:nDataHeight) })
   NEXT








   ::nFirstdRow := ::nTitleRow + iif(!empty(::nTitleUpLine),::nStdLineHeight,0) + ::nTitleHeight + iif(!empty(::nTitleDnLine),::nStdLineHeight,0)




   ::nLastdRow  := ::nBottomRow - iif(::lTotal,::nStdLineHeight/2 ,0 ) -  iif(!::lTotal .AND. ::lSeparator,::oPenHorz:nWidth*10 ,0 ) - iif(::lTotal .AND. ::lBoxOnTotal,::nStdLineHeight ,0 )





   ::lStable := .T.
   ::lFinish := .F.

RETURN (NIL)



static FUNCTION TReport_Init( ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   IF ::bInit <> nil
       Eval( ::bInit, Self )
   ENDIF

RETURN Self



static FUNCTION TReport_End( ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   ::lFinish := .T.

   IF !::lCreated .OR. !::lStable

        IF ::oShdBrush <> NIL
            ::oShdBrush:end()
        ENDIF


            ASend( ::aFont, "End" )
            ASend( ::aPen, "End" )





        if ::oPenHorz <> nil
           ::oPenHorz:End()
        endif

        ::oDevice:End()
        RETU NIL

   ENDIF

   IF !::lBreak .AND. ::bEnd <> nil
       Eval( ::bEnd, Self )
   ENDIF


   ::EndPage()


   IF !::lScreen
       ::oDevice:End()
   ENDIF

   IF ::oShdBrush <> NIL
       ::oShdBrush:end()
   ENDIF


      ASend( ::aFont, "End" )
      ASend( ::aPen, "End" )





   ::oPenHorz:End()

RETURN Self



static FUNCTION TReport_Skip( n ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   STATIC lRunning := .F.

   ::nCounter++

   IF ::bChange <> nil .AND. !lRunning
       lRunning := .T.
       Eval( ::bChange, Self )
       lRunning := .F.
   ENDIF

   IF ::bSkip <> nil
       retu Eval( ::bSkip, n )
   ENDIF

RETURN DbSkip( n )



static FUNCTION TReport_StartPage( ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   STATIC lRunning := .F.

   ::oDevice:StartPage()

   ::nPage++

   ::oRptWnd:Refresh()

   IF ::bStartPage <> nil .AND. !lRunning
       lRunning := .T.
       Eval( ::bStartPage, Self )
       lRunning := .F.
   ENDIF

   ::oHeader:Say()
   ::oTitle:Say()
   ::ColTitle()
   ::lFirstRow := .T.

RETURN Self



static FUNCTION TReport_EndPage( ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   STATIC lRunning := .F.

   IF ::bEndPage <> nil .AND. !lRunning
       lRunning := .T.
       Eval( ::bEndPage, Self )
       lRunning := .F.
   ENDIF

   ::PageTotal()
   ::oFooter:Say()

   IF ::bPostPage <> nil .AND. !lRunning
       lRunning := .T.
       Eval( ::bPostPage, Self )
       lRunning := .F.
   ENDIF

   IF !::lBreak .AND. ::lFinish .AND. ::bPostEnd <> nil .AND. !lRunning
       lRunning := .T.
       Eval( ::bPostEnd, Self )
       lRunning := .F.
   ENDIF

   ::oDevice:EndPage()

   IF !(::lFinish)
       ::StartPage()
   ENDIF

RETURN Self



static FUNCTION TReport_StartLine( nHeight, lSeparator ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   STATIC lRunning := .F.


   If( nHeight == nil, nHeight := ::nStdLineHeight, ) ; If( lSeparator == nil, lSeparator := .F., );

   IF nHeight == 0
     RETU NIL
   ENDIF

   IF (nHeight+::nRow) >= ::nBottomRow
         ::EndPage()
         lSeparator := .F.
   ENDIF

   IF lSeparator
     ::Separator()
   ENDIF

   ::Shadow(nHeight)
   ::Grid(nHeight)

   IF ::bStartLine <> nil .AND. !lRunning
      lRunning := .T.
      Eval( ::bStartLine, Self)
      lRunning := .F.
   ENDIF

RETURN Self



static FUNCTION TReport_EndLine( nHeight ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   STATIC lRunning := .F.

   If( nHeight == nil, nHeight := ::nStdLineHeight, ) ;

   IF ::bEndLine <> nil .AND. !lRunning
      lRunning := .T.
      Eval( ::bEndLine, Self)
      lRunning := .F.
   ENDIF

   ::nRow      += nHeight
   ::lFirstRow := .F.

   IF ::NeedNewPage()
       ::EndPage()
   ENDIF

RETURN Self



static FUNCTION TReport_StartGroup( nGroup ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   STATIC lRunning := .F.

   ::aGroups[nGroup]:lNeedStart := .F.

   IF !eval(::bWhile)
         RETU NIL
   ENDIF

   IF ::bStartGroup <> nil .AND. !lRunning
      lRunning := .T.
      Eval( ::bStartGroup, ::aGroups[nGroup])
      lRunning := .F.
   ENDIF

   IF ::aGroups[nGroup]:lHeader
      ::StartLine(::aGroups[nGroup]:nHeaderHeight)
      ::aGroups[nGroup]:Header(::nRow)
      ::EndLine(::aGroups[nGroup]:nHeaderHeight)
   ENDIF

RETURN Self



static FUNCTION TReport_EndGroup( nGroup ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   STATIC lRunning := .F.

   IF ::bEndGroup <> nil .AND. !lRunning
      lRunning := .T.
      Eval( ::bEndGroup, ::aGroups[nGroup])
      lRunning := .F.
   ENDIF

   IF !::lSummary .AND. ::lTotal
       ::StartLine(::aGroups[nGroup]:nFooterHeight*2)
       ::TotalLine(::nGroupLine, 0)
   ENDIF

   IF ::aGroups[nGroup]:lFooter
      ::StartLine(::aGroups[nGroup]:nFooterHeight)
      ::aGroups[nGroup]:Footer(::nRow)
      ::EndLine(::aGroups[nGroup]:nFooterHeight)
   ENDIF

   IF ::bPostGroup <> nil .AND. !lRunning
      lRunning := .T.
      Eval( ::bPostGroup, ::aGroups[nGroup])
      lRunning := .F.
   ENDIF




   IF !::lFirstRow              .AND.  ::aGroups[nGroup]:lEject  .AND.  eval(::bWhile)            .AND.  eval(::bFor)

      ::EndPage()
   ENDIF

   ::aGroups[nGroup]:Reset()
   ::aGroups[nGroup]:lNeedStart := .T.

RETURN Self



static FUNCTION TReport_PageTotal( ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   LOCAL nFor, nColumns





   IF !(::lTotal) .OR. (!::lPageTotal .AND. !::lFinish)
      IF ::lSeparator .OR. ::lJoin
          ::TotalLine(::nTotalLine, 0)
      ENDIF
      RETU (NIL)
   ENDIF

   nColumns := len(::aColumns)





   IF ::lBoxOnTotal
     ::TotalLine(::nTotalLine, 2)
     ::Grid()
   ELSE
     ::TotalLine(::nTotalLine, 0)
   ENDIF





   IF ::lFinish
      IF !empty(::cGrandTotal)





         ::oDevice:Say(::nRow                    , ::aCols[1]                , ::cGrandTotal             , ::aFont[eval(::bStdFont)] , NIL                       , ::aClrText[eval(::bStdFont)],2)
      ENDIF
   ELSE
      IF !empty(::cPageTotal)





         ::oDevice:Say(::nRow                    , ::aCols[1]                , ::cPageTotal              , ::aFont[eval(::bStdFont)] , NIL                       , ::aClrText[eval(::bStdFont)],2)
      ENDIF
   ENDIF





   FOR nFor := 1 TO nColumns
      ::aColumns[nFor]:SayTotal(::nRow, ::aCols[nFor])
   NEXT

   ::nRow += ::nStdLineHeight

   IF ::lBoxOnTotal
      ::TotalLine(::nTotalLine, 0)
   ENDIF

RETURN Self



static FUNCTION TReport_ColTitle( ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   LOCAL nFor1, nFor2, nColumns, nMaxHeight

   nColumns   := len(::aColumns)
   nMaxHeight := 0

   ::nRow := ::nTitleRow





   ::TotalLine(::nTitleUpLine, 1)





   FOR nFor1 := 1 TO ::nMaxTitle

      FOR nFor2 := 1 TO nColumns



         ::aColumns[nFor2]:saytitle(::nRow , ::aCols[nFor2] , nFor1 )
         nMaxHeight := Max(nMaxHeight, ::aColumns[nFor2]:nTitleHeight)
      NEXT

      IF !empty(::nTitleUpLine)
           ::Grid(nMaxHeight)
      ENDIF

      ::nRow += nMaxHeight
      nMaxHeight := 0

   NEXT





   ::TotalLine(::nTitleDnLine, 2)

   ::lFirstRow := .T.

RETURN Self



static FUNCTION TReport_TotalLine( nType, nGrid ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

     LOCAL nFor, nColumns, nJoin, nGridRow, nGridHeight, nHeight
     LOCAL cChar, cLeft, cRight

     IF nType == NIL .OR. empty(nType)
          RETU NIL
     ENDIF

     If( nGrid == nil, nGrid := 0, ) ;

     nJoin       := iif(::lJoin,::nSeparator/2 ,0 )
     nGridRow    := 0
     nGridHeight := 0
     cChar       := "³"
     cLeft       := "À"
     cRight      := "Ù"

     nColumns := len(::aColumns)

     IF nType == 1

          IF ::lScreen .OR. ::lPrinter

               nHeight := Int(::oPenHorz:nWidth*10)

               DO CASE
               CASE nGrid == 0
                    nGridRow    := ::nRow
                    nGridHeight := Int(nHeight*.5)
               CASE nGrid == 1
                    nGridRow    := ::nRow+Int(nHeight*.5)
                    nGridHeight := Int(nHeight*.5)
               CASE nGrid == 2
                    nGridRow    := ::nRow
                    nGridHeight := nHeight
               ENDCASE

               ::Grid(nGridHeight, nGridRow, cChar)

               FOR nFor := 1 TO nColumns





                    ::oDevice:Line(::nRow+Int(nHeight*.5) , ::aCols[nFor] - nJoin , ::nRow+Int(nHeight*.5) , ::aCols[nFor]+::aColumns[nFor]:nWidth + nJoin , ::oPenHorz)

               next

          ELSE

               nHeight     := ::nStdLineHeight
               nGridRow    := ::nRow
               nGridHeight := nHeight

               DO CASE
               CASE nGrid == 0
                    cChar  := "Á"
                    cLeft  := "À"
                    cRight := "Ù"
               CASE nGrid == 1
                    cChar  := "Â"
                    cLeft  := "Ú"
                    cRight := "¿"
               CASE nGrid == 2
                    cChar  := "Å"
                    cLeft  := "Ã"
                    cRight := "´"
               ENDCASE

               ::Grid(nGridHeight, nGridRow, cChar)

               FOR nFor := 1 TO nColumns





                    ::oDevice:Say(::nRow, ::aCols[nFor], Replicate("Ä",::aColumns[nFor]:nWidth) , ::aFont[eval(::bStdFont)], ::aColumns[nFor]:nWidth)

                    IF nFor == 1 .AND. ::aColumns[nFor]:lGrid



                         ::oDevice:Say(::nRow, ::aCols[nFor]-1, cLeft , ::aFont[eval(::bStdFont)],1)
                    ENDIF

                    IF nFor == nColumns .AND. ::aColumns[nFor]:lGrid



                         ::oDevice:Say(::nRow, ::aCols[nFor]+::aColumns[nFor]:nWidth, cRight , ::aFont[eval(::bStdFont)],1)
                    ENDIF

               next

          ENDIF

     ELSEIF nType == 2

          IF ::lScreen .OR. ::lPrinter

               nHeight := ::oPenHorz:nWidth*10

               DO CASE
               CASE nGrid == 0
                    nGridRow    := ::nRow
                    nGridHeight := Int(nHeight*.6)
               CASE nGrid == 1
                    nGridRow    := ::nRow+Int(nHeight*.4)
                    nGridHeight := Int(nHeight*.6)
               CASE nGrid == 2
                    nGridRow    := ::nRow
                    nGridHeight := nHeight
               ENDCASE

               ::Grid(nGridHeight, nGridRow, cChar)

               FOR nFor := 1 TO nColumns





                    ::oDevice:Line(::nRow+Int(nHeight*.4) , ::aCols[nFor] - nJoin , ::nRow+Int(nHeight*.4) , ::aCols[nFor]+::aColumns[nFor]:nWidth + nJoin , ::oPenHorz)





                    ::oDevice:Line(::nRow+Int(nHeight*.6), ::aCols[nFor] - nJoin , ::nRow+Int(nHeight*.6) , ::aCols[nFor]+::aColumns[nFor]:nWidth + nJoin , ::oPenHorz)

               next

          ELSE

               nHeight     := ::nStdLineHeight
               nGridRow    := ::nRow
               nGridHeight := nHeight

               DO CASE
               CASE nGrid == 0
                    cChar  := "Ï"
                    cLeft  := "Ô"
                    cRight := "¾"
               CASE nGrid == 1
                    cChar  := "Ñ"
                    cLeft  := "Õ"
                    cRight := "¸"
               CASE nGrid == 2
                    cChar  := "Ø"
                    cLeft  := "Æ"
                    cRight := "µ"
               ENDCASE

               ::Grid(nGridHeight, nGridRow, cChar)

               FOR nFor := 1 TO nColumns





                    ::oDevice:Say(::nRow, ::aCols[nFor], Replicate("Í",::aColumns[nFor]:nWidth) , ::aFont[eval(::bStdFont)], ::aColumns[nFor]:nWidth)

                    IF nFor == 1 .AND. ::aColumns[nFor]:lGrid



                         ::oDevice:Say(::nRow, ::aCols[nFor]-1, cLeft , ::aFont[eval(::bStdFont)],1)
                    ENDIF

                    IF nFor == nColumns .AND. ::aColumns[nFor]:lGrid



                         ::oDevice:Say(::nRow, ::aCols[nFor]+::aColumns[nFor]:nWidth, cRight , ::aFont[eval(::bStdFont)],1)
                    ENDIF

               next

          ENDIF

     ENDIF

     ::nRow += nHeight

RETURN Self

static FUNCTION TReport_BackLine( nLine ) ; local Self AS CLASS TReport := QSelf() AS CLASS TReport

   if !Empty( ::nStdLineHeight )
      ::nRow -= ::nStdLineHeight * iif( nLine == nil, 1 , nLine )
   end

RETURN ( ::nRow )
