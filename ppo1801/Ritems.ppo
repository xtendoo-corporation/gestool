#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 134 ".\.\Prg\Ritems.prg"
static aItmDoc    := {  {"cTipo",     "C",     2,   0, "Tipo del documento" }, {"Codigo",    "C",     3,   0, "Código del documento" }, {"nLenPag",   "N",     6,   2, "Alto del papel" }, {"nWidPag",   "N",     6,   2, "Ancho del papel" }, {"nLenDoc",   "N",     6,   2, "Alto del documento" }, {"nWidDoc",   "N",     6,   2, "Ancho del documento" }, {"nInicio",   "N",     6,   2, "" }, {"nFin",      "N",     6,   2, "" }, {"nLeft",     "N",     6,   2, "Margen derecho del documento" }, {"nRight",    "N",     6,   2, "Margen izquierdo del documento" }, {"nTypeLine", "N",     1,   0, "Tipo de línea del documento" }, {"cDescrip",  "C",   100,   0, "Nombre del documento" }, {"nAjuste",   "N",     1,   0, "Ajuste del documento" }, {"lVisual",   "L",     1,   0, "Lógico documento de estilo visual" }, {"mReport",   "M",     1,   0, "Contenido del documento de estilo visual" } }







































static aTipDoc     := {  "Artículos [Etiquetas]", "Clientes [Etiquetas]", "Proveedores [Etiquetas]", "Albarán proveedores [Etiquetas]", "Factura proveedores [Etiquetas]", "Factura rectificativas de proveedores [Etiquetas]", "Ofertas de artículos [Etiquetas]", "Producción [Etiquetas]", "Pedido de proveedores [Etiquetas]", "Albaran de clientes [Etiquetas]", "Pedido de clientes [Etiquetas]", "Presupuesto de clientes [Etiquetas]", "Factura de clientes [Etiquetas]", "Factura rectificativa de cliente [Etiquetas]", "S.A.T. clientes [Etiquetas]", "Pedido proveedores", "Albarán proveedores", "Factura proveedores", "Factura rectificativas proveedores", "Recibos facturas proveedor", "S.A.T. clientes", "Presupuesto clientes", "Pedido clientes", "Albarán clientes", "Factura clientes", "Factura de anticipos", "Factura rectificativa", "Recibos facturas clientes", "Tickets clientes", "Depositos almacén", "Existencias almacén", "Movimientos de almacén", "Entregas a cuenta en pedidos de clientes", "Entregas a cuenta en albaranes de clientes", "Parte de producción", "Expedientes", "Arqueo de sesiones", "Pagos de clientes", "Liquidación de agentes" }







































static aCodDoc     := {  "AR", "CL", "PL", "AL", "FL", "RL", "OF", "LP", "PE", "AB", "PB", "PR", "FB", "FI", "SA", "PP", "AP", "FP", "TP", "RP", "SC", "RC", "PC", "AC", "FC", "TC", "FR", "RF", "TK", "DA", "EX", "RM", "EP", "EA", "PO", "ED", "AQ", "MP", "LQ" }

static oWndBrw
static dbfItm
static dbfCol
static dbfDoc
static dbfBmp
static dbfBox
static nAjuste
static bEdit0     := { |aTmp, aGet, cDbfas, oBrw, bWhen, bValid, nMode | EdtDocs( aTmp, aGet, cDbfas, oBrw, bWhen, bValid, nMode ) }
static bEdit1     := { |aTmp, aGet, cDbfas, oBrw, bWhen, bValid, nMode | RenameItems( aTmp, aGet, cDbfas, oBrw, bWhen, bValid, nMode ) }



STATIC FUNCTION OpenFiles()

   local oError
   local oBlock
   local lOpenFiles  := .T.

   if !lExistTable( cPatEmp() + "RDOCUMEN.DBF" )
      mkDocs( cPatEmp() )
   end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RDOCUMEN.DBF" ), ( cCheckArea( "RDOCUMEN", @dbfDoc ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RDOCUMEN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   RECOVER USING oError

      lOpenFiles        := .F.

      msgStop( "Imposible abrir todas las bases de datos" + Chr(13)+Chr(10) + ErrorMessage( oError ) )
      CloseFiles()

   end

   ErrorBlock( oBlock )

Return ( lOpenFiles )



FUNCTION CfgDocs( oMenuItem, oWnd )

   local oRpl
   local oFlt
   local nLevel

    IF oWndBrw == NIL

   nLevel   := Auth():Level( oMenuItem )
   if nAnd( nLevel, 1 ) == 0
      msgStop( "Acceso no permitido." )
      return nil
   end





   if oWnd <> nil
      SysRefresh(); oWnd:CloseAll(); SysRefresh()
   end

   if !OpenFiles()
      return nil
   end













   oWndBrw := TShell():New( 2, 10, 18, 70, "Documentos",, oWnd,,, .F.,,, ( dbfDoc ),,,,, {"Código" , "Documento"}, {||( WinAppRec( oWndBrw:oBrw, bEdit0, dbfDoc, , {|oGet| NotValid( oGet, dbfDoc ) } ) )}, {||( VisualEdtDocs( dbfDoc ) )}, {||( WinDelRec( oWndBrw:oBrw, dbfDoc, {|| DocDelRec() } ) )},, nil, nLevel, "gc_document_text_screw_16", ( 33 + ( 115 * 256 ) + ( 70 * 65536 ) ),,, .T. )

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Código"
         :cSortOrder       := "Codigo"
         :bEditValue       := {|| ( dbfDoc )->Codigo }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Documento"
         :cSortOrder       := "cDescrip"
         :bEditValue       := {|| ( dbfDoc )->cDescrip }
         :nWidth           := 280
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Tipo de documento"
         :bEditValue       := {|| cTipDoc( ( dbfDoc )->cTipo ) }
         :nWidth           := 280
      end

      oWndBrw:cHtmlHelp    := "Documentos"

      oWndBrw:CreateXFromCode()





      oWndBrw:NewAt( "BUS",,, {||( oWndBrw:SearchSetFocus() )}, "(B)uscar", "B",,,,, .F. )

      oWndBrw:AddSeaBar()







      oWndBrw:NewAt( "NEW",,, {||( oWndBrw:RecAdd() )}, "(A)ñadir", "A",,, 2,, .F. )






      oWndBrw:NewAt( "DUP",,, {||( if( ( dbfDoc )->lVisual, WinDupRec( oWndBrw:oBrw, bEdit0, dbfDoc ), msgInfo( "No se puede modificar el formato." + Chr(13)+Chr(10) + "Tiene que crear un nuevo formato de forma visual.", "Formato obsoleto" ) ) )}, "(D)uplicar", "D",,, 2,, .F. )






        oWndBrw:NewAt( "EDIT",,, {||( oWndBrw:RecEdit() )}, "(M)odificar", "M",,, 4,, .F. )






      oWndBrw:NewAt( "GC_TEXT_FIELD_",,, {||( WinEdtRec( oWndBrw:oBrw, bEdit1, dbfDoc ) )}, "(R)enombrar", "R",,, 4,, .F. )






    oWndBrw:NewAt( "ZOOM",,, {||( WinZooRec( oWndBrw:oBrw, bEdit0, dbfDoc ) )}, "(Z)oom", "Z",,, 4,, .F. )






    oWndBrw:NewAt( "DEL",,, {||( oWndBrw:RecDel() )}, "(E)liminar", "E",,, 16,, .F. )






      oFlt := oWndBrw:NewAt( "BFILTER",,, {||( ( dbfDoc )->( dbClearFilter() ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Filtrar",,, {|This|( This:Toggle() )}, 4,, .F. )






         oWndBrw:NewAt( "GC_OBJECT_CUBE_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "AR" }, "Field->cTipo == 'AR'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Atículos[etiquetas]",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "GC_USER_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "CL" }, "Field->cTipo == 'CL'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Clientes[etiquetas]",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "gc_businessman_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "PL" }, "Field->cTipo == 'PL'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Proveedores[etiquetas]",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "gc_document_empty_businessman_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "FL" }, "Field->cTipo == 'FL'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Albarán proveedor[etiquetas]",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "gc_document_text_businessman_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "FL" }, "Field->cTipo == 'FL'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Factura proveedor[etiquetas]",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "gc_clipboard_empty_businessman_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "PP" }, "Field->cTipo == 'PP'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Pedidos a proveedores",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "gc_document_empty_businessman_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "AP" }, "Field->cTipo == 'AP'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Albaran de proveedores",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "gc_document_text_businessman_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "FP" }, "Field->cTipo == 'FP'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Factura de proveedores",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "gc_document_text_businessman_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "TP" }, "Field->cTipo == 'TP'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Factura rectificativa de proveedores",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "GC_BRIEFCASE2_BUSINESSMAN_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "RP" }, "Field->cTipo == 'RP'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Recibos facturas proveedor",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "GC_NOTEBOOK_USER_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "RC" }, "Field->cTipo == 'RC'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Presupuesto clientes",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "GC_CLIPBOARD_EMPTY_USER_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "PC" }, "Field->cTipo == 'PC'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Pedido clientes",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "GC_DOCUMENT_EMPTY_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "AC" }, "Field->cTipo == 'AC'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Albarán clientes",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "GC_DOCUMENT_TEXT_USER_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "FC" }, "Field->cTipo == 'FC'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Factura clientes",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "GC_DOCUMENT_TEXT_MONEY2_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "TC" }, "Field->cTipo == 'TC'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Factura de anticipos",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "GC_DOCUMENT_TEXT_USER_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "FR" }, "Field->cTipo == 'FR'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Factura rectificativa",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "GC_CASH_REGISTER_USER_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "TK" }, "Field->cTipo == 'TK'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Tikets de clientes",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "GC_BRIEFCASE2_USER_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "RF" }, "Field->cTipo == 'RF'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Recibos facturas clientes",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "GC_PENCIL_PACKAGE_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "RM" }, "Field->cTipo == 'RM'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Movimientos de almacén",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "GC_PACKAGE_PLUS_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "DA" }, "Field->cTipo == 'DA'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Depositos almacén",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "GC_PACKAGE_CHECK_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "EX" }, "Field->cTipo == 'EX'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Existencias almacén",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "GC_CLIPBOARD_EMPTY_USER_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "EP" }, "Field->cTipo == 'EP'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Entregas a cuenta en pedidos de clientes",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "GC_DOCUMENT_EMPTY_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "EA" }, "Field->cTipo == 'EA'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Entregas a cuenta en albaranes de clientes",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "GC_DOCUMENT_TEXT_WORKER_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "PO" }, "Field->cTipo == 'PO'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Parte de producción",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "gc_folder_document_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "ED" }, "Field->cTipo == 'ED'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Expedientes",,,, 4, oFlt, .F. )






         oWndBrw:NewAt( "GC_DOCUMENT_TEXT_WORKER_",,, {||( ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == "EP" }, "Field->cTipo == 'EP'" ) ), ( dbfDoc )->( dbGoTop() ), oWndBrw:Refresh() )}, "Etiquetas producción",,,, 4, oFlt, .F. )






      oWndBrw:NewAt( "gc_export2_",,, {||( ControllerExportDocument( oWndBrw, ".fr3" ) )}, "Exportar fr3", "3",,, 4,, .F. )






      oWndBrw:NewAt( "gc_export2_",,, {||( ControllerExportDocument( oWndBrw, ".zip" ) )}, "E(x)portar zip", "X",,, 4,, .F. )






      oWndBrw:NewAt( "gc_import_",,, {||( DlgImportDocument( oWndBrw ) )}, "Im(p)ortar zip", "P",,, 4,, .F. )





      oWndBrw:NewAt( "END",,, {||( oWndBrw:End() )}, "(S)alir", "S",,,,, .F. )

        oWndBrw:Activate(, oWndBrw:bLClicked, oWndBrw:bRClicked, oWndBrw:bMoved, oWndBrw:bResized, oWndBrw:bPainted, oWndBrw:bKeyDown, oWndBrw:bInit,,,,,,,,, {|| ( CloseFiles() )},, oWndBrw:bLButtonUp, .F. )

    ELSE

        oWndBrw:SetFocus()

    end

RETURN NIL



STATIC FUNCTION CloseFiles()

   ( dbfDoc    )->( dbCloseArea() )

   dbfDoc            := nil

   oWndBrw           := nil

RETURN .T.



STATIC FUNCTION EdtDocs( aTmp, aGet, dbfDoc, oBrw, cTipoDoc, bValid, nMode )

   local oDlg
   local nPos
   local oTipDoc
   local cTipDoc     := aTipDoc[ 1 ]
   local cCodDoc     := aCodDoc[ 1 ]
   local oBtnAceptar

   if nMode == 1
      nPos              := aScan( aTipDoc, {| aTipDoc | substr( aTipDoc, 1, 2 ) == cTipoDoc } )
      cTipDoc           := aTipDoc[ if( nPos <> 0, nPos, 1 )  ]
      aTmp[ 14 ]  := .T.
   else
      nPos        := aScan( aCodDoc, {| aCodDoc | SubStr( aCodDoc, 1, 2 ) == aTmp[ 1 ] } )
      cTipDoc     := aTipDoc[ if( nPos <> 0, nPos, 1 )  ]
      cCodDoc     := aTmp[ 1 ]
   end






   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "documento : " + rtrim( aTmp[ 12 ] ), "DOCUMENTS",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )









      oTipDoc := TComboBox():ReDefine( 100, { | u | If( PCount()==0, cTipDoc, cTipDoc:= u ) }, aTipDoc, oDlg,, {||    ( cCodDoc := aCodDoc[ Max( 1, oTipDoc:nAt ) ], .T. )}, {|Self|( cCodDoc := aCodDoc[ Max( 1, oTipDoc:nAt ) ] )},,,, .F., {||     ( nMode == 1 )},,,,,, "oTipDoc",,,,,,, )






    aGet[ 2 ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ 2 ], aTmp[ 2 ]:= u ) }, oDlg,, "@!", {||    ( notValid( aGet[ 2 ], dbfDoc ) )},,,,,, .F., {||     ( nMode == 1 .OR. nMode == 4 )},, .F., .F.,,,,,, nil,,, )





    aGet[ 12 ] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[ 12 ], aTmp[ 12 ]:= u ) }, oDlg,,,,,,,,, .F., {||         ( nMode <> 3 )}, {|nKey,nFlags,Self| ( ActTitle( nKey, nFlags, Self, nMode, oDlg ) ) }, .F., .F.,,,,,, nil,,, )





   oBtnAceptar := TButton():ReDefine( 511, {||(  SaveEdtDocs( aTmp, aGet, oDlg, oBrw, oBtnAceptar, cCodDoc, nMode ) )}, oDlg,,, .F., {||     (  nMode <> 3 )},,, .F. )





    TButton():ReDefine( 510, {||(  oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .T. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| SaveEdtDocs( aTmp, aGet, oDlg, oBrw, oBtnAceptar, cCodDoc, nMode ) } )
   end


   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted := {|hDC,cPS|( lPaintDoc( oDlg, { aTmp[ 3 ], aTmp[ 4 ] }, { aTmp[ 9 ], aTmp[ 7 ], aTmp[ 10], aTmp[ 8 ]} ) )}, .T.,,,, oDlg:bRClicked,,, )

RETURN ( oDlg:nResult == 1 )



FUNCTION PrnDoc( cTipo, oReport, cDiv, nVdv )

    SetMargin( cTipo, oReport )
    PrintItems( cTipo, oReport, cDiv, nVdv )

RETURN NIL



FUNCTION SetMargin( cTipo, oReport )

   local nTipoLinea
   local oError
   local oBlock
   local dbfDocment
   local lOpenFiles  := .F.





   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RDOCUMEN.DBF" ), ( cCheckArea( "RDOCUMEN", @dbfDocment ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RDOCUMEN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      lOpenFiles     := .T.

   RECOVER USING oError

      ( dbfDocment )->( dbCloseArea() )

   end

   ErrorBlock( oBlock )

   if !lOpenFiles
      msgStop( "Imposible abrir todas las bases de datos de documentos." + Chr(13)+Chr(10) + ErrorMessage( oError ) )
      Return ( lOpenFiles )
   end





   if ( dbfDocment )->( dbSeek( cTipo ) )

      if ( dbfDocment )->nWidPag <> 0 .AND. ( dbfDocment )->nLenPag <> 0

         oReport:oDevice:SetSize( ( dbfDocment )->nWidPag * 100, ( dbfDocment )->nLenPag * 100 )

         oReport:nWidth  := oReport:oDevice:nHorzRes()
         oReport:nHeight := oReport:oDevice:nVertRes()

      end





      oReport:Margin( ( dbfDocment )->nInicio, 4,    2 )
      oReport:Margin( ( dbfDocment )->nFin,    5, 2 )
      oReport:Margin( ( dbfDocment )->nLeft,   1,   2 )
      oReport:Margin( ( dbfDocment )->nRight,  2,  2 )

      nTipoLinea           := ( dbfDocment )->nTypeLine - 1
        oReport:nTitleUpLine := nTipoLinea
        oReport:nTitleDnLine := nTipoLinea

   else

      MsgTime( "Imposible establecer margenes documento " + cTipo, "Atención" )

   end

   ( dbfDocment )->( dbCloseArea() )

Return ( lOpenFiles )



FUNCTION PrintItems( cTipo, oInf, lPreview, nOffSet )

   local cText
   local cLine
   local nFor
   local nRow
   local nCol
   local nSizTxt
   local aCoors
   local nLines
   local nHeight
   local nSize
   local oFont
   local dbfBox
   local dbfBmp
   local dbfItems
   local bCondition
   local aStart
   local aEnd
   local oPen
   local fColor
   local nWidth
   local cMasc
   local oError
   local oBlock
   local lOpenFiles  := .F.

   If( lPreview == nil, lPreview := .F., ) ;
   If( nOffSet == nil, nOffSet := 0, ) ;

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RBITMAP.DBF" ), ( cCheckArea( "RBITMAP", @dbfBmp ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RBITMAP.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RBOX.DBF" ), ( cCheckArea( "RBOX", @dbfBox ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RBOX.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RITEMS.DBF" ), ( cCheckArea( "RITEMS", @dbfItems ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RITEMS.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      lOpenFiles     := .T.

   RECOVER USING oError

      ( dbfBmp   )->( dbCloseArea() )
      ( dbfBox   )->( dbCloseArea() )
      ( dbfItems )->( dbCloseArea() )

   end
   ErrorBlock( oBlock )

   if !lOpenFiles
      msgStop( "Imposible abrir todas las bases de datos de documentos." + Chr(13)+Chr(10) + ErrorMessage( oError ) )
      Return ( lOpenFiles )
   end

   nAjuste           := 0






   if ( dbfBmp )->( dbSeek( cTipo ) )

      while ( dbfBmp )->Codigo == cTipo .AND. !( dbfBmp )->( Eof() )

         if File( ( dbfBmp )->cFichero )

            aStart := oInf:oDevice:Cmtr2Pix( ( dbfBmp )->nRowTop + nOffSet, ( dbfBmp )->nColTop )
            aEnd   := oInf:oDevice:Cmtr2Pix( ( dbfBmp )->nRowBottom + nOffSet, ( dbfBmp )->nColBottom )

            oInf:oDevice:SayBitmap( aStart[1], aStart[2], ( dbfBmp )->cFichero, aEnd[1], aEnd[2] )

         end

         ( dbfBmp )->( dbSkip() )

      end

   end






   if ( dbfBox )->( dbSeek( cTipo ) )

      while ( dbfBox )->Codigo == cTipo .AND. !( dbfBox )->( Eof() )

         if !Empty( ( dbfBox )->lCondicion ) .AND. !lPreview
            bCondition  := bChar2Block( ( dbfBox )->lCondicion, .T. )
         else
            bCondition  := {|| .T. }
         end

         if Eval( bCondition )

            aStart := oInf:oDevice:Cmtr2Pix( ( dbfBox )->nRowTop + nOffSet, ( dbfBox )->nColTop )
            aEnd   := oInf:oDevice:Cmtr2Pix( ( dbfBox )->nRowBottom + nOffSet, ( dbfBox )->nColBottom )

            oPen := TPen():New(, ( dbfBox )->nTypeLine, ( ( dbfBox )->Red + ( ( dbfBox )->Green * 256 ) + ( ( dbfBox )->Blue * 65536 ) ), )

            if ( aStart[1] == aEnd[1] .OR. aStart[2] == aEnd[2] )
               oInf:oDevice:Line( aStart[1], aStart[2], aEnd[1], aEnd[2], oPen )
            else
               oInf:oDevice:Box( aStart[1], aStart[2], aEnd[1], aEnd[2], oPen )
            end
            oPen:end()

         end

         ( dbfBox )->( dbSkip() )

      end

   end






   if ( dbfItems )->( dbSeek( cTipo ) )

      while ( dbfItems )->Codigo == cTipo .AND. !( dbfItems )->( Eof() )

         nRow  := ( dbfItems )->nLinea + ( ( oInf:nPage - 1 ) * nAjuste ) + nOffSet
         nCol  := ( dbfItems )->nColumna
         nSize := ( dbfItems )->nSize

         if nRow <> 0 .OR. nCol <> 0

            if !Empty( ( dbfItems )->lCondicion ) .AND. !lPreview

               if !Empty( Rtrim( ( dbfItems )->cFichero ) )
                  dbSelectArea( ( &( ( dbfItems )->cFichero ) ) )
               end

               bCondition  := bChar2Block( ( dbfItems )->lCondicion, .T. )

            else

               bCondition  := {|| .T. }

            end

            if Eval( bCondition )

               if ( dbfItems )->lLiteral

                  cText       := ( dbfItems )->cCampo
                  cText       := if( SubStr( cText, 1, 1 ) <> '"', '"' + Rtrim( cText ) + '"', cText )
                  cText       := Eval( bChar2Block( cText ) )

               else

                  if lPreview

                     if ( dbfItems )->lLiteral
                        cText := ( dbfItems )->cCampo
                     else
                        cText := ( dbfItems )->cLiteral
                     end

                  else

                     if !Empty( RTrim( ( dbfItems )->cFichero ) )
                        if At( Type( ( ( dbfItems )->cFichero ) ), "UE" ) == 0
                           dbSelectArea( ( &( ( dbfItems )->cFichero ) ) )
                        end
                     end

                     cText    := Eval( bChar2Block( ( dbfItems )->cCampo ) )

                  end

               end



               if !Empty( ( dbfItems )->fFaceName )















                  oFont := TFont():New(   Rtrim( ( dbfItems )->fFaceName ), 0, ( dbfItems )->fWidth, , ( dbfItems )->fItalic, , , , ( dbfItems )->fStrikeOut, , , , , , , oInf:oDevice )
               else
                  oFont := TFont():New( "Arial", 0, -10,,.T.,,,,,,,,,,, oInf:oDevice )
               end

               IF Empty( Rtrim( ( dbfItems )->cMascara ) ) .OR. lPreview
                  cText    := cValToChar( cText )
                    ELSE
                  cMasc    := Eval( bChar2Block( Rtrim( ( dbfItems )->cMascara ) ) )
                  if ValType( cMasc ) == "C"
                     cText := Trans( cText, cMasc )
                  else
                     cText := cValToChar( cText )
                  end
                    end

                    IF ValType( cText ) == "N" .AND. cText == 0
                  cText    := ""
                    end

               if lPreview
                  nLines   := 1
               else
                  nLines   := MlCount( cText, If( nSize == 0, 50, nSize ) )
               end

               nHeight     := oInf:oDevice:GetTextHeight( "B", oFont )
               nSizTxt     := oInf:oDevice:GetTextWidth( Replicate( "B", nSize ), oFont )

               for nFor := 1 to nLines

                  if ( dbfItems )->nAjuste == 3
                     cLine := Alltrim( MemoLine( Ltrim( cText ), If( nSize == 0, 50, nSize ), nFor ) )
                  else
                     cLine := AllTrim( MemoLine( cText, If( nSize == 0, 50, nSize ), nFor ) )
                  end



                  aCoors   := oInf:oDevice:Cmtr2Pix( nRow, nCol )

                  if nSize <> 0

                     nWidth   := oInf:oDevice:GetTextWidth( cLine, oFont )

                     do case
                        case ( dbfItems )->nAjuste == 3
                           aCoors[2] += ( nSizTxt - nWidth )

                        case ( dbfItems )->nAjuste == 2
                           aCoors[2] += ( ( nSizTxt / 2 ) - ( nWidth / 2 )  )

                     endcase

                  end



                  if lPreview
                     if ( dbfItems )->lLiteral
                        fColor   := 0
                     else
                        fColor   := 255
                     end
                  else
                     fColor      := ( dbfItems )->fColor
                  end



                  oInf:oDevice:Say( aCoors[ 1 ] + ( ( nFor - 1 ) * nHeight ), aCoors[ 2 ], cLine, oFont , nil, fColor )

               next

               if oFont <> nil
                  oFont:end()
               end

            end

         end

         ( dbfItems )->( dbSkip() )

      end

   end

   ( dbfBmp   )->( dbCloseArea() )
   ( dbfBox   )->( dbCloseArea() )
   ( dbfItems )->( dbCloseArea() )

Return ( lOpenFiles )



FUNCTION PrintColum( cTipo, oInf, lPreview )

   local bTitle
   local bData
   local dbfDoc
    local    nSize
    local    cPicture
    local    nColFmt
    local nColor
    local    oFont
    local lShadow
    local lGird
   local nCol
   local nHeight
   local oError
   local oBlock
   local lOpenFiles  := .F.
   local lNewLine

   If( lPreview == nil, lPreview := .F., ) ;

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RCOLUM.DBF" ), ( cCheckArea( "RCOLUM", @dbfDoc ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RCOLUM.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      lOpenFiles     := .T.

   RECOVER USING oError

      ( dbfDoc )->( dbCloseArea() )

   end

   ErrorBlock( oBlock )

   if !lOpenFiles

      msgStop( "Imposible abrir todas las bases de datos de columnas." + Chr(13)+Chr(10) + ErrorMessage( oError ) )

      Return ( lOpenFiles )

   end





   if ( dbfDoc )->( dbSeek( cTipo ) )

      while ( dbfDoc )->Codigo == cTipo .AND. !( dbfDoc )->( eof() )

         if !Empty( ( dbfDoc )->cTitulo )
            bTitle      := { bRetTitle( dbfDoc ) }
         else
            bTitle      := nil
         end





         if lPreview

            bData       := ""
            cPicture    := ""

         else

            if !Empty( ( dbfDoc )->cFichero )
               bData    := Rtrim( &( ( dbfDoc )->cFichero ) ) + "->"
            else
               bData    := ""
            end

            bData       += Rtrim( ( dbfDoc )->cCampo )
            bData       := { bChar2Block( bData ) }

            cPicture    := { bChar2Block( Rtrim( ( dbfDoc )->cMascara ) ) }

         end

         if !( dbfDoc )->lAutPos
            nCol        := ( ( dbfDoc )->nColumna * 10 * oInf:oDevice:nHorzRes() / oInf:oDevice:nHorzSize() )
            nCol        -= oInf:oDevice:nYoffset
         else
            nCol        := 0
         end

         if !Empty( ( dbfDoc )->nHeight )
            nHeight     := ( dbfDoc )->nHeight / 2.54 * oInf:nLogPixY
            nSize       := ( dbfDoc )->nSize   / 2.54 * oInf:nLogPixX
         else
            nSize       := ( dbfDoc )->nSize
         end

         nColor         := ( dbfDoc )->fColor
         lShadow        := ( dbfDoc )->lShadow
         lGird          := ( dbfDoc )->lGird
         lNewLine       := ( dbfDoc )->lNewLine





         do case
         case ( dbfDoc )->nAjuste == 1
            nColFmt     := 1
         case ( dbfDoc )->nAjuste == 2
            nColFmt     := 3
         case ( dbfDoc )->nAjuste == 3
            nColFmt     := 2
         end





         if !empty( ( dbfDoc )->fFaceName )
            oFont       := TFont():New( Rtrim( ( dbfDoc )->fFaceName ), 0, ( dbfDoc )->fWidth,, ( dbfDoc )->fItalic,,,, ( dbfDoc )->fStrikeOut,,,,,,, oInf:oDevice )
         else
            oFont       := TFont():New( "Arial", 0, -10,,.T.,,,,,,,,,,, oInf:oDevice )
         end

         RptAddOColumn( bTitle, nCol, bData, nSize, cPicture, oFont, oFont, oFont, .F., , nColFmt, lShadow, lGird, lNewLine, , nColor, nHeight )

         ( dbfDoc )->( dbSkip() )

      end

   else

      RptAddOColumn()

   end

   ( dbfDoc )->( dbCloseArea() )

Return ( lOpenFiles )



FUNCTION mkDocs( cPath, lAppend, cPathOld, oMeter, lReindex, cVia )

   local oBlock
   local oError
   local dbfDocs
   local lMakeFiles  := .T.

   If( lAppend == nil, lAppend := .F., ) ;
   If( lReindex == nil, lReindex := .T., ) ;
   If( cVia == nil, cVia := cDriver(), ) ;

   if oMeter <> nil
        oMeter:cText    := "Generando Bases"
      SysRefresh()
   end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if !lExistTable( cPath + "RDocumen.Dbf", cVia )
      dbCreate( cPath + "RDocumen.Dbf", aSqlStruct( aItmDoc ), ( cVia ) )
   end

   if lAppend

      if lIsDir( cPathOld )

         if lExistTable( cPathOld + "RDOCUMEN.DBF" )
            dbUseArea( .T., ( cVia ), cPath + "RDOCUMEN.DBF", cCheckArea( "RDOCUMEN", @dbfDocs ), .F. )
            ( dbfDocs )->( __dbApp( cPathOld + "RDOCUMEN.DBF" ) )
            ( dbfDocs )->( dbCloseArea() )
         end

      else

         if lExistTable( cPatDat() + "RDOCUMEN.DBF" )
            dbUseArea( .T., ( cVia ), cPath + "RDOCUMEN.DBF", cCheckArea( "RDOCUMEN", @dbfDocs ), .F. )
            ( dbfDocs )->( __dbApp( cPatDat() + "RDOCUMEN.DBF" ) )
            ( dbfDocs )->( dbCloseArea() )
         end

      end

   end

   RECOVER USING oError

      lMakeFiles     := .F.

      msgStop( "Imposible crear todas las bases de datos" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lMakeFiles
      lMakeFiles     := rxDocs( cPath, oMeter, cVia )
   end

RETURN ( lMakeFiles )



FUNCTION rxDocs( cPath, oMeter, cVia )

   local cDbf
   local oBlock
   local oError
   local lReindexFiles  := .T.

   If( cPath == nil, cPath := cPatEmp(), ) ;
   If( cVia == nil, cVia := cDriver(), ) ;

   fEraseIndex( cPath + "RDOCUMEN.CDX" )

   if !lExistTable( cPath + "RDOCUMEN.DBF" )
      dbCreate( cPath + "RDOCUMEN.DBF", aSqlStruct( aItmDoc ), ( cVia ) )
   end




   dbUseArea( .T., ( cVia ), cPath + "RDOCUMEN.DBF", cCheckArea( "RDOCUMEN", @cDbf ), .F. )
   if !( cDbf )->( neterr() )
      ( cDbf )->( __dbPack() )

      ( cDbf )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( cDbf )->( ordCreate( cPath + "RDOCUMEN.CDX", "Codigo", "Codigo", {|| Field->Codigo }, ) )

      ( cDbf )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( cDbf )->( ordCreate( cPath + "RDOCUMEN.CDX", "cTipo", "cTipo + Codigo", {|| Field->cTipo + Field->Codigo }, ) )

      ( cDbf )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( cDbf )->( ordCreate( cPath + "RDOCUMEN.CDX", "cDescrip", "cDescrip", {|| Field->cDescrip }, ) )

      ( cDbf )->( dbCloseArea() )
   end











Return ( lReindexFiles )



STATIC FUNCTION ActTitle( nKey, nFlags, oGet, nMode, oDlg )

    oGet:assign()
    oDlg:cTitle( "Documento : " + rtrim( oGet:varGet() ) + Chr( nKey ) )

RETURN NIL



function lPaintDoc( oDlg, aCoors, aCols )

return .T.



function lPntDoc( oDlg, aCoors, aCols )

   local hSombra
   local hFondo
   local hHoja
   local hPen
   local hPen1
   local ny
   local nyy
   local ny1
   local ny2
   local nx
   local nxx
   local nx1
   local nx2
   local aVars
   local nEscala  := .1
   local nAltFon  := 280
   local nAncFon  := 306

   if aCoors   <> NIL

      aVars    := aClone( aCoors )

      aVars[ 1 ] = aVars[ 1 ] / nEscala
      aVars[ 2 ] = aVars[ 2 ] / nEscala

      oDlg:GetDc()

      hSombra = CreateSolidBrush( GetSysColor( 16 ) )
      hFondo  = CreateSolidBrush( GetSysColor( 15 ) )
      hHoja   = CreateSolidBrush( 16777215 )

      hPen    = CreatePen( 2  , 2, 8388608 )
      hPen1   = CreatePen( 0, 1, 8388608 )

      ny      = ( nAltFon / 2 ) - ( aVars[ 1 ] / 2 ) + 8
      nx      = ( nAncFon / 2 ) - ( aVars[ 2 ] / 2 ) + 8
      nxx     = nx + aVars[ 2 ]
      nyy     = ny + aVars[ 1 ]

      FillRect( oDlg:hDC, { 7, 7, 18 + nAltFon , 18 + nAncFon }, hFondo )
      FillRect( oDlg:hDC, { ny, nx, ny + aVars[ 1 ], nx + aVars[ 2 ] }, hHoja )
      FillRect( oDlg:hDC, { ny + aVars[ 1 ], nx + 10, ny + aVars[ 1 ] + 10, nx + aVars[ 2 ] + 10 }, hSombra )
      FillRect( oDlg:hDC, { ny + 10, nx + aVars[ 2 ], ny + aVars[ 1 ] + 10, nx + aVars[ 2 ] + 10 }, hSombra )





      nx1     = nx + ( aCols[ 1 ] / nEscala )
      ny1     = ny + ( aCols[ 2 ] / nEscala )
      nx2     = nx + aVars[ 2 ] - ( aCols[ 3 ] / nEscala )
      ny2     = ny + aVars[ 1 ] - ( aCols[ 4 ] / nEscala )

      Rectangle( oDlg:hDC, ny1, nx1, ny2, nx2, hPen )

      DeleteObject( hSombra )
      DeleteObject( hFondo )
      DeleteObject( hHoja )
      DeleteObject( hPen )
      DeleteObject( hPen1 )





      oDlg:ReleaseDc()

   endif

return .T.
























































































































































































































































































FUNCTION AppDocCal( dbfDocFld, cCodDoc, aBase1 )

   local n

   if cCodDoc == nil
      return .F.
   end

   if aBase1 == nil
      return .F.
   end

   FOR n := 1 TO len( aBase1 )

      ( dbfDocFld )->( dbAppend() )
      ( dbfDocFld )->CTIPDOC := cCodDoc
      ( dbfDocFld )->CFLDDOC := aBase1[ n, 1 ]
      ( dbfDocFld )->CDESDOC := aBase1[ n, 5 ]
      ( dbfDocFld )->CMASDOC := aBase1[ n, 6 ]
      ( dbfDocFld )->CCONDOC := aBase1[ n, 7 ]
      ( dbfDocFld )->NALIDOC := if( aBase1[ n, 2 ] == "N", 3, 1 )
      ( dbfDocFld )->NSIZDOC := aBase1[ n, 3 ] + aBase1[ n, 4 ]

   NEXT

RETURN NIL



FUNCTION AppObjItm( dbfDocFld, cCodDoc, oDbf, cArea )

   local n

   if cCodDoc == nil
      return .F.
   end

   for n := 1 to len( oDbf:aTField )

      if !Empty( oDbf:aTField[ n ]:cComment ) .AND. !oDbf:aTField[ n ]:lHide

         ( dbfDocFld )->( dbAppend() )

         ( dbfDocFld )->cTipDoc     := cCodDoc

         if oDbf:aTField[ n ]:lCalculate .AND. Valtype( oDbf:aTField[ n ]:bSetGet ) == "C"
            ( dbfDocFld )->cFldDoc  := oDbf:aTField[ n ]:bSetGet
         else
            ( dbfDocFld )->cFldDoc  := oDbf:aTField[ n ]:cName
         end

         ( dbfDocFld )->cDesDoc     := oDbf:aTField[ n ]:cComment
         ( dbfDocFld )->nAliDoc     := if( oDbf:aTField[ n ]:cType == "N", 3, 1 )
         ( dbfDocFld )->nSizDoc     := oDbf:aTField[ n ]:nLen + oDbf:aTField[ n ]:nDec
         ( dbfDocFld )->cMasDoc     := if( ValType( oDbf:aTField[ n ]:cPict ) == "B", Eval( oDbf:aTField[ n ]:cPict ), oDbf:aTField[ n ]:cPict )
         ( dbfDocFld )->cConDoc     := ""

         if cArea <> nil
            ( dbfDocFld )->cAreDoc  := cArea
         end

      end

   next

RETURN NIL








































































































































































































































































































































































































































































static function bRetTitle( cDocu )

   local cTit  := Rtrim( ( cDocu )->cTitulo )

return {|| cTit }












static function DocDelRec()

   local cCodDoc  := ( dbfDoc )->Codigo

   while ( dbfItm )->( dbSeek( cCodDoc ) ) .AND. !( dbfItm )->( eof() )
      if ( dbfItm )->( dbRLock() )
         ( dbfItm )->( dbDelete() )
         ( dbfItm )->( dbUnLock() )
      end
   end

   while ( dbfCol )->( dbSeek( cCodDoc ) ) .AND. !( dbfCol )->( eof() )
      if ( dbfCol )->( dbRLock() )
         ( dbfCol )->( dbDelete() )
      end
   end

   while ( dbfBmp )->( dbSeek( cCodDoc ) ) .AND. !( dbfBmp )->( eof() )
      if ( dbfBmp )->( dbRLock() )
         ( dbfBmp )->( dbDelete() )
      end
   end

   while ( dbfBox )->( dbSeek( cCodDoc ) ) .AND. !( dbfBox )->( eof() )
      if ( dbfBox )->( dbRLock() )
         ( dbfBox )->( dbDelete() )
      end
   end

return .T.































function aDocs( cCodDoc, dbfDoc, lIncNoImp )

   local aDocs := {}
   local nOrd  := ( dbfDoc )->( OrdSetFocus( "cTipo" ) )

   If( lIncNoImp == nil, lIncNoImp := .F., ) ;

   if !( dbfDoc )->( dbSeek( cCodDoc ) )

      aAdd( aDocs, "    - No hay documentos" )

   else

      if lIncNoImp
            aAdd( aDocs, "No imprimir" )
      end

      while ( dbfDoc )->cTipo == cCodDoc .AND. !( dbfDoc )->( eof() )

         aAdd( aDocs, ( dbfDoc )->Codigo + " - " + Rtrim( ( dbfDoc )->cDescrip ) )

         ( dbfDoc )->( dbSkip() )

      end

   end

   ( dbfDoc )->( OrdSetFocus( nOrd ) )

return ( aDocs )



function cEstilo( lNegrita, lCursiva )

   local cEstilo

   do case
      case lNegrita .AND. !lCursiva
         cEstilo  := "Negrita"
      case !lNegrita .AND. lCursiva
         cEstilo  := "Cursiva"
      case lNegrita .AND. lCursiva
         cEstilo  := "Negrita Cursiva"
      otherwise
         cEstilo  := "Normal"
   end

RETURN ( cEstilo )

























































































STATIC Function ControllerExportDocument( oWndBrw, cExtension )

   local cFileToExport  := DlgExportDocument( oWndBrw, cExtension )

   if empty( cFileToExport )
      RETURN ( nil )
   end

   if cExtension == ".zip"
      ZipExportDocument( cFileToExport )
   else
      Fr3ExportDocument( cFileToExport )
   end

RETURN ( nil )



Static Function DlgExportDocument( oWndBrw, cExtension )

   local oDlg
   local oGetFile
   local cGetFile

   If( cExtension == nil, cExtension := ".zip", ) ;

   cGetFile             := padr( cPatDocuments() + alltrim( ( dbfDoc )->cDescrip ) + cExtension, 300 )

   oDlg = TDialog():New(,,,,, "EXPDOCS",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )



      TSay():ReDefine( 100, {|| ( dbfDoc )->cDescrip}, oDlg,,,, .F.,, .F., .F., )





      oGetFile := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, cGetFile, cGetFile:= u ) }, oDlg,,,,,,,,, .F.,,, .F., .F.,,,,, {|Self|( oGetFile:cText( Padr( cGetFile( "*" + cExtension, "Seleccion de fichero" ), 100 ) ) )}, nil, "FOLDER",, )




      TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )




      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

   oDlg:AddFastKey( 116, {|| oDlg:End( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if ( oDlg:nResult == 1 )
      RETURN ( alltrim( cGetFile ) )
   end

RETURN ( nil )



STATIC FUNCTION fr3ExportDocument( cGetFile )

   if file( cGetFile ) .AND. !msgYesNo( "El fichero " + ( cGetFile ) + " ya existe.", "¿ Desea sobrescribir el fichero?" )
      RETURN ( nil )
   end

   if memowrit( cGetFile, ( dbfDoc )->mReport )
      msgInfo( "Fichero " + ( cGetFile ) + " exportado con éxito." )
   else
      msgStop( "El fichero " + ( cGetFile ) + " no ha sido exportado con éxito." )
   end

RETURN ( nil )



Static Function zipExportDocument( cGetFile )

   local aDir
   local nZip
   local tmpDoc
   local tmpItm
   local tmpCol
   local tmpBmp
   local tmpBox
   local oBlock
   local oError
   local lExport     := .T.
   local nHandle     := 0
   local cCodDoc     := ( dbfDoc )->Codigo
   local nRecAnt     := ( dbfDoc )->( Recno() )

   cGetFile          := Rtrim( cGetFile )

   EraseFilesInDirectory( cPatIn(), "*.*" )

   if !mkDocs( cPatIn(), , , , .F., cLocalDriver() )
      Return .F.
   end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      dbUseArea( .T., ( cLocalDriver() ), ( cPatIn() + "RDOCUMEN.DBF" ), ( cCheckArea( "RDOCUMEN", @tmpDoc ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatIn() + "RDOCUMEN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      if ( dbfDoc )->( dbSeek( cCodDoc ) )
         while ( dbfDoc )->Codigo == cCodDoc .AND. !( dbfDoc )->( eof() )
            dbPass( dbfDoc, tmpDoc, .T. )
            ( dbfDoc )->( dbSkip() )
         end
      end

   RECOVER USING oError

      lExport         := .F.

      msgStop( "Imposible abrir todas las bases de datos" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if !Empty( tmpDoc )
      ( tmpDoc )->( dbCloseArea() )
   end

   ( dbfDoc )->( dbGoTo( nRecAnt ) )






   if lExport






      nHandle := fCreate( cGetFile )
      if nHandle <> -1

         if fClose( nHandle ) .AND. ( fErase( cGetFile ) == 0 )

            aDir     := Directory( cPatIn() + "*.*" )

            hb_SetDiskZip( {|| nil } )
            aEval( aDir, { | cName, nIndex | hb_ZipFile( cGetFile, cPatIn() + cName[ 1 ], 9 ) } )
            hb_gcAll()

            EraseFilesInDirectory( cPatIn(), "*.*" )

            msgInfo( "Documento exportado satisfactoriamente" )

         else

            MsgStop( "Error en la unidad" )

            Return ( .F. )

         end

      else

         MsgStop( "Ruta no válida" )

         Return ( .F. )

      end

   end

Return ( lExport )



Static Function DlgImportDocument( oWndBrw )

   local oDlg
   local oGetFile
   local cGetFile    := Padr( FullCurDir() + "Docs.Zip", 100 )
   local oSayProc
   local cSayProc    := ""

   oDlg = TDialog():New(,,,,, "IMPDOCS",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )





      oGetFile := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, cGetFile, cGetFile:= u ) }, oDlg,,,,,,,,, .F.,,, .F., .F.,,,,, {|Self|( oGetFile:cText( Padr( cGetFile( "*.Zip", "Selección de fichero" ), 100 ) ) )}, nil, "Folder",, )



      oSayProc := TSay():ReDefine( 110, {|| cSayProc}, oDlg,,,, .F.,, .F., .F., )




      TButton():ReDefine( 1, {||( oDlg:Disable(), ImportDocument( cGetFile, oSayProc ), oDlg:Enable() )}, oDlg,,, .F.,,,, .F. )




        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

   oDlg:AddFastKey( 116, {|| oDlg:Disable(), ImportDocument( cGetFile, oSayProc ), oDlg:Enable() } )

    oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if oWndBrw <> nil
      oWndBrw:Refresh()
   end

Return ( nil  )



Static Function ImportDocument( cGetFile, oSayProc )

   local nZip
   local tmpDoc
   local tmpItm
   local tmpCol
   local tmpBmp
   local tmpBox
   local oError
   local oBlock
   local aFiles
   local lImport     := .T.

   cGetFile          := Rtrim( cGetFile )

   if !file( cGetFile )
      MsgStop( "El fichero " + cGetFile + " no existe." )
      Return .F.
   end

   aFiles            := Hb_GetFilesInZip( cGetFile )
   if !Hb_UnZipFile( cGetFile, , , , cPatIn(), aFiles )
      MsgStop( "No se ha descomprimido el fichero " + cGetFile, "Error" )
      Return .F.
   end
   hb_gcAll()

   if !File( cPatIn() + "RDOCUMEN.DBF" )

      MsgStop( "Faltan ficheros para importar el documento" )
      return .F.

   end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cLocalDriver() ), ( cPatIn() + "RDOCUMEN.DBF" ), ( cCheckArea( "RDOCUMEN",   @tmpDoc ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )

   oSayProc:SetText( "Importando documento" )

   while !( tmpDoc )->( eof() )
      while dbSeekInOrd( ( tmpDoc )->Codigo, "Codigo", dbfDoc )
         if ( dbfDoc )->( dbRLock() )
            ( dbfDoc )->( dbDelete() )
         end
      end
      ( tmpDoc )->( dbSkip() )
   end

   ( tmpDoc )->( dbGoTop() )
   while !( tmpDoc )->( eof() )
      dbPass( tmpDoc, dbfDoc, .T. )
      ( tmpDoc )->( dbSkip() )
   end

   oSayProc:SetText( "Proceso finalizado" )

   msgInfo( "Documento importado satisfactoriamente" )

   RECOVER USING oError

      lImport        := .F.

      msgStop( "Imposible abrir todas las bases de datos" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if !Empty( tmpDoc )
      ( tmpDoc )->( dbCloseArea() )
   end






   dbfErase( cPatIn() + "RDocumen" )

Return ( lImport )











































Function lExisteDocumento( cCodigoDocumento, dbfDoc )

   local nOrd
   local lExisteDocumento        := .T.

   if Empty( cCodigoDocumento )
      MsgStop( "Código de documento está vacío." )
      Return ( .F. )
   end

   do case
      case Valtype( dbfDoc ) == "C"

         nOrd                    := ( dbfDoc )->( OrdSetFocus( "Codigo" ) )

         if !( dbfDoc )->( dbSeek( cCodigoDocumento ) )
            MsgStop( "Código de documento " + cCodigoDocumento + " no encontrado." )
            lExisteDocumento     := .F.
         end

         ( dbfDoc )->( OrdSetFocus( nOrd ) )

      case Valtype( dbfDoc ) == "O"

         nOrd                    := dbfDoc:OrdSetFocus( "Codigo" )

         if !( dbfDoc:Seek( cCodigoDocumento ) )
            MsgStop( "Código de documento " + cCodigoDocumento + " no encontrado." )
            lExisteDocumento     := .F.
         end

         dbfDoc:OrdSetFocus( nOrd )

   end

Return ( lExisteDocumento )



Function lVisualDocumento( cCodigoDocumento, dbfDoc )

   local lVisualDocumento  := .T.
   local nOrd              := ( dbfDoc )->( OrdSetFocus( "Codigo" ) )

   if ( dbfDoc )->( dbSeek( cCodigoDocumento ) )
      lVisualDocumento     := ( dbfDoc )->lVisual
   else
      MsgStop( "Código de documento " + cCodigoDocumento + " no existe." )
   end

   ( dbfDoc )->( OrdSetFocus( nOrd ) )

Return ( lVisualDocumento )



Function lMemoDocumento( cCodigoDocumento, dbfDoc )

   local lMemoDocumento    := .T.
   local nOrd              := ( dbfDoc )->( OrdSetFocus( "Codigo" ) )

   if ( dbfDoc )->( dbSeek( cCodigoDocumento ) )
      lMemoDocumento       := !empty( ( dbfDoc )->mReport )
   else
      MsgStop( "Código de documento " + cCodigoDocumento + " no encontrado." )
   end

   ( dbfDoc )->( OrdSetFocus( nOrd ) )

Return ( lMemoDocumento )



Static Function SaveEdtDocs( aTmp, aGet, oDlg, oBrw, oBtnAceptar, cTipDoc, nMode )

   local oError
   local oBlock
   local cCod           := aTmp[ 2 ]

   aTmp[ 1   ]     := SubStr( cTipDoc, 1, 2 )






   if Empty( cCod )
      MsgStop( "Código no puede estar vacío" )
      aGet[ 2 ]:SetFocus()
      return nil
   end

   if Empty( aTmp[ 12 ] )
      MsgStop( "Descripción no puede estar vacía" )
      aGet[ 12 ]:SetFocus()
      return nil
   end

   if nMode == 1 .OR. nMode == 4






      if ( dbfDoc )->( dbSeek( cCod ) )
         msgStop( "Código ya existente" )
         aGet[ 2 ]:SetFocus()
         return nil
      end

   end

   oBlock      := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      BeginTransaction()

      if nMode == 2



         while ( dbfItm )->( dbSeek( cCod ) ) .AND. !( dbfItm )->( eof() )
            if dbLock( dbfItm )
               ( dbfItm )->( dbDelete() )
               ( dbfItm )->( dbUnLock() )
            end
         end

         while ( dbfCol )->( dbSeek( cCod ) ) .AND. !( dbfCol )->( eof() )
            if dbLock( dbfCol )
               ( dbfCol )->( dbDelete() )
               ( dbfCol )->( dbUnLock() )
            end
         end

         while ( dbfBmp )->( dbSeek( cCod ) ) .AND. !( dbfBmp )->( eof() )
            if dbLock( dbfBmp )
               ( dbfBmp )->( dbDelete() )
               ( dbfBmp )->( dbUnLock() )
            end
         end

         while ( dbfBox )->( dbSeek( cCod ) ) .AND. !( dbfBox )->( eof() )
            if dbLock( dbfBox )
               ( dbfBox )->( dbDelete() )
               ( dbfBox )->( dbUnLock() )
            end
         end

      end

      WinGather( aTmp, nil, dbfDoc, oBrw, nMode, nil, .F. )

      CommitTransaction()

   RECOVER USING oError

      RollBackTransaction()
      msgStop( "Imposible almacenar documento" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end
   ErrorBlock( oBlock )






   VisualEdtDocs( dbfDoc )

Return ( oDlg:end( 1 ) )



 FUNCTION BrwDocumento( oGet, oGet2, cTipDoc )

   local oDlg
   local oBrw
   local oGet1
   local cGet1
   local nOrd     := GetBrwOpt( "BrwDocumentos" )
   local oCbxOrd
   local aCbxOrd  := { "Código" }
   local cCbxOrd

   if !OpenFiles( .T. )
      Return nil
   end

   nOrd           := Min( Max( nOrd, 1 ), len( aCbxOrd ) )
   cCbxOrd        := aCbxOrd[ nOrd ]

   if !Empty( cTipDoc )
      ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == cTipDoc }, "cTipo == '" + cTipDoc + "'" ) )
      ( dbfDoc )->( dbGoTop() )
   end

   oDlg = TDialog():New(,,,, "Seleccione un documento", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )






      oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,, {||    ( OrdClearScope( oBrw, dbfDoc ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, dbfDoc, .T., nil, .F. ) ) }, .F., .F.,,,,,, nil, "FIND",, )






      oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,, {|Self|( ( dbfDoc )->( OrdSetFocus( oCbxOrd:nAt ) ), oBrw:Refresh(), oGet1:SetFocus() )},,,, .F.,,,,,,, "oCbxOrd",,,,,,, )

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:cAlias          := dbfDoc

      oBrw:nMarqueeStyle   := 5

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }
      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }

      oBrw:CreateFromResource( 105 )

      with object ( oBrw:AddCol() )
         :cHeader          := "Código"
         :bStrData         := {|| ( dbfDoc )->Codigo }
         :nWidth           := 80
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Nombre"
         :bStrData         := {|| ( dbfDoc )->cDescrip }
         :nWidth           := 280
      end




        TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )




        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )




        TButton():ReDefine( 500, {||( addRecDocument( dbfDoc, oBrw, bEdit0, cTipDoc ) )}, oDlg,,, .F.,,,, .F. )




        TButton():ReDefine( 501, {||( VisualEdtDocs( dbfDoc ) )}, oDlg,,, .F.,,,, .F. )

      oDlg:AddFastKey( 113,       {|| addRecDocument( dbfDoc, oBrw, bEdit0, cTipDoc ) } )
      oDlg:AddFastKey( 114,       {|| VisualEdtDocs( dbfDoc ) } )

      oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )
      oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   DestroyFastFilter( dbfDoc )

   SetBrwOpt( "BrwDocumentos", ( dbfDoc )->( OrdNumber() ) )

   if oDlg:nResult == 1

      if ValType( oGet ) == "O"
         oGet:cText( ( dbfDoc )->Codigo )
      else
         oGet     := ( dbfDoc )->Codigo
      end

      if ValType( oGet2 ) == "O"
         oGet2:cText( AllTrim( ( dbfDoc )->cDescrip ) )
      else
         oGet2    := AllTrim( ( dbfDoc )->cDescrip )
      end

   end

   if !Empty( cTipDoc )
      ( dbfDoc )->( dbClearFilter() )
   end

   CloseFiles()

RETURN ( oDlg:nResult == 1 )



Function addRecDocument( dbfDoc, oBrw, bEdit0, cTipDoc )

      DestroyFastFilter( dbfDoc )

      WinAppRec( oBrw, bEdit0, dbfDoc, cTipDoc )

      ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == cTipDoc }, "cTipo == '" + cTipDoc + "'" ) )
      ( dbfDoc )->( dbGoTop() )

Return( .T. )



FUNCTION cDocumento( oGet, oGet2, dbfDoc, cTipDoc )

   local lValid      := .F.
   local xValor      := oGet:varGet()
   local lOpen       := .F.
   local nOrdAnt

   if Empty( xValor )

      if !Empty( oGet2 )
         oGet2:cText( "" )
      end

      return .T.

   end

   if Empty( dbfDoc )
      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RDOCUMEN.DBF" ), ( cCheckArea( "RDOCUMEN", @dbfDoc ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RDOCUMEN.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      lOpen          := .T.
   end

   if !Empty( cTipDoc )
      ( dbfDoc )->( dbSetFilter( {|| Field->cTipo == cTipDoc }, "Field->cTipo == '" + cTipDoc + "'" ) )
   end

   nOrdAnt           := ( dbfDoc )->( ordsetfocus( "Codigo" ) )

   if ( dbfDoc )->( dbSeek( xValor ) ) .OR. ( dbfDoc )->( dbSeek( Upper( xValor ) ) )

      if ValType( oGet ) == "O"
         oGet:cText( ( dbfDoc )->Codigo )
      else
         oGet        := ( dbfDoc )->Codigo
      end

      if !Empty( oGet2 )
         if ValType( oGet2 ) == "O"
            oGet2:cText( ( dbfDoc )->cDescrip )
         else
            oGet2    := ( dbfDoc )->cDescrip
         end
      end

      lValid         := .T.

   else

      msgStop( "Documento no encontrado", "Aviso del sistema" )

   end

   if !Empty( cTipDoc )
      ( dbfDoc )->( dbSetFilter() )
   end

   ( dbfDoc )->( ordsetfocus( nOrdAnt ) )

   if lOpen
      ( dbfDoc )->( dbCloseArea() )
   end

RETURN lValid



FUNCTION cNombreDoc( cCodigo )

   local cNombre  := Space( 100 )

   if !OpenFiles( .T. )
      Return nil
   end

   if ( dbfDoc )->( dbSeek( cCodigo ) )
      cNombre     := ( dbfDoc )->cDescrip
   end

   CloseFiles()

RETURN ( cNombre )



Static Function aItmFld()

   local aItm  := {}

   aAdd( aItm, { "CTIPDOC", "C",  2, 0 } )
   aAdd( aItm, { "CFLDDOC", "C",100, 0 } )
   aAdd( aItm, { "CAREDOC", "C", 50, 0 } )
   aAdd( aItm, { "CDESDOC", "C",200, 0 } )
   aAdd( aItm, { "CMASDOC", "C", 50, 0 } )
   aAdd( aItm, { "CCONDOC", "C",100, 0 } )
   aAdd( aItm, { "NALIDOC", "N",  1, 0 } )
   aAdd( aItm, { "NSIZDOC", "N",  3, 0 } )

Return ( aItm )



Static Function aItmCol()

   local aItm  := {}

   aAdd( aItm, { "CTIPDOC", "C",  2, 0 } )
   aAdd( aItm, { "CFLDDOC", "C",100, 0 } )
   aAdd( aItm, { "CAREDOC", "C", 50, 0 } )
   aAdd( aItm, { "CDESDOC", "C",200, 0 } )
   aAdd( aItm, { "CMASDOC", "C", 50, 0 } )
   aAdd( aItm, { "CCONDOC", "C",100, 0 } )
   aAdd( aItm, { "NALIDOC", "N",  1, 0 } )
   aAdd( aItm, { "LBitmap", "L",  1, 0 } )
   aAdd( aItm, { "NSIZDOC", "N",  3, 0 } )
   aAdd( aItm, { "NWIDDOC", "N",  3, 0 } )

Return ( aItm )



Static Function VisualEdtDocs( dbfDoc )

   local oFr
   local cTipo

   if !( dbfDoc )->lVisual
      msgInfo( "No se puede modificar el formato, tiene que crear un nuevo formato de forma visual.", "Formato obsoleto" )
      Return .F.
   end

   cTipo                := ( dbfDoc )->cTipo



   oFr                  := frReportManager():New()
   oFr:ClearDataSets()
   oFr:LoadLangRes(     "Spanish.Xml" )
   oFr:SetProperty(     "Designer.DefaultFont", "Name", "Verdana")
   oFr:SetProperty(     "Designer.DefaultFont", "Size", 10)
   oFr:SetIcon( 1 )
   oFr:SetTitle(        "Diseñador de documentos" )
   oFr:SetEventHandler( "Designer", "OnSaveReport", {|| oFr:SaveToBlob( ( dbfDoc )->( Select() ), "mReport" ) } )

   do case
      case cTipo == "AR"
         DesignReportArticulo( oFr, dbfDoc )

      case cTipo == "OF"
         DesignReportOferta( oFr, dbfDoc )

      case cTipo == "CL"
         DesignReportClient( oFr, dbfDoc )

      case cTipo == "PL"
         DesignReportProvee( oFr, dbfDoc )

      case cTipo == "AL"
         DesignLabelAlbaranProveedor( oFr, dbfDoc )

      case cTipo == "FL"
         DesignLabelFacturaProveedor( oFr, dbfDoc )

      case cTipo == "RL"
         DesignLabelFacturaRectificativaProveedor( oFr, dbfDoc )

      case cTipo == "PE"
         DesignLabelPedidoProveedores( oFr, dbfDoc )

      case cTipo == "AB"
         DesignLabelAlbaranClientes( oFr, dbfDoc )

      case cTipo == "PB"
         DesignLabelPedidoClientes( oFr, dbfDoc )

      case cTipo == "PR"
         DesignLabelPresupuestoClientes( oFr, dbfDoc )

      case cTipo == "FB"
         DesignLabelFacturaClientes( oFr, dbfDoc )

      case cTipo == "FI"
         DesignLabelFacturaRectificativaClientes( oFr, dbfDoc )

      case cTipo == "SA"
         DesignLabelSATClientes( oFr, dbfDoc )

      case cTipo == "PP"
         DesignReportPedPrv( oFr, dbfDoc )

      case cTipo == "AP"
         DesignReportAlbPrv( oFr, dbfDoc )

      case cTipo == "FP"
         DesignReportFacPrv( oFr, dbfDoc )

      case cTipo == "TP"
         DesignReportRctPrv( oFr, dbfDoc )

      case cTipo == "SC"
         DesignReportSatCli( oFr, dbfDoc )

      case cTipo == "RC"
         DesignReportPreCli( oFr, dbfDoc )

      case cTipo == "PC"
         DesignReportPedCli( oFr, dbfDoc )

      case cTipo == "AC"
         DesignReportAlbCli( oFr, dbfDoc )

      case cTipo == "FC"
         DesignReportFacCli( oFr, dbfDoc )

      case cTipo == "FR"
         DesignReportFacRec( oFr, dbfDoc )

      case cTipo == "TC"
         DesignReportAntCli( oFr, dbfDoc )

      case cTipo == "TK"
         DesignReportTikCli( oFr, dbfDoc )

      case cTipo == "RF"
         DesignReportRecCli( oFr, dbfDoc )

      case cTipo == "RP"
         DesignReportRecPrv( oFr, dbfDoc )

      case cTipo == "EP"
         DesignReportEntPedCli( oFr, dbfDoc )

      case cTipo == "EA"
         DesignReportEntAlbCli( oFr, dbfDoc )

      case cTipo == "PO"

         with object ( TProduccion():Create( cPatEmp() ) )
            :DesignReportProducc( oFr, dbfDoc )
            :end()
         end

      case cTipo == "AQ"

         with object ( TTurno():Create( cPatEmp() ) )
            :DesignReport( oFr, dbfDoc )
            :end()
         end

      case cTipo == "RM"

         with object ( TRemMovAlm():New( cPatEmp() ) )
            :DesignReportRemMov( oFr, dbfDoc )
            :end()
         end

      case cTipo == "MP"

         DesignReportPgoCli( oFr, dbfDoc )

      case cTipo == "LQ"

         with object ( TCobAge():Create( cPatEmp() ) )
            :DesignReport( oFr, dbfDoc )
            :end()
         end

      case cTipo == "ED"

         with object ( TExpediente():Create( cPatEmp() ) )
            :DesignReport( oFr, dbfDoc )
            :end()
         end

      case cTipo == "LP"

         with object ( TProduccion():Create( cPatEmp() ) )
            :OpenFiles()
            :DesignLabelProducc( oFr, dbfDoc )
            :CloseFiles()
            :end()
         end

      otherwise
         msgStop( "Diseñador visual aún no habilitado" )

   end

   if !Empty( oFr )
      oFr:destroyFr()
      oFr               := nil
   end

Return nil



STATIC FUNCTION RenameItems( aTmp, aGet, dbfDoc, oBrw, bWhen, bValid, nMode )

   local oDlg
   local nPos
   local oTipDoc
   local cTipDoc  := aTipDoc[ 1 ]
   local cCodDoc  := aCodDoc[ 1 ]

   if !( dbfDoc )->lVisual
      msgInfo( "No se puede modificar el formato." + Chr(13)+Chr(10) + "Tiene que crear un nuevo formato de forma visual.", "Formato obsoleto" )
      Return .F.
   end

   oDlg = TDialog():New(,,,, "Renombrando documento : " + rtrim( aTmp[ 12 ] ), "DOCUMENTS",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )

      nPos        := aScan( aCodDoc, {| aCodDoc | SubStr( aCodDoc, 1, 2 ) == aTmp[ 1 ] } )
      cTipDoc     := aTipDoc[ if( nPos <> 0, nPos, 1 )  ]
      cCodDoc     := aTmp[ 1 ]






      oTipDoc := TComboBox():ReDefine( 100, { | u | If( PCount()==0, cTipDoc, cTipDoc:= u ) }, aTipDoc, oDlg,,,,,,, .F., {||     ( .F. )},,,,,, "oTipDoc",,,,,,, )





        aGet[ 2 ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTmp[ 2 ], aTmp[ 2 ]:= u ) }, oDlg,, "@!",,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )




        aGet[ 12 ] := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTmp[ 12 ], aTmp[ 12 ]:= u ) }, oDlg,,,,,,,,, .F.,, {|nKey,nFlags,Self| ( ActTitle( nKey, nFlags, Self, nMode, oDlg ) ) }, .F., .F.,,,,,, nil,,, )




      TButton():ReDefine( 511, {||( SaveRenameItems( aTmp, aGet, oDlg, oBrw, nMode ) )}, oDlg,,, .F.,,,, .F. )





      TButton():ReDefine( 510, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .T. )

   oDlg:AddFastKey( 116, {|| SaveRenameItems( aTmp, aGet, oDlg, oBrw, nMode ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

RETURN ( oDlg:nResult == 1 )



Static Function SaveRenameItems( aTmp, aGet, oDlg, oBrw, nMode )

   if Empty( aTmp[ 12 ] )
      MsgStop( "Descripción no puede estar vacía" )
      aGet[ 12 ]:SetFocus()
      return nil
   end

   WinGather( aTmp, aGet, dbfDoc, oBrw, nMode, nil, .F. )

Return( oDlg:end( 1 ) )



FUNCTION EdtDocumento( cCodDoc )

   local nLevel

   if Empty( cCodDoc )
      Return .F.
   end

   nLevel         := Auth():Level( "01068" )

   if nAnd( nLevel, 1 ) == 0 .OR. nAnd( nLevel, 4 ) == 0
      msgStop( "Acceso no permitido." )
      return .T.
   end

   if OpenFiles()

      if dbSeekInOrd( cCodDoc, "Codigo", dbfDoc )
         VisualEdtDocs( dbfDoc )
      else
         MsgStop( "No se encuentra formato de etiqueta" )
      end

      CloseFiles()
   end

Return .T.



Static Function cTipDoc( cTipo )

   local nPos     := aScan( aCodDoc, cTipo )
   local cTipDoc  := aTipDoc[ Min( Max( nPos, 1 ), len( aTipDoc ) ) ]

Return ( cTipDoc )



Function cFirstDoc( cTipo, dbfDoc )

   local cFirstDoc      := ""

   do case
      case Valtype( dbfDoc ) == "C"

         if dbSeekInOrd( cTipo, "cTipo", dbfDoc )
            cFirstDoc   := ( dbfDoc )->Codigo
         end

      case Valtype( dbfDoc ) == "O"

         if dbfDoc:SeekInOrd( cTipo, "cTipo" )
            cFirstDoc   := dbfDoc:Codigo
         end

   end

Return ( cFirstDoc )



FUNCTION cSelPrimerDoc( cTipDoc )

   local cCodigo  := Space( 3 )

   if !OpenFiles( .T. )
      Return nil
   end

   ( dbfDoc )->( OrdSetFocus( "cTipo" ) )

   if ( dbfDoc )->( dbSeek( cTipDoc ) )
      cCodigo     := ( dbfDoc )->Codigo
   end

   CloseFiles()

RETURN ( cCodigo )
