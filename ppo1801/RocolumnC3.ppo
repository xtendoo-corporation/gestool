#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 21 ".\.\Prg\RocolumnC3.prg"
_HB_CLASS TROColumn ; function TROColumn ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TROColumn", iif( .F., { }, { @HBObject() } ), @TROColumn() ) ) ;

     _HB_MEMBER { oReport } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oReport"}, .F. )
     _HB_MEMBER { aData, aTitle, aPicture } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aData", "aTitle", "aPicture"}, .F. )
     _HB_MEMBER { oDataFont, oTitleFont, oTotalFont, bTotalExpr, bColor } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oDataFont", "oTitleFont", "oTotalFont", "bTotalExpr", "bColor"}, .F. )
     _HB_MEMBER { cTotalPict } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cTotalPict"}, .F. )

     _HB_MEMBER { nWidth, nHeight, nDataHeight, nTitleHeight, nTotal, nCol, nSize, nPad, nPen, nOrder, nCalCol, nCurLine } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nWidth", "nHeight", "nDataHeight", "nTitleHeight", "nTotal", "nCol", "nSize", "nPad", "nPen", "nOrder", "nCalCol", "nCurLine"}, .F. )

     _HB_MEMBER { lTotal, lShadow, lGrid, lTotalExpr, lUnderline, lDobleUnd, lTextUnd, lSeparator } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lTotal", "lShadow", "lGrid", "lTotalExpr", "lUnderline", "lDobleUnd", "lTextUnd", "lSeparator"}, .F. )
     _HB_MEMBER { Cargo } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Cargo"}, .F. )
     _HB_MEMBER { nColor } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nColor"}, .F. )
     _HB_MEMBER { lNewLine } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lNewLine"}, .F. )



     _HB_MEMBER New( aTitle, nCol, aData, nSize, aPicture, oFont, lTotal, bTotalExpr, cFmt, lShadow, lGrid, lNewLine, oReport) AS CLASS TROColumn; oClass:AddMethod( "New", @TROColumn_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

     _HB_MEMBER Stabilize(); oClass:AddMethod( "Stabilize", @TROColumn_Stabilize(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

     _HB_MEMBER SayTitle( nRow, nCol, nLine); oClass:AddMethod( "SayTitle", @TROColumn_SayTitle(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
     _HB_MEMBER SayData( nRow, nCol, nLine); oClass:AddMethod( "SayData", @TROColumn_SayData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
     _HB_MEMBER SayTotal( nRow, nCol); oClass:AddMethod( "SayTotal", @TROColumn_SayTotal(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
     _HB_MEMBER Separator( nDataLine, nRow); oClass:AddMethod( "Separator", @TROColumn_Separator(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
     _HB_MEMBER Underline( lTextLength, lDouble, nDataLine, nRow); oClass:AddMethod( "Underline", @TROColumn_Underline(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
     _HB_MEMBER TitleHeight( nLine); oClass:AddMethod( "TitleHeight", @TROColumn_TitleHeight(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TROColumn ;




















static FUNCTION TROColumn_New( aTitle     , nCol       , aData      , nSize      , aPicture   , oFont      , oTitleFont , oTotalFont , lTotal     , bTotalExpr , nFmt       , lShadow    , lGrid      , lNewLine   , nPen       , nColor     , nHeight    , oReport ) ; local Self AS CLASS TROColumn := QSelf() AS CLASS TROColumn
















     If( aTitle == nil, aTitle := {{|| ""} }, ) ; If( aData == nil, aData := {{|| ""} }, ); If( nSize == nil, nSize := 0, ); If( aPicture == nil, aPicture := {{|| ""} }, ); If( nCol == nil, nCol := 0, ); If( oFont == nil, oFont := TFont():New( "Ms Sans Serif", 6, 12, .F. ), ); If( oTitleFont == nil, oTitleFont := TFont():New( "Ms Sans Serif", 6, 12, .F. ), ); If( oTotalFont == nil, oTotalFont := TFont():New( "Ms Sans Serif", 6, 12, .F. ), ); If( nPen == nil, nPen := 1, ); If( lTotal == nil, lTotal := .F., ); If( lShadow == nil, lShadow := .F., ); If( lGrid == nil, lGrid := .F., ); If( lNewLine == nil, lNewLine := .F., ); If( nColor == nil, nColor := 0, ); If( nHeight == nil, nHeight := 0, ); If( nFmt == nil, nFmt := iif(Valtype(Eval(aData[1]))=="N",2, 1), );

     ::aTitle     = aTitle
     ::aData      = aData
     ::nSize      = nSize
     ::aPicture   = aPicture
     ::oDataFont  = oFont
     ::oTitleFont = oTitleFont
     ::oTotalFont = oTotalFont
     ::lTotal     = lTotal
     ::lShadow    = lShadow
     ::lGrid      = lGrid
     ::lNewLine   = lNewLine
     ::lUnderline = .F.
     ::lDobleUnd  = .F.
     ::lSeparator = .T.
     ::lTextUnd   = .F.
     ::nPen       = nPen
     ::nTotal     = 0
     ::oReport    = oReport
     ::bTotalExpr = bTotalExpr
     ::nCol       = nCol
     ::cTotalPict = iif(len(aPicture)>0, aPicture[1], "")
     ::nWidth     = 0
     ::nCalCol    = 0
     ::nOrder     = 0
     ::nColor     = nColor
     ::nHeight    = nHeight
     ::nPad       = nFmt

     ::lTotalExpr = !(bTotalExpr == NIL)

     while len(::aPicture) < len(::aData)
          Aadd(::aPicture,::cTotalPict)
     ENDDO

RETURN Self



static FUNCTION TROColumn_Stabilize( nOrder ) ; local Self AS CLASS TROColumn := QSelf() AS CLASS TROColumn

     LOCAL nFor, nWidth, nLen

     ::nDataHeight  := ::oReport:oDevice:GetTextHeight(::oReport:cCharPattern, ::oDataFont )
     ::nTitleHeight := ::oReport:oDevice:GetTextHeight(::oReport:cCharPattern, ::oTitleFont )

     IF !empty(::nSize)
          ::nWidth := ::oReport:oDevice:GetTextWidth( Replicate(::oReport:cCharPattern, ::nSize), ::oDataFont )
          RETU NIL
     ENDIF


     FOR nFor := 1 TO len(::aData)
          nLen      := len(cValtoChar(Transform(eval(::aData[nFor]),eval(::aPicture[nFor]))))
          nWidth    := ::oReport:oDevice:GetTextWidth(Replicate(::oReport:cCharPattern,nLen),::oDataFont )
          ::nWidth  := Max(::nWidth,nWidth)
     NEXT

     FOR nFor := 1 TO len(::aTitle)
          nLen      := len(eval(::aTitle[nFor]))
          nWidth    := ::oReport:oDevice:GetTextWidth(Replicate(::oReport:cCharPattern,nLen),::oTitleFont )
          ::nWidth  := Max(::nWidth,nWidth)
     NEXT

     ::nOrder := nOrder

RETURN NIL



static FUNCTION TROColumn_SayTitle( nRow, nCol, nLine ) ; local Self AS CLASS TROColumn := QSelf() AS CLASS TROColumn

     LOCAL cTitle



     If( nRow == nil, nRow := 0, ) ; If( nCol == nil, nCol := ::nCol, ); If( nLine == nil, nLine := 1, );

     IF nLine > len(::aTitle)
          RETU NIL
     ENDIF

     cTitle := eval(::aTitle[nLine])

     ::nCurLine := nLine

     ::oReport:oDevice:Say(nRow, nCol, cTitle, ::oTitleFont, ::nWidth, ::nColor, , ::nPad-1)

RETURN NIL




static FUNCTION TROColumn_SayData( nRow, nCol, nLine ) ; local Self AS CLASS TROColumn := QSelf() AS CLASS TROColumn

   LOCAL cText
   LOCAL cLine
   LOCAL nFor
   LOCAL nWidth
   LOCAL uData



   If( nRow == nil, nRow := 0, ) ; If( nCol == nil, nCol := ::nCol, ); If( nLine == nil, nLine := 1, );

   IF nLine > len(::aData)
      Return Nil
   ENDIF

   ::nCurLine  := nLine

   uData       := Eval( ::aData[ nLine ] )

   if Valtype( uData ) == "C" .AND. File( Rtrim( uData ) )
      ::oReport:oDevice:SayBitmap( nRow, nCol, Rtrim( uData ), ::nSize, ::nHeight )
      ::oReport:EndLine( ::nHeight )
      Return nil
   end

   cText    := Transform( uData, Eval( ::aPicture[nLine] ) )
   nWidth   := ::oReport:oDevice:GetTextWidth( cText, ::oDataFont )

   IF Valtype( uData ) == "C" .AND. len( AllTrim( cText ) ) > ::nSize

      nLine := mlCount( cText, ::nSize )

      FOR nFor := 1 TO nLine
         cLine := AllTrim( MemoLine( cText, ::nSize, nFor ) )
         ::oReport:StartLine()
         ::oReport:oDevice:Say( ::oReport:nRow, nCol, cLine, ::oDataFont, ::nWidth, ::nColor, , ::nPad - 1 )
         ::oReport:EndLine()
      NEXT

      if !::lNewLine
         ::oReport:BackLine( 1 )
      end


   ELSE

      ::oReport:oDevice:Say( nRow, nCol, cText, ::oDataFont, ::nWidth, ::nColor, , ::nPad - 1 )

      if ::lNewLine
         ::oReport:StartLine()
         ::oReport:EndLine()
      end

   end

   IF ::lUnderline
      ::Underline( ::lTextUnd, ::lDobleUnd, nLine , nRow + ::nDataHeight )
   ENDIF

RETURN NIL



static FUNCTION TROColumn_SayTotal( nRow, nCol ) ; local Self AS CLASS TROColumn := QSelf() AS CLASS TROColumn

     LOCAL cText


     If( nRow == nil, nRow := 0, ) ; If( nCol == nil, nCol := ::nCol, );

     IF !::lTotal
          RETU NIL
     ENDIF

     cText := Transform(::nTotal,::cTotalPict)

     ::oReport:oDevice:Say(nRow, nCol, cText, ::oDataFont, ::nWidth, ::nColor, , ::nPad-1)

RETURN NIL



static FUNCTION TROColumn_TitleHeight( nLine ) ; local Self AS CLASS TROColumn := QSelf() AS CLASS TROColumn

     LOCAL cText, cChar
     LOCAL nFor, nWidth, nLen, nLenData

     IF !empty(::nWidth)
          RETU NIL
     ENDIF

     cChar := ::oReport:cCharPattern

     ::nDataHeight  := len(::aData) * ::oReport:oDevice:GetTextHeight(cChar, ::oDataFont)
     ::nTitleHeight := len(::aTitle) * ::oReport:oDevice:GetTextHeight(cChar, ::oFontTitle)

     nLenData := len(::aData)

     FOR nFor := 1 TO nLenData
          cText    := Transform(eval(::aData[nLine]),eval(::aPicture[nLine]))
          nLen     := len(cText)
          nWidth   := ::oReport:oDevice:GetTextWidth(Replicate(cChar,nLen), ::oDataFont)
          ::nWidth := Max(::nWidth,nWidth)
     NEXT

RETURN NIL



static FUNCTION TROColumn_Underline( lTextUnd, lDobleUnd, nLine, nRow ) ; local Self AS CLASS TROColumn := QSelf() AS CLASS TROColumn

     LOCAL nLeft, nRight, nWidth




     If( lTextUnd == nil, lTextUnd := ::lTextUnd, ) ; If( lDobleUnd == nil, lDobleUnd := ::lDobleUnd, ); If( nLine == nil, nLine := 1, ); If( nRow == nil, nRow := ::oReport:nRow, );

     DO CASE
     CASE !lTextUnd .AND. ::lGrid
          nLeft  := ::nCalCol  + Int(::oReport:nSeparator/2)
          nRight := nLeft + ::nWidth + Int(::oReport:nSeparator/2)
     CASE lTextUnd

          nWidth := ::oReport:oDevice:GetTextWidth(alltrim( Transform(eval(::aData[nLine]),eval(::aPicture[nLine]))),::oDataFont)
          DO CASE
               CASE ::nPad == 2
                    nLeft := ::nCalCol+::nWidth-nWidth
               CASE ::nPad == 3
                    nLeft := ::nCalCol+Int(::nWidth/2)-Int(nWidth/2)
               OTHERWISE
                    nLeft := ::nCalCol
          ENDCASE
          nRight := nLeft + nWidth
     OTHERWISE
          nLeft  := ::nCalCol
          nRight := nLeft + ::nWidth
     ENDCASE


     IF lDobleUnd
          nWidth := ::oReport:aPen[::nPen]:nWidth




          ::oReport:oDevice:Line(nRow-nWidth, nLeft, nRow-nWidth, nRight, ::oReport:aPen[::nPen])





          ::oReport:oDevice:Line(nRow+nWidth, nLeft, nRow+nWidth, nRight, ::oReport:aPen[::nPen])
     ELSE




          ::oReport:oDevice:Line(nRow, nLeft, nRow, nRight, ::oReport:aPen[::nPen])
     ENDIF

RETURN NIL



static FUNCTION TROColumn_Separator( nRow, lForced ) ; local Self AS CLASS TROColumn := QSelf() AS CLASS TROColumn

   LOCAL nLeft, nRight, nSep


   If( nRow == nil, nRow := ::oReport:nRow, ) ; If( lForced == nil, lForced := .F., );

   IF !::lSeparator .AND. !lForced
      RETURN NIL
   ENDIF

   nSep   := iif( ::lGrid, Int(::oReport:nSeparator/2), 0)
   nLeft  := ::nCalCol  - nSep
   nRight := nLeft + ::nWidth + (nSep*2)





   ::oReport:oDevice:Line(nRow, nLeft, nRow, nRight, ::oReport:aPen[::nPen])

RETURN NIL
