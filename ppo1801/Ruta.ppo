#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 17 ".\.\Prg\Ruta.prg"
   static oWndBrw
   static bEdit         := { |aTemp, aoGet, dbfRuta, oBrw, bWhen, bValid, nMode | EdtRec( aTemp, aoGet, dbfRuta, oBrw, bWhen, bValid, nMode ) }


static dbfRuta








STATIC FUNCTION OpenFiles( cPatEmp )

   local lOpen       := .T.
   local oBlock      := ErrorBlock( {| oError | ApoloBreak( oError ) } )

   If( cPatEmp == nil, cPatEmp := cPatEmp(), ) ;

   BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RUTA.DBF" ), ( cCheckArea( "RUTA", @dbfRuta ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RUTA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   RECOVER

      msgStop( "Imposible abrir todas las bases de datos rutas" )

      CloseFiles()

      lOpen          := .F.

   end

   ErrorBlock( oBlock )

RETURN lOpen



STATIC FUNCTION CloseFiles()

   oWndBrw  := nil

   ( dbfRuta )->( dbCloseArea() )

   dbfRuta  := nil

RETURN ( .T. )



FUNCTION Ruta( oMenuItem, oWnd )

   local nLevel

   If( oMenuItem == nil, oMenuItem := "01031", ) ;
   If( oWnd == nil, oWnd := oWnd(), ) ;

    IF oWndBrw == NIL

   nLevel               := Auth():Level( oMenuItem )

   if nAnd( nLevel, 1 ) == 0
      msgStop( "Acceso no permitido." )
      return nil
   end





   if oWnd <> nil
      SysRefresh(); oWnd:CloseAll(); SysRefresh()
   end





   AddMnuNext( "Rutas", ProcName() )

   if !OpenFiles()
      return nil
   end














   oWndBrw := TShell():New( 2, 10, 18, 70, "Rutas",, oWnd,,, .F.,,, ( dbfRuta ),,,,, {"Código",    "Nombre"}, {||( WinAppRec( oWndBrw:oBrw, bEdit, dbfRuta ) )}, {||( WinEdtRec( oWndBrw:oBrw, bEdit, dbfRuta ) )}, {||( DBDelRec(  oWndBrw:oBrw, dbfRuta ) )}, {||( WinDupRec( oWndBrw:oBrw, bEdit, dbfRuta ) )}, nil, nLevel, "gc_signpost2_16", ( 190 + ( 57 * 256 ) + ( 0 * 65536 ) ),,, .T. )

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodRut"
         :bEditValue       := {|| ( dbfRuta )->cCodRut }
         :nWidth           := 60
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cDesRut"
         :bEditValue       := {|| ( dbfRuta )->cDesRut }
         :nWidth           := 260
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      oWndBrw:CreateXFromCode()





      oWndBrw:NewAt( "BUS",,, {||( oWndBrw:SearchSetFocus() )}, "(B)uscar", "B",,,,, .F. )

      oWndBrw:AddSeaBar()








      oWndBrw:NewAt( "NEW",,, {||( oWndBrw:RecAdd() )}, "(A)ñadir", "A",,, 2,, .F. )







        oWndBrw:NewAt( "DUP",,, {||( oWndBrw:RecDup() )}, "(D)uplicar", "D",,, 2,, .F. )







        oWndBrw:NewAt( "EDIT",,, {||( oWndBrw:RecEdit() )}, "(M)odificar", "M",,, 4,, .F. )







        oWndBrw:NewAt( "ZOOM",,, {||( WinZooRec( oWndBrw:oBrw, bEdit, dbfRuta ) )}, "(Z)oom", "Z",,, 8,, .F. )







        oWndBrw:NewAt( "DEL",,, {||( oWndBrw:RecDel() )}, "(E)liminar", "E",,, 16,, .F. )








      oWndBrw:NewAt( "IMP",,, {||( InfRut():New( "Listado de rutas" ):Play() )}, "(L)istado", "L",,, 8,, .F. )







      oWndBrw:NewAt( "END",,, {||( oWndBrw:End() )}, "(S)alir", "S",,,,, .F. )

      oWndBrw:Activate(, oWndBrw:bLClicked, oWndBrw:bRClicked, oWndBrw:bMoved, oWndBrw:bResized, oWndBrw:bPainted, oWndBrw:bKeyDown, oWndBrw:bInit,,,,,,,,, {|| ( CloseFiles() )},, oWndBrw:bLButtonUp, .F. )

    ELSE

        oWndBrw:SetFocus()

    end

RETURN NIL



STATIC FUNCTION EdtRec( aTemp, aoGet, dbfRuta, oBrw, bWhen, bValid, nMode )

    local oDlg
    local oGet

    oDlg = TDialog():New(,,,, LblTitle( nMode ) + "Rutas", "RUTA",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )





        oGet := TGetHlp():ReDefine( 101, { | u | If( PCount()==0, aTemp[ 1 ], aTemp[ 1 ]:= u ) }, oDlg,,, {||    ( NotValid( oGet, dbfRuta ) )},,,,,, .F., {||     ( nMode == 1 .OR. nMode == 4 )},, .F., .F.,,,,,, nil,,, )






        aoGet[ 2 ] := TGetHlp():ReDefine( 102, { | u | If( PCount()==0, aTemp[ 2 ], aTemp[ 2 ]:= u ) }, oDlg,, "@!",,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





      TButton():ReDefine( 1, {||( lPreSave( aTemp, aoGet, dbfRuta, oBrw, nMode, oDlg, oGet ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )




      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 559, {||( ChmHelp( "Ruta" ) )}, oDlg,,, .F.,,,, .F. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| if( nMode == 4, if( oGet:lValid(), lPreSave( aTemp, aoGet, dbfRuta, oBrw, nMode, oDlg, oGet ), ), lPreSave( aTemp, aoGet, dbfRuta, oBrw, nMode, oDlg, oGet ) ) } )
   end

   oDlg:AddFastKey ( 112, {|| ChmHelp( "Ruta" ) } )

   oDlg:bStart := {|| oGet:SetFocus() }

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

RETURN ( oDlg:nResult == 1 )



STATIC FUNCTION lPreSave( aTemp, aoGet, dbfRuta, oBrw, nMode, oDlg, oGet )

   if nMode == 1 .OR. nMode == 4

      if Empty( aTemp[1] )
         MsgStop( "El código de la ruta no puede estar vacío." )
         oGet:SetFocus()
         Return .F.
      end

      if dbSeekInOrd( aTemp[ 1 ], "CCODRUT", dbfRuta )
         msgStop( "Código existente" )
         return nil
      end

   end

   if Empty( aTemp[2] )
      MsgStop( "La descripción de la ruta no puede estar vacía." )
      aoGet[2]:SetFocus()
      Return .F.
   end

   WinGather( aTemp, aoGet, dbfRuta, oBrw, nMode )

Return ( oDlg:end( 1 ) )



FUNCTION RetRuta( cCodRut, dbfRuta )

    local cAreaAnt := Alias()
    local cText        := ""
    local lClose     := .F.

    IF dbfRuta == NIL
      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RUTA.DBF" ), ( cCheckArea( "RUTA", @dbfRuta ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RUTA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
        lClose := .T.
    end

   if ( dbfRuta )->( dbSeek( cCodRut ) )
      cText       := ( dbfRuta )->cDesRut
    end

    IF lClose
        ( dbfRuta )->( dbCloseArea() )
    end

    IF cAreaAnt <> ""
        dbSelectArea( ( cAreaAnt ) )
    end

RETURN cText
























































































































































































































































































































































_HB_CLASS pdaRutaSenderReciver ; function pdaRutaSenderReciver ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "pdaRutaSenderReciver", iif( .F., { }, { @HBObject() } ), @pdaRutaSenderReciver() ) ) ;

   _HB_MEMBER CreateData(); oClass:AddMethod( "CreateData", @pdaRutaSenderReciver_CreateData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS pdaRutaSenderReciver ;



static FUNCTION pdaRutaSenderReciver_CreateData( oPgrActual, oSayStatus, cPatPreVenta ) ; local Self AS CLASS pdaRutaSenderReciver := QSelf() AS CLASS pdaRutaSenderReciver

   local dbfRut
   local tmpRut
   local lExist      := .F.
   local cFileName
   local cPatPc      := if( Empty( cPatPreVenta ), cPatPc(), cPatPreVenta )

   dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "Ruta.Dbf" ), ( cCheckArea( "RUTA", @dbfRut ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
   if !lAIS() ; ordListAdd( ( cPatEmp() + "Ruta.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

   dbUseArea( .T., cDriver(), cPatPc + "Ruta.Dbf", cCheckArea( "RUTA", @tmpRut ), .T. )
   ( tmpRut )->( ordListAdd( cPatPc + "Ruta.Cdx" ) )

   if !Empty( oPgrActual )
      oPgrActual:SetRange( 0, ( tmpRut )->( OrdKeyCount() ) )
   end

   ( tmpRut )->( dbGoTop() )
   while !( tmpRut )->( eof() )

      if ( dbfRut )->( dbSeek( ( tmpRut )->cCodRut ) )
         dbPass( tmpRut, dbfRut, .F. )
      else
         dbPass( tmpRut, dbfRut, .T. )
      end

      if dbLock( tmpRut )
         ( tmpRut )->lSelRut  := .F.
         ( tmpRut )->( dbUnLock() )
      end

      ( tmpRut )->( dbSkip() )

      if !Empty( oSayStatus )
         oSayStatus:SetText( "Sincronizando Rutas " + Alltrim( Str( ( tmpRut )->( OrdKeyNo() ) ) ) + " de " + Alltrim( Str( ( tmpRut )->( OrdKeyCount() ) ) ) )
      end

      SysRefresh()

      if !Empty( oPgrActual )
         oPgrActual:SetPos( ( tmpRut )->( OrdKeyNo() ) )
      end

      SysRefresh()

   end

   ( tmpRut )->( dbCloseArea() )
   ( dbfRut )->( dbCloseArea() )

Return ( Self )





Function IsRuta()

   local oError
   local oBlock

   if !lExistTable( cPatEmp() + "Ruta.Dbf" )
      mkRuta( cPatEmp() )
   end

   oBlock                     := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "Ruta.Dbf" ), ( cCheckArea( "CCODRUT", @dbfRuta ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "Ruta.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   ( dbfRuta )->( dbCloseArea() )

Return ( .T. )



FUNCTION mkRuta( cPath, lAppend, cPathOld, oMeter )

    local dbfRuta

   If( lAppend == nil, lAppend := .F., ) ;
   If( cPath == nil, cPath := cPatEmp(), ) ;

    IF oMeter <> NIL
        oMeter:cText    := "Generando Bases"
      SysRefresh()
    end

   dbCreate( cPath + "Ruta.Dbf", aSqlStruct( aItmRut() ), cDriver() )

   if lAppend .AND. lIsDir( cPathOld ) .AND. lExistTable( cPathOld + "Ruta.Dbf" )

      dbUseArea( .T., cDriver(), cPath + "Ruta.Dbf", cCheckArea( "RUTA", @dbfRuta ), .F. )
      ( dbfRuta )->( __dbApp( cPathOld + "Ruta.Dbf" ) )
        ( dbfRuta )->( dbCloseArea() )

   end

    rxRuta( cPath, oMeter )

RETURN NIL



FUNCTION rxRuta( cPath, oMeter )

    local dbfRuta

   If( cPath == nil, cPath := cPatEmp(), ) ;

   if !lExistTable( cPath + "RUTA.DBF" )
      dbCreate( cPath + "RUTA.DBF", aSqlStrucT( aItmRut() ), cDriver() )
   end

   fEraseIndex( cPath + "RUTA.CDX" )

   dbUseArea( .T., cDriver(), cPath + "RUTA.DBF", cCheckArea( "RUTA", @dbfRuta ), .F. )
   if !( dbfRuta )->( neterr() )
      ( dbfRuta )->( __dbPack() )

      ( dbfRuta )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfRuta )->( ordCreate( cPath + "RUTA.CDX", "CCODRUT", "CCODRUT", {|| Field->CCODRUT } ) )

      ( dbfRuta )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfRuta )->( ordCreate( cPath + "RUTA.CDX", "CDESRUT", "CDESRUT", {|| Field->CDESRUT }, ) )

      ( dbfRuta )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfRuta )->( ordCreate( cPath + "RUTA.CDX", "TRMCOD", "PadL( AllTrim( CCODRUT ), 4 )", {|| PadL( AllTrim( Field->cCodRut ), 4 ) } ) )

      ( dbfRuta )->( dbCloseArea() )

   else
      msgStop( "Imposible abrir en modo exclusivo la tabla de rutas" )
   end

RETURN NIL



function aItmRut()



local aBase := {  {"CCODRUT", "C", 4, 0, "Código de la ruta"   ,  "",                  "", "( cDbfRut )" }, {"CDESRUT", "C",30, 0, "Nombre de la ruta"   ,  "'@!'",              "", "( cDbfRut )" }, {"LSELRUT", "L", 1, 0, ""                    ,  "",                  "", "( cDbfRut )" } }

return ( aBase )



FUNCTION BrwRuta( oGet, dbfRuta, oGet2 )

    local oDlg
   local oSayTit
   local oBtn
   local oFont
    local oBrw
   local oGet1
   local cGet1
   local nOrd        := GetBrwOpt( "BrwRuta" )
    local oCbxOrd
   local aCbxOrd     := { "Código", "Nombre" }
   local cCbxOrd     := "Código"
   local lClose      := .F.
   local nLevel      := Auth():Level( "01031" )
   local oSayText
   local cSayText    := "Listado de rutas"
   local cReturn     := ""

   nOrd              := Min( Max( nOrd, 1 ), len( aCbxOrd ) )
   cCbxOrd           := aCbxOrd[ nOrd ]

   if ( dbfRuta == nil )
      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RUTA.DBF" ), ( cCheckArea( "RUTA", @dbfRuta ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RUTA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClose         := .T.
   end

   nOrd              := ( dbfRuta )->( OrdSetFocus( nOrd ) )
   ( dbfRuta )->( dbGoTop() )

   oDlg = TDialog():New(,,,, "Seleccionar rutas", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )






      oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,, {||       ( OrdClearScope( oBrw, dbfRuta ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, dbfRuta ) ) }, .F., .F.,,,,,, nil, "FIND",, )






        oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,, {|Self|( ( dbfRuta )->( OrdSetFocus( oCbxOrd:nAt ) ), oBrw:Refresh(), oGet1:SetFocus(), oCbxOrd:refresh() )},,,, .F.,,,,,,, "oCbxOrd",,,,,,, )

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:cAlias          := dbfRuta
      oBrw:nMarqueeStyle   := 5
      oBrw:cName           := "Browse.Ruta"

      with object ( oBrw:AddCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cCodRut"
         :bEditValue       := {|| ( dbfRuta )->cCodRut }
         :nWidth           := 60
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "cDesRut"
         :bEditValue       := {|| ( dbfRuta )->cDesRut }
         :nWidth           := 260
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }
      oBrw:bRClicked       := {| nRow, nCol, nFlags | oBrw:RButtonDown( nRow, nCol, nFlags ) }

      oBrw:CreateFromResource( 105 )

      if ( "PDA" $ appParamsMain() )



      oSayText := TSay():ReDefine( 100, {|| cSayText}, oDlg,,,, .F.,, .F., .F., )

      end




      TButton():ReDefine( 1, {||( oDlg:end(1) )}, oDlg,,, .F.,,,, .F. )




      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

      if !( "PDA" $ appParamsMain() )





      TButton():ReDefine( 500, {||( WinAppRec( oBrw, bEdit, dbfRuta ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 2 ) <> 0 .AND. !IsReport() )},,, .F. )





      TButton():ReDefine( 501, {||( WinEdtRec( oBrw, bEdit, dbfRuta ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 4 ) <> 0 .AND. !IsReport() )},,, .F. )

      if nAnd( nLevel, 2 ) <> 0 .AND. !IsReport()
         oDlg:AddFastKey( 113, {|| WinAppRec( oBrw, bEdit, dbfRuta ) } )
      end

      if nAnd( nLevel, 4 ) <> 0 .AND. !IsReport()
         oDlg:AddFastKey( 114, {|| WinEdtRec( oBrw, bEdit, dbfRuta ) } )
      end

      end

      oDlg:AddFastKey( 116,    {|| oDlg:end( 1 ) } )
      oDlg:AddFastKey( 13,{|| oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .F.,,,, oDlg:bRClicked,,, )

   if oDlg:nResult == 1

      cReturn  := ( dbfRuta )->cCodRut

      if IsObject( oGet )
         oGet:cText( ( dbfRuta )->cCodRut )
      end

      if IsObject( oGet2 )
         oGet2:cText( ( dbfRuta )->cDesRut )
      end

   end

   DestroyFastFilter( dbfRuta )

   SetBrwOpt( "BrwRuta", ( dbfRuta )->( OrdNumber() ) )

   if lClose
      ( dbfRuta )->( dbCloseArea() )
   else
      ( dbfRuta )->( OrdSetFocus( nOrd ) )
   end

   if IsObject( oGet )
      oGet:setFocus()
   end

Return ( cReturn )



FUNCTION cRuta( oGet, dbfRuta, oGet2 )

   local lClose   := .F.
   local lValid   := .F.
    local xValor     := oGet:varGet()

   if Empty( xValor ) .OR. ( xValor == Replicate( "Z", 4 ) )
      if IsObject( oGet2 )
         oGet2:cText( "" )
      end
      return .T.
   end

   if Empty( dbfRuta )
      dbUseArea( .T., ( cDriver() ), ( cPatEmp() + "RUTA.DBF" ), ( cCheckArea( "RUTA", @dbfRuta ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatEmp() + "RUTA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClose      := .T.
   end

   if ( dbfRuta )->( dbSeek( xValor ) )

      if IsObject( oGet )
         oGet:cText( ( dbfRuta )->cCodRut )
      end

      if IsObject( oGet2 )
         oGet2:cText( ( dbfRuta )->cDesRut )
      end

      lValid      := .T.

   else

      msgStop( "Ruta no encontrada" )

   end

   if lClose
      ( dbfRuta )->( dbCloseArea() )
   end

RETURN lValid
