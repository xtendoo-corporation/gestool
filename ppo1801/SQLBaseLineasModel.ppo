#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 8 ".\Prg\Models\SQLBaseLineasModel.prg"
_HB_CLASS SQLBaseLineasModel ; function SQLBaseLineasModel ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "SQLBaseLineasModel", iif( .T., { @SQLBaseModel() }, { @HBObject() } ), @SQLBaseLineasModel() ) ) ;

    _HB_MEMBER { idForeignKey } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"idForeignKey"}, .F. )
    _HB_MEMBER { cForeignColumn } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cForeignColumn"}, .F. )
    _HB_MEMBER { aTmpIdsToConfirm } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aTmpIdsToConfirm"}, .F. )

   _HB_MEMBER New(); oClass:AddMethod( "New", @SQLBaseLineasModel_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER setForeignKey(); oClass:AddInline( "setForeignKey", {|Self, id | ( ( Self ) ), ( ::idForeignKey := id ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER buildRowSetWhitForeignKey(); oClass:AddInline( "buildRowSetWhitForeignKey", {|Self, id | ( ( Self ) ), ( ::setForeignKey( id ), ::buildRowSet() ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER resetTmpIds(); oClass:AddInline( "resetTmpIds", {|Self | ( ( Self ) ), ( ::aTmpIdsToConfirm := {} ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER getSelectSentence(); oClass:AddMethod( "getSelectSentence", @SQLBaseLineasModel_getSelectSentence(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getInsertSentence(); oClass:AddMethod( "getInsertSentence", @SQLBaseLineasModel_getInsertSentence(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER insertBuffer(); oClass:AddMethod( "insertBuffer", @SQLBaseLineasModel_insertBuffer(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER confirmIdParentToChildsOf( nId_parent); oClass:AddMethod( "confirmIdParentToChildsOf", @SQLBaseLineasModel_confirmIdParentToChildsOf(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER deletingUs(); oClass:AddMethod( "deletingUs", @SQLBaseLineasModel_deletingUs(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER checksForValid( cColumnToValid); oClass:AddMethod( "checksForValid", @SQLBaseLineasModel_checksForValid(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS SQLBaseLineasModel ;



static FUNCTION SQLBaseLineasModel_New( ) ; local Self AS CLASS SQLBaseLineasModel := QSelf() AS CLASS SQLBaseLineasModel

   ::Super:New()

RETURN ( Self )



static FUNCTION SQLBaseLineasModel_getSelectSentence( ) ; local Self AS CLASS SQLBaseLineasModel := QSelf() AS CLASS SQLBaseLineasModel

    local cSQLSelect

    cSQLSelect          := ::cGeneralSelect + " = " + toSQLString( ::idForeignKey )

    if !empty( ::aTmpIdsToConfirm )

        cSQLSelect += " OR " + ::cColumnKey + " IN ( "

        aeval( ::aTmpIdsToConfirm, { | nID | cSQLSelect += toSQLString( nID ) + ", " } )

        cSQLSelect      := ChgAtEnd( cSQLSelect, " )", 2 )

    endif

RETURN ( cSQLSelect )



static FUNCTION SQLBaseLineasModel_getInsertSentence( ) ; local Self AS CLASS SQLBaseLineasModel := QSelf() AS CLASS SQLBaseLineasModel

    local cSQLInsert := "INSERT INTO " + ::cTableName + " ( "

    hEval( ::hBuffer, {| k, v | if ( k <> ::cColumnKey, cSQLInsert += k + ", ", ) } )

   cSQLInsert        := ChgAtEnd( cSQLInsert, " ) VALUES ( ", 2 )

   hEval( ::hBuffer, {| k, v | if ( k <> ::cColumnKey, if ( k == ::cForeignColumn, cSQLInsert += "null, " , cSQLInsert += toSQLString( v ) + ", " ), ) } )

   cSQLInsert        := ChgAtEnd( cSQLInsert, " )", 2 )

RETURN ( cSQLInsert )



static FUNCTION SQLBaseLineasModel_insertBuffer( ) ; local Self AS CLASS SQLBaseLineasModel := QSelf() AS CLASS SQLBaseLineasModel

   getSQLDatabase():Query( ::getInsertSentence() )

   aadd( ::aTmpIdsToConfirm, getSQLDatabase():LastInsertId() )

   ::buildRowSet()

RETURN ( self )



static FUNCTION SQLBaseLineasModel_confirmIdParentToChildsOf( nId_padre ) ; local Self AS CLASS SQLBaseLineasModel := QSelf() AS CLASS SQLBaseLineasModel

    local cUpdateChildsSentence
    local nIdToConfirm

    if empty( ::aTmpIdsToConfirm )
        RETURN( self )
    endif

    for each nIdToConfirm in ::aTmpIdsToConfirm



        cUpdateChildsSentence :=     "UPDATE " + ::cTableName +     " SET " + ::cForeignColumn + " = " + toSQLString( nId_padre ) +     " WHERE " + ::cColumnKey + " = " + toSQLString( nIdToConfirm )

        getSQLDatabase():Query( cUpdateChildsSentence )

    next

RETURN ( self )



static FUNCTION SQLBaseLineasModel_deletingUs( ) ; local Self AS CLASS SQLBaseLineasModel := QSelf() AS CLASS SQLBaseLineasModel

    local cDeleteSentence

    cDeleteSentence := "DELETE FROM " + ::cTableName + " WHERE "

    aeval( ::aTmpIdsToConfirm, { | v | cDeleteSentence += ::cColumnKey + " = " + toSQLString( v ) + " OR " } )

    cDeleteSentence        := ChgAtEnd( cDeleteSentence, "", 4 )

    getSQLDatabase():Query( cDeleteSentence )

RETURN ( self )



static FUNCTION SQLBaseLineasModel_checksForValid( cColumnToValid ) ; local Self AS CLASS SQLBaseLineasModel := QSelf() AS CLASS SQLBaseLineasModel

   local cSentence := "SELECT " + ::cColumnKey + " FROM " + ::cTableName + " WHERE id_cabecera = "+ toSQLString( ::idForeignKey ) + " AND " + cColumnToValid + " = " + toSQLString( ::hBuffer[ cColumnToValid ] )
   local aIDsToValid
   local nIDToValid

   aIDsToValid    := ::selectFetchArray( cSentence )

   if empty( aIDsToValid )
       RETURN ( nil )
   endif

   nIDToValid     := aIDsToValid[1]

RETURN ( nIDToValid )
