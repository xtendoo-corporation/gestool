#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 7 ".\Prg\Validators\SQLBaseValidator.prg"
_HB_CLASS SQLBaseValidator ; function SQLBaseValidator ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "SQLBaseValidator", iif( .F., { }, { @HBObject() } ), @SQLBaseValidator() ) ) ;

   _HB_MEMBER { oController } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oController"}, .F. )

   _HB_MEMBER { hAsserts } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hAsserts"}, .F. )
   _HB_MEMBER { hValidators } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hValidators"}, .F. )

   _HB_MEMBER { cColumnToProced } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cColumnToProced"}, .F. )

   _HB_MEMBER { lDebugMode } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lDebugMode"}, .F. )

   _HB_MEMBER { uValue } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"uValue"}, .F. )

   _HB_MEMBER New(); oClass:AddMethod( "New", @SQLBaseValidator_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER End() ; oClass:AddVirtual( "End" )

   _HB_MEMBER setValue(); oClass:AddInline( "setValue", {|Self, uValue | ( ( Self ) ), ( ::uValue := uValue ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER assignValue(); oClass:AddInline( "assignValue", {|Self, cColumn, uValue | ( ( Self ) ), (  iif( hb_isnil( uValue ), ::setValue( ::oController:getModelBuffer( cColumn ) ), ::setValue( uValue ) ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getValidators() ; oClass:AddVirtual( "getValidators" )
   _HB_MEMBER getAsserts() ; oClass:AddVirtual( "getAsserts" )

   _HB_MEMBER Validate(); oClass:AddInline( "Validate", {|Self, cColumn, uValue | ( ( Self ) ), ( ::assignValue( cColumn, uValue ), ::ProcessAll( cColumn, ::getValidators() ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Assert(); oClass:AddInline( "Assert", {|Self, cColumn, uValue | ( ( Self ) ), ( ::assignValue( cColumn, uValue ), ::ProcessAll( cColumn, ::getAsserts() ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ProcessAll(); oClass:AddMethod( "ProcessAll", @SQLBaseValidator_ProcessAll(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Process(); oClass:AddMethod( "Process", @SQLBaseValidator_Process(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER sayMessage( cMessage); oClass:AddMethod( "sayMessage", @SQLBaseValidator_sayMessage(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Required(); oClass:AddMethod( "Required", @SQLBaseValidator_Required(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER RequiredOrEmpty( uValue); oClass:AddMethod( "RequiredOrEmpty", @SQLBaseValidator_RequiredOrEmpty(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getUniqueSenctence( uValue); oClass:AddMethod( "getUniqueSenctence", @SQLBaseValidator_getUniqueSenctence(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Unique(); oClass:AddMethod( "Unique", @SQLBaseValidator_Unique(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Exist(); oClass:AddMethod( "Exist", @SQLBaseValidator_Exist(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER EmptyOrExist(); oClass:AddMethod( "EmptyOrExist", @SQLBaseValidator_EmptyOrExist(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER onlyAlphanumeric( uValue); oClass:AddMethod( "onlyAlphanumeric", @SQLBaseValidator_onlyAlphanumeric(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Password( uValue); oClass:AddMethod( "Password", @SQLBaseValidator_Password(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Mail( uValue); oClass:AddMethod( "Mail", @SQLBaseValidator_Mail(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER existArticulo( uValue); oClass:AddMethod( "existArticulo", @SQLBaseValidator_existArticulo(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER existFamilia( uValue); oClass:AddMethod( "existFamilia", @SQLBaseValidator_existFamilia(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER existTipoArticulo( uValue); oClass:AddMethod( "existTipoArticulo", @SQLBaseValidator_existTipoArticulo(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Positive( uValue); oClass:AddMethod( "Positive", @SQLBaseValidator_Positive(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getSenderControllerUuid(); oClass:AddMethod( "getSenderControllerUuid", @SQLBaseValidator_getSenderControllerUuid(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER numeroDocumento( value); oClass:AddMethod( "numeroDocumento", @SQLBaseValidator_numeroDocumento(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getView(); oClass:AddInline( "getView", {|Self | ( ( Self ) ), ( ::oController:getView() ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS SQLBaseValidator ;



static FUNCTION SQLBaseValidator_New( oController ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

   ::oController                 := oController

Return ( Self )



static FUNCTION SQLBaseValidator_ProcessAll( cColumn, hProcess ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

   local hColumn
   local hColumnProcess

   if !hhaskey( hProcess, cColumn )
      RETURN ( .T. )
   end

   hColumnProcess          := hget( hProcess, cColumn )
   if empty( hColumnProcess )
      RETURN ( .T. )
   end

   ::cColumnToProced       := cColumn

   for each hColumn in hColumnProcess

      if !::Process( hColumn:__enumKey(), hColumn:__enumValue() )
         RETURN ( .F. )
      end

   next

RETURN ( .T. )



static FUNCTION SQLBaseValidator_Process( cMethod, cMessage ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

   local oError
   local lValidate   := .F.

   BEGIN SEQUENCE WITH { | oErr | Break( oErr ) }

      lValidate      := Self:&( cMethod )( ::uValue )

      if !lValidate .AND. !empty( cMessage )
         ::sayMessage( cMessage )
      end

   RECOVER USING oError

      eval( errorBlock(), oError )

   end

RETURN ( lValidate )



static FUNCTION SQLBaseValidator_sayMessage( cMessage ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

   local cText    := strtran( cMessage, "{value}", alltrim( cvaltostr( ::uValue ) ) )

   if empty( ::getView() ) .OR. empty( ::getView():oMessage )
      msgstop( cText, "Error" )
      RETURN ( self )
   end

   ::getView():showMessage( cText )

RETURN ( self )



static FUNCTION SQLBaseValidator_Required( uValue ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

RETURN ( !empty( uValue ) )



static FUNCTION SQLBaseValidator_RequiredOrEmpty( uValue ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

   if empty( uValue ) .OR. ( uValue == replicate( "Z", len( uValue ) ) )
      RETURN ( .T. )
   end

RETURN ( ::Required( uValue ) )



static FUNCTION SQLBaseValidator_getUniqueSenctence( uValue ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

   local id
   local cSQLSentence

   cSQLSentence      := "SELECT COUNT(*) FROM " + ::oController:getModelTableName()       + space( 1 )
   cSQLSentence      +=    "WHERE " + ::cColumnToProced + " = " + toSQLString( uValue )   + space( 1 )

   id                := ::oController:getModelBufferColumnKey()
   if !empty( id )
      cSQLSentence   +=    "AND " + ::oController:getModelColumnKey() + " <> " + toSQLString( id )
   end

RETURN ( cSQLSentence )



static FUNCTION SQLBaseValidator_Unique( uValue ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

   local nCount
   local cSQLSentence   := ::getUniqueSenctence( uValue )

   nCount               := getSQLDatabase():getValue( cSQLSentence )

RETURN ( hb_isnumeric( nCount ) .AND. nCount == 0 )



static FUNCTION SQLBaseValidator_Exist( uValue ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

   local nCount
   local cSQLSentence

   cSQLSentence         := "SELECT COUNT(*) FROM " + ::oController:getModelTableName() + space( 1 )
   cSQLSentence         +=    "WHERE " + ::cColumnToProced + " = " + toSQLString( uValue )

   nCount               := getSQLDatabase():getValue( cSQLSentence )

RETURN ( hb_isnumeric( nCount ) .AND. nCount <> 0 )



static FUNCTION SQLBaseValidator_EmptyOrExist( uValue ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

   local nCount
   local cSQLSentence

   if empty( uValue )
      RETURN ( .T. )
   end

   cSQLSentence         := "SELECT COUNT(*) FROM " + ::oController:getModelTableName() + space( 1 )
   cSQLSentence         +=    "WHERE " + ::cColumnToProced + " = " + toSQLString( uValue )

   nCount               := getSQLDatabase():getValue( cSQLSentence )

RETURN ( hb_isnumeric( nCount ) .AND. nCount <> 0 )



static FUNCTION SQLBaseValidator_Mail( uValue ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

   if empty( uValue )
      RETURN .T.
   end

RETURN ( hb_regexmatch( "[A-Z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]{2,4}", uValue, .F. ) )



static FUNCTION SQLBaseValidator_Password( uValue ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator



RETURN ( Len( uValue) >= 8 .AND. Len( uValue) <= 18 )



static FUNCTION SQLBaseValidator_onlyAlphanumeric( uValue ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

RETURN ( hb_regexmatch( "[a-zA-Z0-9]", uValue, .F. ) )



static FUNCTION SQLBaseValidator_existArticulo( uValue ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

   if empty( uValue ) .OR. ( uValue == replicate( "Z", len( uValue ) ) )
      RETURN ( .T. )
   end

   if ArticulosModel():exist( uValue )
      RETURN ( .T. )
   end

RETURN ( .F. )



static FUNCTION SQLBaseValidator_existFamilia( uValue ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

   if empty( uValue ) .OR. ( uValue == replicate( "Z", len( uValue ) ) )
      RETURN ( .T. )
   end

   if FamiliasModel():exist( uValue )
      RETURN ( .T. )
   end

RETURN ( .F. )



static FUNCTION SQLBaseValidator_existTipoArticulo( uValue ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

   if empty( uValue ) .OR. ( uValue == replicate( "Z", len( uValue ) ) )
      RETURN ( .T. )
   end

   if TiposArticulosModel():exist( uValue )
      RETURN ( .T. )
   end

RETURN ( .F. )



static FUNCTION SQLBaseValidator_Positive( uValue ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

RETURN ( hb_isnumeric( uValue ) .AND. ( uValue >= 0 ) )



static FUNCTION SQLBaseValidator_getSenderControllerUuid( ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

   if empty( ::oController )
      RETURN ( "" )
   end

   if empty( ::oController:getSenderController() )
      RETURN ( "" )
   end

RETURN ( ::oController:getSenderController():getUuid() )



static FUNCTION SQLBaseValidator_numeroDocumento( value ) ; local Self AS CLASS SQLBaseValidator := QSelf() AS CLASS SQLBaseValidator

   local nAt
   local cSerie   := ""
   local nNumero

   value          := alltrim( value )

   nAt            := rat( "/", value )
   if nAt <> 0
      nNumero     := substr( value, nAt + 1 )
      cSerie      := substr( value, 1, nAt  )
   else
      nNumero     := value
   end

   if !hb_regexlike( "^[0-9]{1,6}$", nNumero )
      RETURN ( .F. )
   end

RETURN ( .T. )







_HB_CLASS SQLCompanyValidator ; function SQLCompanyValidator ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "SQLCompanyValidator", iif( .T., { @SQLBaseValidator() }, { @HBObject() } ), @SQLCompanyValidator() ) ) ;

   _HB_MEMBER getUniqueSenctence( uValue); oClass:AddMethod( "getUniqueSenctence", @SQLCompanyValidator_getUniqueSenctence(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Exist( uValue); oClass:AddMethod( "Exist", @SQLCompanyValidator_Exist(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS SQLCompanyValidator ;



static FUNCTION SQLCompanyValidator_getUniqueSenctence( uValue ) ; local Self AS CLASS SQLCompanyValidator := QSelf() AS CLASS SQLCompanyValidator

   local id
   local cSQLSentence

   cSQLSentence      := "SELECT COUNT(*) FROM " + ::oController:getModelTableName()       + space( 1 )
   cSQLSentence      +=    "WHERE " + ::cColumnToProced + " = " + toSQLString( uValue )   + space( 1 )
   cSQLSentence      +=    "AND empresa_codigo = " + quoted( cCodEmp() )         + space( 1 )

   id                := ::oController:getModelBufferColumnKey()
   if !empty( id )
      cSQLSentence   +=    "AND " + ::oController:getModelColumnKey() + " <> " + toSQLString( id )
   end

RETURN ( cSQLSentence )



static FUNCTION SQLCompanyValidator_Exist( uValue ) ; local Self AS CLASS SQLCompanyValidator := QSelf() AS CLASS SQLCompanyValidator

   local nCount
   local cSQLSentence

   cSQLSentence      := "SELECT COUNT(*) FROM " + ::oController:getModelTableName()       + space( 1 )
   cSQLSentence      +=    "WHERE " + ::cColumnToProced + " = " + toSQLString( uValue )   + space( 1 )
   cSQLSentence      +=    "AND empresa_codigo = " + quoted( cCodEmp() )

   nCount            := getSQLDatabase():getValue( cSQLSentence )

RETURN ( hb_isnumeric( nCount ) .AND. nCount <> 0 )








_HB_CLASS SQLParentValidator ; function SQLParentValidator ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "SQLParentValidator", iif( .T., { @SQLBaseValidator() }, { @HBObject() } ), @SQLParentValidator() ) ) ;

   _HB_MEMBER getUniqueSenctence( uValue); oClass:AddMethod( "getUniqueSenctence", @SQLParentValidator_getUniqueSenctence(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Exist( uValue); oClass:AddMethod( "Exist", @SQLParentValidator_Exist(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER numeroDocumento( value); oClass:AddMethod( "numeroDocumento", @SQLParentValidator_numeroDocumento(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS SQLParentValidator ;



static FUNCTION SQLParentValidator_getUniqueSenctence( uValue ) ; local Self AS CLASS SQLParentValidator := QSelf() AS CLASS SQLParentValidator

   local id
   local cSQLSentence

   cSQLSentence      := "SELECT COUNT(*) FROM " + ::oController:getModelTableName()       + space( 1 )
   cSQLSentence      +=    "WHERE " + ::cColumnToProced + " = " + toSQLString( uValue )   + space( 1 )
   cSQLSentence      +=    "AND parent_uuid = " + quoted( ::getSenderControllerUuid() )   + space( 1 )

   id                := ::oController:getModelBufferColumnKey()
   if !empty( id )
      cSQLSentence   +=    "AND " + ::oController:getModelColumnKey() + " <> " + toSQLString( id )
   end

RETURN ( cSQLSentence )



static FUNCTION SQLParentValidator_Exist( uValue ) ; local Self AS CLASS SQLParentValidator := QSelf() AS CLASS SQLParentValidator

   local nCount
   local cSQLSentence

   cSQLSentence      := "SELECT COUNT(*) FROM " + ::oController:getModelTableName()       + space( 1 )
   cSQLSentence      +=    "WHERE " + ::cColumnToProced + " = " + toSQLString( uValue )   + space( 1 )
   cSQLSentence      +=    "AND parent_uuid = " + quoted( ::getSenderControllerUuid() )   + space( 1 )

   nCount            := getSQLDatabase():getValue( cSQLSentence )

RETURN ( hb_isnumeric( nCount ) .AND. nCount <> 0 )



static FUNCTION SQLParentValidator_numeroDocumento( value ) ; local Self AS CLASS SQLParentValidator := QSelf() AS CLASS SQLParentValidator

   local nAt
   local cSerie   := ""
   local nNumero

   value          := alltrim( value )

   nAt            := rat( "/", value )
   if nAt <> 0
      nNumero     := substr( value, nAt + 1 )
      cSerie      := substr( value, 1, nAt  )
   else
      nNumero     := value
   end

   if !hb_regexlike( "^[0-9]{1,6}$", nNumero )
      RETURN ( .F. )
   end

RETURN ( .T. )
