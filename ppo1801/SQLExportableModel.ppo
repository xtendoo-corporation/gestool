#line 91 "\fwh1801\include\fivewin.ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 6 ".\Prg\Models\SQLExportableModel.prg"
_HB_CLASS SQLExportableModel ; function SQLExportableModel ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "SQLExportableModel", iif( .T., { @SQLBaseModel() }, { @HBObject() } ), @SQLExportableModel() ) ) ;

   _HB_MEMBER { aFetch } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aFetch"}, .F. )

   _HB_MEMBER { cJsonFileToExport } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cJsonFileToExport"}, .F. )

   _HB_MEMBER { cJsonFileToImport } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cJsonFileToImport"}, .F. )

   _HB_MEMBER setJsonFileToExport(); oClass:AddInline( "setJsonFileToExport", {|Self, cFile | ( ( Self ) ), ( ::cJsonFileToExport := cFile ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER getJsonFileToExport(); oClass:AddInline( "getJsonFileToExport", {|Self | ( ( Self ) ), ( iif(  empty( ::cJsonFileToExport ), cpatout() + ::cTableName + ".json", ::cJsonFileToExport ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER setJsonFileToImport(); oClass:AddInline( "setJsonFileToImport", {|Self, cFile | ( ( Self ) ), ( ::cJsonFileToImport := cFile ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER getJsonFileToImport(); oClass:AddInline( "getJsonFileToImport", {|Self | ( ( Self ) ), ( iif(  empty( ::cJsonFileToImport ), cpatin() + ::cTableName + ".json", ::cJsonFileToImport ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER getSentenceNotSent(); oClass:AddMethod( "getSentenceNotSent", @SQLExportableModel_getSentenceNotSent(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER selectNotSentToJson( cFile); oClass:AddMethod( "selectNotSentToJson", @SQLExportableModel_selectNotSentToJson(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER selectFetchToHash( cSentence); oClass:AddMethod( "selectFetchToHash", @SQLExportableModel_selectFetchToHash(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER saveToJson( cFile); oClass:AddMethod( "saveToJson", @SQLExportableModel_saveToJson(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER selectFetchToJson( cSentence, cFile); oClass:AddMethod( "selectFetchToJson", @SQLExportableModel_selectFetchToJson(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER isInsertOrUpdateFromJson( cFile); oClass:AddMethod( "isInsertOrUpdateFromJson", @SQLExportableModel_isInsertOrUpdateFromJson(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getSentenceSentFromFetch(); oClass:AddMethod( "getSentenceSentFromFetch", @SQLExportableModel_getSentenceSentFromFetch(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getSentenceSenderFromIds( aIds, uValue); oClass:AddMethod( "getSentenceSenderFromIds", @SQLExportableModel_getSentenceSenderFromIds(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getSentenceSentFromIds(); oClass:AddInline( "getSentenceSentFromIds", {|Self, aIds | ( ( Self ) ), ( ::getSentenceSenderFromIds( aIds, toSQLString( hb_datetime() ) ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getSentenceNotSentFromIds(); oClass:AddInline( "getSentenceNotSentFromIds", {|Self, aIds | ( ( Self ) ), ( ::getSentenceSenderFromIds( aIds, "null" ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS SQLExportableModel ;



static FUNCTION SQLExportableModel_getSentenceNotSent( ) ; local Self AS CLASS SQLExportableModel := QSelf() AS CLASS SQLExportableModel

   local cSentence   := "SELECT * FROM " + ::cTableName + " "

   cSentence         +=    "WHERE empresa = " + quoted( cCodEmp() ) + " "

   cSentence         +=       "AND ( ( enviado IS NULL ) OR (enviado = '0000-00-00 00:00:00') )"

RETURN ( cSentence )



static FUNCTION SQLExportableModel_selectNotSentToJson( cFile ) ; local Self AS CLASS SQLExportableModel := QSelf() AS CLASS SQLExportableModel

   local cSentence   := ::getSentenceNotSent()

RETURN ( ::selectFetchToJson( cSentence, cFile ) )



static FUNCTION SQLExportableModel_selectFetchToHash( cSentence ) ; local Self AS CLASS SQLExportableModel := QSelf() AS CLASS SQLExportableModel

   ::fireEvent( "selectingFetchToHash" )

   ::aFetch          := ::getDatabase():selectFetchHash( cSentence, .F. )

   ::fireEvent( "selectedFetchToHash" )

RETURN ( ::aFetch )



static FUNCTION SQLExportableModel_saveToJson( cFile ) ; local Self AS CLASS SQLExportableModel := QSelf() AS CLASS SQLExportableModel

   If( cFile == nil, cFile := ::getJsonFileToExport(), ) ;

   ::fireEvent( "savingToJson" )

   if hb_memowrit( cFile, hb_jsonencode( ::aFetch, .T. ) )
      RETURN ( .T. )
   end

   ::fireEvent( "savedToJson" )

RETURN ( .F. )



static FUNCTION SQLExportableModel_selectFetchToJson( cSentence, cFile ) ; local Self AS CLASS SQLExportableModel := QSelf() AS CLASS SQLExportableModel

   ::selectFetchToHash( cSentence, .F. )

   if !hb_isarray( ::aFetch )
      RETURN ( .F. )
   end

   ::saveToJson( cFile )

RETURN ( .F. )



static FUNCTION SQLExportableModel_isInsertOrUpdateFromJson( cFile ) ; local Self AS CLASS SQLExportableModel := QSelf() AS CLASS SQLExportableModel

   local cJson
   local aJson
   local hBuffer

   If( cFile == nil, cFile := ::getJsonFileToImport(), ) ;

   if !file( cFile )
      RETURN ( .F. )
   end

   cJson             := memoread( cFile )

   if empty( cJson )
      RETURN ( .F. )
   end

   hb_jsondecode( cJson, @aJson )

   if !hb_isarray( aJson )
      RETURN ( .F. )
   end

   for each hBuffer in aJson
      ::insertOnDuplicate( hBuffer )
   next

RETURN ( .T. )



static FUNCTION SQLExportableModel_getSentenceSentFromFetch( aFetch ) ; local Self AS CLASS SQLExportableModel := QSelf() AS CLASS SQLExportableModel

   local cSentence

   If( aFetch == nil, aFetch := ::aFetch, ) ;

   if empty( aFetch )
      RETURN ( nil )
   end

   cSentence         := "UPDATE " + ::cTableName + " SET "

   cSentence         +=    "enviado = " + toSQLString( hb_datetime() ) + " "

   cSentence         += "WHERE uuid IN ( "

   aeval( aFetch, {| h | cSentence += quoted( hget( h, "uuid" ) ) + ", " } )

   cSentence         := chgAtEnd( cSentence, " )", 2 )

RETURN ( cSentence )



static FUNCTION SQLExportableModel_getSentenceSenderFromIds( aIds, uValue ) ; local Self AS CLASS SQLExportableModel := QSelf() AS CLASS SQLExportableModel

   local cSentence

   if empty( aIds )
      RETURN ( nil )
   end

   cSentence         := "UPDATE " + ::cTableName + " SET "

   cSentence         +=    "enviado = " + ( uValue ) + " "

   cSentence         += "WHERE id IN ( "

   aeval( aIds, {| id | cSentence += quoted( id ) + ", " } )

   cSentence         := chgAtEnd( cSentence, " )", 2 )

RETURN ( cSentence )
