#line 91 "\fwh1801\include\fivewin.ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 7 ".\Prg\Models\SQLMovimientosAlmacenModel.prg"
_HB_CLASS SQLMovimientosAlmacenModel ; function SQLMovimientosAlmacenModel ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "SQLMovimientosAlmacenModel", iif( .T., { @SQLExportableModel() }, { @HBObject() } ), @SQLMovimientosAlmacenModel() ) ) ;

   _HB_MEMBER { cTableName } ; oClass:AddMultiData(, "movimientos_almacen", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cTableName"}, .F. )

   _HB_MEMBER { cConstraints } ; oClass:AddMultiData(, "PRIMARY KEY (id), KEY (uuid, empresa_codigo, usuario_codigo)", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cConstraints"}, .F. )

   _HB_MEMBER { aTextoMovimiento } ; oClass:AddMultiData(, { "Entre almacenes", "Regularización", "Objetivos", "Consolidación", "Vacio" }, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aTextoMovimiento"}, .F. )

   _HB_MEMBER getColumns(); oClass:AddMethod( "getColumns", @SQLMovimientosAlmacenModel_getColumns(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getColumnMovimiento(); oClass:AddMethod( "getColumnMovimiento", @SQLMovimientosAlmacenModel_getColumnMovimiento(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getInitialSelect(); oClass:AddMethod( "getInitialSelect", @SQLMovimientosAlmacenModel_getInitialSelect(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getGroupBy(); oClass:AddInline( "getGroupBy", {|Self | ( ( Self ) ), ( "GROUP BY movimientos_almacen.id " ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getDeleteSentenceById( aId); oClass:AddMethod( "getDeleteSentenceById", @SQLMovimientosAlmacenModel_getDeleteSentenceById(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER loadDuplicateBuffer( id); oClass:AddMethod( "loadDuplicateBuffer", @SQLMovimientosAlmacenModel_loadDuplicateBuffer(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getInsertSentence( hBuffer); oClass:AddMethod( "getInsertSentence", @SQLMovimientosAlmacenModel_getInsertSentence(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER assingNumber(); oClass:AddMethod( "assingNumber", @SQLMovimientosAlmacenModel_assingNumber(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER cTextoMovimiento(); oClass:AddInline( "cTextoMovimiento", {|Self, nTipoMovimiento | ( ( Self ) ), ( ::aTextoMovimiento[ Min( Max( nTipoMovimiento, 1 ), len( ::aTextoMovimiento ) ) ] ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getListToSend(); oClass:AddMethod( "getListToSend", @SQLMovimientosAlmacenModel_getListToSend(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getListUuidsToSend(); oClass:AddMethod( "getListUuidsToSend", @SQLMovimientosAlmacenModel_getListUuidsToSend(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER updateMarcaEnvio( aUuids); oClass:AddMethod( "updateMarcaEnvio", @SQLMovimientosAlmacenModel_updateMarcaEnvio(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Syncronize(); oClass:AddMethod( "Syncronize", @SQLMovimientosAlmacenModel_Syncronize(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER prepareFromInsertBuffer(); oClass:AddMethod( "prepareFromInsertBuffer", @SQLMovimientosAlmacenModel_prepareFromInsertBuffer(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER RecalcularPreciosLineas(); oClass:AddMethod( "RecalcularPreciosLineas", @SQLMovimientosAlmacenModel_RecalcularPreciosLineas(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ValidaDocumento(); oClass:AddMethod( "ValidaDocumento", @SQLMovimientosAlmacenModel_ValidaDocumento(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SeederToADS(); oClass:AddMethod( "SeederToADS", @SQLMovimientosAlmacenModel_SeederToADS(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS SQLMovimientosAlmacenModel ;



static FUNCTION SQLMovimientosAlmacenModel_getColumns( ) ; local Self AS CLASS SQLMovimientosAlmacenModel := QSelf() AS CLASS SQLMovimientosAlmacenModel


   hset( ::hColumns, "id",                {  "create"    => "INTEGER AUTO_INCREMENT UNIQUE"           , "default"   => {|| 0 } }                                 )


   hset( ::hColumns, "uuid",              {  "create"    => "VARCHAR(40) NOT NULL UNIQUE"             , "default"   => {|| win_uuidcreatestring() } }            )

   ::getEmpresaColumns()


   hset( ::hColumns, "empresa",           {  "create"    => "VARCHAR( 4 )"                            , "default"   => {|| space( 4 ) } }                        )


   hset( ::hColumns, "numero",            {  "create"    => "CHAR ( 50 )"                             , "default"   => {|| MovimientosAlmacenRepository():getNextNumber() } }                       )


   hset( ::hColumns, "fecha_hora",        {  "create"    => "DATETIME DEFAULT CURRENT_TIMESTAMP"      , "default"   => {|| hb_datetime() } }                     )


   hset( ::hColumns, "tipo_movimiento",   {  "create"    => "TINYINT UNSIGNED NOT NULL"               , "default"   => {|| 1 } }                                 )


   hset( ::hColumns, "almacen_origen",    {  "create"    => "CHAR ( 16 )"                             , "default"   => {|| space( 16 ) } }                       )


   hset( ::hColumns, "almacen_destino",   {  "create"    => "CHAR ( 16 )"                             , "default"   => {|| space( 16 ) } }                       )


   hset( ::hColumns, "divisa",            {  "create"    => "CHAR ( 3 )"                              , "default"   => {|| cDivEmp() } }                         )


   hset( ::hColumns, "divisa_cambio",     {  "create"    => "DECIMAL( 16, 6 )"                        , "default"   => {|| 1 } }                                 )


   hset( ::hColumns, "comentarios",       {  "create"    => "TEXT"                                    , "default"   => {|| "" } }                                )


   hset( ::hColumns, "validado",          {  "create"    => "TINYINT ( 1 )"                           , "default"   => {|| "0" } }                               )

   ::getDateTimeColumns()

   ::getTimeStampSentColumns()

RETURN ( ::hColumns )



static FUNCTION SQLMovimientosAlmacenModel_getInitialSelect( ) ; local Self AS CLASS SQLMovimientosAlmacenModel := QSelf() AS CLASS SQLMovimientosAlmacenModel

   local cSelect





















   cSelect  := "SELECT "                                                                  +  "movimientos_almacen.id                         AS id, "                +  "movimientos_almacen.uuid                       AS uuid, "              +  "movimientos_almacen.numero                     AS numero, "            +  "movimientos_almacen.tipo_movimiento            AS tipo_movimiento, "   +  ::getColumnMovimiento( "movimientos_almacen" )                          +  "movimientos_almacen.fecha_hora                 AS fecha_hora, "        +  "movimientos_almacen.almacen_origen             AS almacen_origen, "    +  "movimientos_almacen.almacen_destino            AS almacen_destino, "   +  SQLMovimientosAlmacenLineasModel():getSQLSubSentenceSumatorioTotalPrecioLinea( "movimientos_almacen_lineas" ) + ", " + SQLMovimientosAlmacenLineasModel():getSQLSumatorioTotalVentaLinea( "movimientos_almacen_lineas" ) + ", " + "movimientos_almacen.divisa                     AS divisa, "            +  "movimientos_almacen.divisa_cambio              AS divisa_cambio, "     +  "movimientos_almacen.comentarios                AS comentarios, "       +  "movimientos_almacen.creado                     AS creado, "            +  "movimientos_almacen.modificado                 AS modificado, "        +  "movimientos_almacen.enviado                    AS enviado, "           +  "movimientos_almacen.validado                   AS validado "           +  "FROM " + ::getTableName() + " "                                           +  "LEFT JOIN movimientos_almacen_lineas "                                 +  "ON movimientos_almacen.uuid = movimientos_almacen_lineas.parent_uuid "

RETURN ( cSelect )



static FUNCTION SQLMovimientosAlmacenModel_getColumnMovimiento( cTable ) ; local Self AS CLASS SQLMovimientosAlmacenModel := QSelf() AS CLASS SQLMovimientosAlmacenModel

   local cSql

   If( cTable == nil, cTable := "", ) ;

   if !empty( cTable )
      cTable      += "."
   end

   cSql           := "CASE "
   cSql           +=    "WHEN " + cTable + "tipo_movimiento = 1 THEN '" + ::aTextoMovimiento[ 1 ] + "'"
   cSql           +=    "WHEN " + cTable + "tipo_movimiento = 2 THEN '" + ::aTextoMovimiento[ 2 ] + "'"
   cSql           +=    "WHEN " + cTable + "tipo_movimiento = 3 THEN '" + ::aTextoMovimiento[ 3 ] + "'"
   cSql           +=    "WHEN " + cTable + "tipo_movimiento = 4 THEN '" + ::aTextoMovimiento[ 4 ] + "'"
   cSql           +=    "ELSE '"                                        + ::aTextoMovimiento[ 5 ] + "'"
   cSql           += "END as nombre_movimiento, "

RETURN ( cSql )



static FUNCTION SQLMovimientosAlmacenModel_getDeleteSentenceById( aIds, aUuids ) ; local Self AS CLASS SQLMovimientosAlmacenModel := QSelf() AS CLASS SQLMovimientosAlmacenModel

   local aSQLDelete        := {}
   local aUuidLineasToDelete
   local aUuidSeriesToDelete

   aadd( aSQLDelete, ::Super:getDeleteSentenceById( aIds ) )

   aUuidLineasToDelete     := SQLMovimientosAlmacenLineasModel():aUuidToDelete( aUuids )

   if empty( aUuidLineasToDelete )
      RETURN ( aSQLDelete )
   end

   aadd( aSQLDelete, SQLMovimientosAlmacenLineasModel():getDeleteSentenceByUuid( aUuidLineasToDelete ) )

   aUuidSeriesToDelete     := SQLMovimientosAlmacenLineasNumerosSeriesModel():aUuidToDelete( aUuidLineasToDelete )

   if empty( aUuidSeriesToDelete )
      RETURN ( aSQLDelete )
   end

   aadd( aSQLDelete, SQLMovimientosAlmacenLineasNumerosSeriesModel():getDeleteSentenceByUuid( aUuidSeriesToDelete ) )

RETURN ( aSQLDelete )



static FUNCTION SQLMovimientosAlmacenModel_loadDuplicateBuffer( id, uuid ) ; local Self AS CLASS SQLMovimientosAlmacenModel := QSelf() AS CLASS SQLMovimientosAlmacenModel

   ::Super:loadDuplicateBuffer( id, uuid )

   hset( ::hBuffer, "numero", MovimientosAlmacenRepository():getNextNumber() )

   hset( ::hBuffer, "fecha_hora", hb_datetime() )

   hset( ::hBuffer, "validado", 0 )

   SQLMovimientosAlmacenLineasModel():duplicateByUuid( uuid, hget( ::hBuffer, "uuid" ) )

RETURN ( ::hBuffer )



static FUNCTION SQLMovimientosAlmacenModel_getInsertSentence( hBuffer ) ; local Self AS CLASS SQLMovimientosAlmacenModel := QSelf() AS CLASS SQLMovimientosAlmacenModel

   If( hBuffer == nil, hBuffer := ::hBuffer, ) ;

   ::assingNumber( hBuffer )

   ::Super:getInsertSentence( hBuffer )

RETURN ( .T. )



static FUNCTION SQLMovimientosAlmacenModel_assingNumber( hBuffer ) ; local Self AS CLASS SQLMovimientosAlmacenModel := QSelf() AS CLASS SQLMovimientosAlmacenModel

   local cNumero     := hget( hBuffer, "numero" )

   if empty( cNumero )
      RETURN ( .F. )
   end

   while !empty( MovimientosAlmacenRepository():getIdByNumber( cNumero ) )
      cNumero        := nextDocumentNumber( cNumero )
   end

   hset( hBuffer, "numero", cNumero )

RETURN ( .T. )



static FUNCTION SQLMovimientosAlmacenModel_getListToSend( ) ; local Self AS CLASS SQLMovimientosAlmacenModel := QSelf() AS CLASS SQLMovimientosAlmacenModel




   local cSql  := "SELECT * "                   +  "FROM " + ::getTableName() + Space(1) +  "WHERE empresa_codigo = " + quoted( cCodEmp() ) + " AND " +  "( ( enviado IS NULL ) OR (enviado = '0000-00-00 00:00:00') )"

RETURN ( ::getDatabase():selectFetchToJson( cSql ) )



static FUNCTION SQLMovimientosAlmacenModel_prepareFromInsertBuffer( hBuffer ) ; local Self AS CLASS SQLMovimientosAlmacenModel := QSelf() AS CLASS SQLMovimientosAlmacenModel

   hSet( hBuffer, "empresa_codigo", cCodEmp() )
   hSet( hBuffer, "fecha_hora", hb_SToT( hGet( hBuffer, "fecha_hora" ) ) )
   hDel( hBuffer, "creado" )
   hDel( hBuffer, "modificado" )
   hDel( hBuffer, "enviado" )

Return ( hBuffer )



static FUNCTION SQLMovimientosAlmacenModel_getListUuidsToSend( ) ; local Self AS CLASS SQLMovimientosAlmacenModel := QSelf() AS CLASS SQLMovimientosAlmacenModel




   local cSql  := "SELECT UUID "                   +  "FROM " + ::getTableName() + Space(1) +  "WHERE empresa_codigo = " + quoted( cCodEmp() ) + " AND " +  "( ( enviado IS NULL ) OR (enviado = '0000-00-00 00:00:00') )"

RETURN ( ::getDatabase():selectFetchArrayOneColumn( cSql ) )



static FUNCTION SQLMovimientosAlmacenModel_updateMarcaEnvio( aUuids ) ; local Self AS CLASS SQLMovimientosAlmacenModel := QSelf() AS CLASS SQLMovimientosAlmacenModel

   local cSentence   := ""

   cSentence         := "UPDATE " + ::getTableName() + " SET "

   cSentence         +=    "enviado = " + toSQLString( hb_datetime() ) + " "

   cSentence         += "WHERE uuid IN ( "

   aeval( aUuids, {| h | cSentence += quoted( h ) + ", " } )

   cSentence         := chgAtEnd( cSentence, " )", 2 )

   ::getDatabase():Exec( cSentence )

RETURN ( nil )



static FUNCTION SQLMovimientosAlmacenModel_RecalcularPreciosLineas( ) ; local Self AS CLASS SQLMovimientosAlmacenModel := QSelf() AS CLASS SQLMovimientosAlmacenModel

   local cSql                    := "select * FROM movimientos_almacen_lineas WHERE movimientos_almacen_lineas.parent_uuid = " + quoted( ::hBuffer[ "uuid" ] )
   local aLineas
   local hLine

   aLineas                 := ::getDatabase():selectFetchHash( cSql )

   for each hLine in aLineas

      SQLMovimientosAlmacenLineasModel():updatePrecioVenta( hget( hLine, "uuid" ), ArticulosModel():getField( "pVtaIva1", "Codigo", hget( hLine, "codigo_articulo" ) ) )

   next

RETURN ( nil )



static FUNCTION SQLMovimientosAlmacenModel_ValidaDocumento( ) ; local Self AS CLASS SQLMovimientosAlmacenModel := QSelf() AS CLASS SQLMovimientosAlmacenModel

   if ::hBuffer[ "validado" ] == 1
      MsgStop( "Documento validado." )
      return .T.
   end

   if ::hBuffer[ "tipo_movimiento" ] <> 4
      MsgStop( "Sólo de validan las consolidaciones." )
      return .T.
   end

   ::hBuffer[ "validado" ] := 1

RETURN ( nil )



static FUNCTION SQLMovimientosAlmacenModel_SeederToADS( ) ; local Self AS CLASS SQLMovimientosAlmacenModel := QSelf() AS CLASS SQLMovimientosAlmacenModel



   local cSql  := "SELECT * "                   +  "FROM " + ::getTableName() + Space(1) +  "WHERE empresa_codigo = " + quoted( cCodEmp() )

RETURN ( getSQLDataBase():selectFetchHash( cSql ) )





static FUNCTION SQLMovimientosAlmacenModel_Syncronize( ) ; local Self AS CLASS SQLMovimientosAlmacenModel := QSelf() AS CLASS SQLMovimientosAlmacenModel

   local cSql

   cSql                    := "UPDATE " + ::cTableName + " "
   cSql                    += "SET " + ::cTableName + ".empresa_codigo = " + ::cTableName + ".empresa "
   cSql                    += "WHERE " + ::cTableName + ".empresa_codigo = ''"

   getSQLDatabase():Exec( cSql )

RETURN ( .T. )



FUNCTION getValorMovimientosAlmacen( id, uuid, cField )

   local uValue      := ""

   if !Empty( id )
      uValue         := SQLMovimientosAlmacenModel():getField( cField, "id", id )
   end

   if !Empty( uuid )
      uValue         := SQLMovimientosAlmacenModel():getField( cField, "uuid", uuid )
   end

RETURN ( uValue )
