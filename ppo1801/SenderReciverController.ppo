#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 6 ".\Prg\Controllers\SenderReciverController.prg"
_HB_CLASS SenderReciverController ; function SenderReciverController ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "SenderReciverController", iif( .T., { @TSenderReciverItem() }, { @HBObject() } ), @SenderReciverController() ) ) ;

   _HB_MEMBER { oController } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oController"}, .F. )

   _HB_MEMBER { aUuidParent } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aUuidParent"}, .F. )

   _HB_MEMBER New(); oClass:AddMethod( "New", @SenderReciverController_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER End(); oClass:AddInline( "End", {|Self | ( ( Self ) ), ( Self ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER CreateData(); oClass:AddMethod( "CreateData", @SenderReciverController_CreateData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER RestoreData(); oClass:AddMethod( "RestoreData", @SenderReciverController_RestoreData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SendData(); oClass:AddMethod( "SendData", @SenderReciverController_SendData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ReciveData(); oClass:AddMethod( "ReciveData", @SenderReciverController_ReciveData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Process(); oClass:AddMethod( "Process", @SenderReciverController_Process(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER cTitle(); oClass:AddInline( "cTitle", {|Self | ( ( Self ) ), ( lower( ::oController:cTitle ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ProcesaCabecera( cFile); oClass:AddMethod( "ProcesaCabecera", @SenderReciverController_ProcesaCabecera(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ProcesaLineas( cFileLine); oClass:AddMethod( "ProcesaLineas", @SenderReciverController_ProcesaLineas(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ActualizaStock( hBuffer); oClass:AddMethod( "ActualizaStock", @SenderReciverController_ActualizaStock(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER RollbackStock( hBuffer); oClass:AddMethod( "RollbackStock", @SenderReciverController_RollbackStock(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS SenderReciverController ;



static FUNCTION SenderReciverController_New( oController ) ; local Self AS CLASS SenderReciverController := QSelf() AS CLASS SenderReciverController

   ::oController                 := oController

   ::super:new( ::oController:cTitle )

RETURN ( Self )



static FUNCTION SenderReciverController_CreateData( ) ; local Self AS CLASS SenderReciverController := QSelf() AS CLASS SenderReciverController

   local lSnd        := .T.
   local cFileName
   local cFile
   local cJson

   if ::oSender:lServer

      cFileName      := ::oController:cOldName + StrZero( ::nGetNumberToSend(), 6 ) + ".All"





      ::oSender:SetText( "Enviando " + ::cTitle() )

      cJson          := ::oController:oModel:getListToSend()
      ::aUuidParent  := ::oController:oModel:getListUuidsToSend()

      cFile          := cPatSnd() + ::oController:cName + ".json"

      ::oSender:SetText( "Exportando fichero json " + alltrim( cFile ) )

      if !MemoWrit( cFile, cJson )
         lSnd        := .F.
         ::oSender:SetText( "Error al escribir el fichero " + alltrim( cFile ) )
      end





      if !Empty( ::oController:oLineasController ) .AND. len( ::aUuidParent ) > 0

         ::oSender:SetText( "Enviando " + lower( ::oController:oLineasController:cTitle ) )

         cJson          := ::oController:oLineasController:oModel:getListToSend( ::aUuidParent )

         cFile          := cPatSnd() + ::oController:oLineasController:cName + ".json"

         ::oSender:SetText( "Exportando fichero json " + alltrim( cFile ) )

         if !MemoWrit( cFile, cJson )
            lSnd        := .F.
            ::oSender:SetText( "Error al escribir el fichero " + alltrim( cFile ) )
         end

      end





      if lSnd

         ::oSender:SetText( "Comprimiendo " + ::cTitle() )

         if ::oSender:lZipData( cFileName )
            ::oSender:SetText( "Ficheros comprimidos en " + Rtrim( cFileName ) )
         else
            ::oSender:SetText( "ERROR al crear fichero comprimido" )
         end

      else

         ::oSender:SetText( "No hay " + ::cTitle() + " para enviar" )

      end

   end

RETURN ( Self )



static FUNCTION SenderReciverController_SendData( ) ; local Self AS CLASS SenderReciverController := QSelf() AS CLASS SenderReciverController

   local cFileName

   if ::oSender:lServer
      cFileName         := ::oController:cOldName + StrZero( ::nGetNumberToSend(), 6 ) + ".All"
   else
      cFileName         := ::oController:cOldName + StrZero( ::nGetNumberToSend(), 6 ) + "." + RetSufEmp()
   end





   if !file( cPatOut() + cFileName )
      ::oSender:SetText( "El fichero " + cPatOut() + cFileName + " no existe" )
      RETURN ( Self )
   end

   if ::oSender:SendFiles( cPatOut() + cFileName, cFileName )
      ::IncNumberToSend()
      ::lSuccesfullSend := .T.
      ::oSender:SetText( "Fichero enviado " + cFileName )
   else
      ::oSender:SetText( "ERROR al enviar fichero" + cFileName )
   end

RETURN ( Self )



static FUNCTION SenderReciverController_RestoreData( ) ; local Self AS CLASS SenderReciverController := QSelf() AS CLASS SenderReciverController

   if len( ::aUuidParent ) > 0
      ::oController:oModel:updateMarcaEnvio( ::aUuidParent )
   end

RETURN ( Self )



static FUNCTION SenderReciverController_ReciveData( ) ; local Self AS CLASS SenderReciverController := QSelf() AS CLASS SenderReciverController

   local n
   local aExt

   aExt     := ::oSender:aExtensions()





   ::oSender:SetText( "Recibiendo " + ::cTitle() )

   for n := 1 to len( aExt )
      ::oSender:GetFiles( ::oController:cOldName + "*." + aExt[ n ], cPatIn() )
   next

   ::oSender:SetText( ::oController:cTitle + " recibidos" )

RETURN ( Self )



static FUNCTION SenderReciverController_Process( ) ; local Self AS CLASS SenderReciverController := QSelf() AS CLASS SenderReciverController

   local m
   local oError
   local oBlock
   local aFiles            := directory( cPatIn() + ::oController:cOldName + "*.*" )
   local cFile             := cPatSnd() + ::oController:cName + ".json"
   local cFileLine         := cPatSnd() + ::oController:oLineasController:cName + ".json"

   for m := 1 to len( aFiles )

      ::oSender:SetText( "Procesando fichero : " + aFiles[ m, 1 ] )

      oBlock               := ErrorBlock( { | oError | ApoloBreak( oError ) } )
      BEGIN SEQUENCE

         if ::oSender:lUnZipData( cPatIn() + aFiles[ m, 1 ], .F. )

            if File( cFile ) .AND. File( cFileLine )

               ::ProcesaCabecera( cFile )

               ::ProcesaLineas( cFileLine )

               ::oSender:appendFileRecive( aFiles[ m, 1 ] )

            else

               ::oSender:SetText( "Faltan ficheros json para poder importar" )

            end

         else

            ::oSender:SetText( "Error al descomprimir los ficheros" )

         end

      RECOVER USING oError

         ::oSender:SetText( "Error procesando fichero " + aFiles[ m, 1 ] )
         ::oSender:SetText( ErrorMessage( oError ) )

      end
      ErrorBlock( oBlock )

   next

RETURN ( Self )



static FUNCTION SenderReciverController_ProcesaCabecera( cFile ) ; local Self AS CLASS SenderReciverController := QSelf() AS CLASS SenderReciverController

   local cJson
   local aJson
   local hBuffer

   cJson             := memoread( cFile )

   if empty( cJson )
      ::oSender:SetText( "Error procesando fichero " + cFile )
      RETURN ( self )
   end

   hb_jsondecode( cJson, @aJson )

   if !hb_isarray( aJson )
      RETURN ( .F. )
   end

   for each hBuffer in aJson

      if AllTrim( Application():codigoAlmacen() ) <> AllTrim( hGet( hBuffer, "almacen_destino" ) ) .AND. AllTrim( Application():codigoAlmacen() ) <> AllTrim( hGet( hBuffer, "almacen_origen" ) )

         ::oSender:SetText( "Movimiento nº " + AllTrim( hGet( hBuffer, "numero" ) ) + " desestimado por no coincidir el almacén " + cFile )

      else

         ::oController:oModel:InSertOrUpdateFromUuid( ::oController:oModel:prepareFromInsertBuffer( hBuffer ) )

      end

   next

RETURN ( Self )



static FUNCTION SenderReciverController_ProcesaLineas( cFileLine ) ; local Self AS CLASS SenderReciverController := QSelf() AS CLASS SenderReciverController

   local cJson
   local aJson
   local hBuffer

   cJson             := memoread( cFileLine )

   if empty( cJson )
      ::oSender:SetText( "Error procesando fichero " + cFileLine )
      RETURN ( self )
   end

   hb_jsondecode( cJson, @aJson )

   if !hb_isarray( aJson )
      RETURN ( .F. )
   end

   for each hBuffer in aJson

      if ::oController:oModel:existeUuid( hGet( hBuffer, "parent_uuid" ) )

         ::RollbackStock( hBuffer )

         ::oController:oLineasController:oModel:InsertOrUpdateFromUuid( ::oController:oLineasController:oModel:prepareFromInsertBuffer( hBuffer ) )

         ::ActualizaStock( hBuffer )

      end

   next

RETURN ( Self )



static FUNCTION SenderReciverController_RollbackStock( hBuffer ) ; local Self AS CLASS SenderReciverController := QSelf() AS CLASS SenderReciverController

   local hStockBuffer   := {=>}
   local hParent        := {=>}
   local hLine          := {=>}

   if !::oController:oLineasController:oModel:existeUuid( hGet( hBuffer, "uuid" ) )
      Return( self )
   end

   hParent              := ::oController:oModel:getWhereUuid( hBuffer[ "parent_uuid" ] )
   hLine                := ::oController:oLineasController:oModel:getWhereUuid( hBuffer[ "uuid" ] )

   hset( hStockBuffer, "codigo_articulo", AllTrim( hLine[ "codigo_articulo" ] ) )
   hset( hStockBuffer, "codigo_almacen_entrada", AllTrim( hParent[ "almacen_destino" ] ) )
   hset( hStockBuffer, "codigo_almacen_salida", AllTrim( hParent[ "almacen_origen" ] ) )
   hset( hStockBuffer, "codigo_primera_propiedad", AllTrim( hLine[ "codigo_primera_propiedad" ] ) )
   hset( hStockBuffer, "valor_primera_propiedad", AllTrim( hLine[ "valor_primera_propiedad" ] ) )
   hset( hStockBuffer, "codigo_segunda_propiedad", AllTrim( hLine[ "codigo_segunda_propiedad" ] ) )
   hset( hStockBuffer, "valor_segunda_propiedad", AllTrim( hLine[ "valor_segunda_propiedad" ] ) )
   hset( hStockBuffer, "lote", AllTrim( hLine[ "lote" ] ) )
   hset( hStockBuffer, "bultos_articulo", hLine[ "bultos_articulo" ] )
   hset( hStockBuffer, "cajas_articulo", hLine[ "cajas_articulo" ] )
   hset( hStockBuffer, "unidades_articulo", ( NotCaja( hLine[ "cajas_articulo" ] ) * hLine[ "unidades_articulo" ] ) )
   hset( hStockBuffer, "fecha", hb_ttod( hParent[ "fecha_hora" ] ) )
   hset( hStockBuffer, "hora", substr( hb_tstostr( hParent[ "fecha_hora" ] ), 12, 8 ) )
   hset( hStockBuffer, "tipo_movimiento", hParent[ "tipo_movimiento" ] )

RETURN ( Self )



static FUNCTION SenderReciverController_ActualizaStock( hBuffer ) ; local Self AS CLASS SenderReciverController := QSelf() AS CLASS SenderReciverController

   local hStockBuffer   := {=>}
   local hParent        := ::oController:oModel:getWhereUuid( hBuffer[ "parent_uuid" ] )

   hset( hStockBuffer, "codigo_articulo", AllTrim( hBuffer[ "codigo_articulo" ] ) )
   hset( hStockBuffer, "codigo_almacen_entrada", AllTrim( hParent[ "almacen_destino" ] ) )
   hset( hStockBuffer, "codigo_almacen_salida", AllTrim( hParent[ "almacen_origen" ] ) )
   hset( hStockBuffer, "codigo_primera_propiedad", AllTrim( hBuffer[ "codigo_primera_propiedad" ] ) )
   hset( hStockBuffer, "valor_primera_propiedad", AllTrim( hBuffer[ "valor_primera_propiedad" ] ) )
   hset( hStockBuffer, "codigo_segunda_propiedad", AllTrim( hBuffer[ "codigo_segunda_propiedad" ] ) )
   hset( hStockBuffer, "valor_segunda_propiedad", AllTrim( hBuffer[ "valor_segunda_propiedad" ] ) )
   hset( hStockBuffer, "lote", AllTrim( hBuffer[ "lote" ] ) )
   hset( hStockBuffer, "bultos_articulo", hBuffer[ "bultos_articulo" ] )
   hset( hStockBuffer, "cajas_articulo", hBuffer[ "cajas_articulo" ] )
   hset( hStockBuffer, "unidades_articulo", ( NotCaja( hBuffer[ "cajas_articulo" ] ) * hBuffer[ "unidades_articulo" ] ) )
   hset( hStockBuffer, "fecha", hb_ttod( hParent[ "fecha_hora" ] ) )
   hset( hStockBuffer, "hora", substr( hb_tstostr( hParent[ "fecha_hora" ] ), 12, 8 ) )
   hset( hStockBuffer, "tipo_movimiento", hParent[ "tipo_movimiento" ] )

RETURN ( Self )
