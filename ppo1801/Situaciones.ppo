#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 5 ".\.\Prg\Situaciones.prg"
static oWndBrw
static bEdit      := { |aTmp, aGet, dbfSitua, oBrw, bWhen, bValid, nMode | EdtRec( aTmp, aGet, dbfSitua, oBrw, bWhen, bValid, nMode ) }
static dbfSitua



STATIC FUNCTION OpenFiles()

   local lOpen    := .T.
   local oBlock   := ErrorBlock( {| oError | ApoloBreak( oError ) } )

   BEGIN SEQUENCE

      if !lExistTable( cPatDat() + "SITUA.DBF" )
         mkSitua( cPatDat() )
      end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "SITUA.DBF" ), ( cCheckArea( "SITUA", @dbfSitua ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatDat() + "SITUA.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

   RECOVER

      msgStop( "Imposible abrir todas las bases de datos" )
      CloseFiles ()
      lOpen       := .F.

   end

   ErrorBlock( oBlock )

RETURN ( lOpen )



STATIC FUNCTION CloseFiles()

   if dbfSitua <> nil
      ( dbfSitua ) -> ( dbCloseArea() )
   end

   dbfSitua := nil
   oWndBrw  := nil

RETURN .T.



FUNCTION Situaciones( oMenuItem, oWnd )

   local nLevel

   If( oMenuItem == nil, oMenuItem := "situaciones", ) ;
   If( oWnd == nil, oWnd := oWnd(), ) ;

   if oWndBrw == NIL





      nLevel            := Auth():Level( oMenuItem )

      if nAnd( nLevel, 1 ) == 0
         msgStop( "Acceso no permitido." )
         return nil
      end





      if oWnd <> nil
         SysRefresh(); oWnd:CloseAll(); SysRefresh()
      end





      if !OpenFiles()
         return Nil
      end





      AddMnuNext( "Situaciones", ProcName() )













      oWndBrw := TShell():New( 2, 10, 18, 70, "Situaciones",, oWnd,,, .F.,,, ( dbfSitua ),,,,, {"Situaciones"}, {||( WinAppRec( oWndBrw:oBrw, bEdit, dbfSitua ) )}, {||( WinEdtRec( oWndBrw:oBrw, bEdit, dbfSitua ) )}, {||( WinDelRec( oWndBrw:oBrw, dbfSitua ) )}, {||( WinDupRec( oWndBrw:oBrw, bEdit, dbfSitua ) )}, nil, nLevel, "gc_document_attachment_16", ( 104 + ( 0 * 256 ) + ( 63 * 65536 ) ),,, .T. )

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Situaciones"
         :cSortOrder       := "cSitua"
         :bEditValue       := {|| ( dbfSitua )->cSitua }
         :nWidth           := 800
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      oWndBrw:cHtmlHelp    := "Situaciones"

      oWndBrw:CreateXFromCode()





      oWndBrw:NewAt( "BUS",,, {||( oWndBrw:SearchSetFocus() )}, "(B)uscar", "B",,,,, .F. )

      oWndBrw:AddSeaBar()








      oWndBrw:NewAt( "NEW",,, {||( oWndBrw:RecAdd() )}, "(A)ñadir", "A",,, 2,, .F. )







      oWndBrw:NewAt( "EDIT",,, {||( oWndBrw:RecEdit() )}, "(M)odificar", "M",,, 4,, .F. )







      oWndBrw:NewAt( "ZOOM",,, {||( WinZooRec( oWndBrw:oBrw, bEdit, dbfSitua ) )}, "(Z)oom", "Z",,, 8,, .F. )







      oWndBrw:NewAt( "DEL",,, {||( oWndBrw:RecDel() )}, "(E)liminar", "E",,, 16,, .F. )





      oWndBrw:NewAt( "END",,, {||( oWndBrw:end() )}, "(S)alir", "S",,,,, .F. )

      oWndBrw:Activate(, oWndBrw:bLClicked, oWndBrw:bRClicked, oWndBrw:bMoved, oWndBrw:bResized, oWndBrw:bPainted, oWndBrw:bKeyDown, oWndBrw:bInit,,,,,,,,, {|| ( CloseFiles() )},, oWndBrw:bLButtonUp, .F. )

   else

      oWndBrw:SetFocus()

   end

 RETURN NIL



STATIC FUNCTION EdtRec( aTmp, aGet, dbfSitua, oBrw, bWhen, bValid, nMode )

   local oDlg

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "situación", "SITUACION",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )





   aGet[ ( dbfSitua )->( FieldPos( "cSitua" ) ) ] := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ ( dbfSitua )->( FieldPos( "cSitua" ) ) ], aTmp[ ( dbfSitua )->( FieldPos( "cSitua" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





   TButton():ReDefine( 1, {||( EndTrans( aTmp, aGet, dbfSitua, oBrw, nMode, oDlg ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





   TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

   if nMode <> 3
      oDlg:AddFastKey( 116, {|| EndTrans( aTmp, aGet, dbfSitua, oBrw, nMode, oDlg ) } )
   end

   oDlg:bStart := {|| aGet[ ( dbfSitua )->( FieldPos( "cSitua" ) ) ]:SetFocus() }

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

RETURN ( oDlg:nResult == 1 )



STATIC FUNCTION EndTrans( aTmp, aGet, dbfSitua, oBrw, nMode, oDlg )



   if nMode == 1 .OR. nMode == 4
      if Existe( Upper( aTmp[ ( dbfSitua )->( FieldPos( "cSitua" ) ) ] ), dbfSitua, "cSitua" )
         msgStop( "Situación existente" )
         aGet[ ( dbfSitua )->( FieldPos( "cSitua" ) ) ]:SetFocus()
         return nil
      end
   end

   if Empty( aTmp[ ( dbfSitua )->( FieldPos( "cSitua" ) ) ] )
      MsgStop( "La situación no puede estar vacía" )
      aGet[ ( dbfSitua )->( FieldPos( "cSitua" ) ) ]:SetFocus()
      return nil
   end



   WinGather( aTmp, aGet, dbfSitua, oBrw, nMode )

RETURN ( oDlg:end( 1 ) )



Function aSituacion( dbfSitua )

   local oError
   local oBlock
   local aSitua   := {}

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      aAdd( aSitua, "" )

      ( dbfSitua )->( dbGoTop() )
      while !( dbfSitua )->( Eof() )
         aAdd( aSitua, ( dbfSitua )->cSitua )
         ( dbfSitua )->( dbSkip() )
      end

   RECOVER USING oError

      msgStop( "Imposible cargar situaciones" + Chr(13)+Chr(10) + ErrorMessage( oError )  )

   end

   ErrorBlock( oBlock )

Return aSitua



FUNCTION mkSitua( cPath, lAppend, cPathOld )

   local dbfSitua

   If( cPath == nil, cPath := cPatDat(), ) ;
   If( lAppend == nil, lAppend := .F., ) ;

   if !lExistTable( cPatDat() + "Situa.Dbf" )
      dbCreate( cPatDat() + "Situa.Dbf", { { "cSitua", "C", 30, 0 } }, cDriver() )
   end

   if lExistIndex( cPatDat() + "Situa.Cdx" )
      fErase( cPatDat() + "Situa.Cdx" )
   end

   if !lExistTable( cPath + "Situa.Dbf" )
      dbCreate( cPath + "Situa.Dbf", { { "cSitua", "C", 30, 0 } }, cDriver() )
   end

   if lExistIndex( cPath + "Situa.Cdx" )
      fErase( cPath + "Situa.Cdx" )
   end

   if lAppend .AND. lExistTable( cPathOld + "Situa.Dbf" )

      dbUseArea( .T., cDriver(), "Situa.Dbf", cCheckArea( "Situa", @dbfSitua ), .F. )
      ( dbfSitua )->( __dbApp( cPathOld + "Situa.Dbf" ) )
      ( dbfSitua )->( dbCloseArea() )

   end

   rxSitua( cPath )

RETURN .T.



FUNCTION rxSitua( cPath, oMeter )

   local dbfSitua

   If( cPath == nil, cPath := cPatDat(), ) ;

   IF !lExistTable( cPath + "SITUA.DBF" )
      dbCreate( cPath + "Situa.Dbf", { { "cSitua", "C", 30, 0 } }, cDriver() )
   end

   IF lExistIndex( cPath + "SITUA.CDX" )
      fErase( cPath + "SITUA.CDX" )
   end

   if lExistTable( cPath + "SITUA.DBF" )
      dbUseArea( .T., cDriver(), cPath + "SITUA.DBF", cCheckArea( "SITUA", @dbfSitua ), .F. )

      if !( dbfSitua )->( neterr() )
         ( dbfSitua )->( __dbPack() )

         ( dbfSitua )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
         ( dbfSitua )->( ordCreate( cPath + "SITUA.CDX", "CSITUA", "Upper( Field->cSitua )", {|| Upper( Field->cSitua ) } ) )

         ( dbfSitua )->( dbCloseArea() )
      else

         msgStop( "Imposible abrir en modo exclusivo situaciones" )

      end

   end

RETURN NIL



FUNCTION IsSitua()

   local oError
   local oBlock   := ErrorBlock( {| oError | ApoloBreak( oError ) } )

   BEGIN SEQUENCE

   if !lExistTable( cPatDat() + "SITUA.DBF" )
      mkSitua( cPatDat() )
   end

   if !lExistIndex( cPatDat() + "SITUA.CDX" )
      rxSitua( cPatDat() )
   end

   RECOVER USING oError

      msgStop( "Imposible realizar las comprobación inicial de situaciones" + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

 RETURN ( .T. )







_HB_CLASS SituacionesModel ; function SituacionesModel ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "SituacionesModel", iif( .T., { @ADSBaseModel() }, { @HBObject() } ), @SituacionesModel() ) ) ;

   _HB_MEMBER getTableName(); oClass:AddInline( "getTableName", {|Self | ( ( Self ) ), ::getDatosTableName( "Situa" ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getArrayNombres(); oClass:AddMethod( "getArrayNombres", @SituacionesModel_getArrayNombres(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS SituacionesModel ;



static FUNCTION SituacionesModel_getArrayNombres( ) ; local Self AS CLASS SituacionesModel := QSelf() AS CLASS SituacionesModel

   local cStm           := "getSituaciones"
   local cSql           := ""
   local aSituaciones   := {}

   cSql                 := "SELECT cSitua FROM " + ::getTableName()

   if ::ExecuteSqlStatement( cSql, @cStm )

      if ( ( cStm )->( ordKeyCount() ) > 0 )

         ( cStm )->( dbGoTop() )

         while !( cStm )->( Eof() )

            aAdd( aSituaciones, ( cStm )->cSitua )

            ( cStm )->( dbSkip() )

         end

      end

   end

Return ( aSituaciones )
