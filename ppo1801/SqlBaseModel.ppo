#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 8 ".\Prg\Models\SqlBaseModel.prg"
_HB_CLASS SQLBaseModel ; function SQLBaseModel ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "SQLBaseModel", iif( .F., { }, { @HBObject() } ), @SQLBaseModel() ) ) ;

   _HB_MEMBER { oDatabase } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oDatabase"}, .F. )

   _HB_MEMBER { oController } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oController"}, .F. )

   _HB_MEMBER { oEvents } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oEvents"}, .F. )

   _HB_MEMBER { oStatement } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oStatement"}, .F. )

   _HB_MEMBER { cTableName } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cTableName"}, .F. )

   _HB_MEMBER { cConstraints } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cConstraints"}, .F. )

   _HB_MEMBER { hColumns } ; oClass:AddMultiData(, {=>}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hColumns"}, .F. )

   _HB_MEMBER { cColumnOrientation } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cColumnOrientation"}, .F. )

   _HB_MEMBER { cGeneralSelect } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cGeneralSelect"}, .F. )

   _HB_MEMBER { cGeneralWhere } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cGeneralWhere"}, .F. )

   _HB_MEMBER { cFilterWhere } ; oClass:AddMultiData(, "", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cFilterWhere"}, .F. )

   _HB_MEMBER { cOthersWhere } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cOthersWhere"}, .F. )

   _HB_MEMBER { cColumnKey } ; oClass:AddMultiData(, "id", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cColumnKey"}, .F. )

   _HB_MEMBER { cColumnCode } ; oClass:AddMultiData(, "codigo", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cColumnCode"}, .F. )

   _HB_MEMBER { hBuffer } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hBuffer"}, .F. )

   _HB_MEMBER { cSQLInsert } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cSQLInsert"}, .F. )

   _HB_MEMBER { cSQLUpdate } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cSQLUpdate"}, .F. )

   _HB_MEMBER { cGroupBy } ; oClass:AddMultiData(, "", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cGroupBy"}, .F. )

   _HB_MEMBER { cOrderBy } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cOrderBy"}, .F. )

   _HB_MEMBER { cOrientation } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cOrientation"}, .F. )

   _HB_MEMBER { cFind } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cFind"}, .F. )

   _HB_MEMBER { aRecordsToDelete } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aRecordsToDelete"}, .F. )
   _HB_MEMBER { aUuidsToDelete } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aUuidsToDelete"}, .F. )

   _HB_MEMBER New(); oClass:AddMethod( "New", @SQLBaseModel_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER End(); oClass:AddMethod( "End", @SQLBaseModel_End(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER setSQLInsert(); oClass:AddInline( "setSQLInsert", {|Self, cSQLInsert | ( ( Self ) ), ( ::cSQLInsert := cSQLInsert ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getSQLInsert(); oClass:AddInline( "getSQLInsert", {|Self | ( ( Self ) ), ( ::cSQLInsert ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER setSQLUpdate(); oClass:AddInline( "setSQLUpdate", {|Self, cSQLUpdate | ( ( Self ) ), ( ::cSQLUpdate := cSQLUpdate ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getSQLUpdate(); oClass:AddInline( "getSQLUpdate", {|Self | ( ( Self ) ), ( ::cSQLUpdate ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER setAttribute( key, value); oClass:AddMethod( "setAttribute", @SQLBaseModel_setAttribute(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getAttribute( key, value); oClass:AddMethod( "getAttribute", @SQLBaseModel_getAttribute(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER setDatabase(); oClass:AddInline( "setDatabase", {|Self, oDb | ( ( Self ) ), ( ::oDatabase := oDb ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getDatabase(); oClass:AddInline( "getDatabase", {|Self | ( ( Self ) ), ( if( empty( ::oDatabase ), getSQLDatabase(), ::oDatabase ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getTableName(); oClass:AddInline( "getTableName", {|Self | ( ( Self ) ), ( ::cTableName ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER getColumns(); oClass:AddInline( "getColumns", {|Self | ( ( Self ) ), ( ::hColumns ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getTableColumns(); oClass:AddMethod( "getTableColumns", @SQLBaseModel_getTableColumns(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getEmpresaColumns(); oClass:AddMethod( "getEmpresaColumns", @SQLBaseModel_getEmpresaColumns(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getDateTimeColumns(); oClass:AddMethod( "getDateTimeColumns", @SQLBaseModel_getDateTimeColumns(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getTimeStampColumns(); oClass:AddMethod( "getTimeStampColumns", @SQLBaseModel_getTimeStampColumns(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getTimeStampSentColumns(); oClass:AddMethod( "getTimeStampSentColumns", @SQLBaseModel_getTimeStampSentColumns(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getSerializeColumns(); oClass:AddMethod( "getSerializeColumns", @SQLBaseModel_getSerializeColumns(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getColumnsForBrowse(); oClass:AddMethod( "getColumnsForBrowse", @SQLBaseModel_getColumnsForBrowse(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getHeadersForBrowse(); oClass:AddMethod( "getHeadersForBrowse", @SQLBaseModel_getHeadersForBrowse(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getValueFromColumn( cColumn, cKey); oClass:AddMethod( "getValueFromColumn", @SQLBaseModel_getValueFromColumn(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getHeaderFromColumn(); oClass:AddInline( "getHeaderFromColumn", {|Self, cColumn | ( ( Self ) ), ( ::getValueFromColumn( cColumn, "header" ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getHeaderFromColumnOrder(); oClass:AddInline( "getHeaderFromColumnOrder", {|Self | ( ( Self ) ), ( ::getValueFromColumn( ::cColumnOrder, "header" ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getLenFromColumn(); oClass:AddInline( "getLenFromColumn", {|Self, cColumn | ( ( Self ) ), ( ::getValueFromColumn( cColumn, "len" ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER getCreateTableSentence(); oClass:AddMethod( "getCreateTableSentence", @SQLBaseModel_getCreateTableSentence(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getAlterTableSentences(); oClass:AddMethod( "getAlterTableSentences", @SQLBaseModel_getAlterTableSentences(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getGeneralSelect(); oClass:AddMethod( "getGeneralSelect", @SQLBaseModel_getGeneralSelect(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getInitialSelect(); oClass:AddInline( "getInitialSelect", {|Self | ( ( Self ) ), ( "SELECT * FROM " + ::getTableName() ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getField( cField, cBy, cId); oClass:AddMethod( "getField", @SQLBaseModel_getField(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getHash( cField, cBy, cId); oClass:AddMethod( "getHash", @SQLBaseModel_getHash(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getIdSelect( id); oClass:AddMethod( "getIdSelect", @SQLBaseModel_getIdSelect(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getWhereSelect( cWhere); oClass:AddMethod( "getWhereSelect", @SQLBaseModel_getWhereSelect(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getSelectSentence(); oClass:AddMethod( "getSelectSentence", @SQLBaseModel_getSelectSentence(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER setCreatedTimeStamp( hBuffer); oClass:AddMethod( "setCreatedTimeStamp", @SQLBaseModel_setCreatedTimeStamp(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER setUpdatedTimeStamp( hBuffer); oClass:AddMethod( "setUpdatedTimeStamp", @SQLBaseModel_setUpdatedTimeStamp(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getInsertSentence(); oClass:AddMethod( "getInsertSentence", @SQLBaseModel_getInsertSentence(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getInsertIgnoreSentence(); oClass:AddInline( "getInsertIgnoreSentence", {|Self, hBuffer | ( ( Self ) ), ( ::getInsertSentence( hBuffer, .T. ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getUpdateSentence(); oClass:AddMethod( "getUpdateSentence", @SQLBaseModel_getUpdateSentence(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getInsertOnDuplicateSentence( hBuffer); oClass:AddMethod( "getInsertOnDuplicateSentence", @SQLBaseModel_getInsertOnDuplicateSentence(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getdeleteSentenceByUuid( aUuid); oClass:AddMethod( "getdeleteSentenceByUuid", @SQLBaseModel_getdeleteSentenceByUuid(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getDeleteSentenceById( aId); oClass:AddMethod( "getDeleteSentenceById", @SQLBaseModel_getDeleteSentenceById(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getDeleteSentenceWhereParentUuid( uUuid); oClass:AddMethod( "getDeleteSentenceWhereParentUuid", @SQLBaseModel_getDeleteSentenceWhereParentUuid(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER aUuidToDelete(); oClass:AddMethod( "aUuidToDelete", @SQLBaseModel_aUuidToDelete(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getDropTableSentence(); oClass:AddMethod( "getDropTableSentence", @SQLBaseModel_getDropTableSentence(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER setGeneralSelect(); oClass:AddInline( "setGeneralSelect", {|Self, cSelect | ( ( Self ) ), ( ::cGeneralSelect  := cSelect ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER setGeneralWhere(); oClass:AddInline( "setGeneralWhere", {|Self, cWhere | ( ( Self ) ), ( ::cGeneralWhere   := cWhere ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER addGeneralWhere( cSQLSelect); oClass:AddMethod( "addGeneralWhere", @SQLBaseModel_addGeneralWhere(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER addEmpresaWhere(); oClass:AddMethod( "addEmpresaWhere", @SQLBaseModel_addEmpresaWhere(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER addParentUuidWhere(); oClass:AddMethod( "addParentUuidWhere", @SQLBaseModel_addParentUuidWhere(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER setOthersWhere(); oClass:AddInline( "setOthersWhere", {|Self, cWhere | ( ( Self ) ), ( ::cOthersWhere   := cWhere ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER addOthersWhere( cSQLSelect); oClass:AddMethod( "addOthersWhere", @SQLBaseModel_addOthersWhere(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER setFilterWhere(); oClass:AddInline( "setFilterWhere", {|Self, cWhere | ( ( Self ) ), ( ::cFilterWhere    := cWhere ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER clearFilterWhere(); oClass:AddInline( "clearFilterWhere", {|Self | ( ( Self ) ), ( ::cFilterWhere    := "" ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getFilterWhere(); oClass:AddInline( "getFilterWhere", {|Self, cWhere | ( ( Self ) ), ( ::cFilterWhere ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER insertFilterWhere( cWhere); oClass:AddMethod( "insertFilterWhere", @SQLBaseModel_insertFilterWhere(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER addFilterWhere( cSQLSelect); oClass:AddMethod( "addFilterWhere", @SQLBaseModel_addFilterWhere(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER addFindWhere( cSQLSelect); oClass:AddMethod( "addFindWhere", @SQLBaseModel_addFindWhere(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER setOrderBy(); oClass:AddInline( "setOrderBy", {|Self, cOrderBy | ( ( Self ) ), ( ::cOrderBy        := cOrderBy ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getOrderBy(); oClass:AddInline( "getOrderBy", {|Self | ( ( Self ) ), ( ::cOrderBy ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER setOrientation(); oClass:AddInline( "setOrientation", {|Self, cOrientation | ( ( Self ) ), ( ::cOrientation    := cOrientation ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getOrientation(); oClass:AddInline( "getOrientation", {|Self | ( ( Self ) ), ( ::cOrientation ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER setGroupBy(); oClass:AddInline( "setGroupBy", {|Self, cGroupBy | ( ( Self ) ), ( ::cGroupBy        := cGroupBy ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getGroupBy(); oClass:AddInline( "getGroupBy", {|Self | ( ( Self ) ), ( ::cGroupBy ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER addGroupBy( cSQLSelect); oClass:AddMethod( "addGroupBy", @SQLBaseModel_addGroupBy(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getWhereOrAnd(); oClass:AddInline( "getWhereOrAnd", {|Self, cSQLSelect | ( ( Self ) ), ( if( hb_at( "WHERE", cSQLSelect ) <> 0, " AND ", " WHERE " ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER isEmpresaColumn(); oClass:AddInline( "isEmpresaColumn", {|Self | ( ( Self ) ), ( hb_hhaskey( ::hColumns, "empresa_codigo" ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER isParentUuidColumn(); oClass:AddInline( "isParentUuidColumn", {|Self | ( ( Self ) ), ( hb_hhaskey( ::hColumns, "parent_uuid" ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER getEditValue(); oClass:AddMethod( "getEditValue", @SQLBaseModel_getEditValue(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getValueField( cColumn, uValue); oClass:AddMethod( "getValueField", @SQLBaseModel_getValueField(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getMethod( cMethod); oClass:AddMethod( "getMethod", @SQLBaseModel_getMethod(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getSelectByOrder(); oClass:AddMethod( "getSelectByOrder", @SQLBaseModel_getSelectByOrder(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getWhere(); oClass:AddInline( "getWhere", {|Self, cWhere | ( ( Self ) ), ( atail( ::getDatabase():selectFetchHash( ::getWhereSelect( cWhere ) ) ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER setFind(); oClass:AddInline( "setFind", {|Self, cFind | ( ( Self ) ), ( ::cFind := cFind ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER findById( nId); oClass:AddMethod( "findById", @SQLBaseModel_findById(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER getBuffer( cColumn); oClass:AddMethod( "getBuffer", @SQLBaseModel_getBuffer(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER setBuffer( cColumn, uValue); oClass:AddMethod( "setBuffer", @SQLBaseModel_setBuffer(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER setBufferPadr( cColumn, uValue); oClass:AddMethod( "setBufferPadr", @SQLBaseModel_setBufferPadr(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER insertBuffer( hBuffer); oClass:AddMethod( "insertBuffer", @SQLBaseModel_insertBuffer(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER insertIgnoreBuffer( hBuffer); oClass:AddMethod( "insertIgnoreBuffer", @SQLBaseModel_insertIgnoreBuffer(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER updateBuffer( hBuffer); oClass:AddMethod( "updateBuffer", @SQLBaseModel_updateBuffer(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER insertOnDuplicate( hBuffer); oClass:AddMethod( "insertOnDuplicate", @SQLBaseModel_insertOnDuplicate(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER insertOnDuplicateTransactional(); oClass:AddInline( "insertOnDuplicateTransactional", {|Self, hBuffer | ( ( Self ) ), ( ::insertOnDuplicate( hBuffer, .T. ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER deleteSelection( aIds); oClass:AddMethod( "deleteSelection", @SQLBaseModel_deleteSelection(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER deleteById( uId); oClass:AddMethod( "deleteById", @SQLBaseModel_deleteById(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER deleteByUuid( uUuid); oClass:AddMethod( "deleteByUuid", @SQLBaseModel_deleteByUuid(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER deleteWhereParentUuid( uUuid); oClass:AddMethod( "deleteWhereParentUuid", @SQLBaseModel_deleteWhereParentUuid(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER loadBlankBuffer(); oClass:AddMethod( "loadBlankBuffer", @SQLBaseModel_loadBlankBuffer(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER loadDuplicateBuffer(); oClass:AddMethod( "loadDuplicateBuffer", @SQLBaseModel_loadDuplicateBuffer(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER loadCurrentBuffer(); oClass:AddMethod( "loadCurrentBuffer", @SQLBaseModel_loadCurrentBuffer(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER defaultCurrentBuffer(); oClass:AddMethod( "defaultCurrentBuffer", @SQLBaseModel_defaultCurrentBuffer(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER insertBlankBuffer(); oClass:AddInline( "insertBlankBuffer", {|Self | ( ( Self ) ), ( ::loadBlankBuffer(), ::insertBuffer() ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER setEvents( aEvents, bEvent); oClass:AddMethod( "setEvents", @SQLBaseModel_setEvents(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER setEvent(); oClass:AddInline( "setEvent", {|Self, cEvent, bEvent | ( ( Self ) ), ( if( !empty( ::oEvents ), ::oEvents:set( cEvent, bEvent ), ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER fireEvent(); oClass:AddInline( "fireEvent", {|Self, cEvent | ( ( Self ) ), ( if( !empty( ::oEvents ), ::oEvents:fire( cEvent ), ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER updateFieldWhereId( id, cField, uValue); oClass:AddMethod( "updateFieldWhereId", @SQLBaseModel_updateFieldWhereId(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER updateFieldWhereUuid( uuid, cField, uValue); oClass:AddMethod( "updateFieldWhereUuid", @SQLBaseModel_updateFieldWhereUuid(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER updateFieldsWhereUuid( uuid, hFields); oClass:AddMethod( "updateFieldsWhereUuid", @SQLBaseModel_updateFieldsWhereUuid(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER getUuidWhereColumn( uValue, cColumn, uDefault); oClass:AddMethod( "getUuidWhereColumn", @SQLBaseModel_getUuidWhereColumn(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getUuidWhereNombre(); oClass:AddInline( "getUuidWhereNombre", {|Self, uValue | ( ( Self ) ), ( ::getUuidWhereColumn( uValue, "nombre", "" ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getUuidWhereCodigo(); oClass:AddInline( "getUuidWhereCodigo", {|Self, uValue | ( ( Self ) ), ( ::getUuidWhereColumn( uValue, "codigo", "" ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getWhereUuid( Uuid); oClass:AddMethod( "getWhereUuid", @SQLBaseModel_getWhereUuid(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getWhereCodigo( cCodigo); oClass:AddMethod( "getWhereCodigo", @SQLBaseModel_getWhereCodigo(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getWhereNombre( cNombre); oClass:AddMethod( "getWhereNombre", @SQLBaseModel_getWhereNombre(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getColumnWhereId( id, cColumn); oClass:AddMethod( "getColumnWhereId", @SQLBaseModel_getColumnWhereId(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getNombreWhereId(); oClass:AddInline( "getNombreWhereId", {|Self, id | ( ( Self ) ), ( ::getColumnWhereId( id, "nombre" ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getColumnWhereUuid( uuid, cColumn); oClass:AddMethod( "getColumnWhereUuid", @SQLBaseModel_getColumnWhereUuid(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getNombreWhereUuid(); oClass:AddInline( "getNombreWhereUuid", {|Self, uuid | ( ( Self ) ), ( ::getColumnWhereUuid( uuid, "nombre" ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getCodigoWhereUuid(); oClass:AddInline( "getCodigoWhereUuid", {|Self, uuid | ( ( Self ) ), ( ::getColumnWhereUuid( uuid, "codigo" ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getColumnWhereId( id, cColumn); oClass:AddMethod( "getColumnWhereId", @SQLBaseModel_getColumnWhereId(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getArrayColumns( cColumn); oClass:AddMethod( "getArrayColumns", @SQLBaseModel_getArrayColumns(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getArrayNombres(); oClass:AddInline( "getArrayNombres", {|Self, cColumn | ( ( Self ) ), ( ::getArrayColumns( "nombre" ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getArrayColumnsWithBlank( cColumn); oClass:AddMethod( "getArrayColumnsWithBlank", @SQLBaseModel_getArrayColumnsWithBlank(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getNombresWithBlank(); oClass:AddInline( "getNombresWithBlank", {|Self | ( ( Self ) ), ( ::getArrayColumnsWithBlank( "nombre" ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getSenderControllerParentUuid(); oClass:AddMethod( "getSenderControllerParentUuid", @SQLBaseModel_getSenderControllerParentUuid(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER InsertOrUpdateFromUuid( hBuffer); oClass:AddMethod( "InsertOrUpdateFromUuid", @SQLBaseModel_InsertOrUpdateFromUuid(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER existeUuid( uuid); oClass:AddMethod( "existeUuid", @SQLBaseModel_existeUuid(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER lExisteTable(); oClass:AddMethod( "lExisteTable", @SQLBaseModel_lExisteTable(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS SQLBaseModel ;



static FUNCTION SQLBaseModel_New( oController ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   if empty( ::hColumns ) .AND. empty( ::getColumns() )
      msgstop( "La definición de columnas no puede estar vacia" )
      RETURN ( Self )
   end

   ::oController                 := oController

   ::oDatabase                   := getSQLDatabase()

   ::oEvents                     := Events():New()

   if empty( ::cColumnKey )
      ::cColumnKey               := hGetKeyAt( ::hColumns, 1 )
   end

   ::cGeneralSelect              := "SELECT * FROM " + ::getTableName()

RETURN ( Self )



static FUNCTION SQLBaseModel_End( ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   ::oEvents:End()

RETURN ( nil )



static FUNCTION SQLBaseModel_getDateTimeColumns( ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel


   hset( ::hColumns, "creado",      {  "create"    => "DATETIME DEFAULT NULL"       , "default"   => {|| hb_datetime() } }         )


   hset( ::hColumns, "modificado",  {  "create"    => "DATETIME DEFAULT NULL"       , "default"   => {|| hb_datetime() } }         )

RETURN ( ::hColumns )



static FUNCTION SQLBaseModel_getTimeStampSentColumns( ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel


   hset( ::hColumns, "enviado",     {  "create"    => "DATETIME DEFAULT NULL"       , "text"      => "Enviado fecha y hora" }      )

RETURN ( ::hColumns )



static FUNCTION SQLBaseModel_getTimeStampColumns( ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel


   hset( ::hColumns, "created_at",     {  "create"    => "TIMESTAMP NULL DEFAULT NULL" , "default"   => {|| hb_datetime() } }         )


   hset( ::hColumns, "updated_at",     {  "create"    => "TIMESTAMP NULL DEFAULT NULL" , "default"   => {|| hb_datetime() } }         )

RETURN ( ::hColumns )



static FUNCTION SQLBaseModel_getEmpresaColumns( ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel


   hset( ::hColumns, "empresa_codigo", {  "create"    => "VARCHAR ( 40 ) NOT NULL"       , "default"   => {|| cCodEmp() } }        )


   hset( ::hColumns, "usuario_codigo", {  "create"    => "VARCHAR ( 40 ) NOT NULL"       , "default"   => {|| Auth():Codigo() } }           )

RETURN ( ::hColumns )



static FUNCTION SQLBaseModel_getGeneralSelect( ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cSQLSelect

   ::fireEvent( "getingInitialSelect" )

   cSQLSelect              := ::getInitialSelect()

   ::fireEvent( "gotInitialSelect" )

   cSQLSelect              := ::addGeneralWhere( cSQLSelect )

   cSQLSelect              := ::addOthersWhere( cSQLSelect )

   cSQLSelect              := ::addEmpresaWhere( cSQLSelect )

   cSQLSelect              := ::addParentUuidWhere( cSQLSelect )

   cSQLSelect              := ::addFilterWhere( cSQLSelect )

   cSQLSelect              := ::addGroupBy( cSQLSelect )

RETURN ( cSQLSelect )



static FUNCTION SQLBaseModel_getIdSelect( id ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cSQLSelect        := ::cGeneralSelect + " "
   cSQLSelect              += "WHERE id = " + toSQLString( id )

RETURN ( cSQLSelect )



static FUNCTION SQLBaseModel_getWhereSelect( cWhere ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cSQLSelect        := ::cGeneralSelect + " "
   cSQLSelect              += "WHERE " + cWhere

RETURN ( cSQLSelect )



static FUNCTION SQLBaseModel_getSelectSentence( cOrderBy, cOrientation ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cSQLSelect

   ::cOrderBy              := cOrderBy

   ::cOrientation          := cOrientation

   ::fireEvent( "gettingSelectSentence")

   cSQLSelect              := ::getGeneralSelect()

   cSQLSelect              := ::addFindWhere( cSQLSelect )

   cSQLSelect              := ::getSelectByOrder( cSQLSelect )

   ::fireEvent( "gotSelectSentence")

RETURN ( cSQLSelect )



static FUNCTION SQLBaseModel_addGeneralWhere( cSQLSelect ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   if empty( ::cGeneralWhere )
      RETURN ( cSQLSelect )
   end

   cSQLSelect     += ::getWhereOrAnd( cSQLSelect ) + ::cGeneralWhere

RETURN ( cSQLSelect )



static FUNCTION SQLBaseModel_addOthersWhere( cSQLSelect ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   if empty( ::cOthersWhere )
      RETURN ( cSQLSelect )
   end

   cSQLSelect     += ::getWhereOrAnd( cSQLSelect ) + ::cOthersWhere

RETURN ( cSQLSelect )



static FUNCTION SQLBaseModel_addEmpresaWhere( cSQLSelect ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   if !::isEmpresaColumn()
      RETURN ( cSQLSelect )
   end

   cSQLSelect     += ::getWhereOrAnd( cSQLSelect ) + ::cTableName + ".empresa_codigo = " + toSQLString( cCodEmp() )

RETURN ( cSQLSelect )



static FUNCTION SQLBaseModel_addParentUuidWhere( cSQLSelect ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local uuid

   if !::isParentUuidColumn()
      RETURN ( cSQLSelect )
   end

   if empty( ::oController )
      RETURN ( cSQLSelect )
   end

   if empty( ::oController:getSenderController() )
      RETURN ( cSQLSelect )
   end

   uuid           := ::oController:getSenderController():getUuid()

   if !empty( uuid )
      cSQLSelect  += ::getWhereOrAnd( cSQLSelect ) + ::cTableName + ".parent_uuid = " + quoted( uuid )
   end

RETURN ( cSQLSelect )



static FUNCTION SQLBaseModel_insertFilterWhere( cWhere ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   if empty( ::cFilterWhere )
      ::cFilterWhere    := cWhere
   else
      ::cFilterWhere    += " AND " + cWhere
   end

RETURN ( ::cFilterWhere )



static FUNCTION SQLBaseModel_addFilterWhere( cSQLSelect ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   if empty( ::cFilterWhere )
      RETURN ( cSQLSelect )
   end

   cSQLSelect     += ::getWhereOrAnd( cSQLSelect ) + ::cFilterWhere

RETURN ( cSQLSelect )



static FUNCTION SQLBaseModel_addGroupBy( cSQLSelect ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   if empty( ::getGroupBy() )
      RETURN ( cSQLSelect )
   end

   cSQLSelect     += space( 1 )
   cSQLSelect     += ::getGroupBy()

RETURN ( cSQLSelect )



static FUNCTION SQLBaseModel_addFindWhere( cSQLSelect ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   if empty( ::cOrderBy ) .OR. empty( ::cFind )
      RETURN ( cSQLSelect )
   end

   cSQLSelect     += space( 1 )
   cSQLSelect     += ::getWhereOrAnd( cSQLSelect ) + "UPPER(" + ::cOrderBy +") LIKE '%" + Upper( ::cFind ) + "%'"

RETURN ( cSQLSelect )




















static FUNCTION SQLBaseModel_getSelectByOrder( cSQLSelect ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   if empty( ::cOrderBy )
      RETURN ( cSQLSelect )
   end

   cSQLSelect     += " ORDER BY " + ::cOrderBy

   if !empty( ::cOrientation ) .AND. ::cOrientation == "A"
      cSQLSelect  += " DESC"
   else
      cSQLSelect  += " ASC"
   end

RETURN ( cSQLSelect )



static FUNCTION SQLBaseModel_getCreateTableSentence( cDatabaseMySQL ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cSQLCreateTable

   If( cDatabaseMySQL == nil, cDatabaseMySQL := ::oDatabase:cDatabaseMySQL, ) ;

   cSQLCreateTable         := "CREATE TABLE " + cDatabaseMySQL + "." + ::cTableName + " ( "


   hEval( ::getColumns(), {| k, hash | if( hhaskey( hash, "create" ), cSQLCreateTable += k + " " + hget( hash, "create" ) + ", ", ) } )

   if !empty( ::cConstraints )

      cSQLCreateTable      += ::cConstraints + " )"

   else

      cSQLCreateTable      := chgAtEnd( cSQLCreateTable, " )", 2 )

   end



RETURN ( cSQLCreateTable )



static FUNCTION SQLBaseModel_getAlterTableSentences( cDatabaseMySQL, aSchemaColumns ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local aAlter
   local hColumn
   local hColumns
   local nPosition

   if empty( aSchemaColumns )
      RETURN ( self )
   end

   If( cDatabaseMySQL == nil, cDatabaseMySQL := ::oDatabase:cDatabaseMySQL, ) ;

   aAlter                  := {}
   hColumns                := ::getTableColumns()

   for each hColumn in aSchemaColumns

      nPosition            := ascan( hb_hkeys( hColumns ), hget( hColumn, "COLUMN_NAME" ) )

      if nPosition <> 0
         hb_hdelat( hColumns, nPosition )
      else
         aadd( aAlter, "ALTER TABLE " + cDatabaseMySQL + "." + ::cTableName + " DROP COLUMN " + hget( hColumn, "COLUMN_NAME" ) )
      end

   next

   if !empty( hColumns )
      heval( hColumns, {| k, hash | aadd( aAlter, "ALTER TABLE " + cDatabaseMySQL + "." + ::cTableName + " ADD COLUMN " + k + " " + hget( hash, "create" ) ) } )
   end

   if !empty( hColumns )
      msgInfo( hb_valtoexp( hColumns ), "getAlterTableSentences " + cDatabaseMySQL + "." + ::cTableName, "Alter table" )
   end

RETURN ( aAlter )



static FUNCTION SQLBaseModel_getDropTableSentence( ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

RETURN ( "DROP TABLE " + ::cTableName )



static FUNCTION SQLBaseModel_findById( id ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local hBuffer

   if !hb_isnumeric( id )
      RETURN ( nil )
   end

   hBuffer        := atail( ::getDatabase():selectPadedFetchHash( ::getIdSelect( id ) ) )

   if hb_ishash( hBuffer )
      heval( hBuffer, {|k,v| hset( hBuffer, k, ::getAttribute( k, v ) ) } )
   end

RETURN ( hBuffer )



static FUNCTION SQLBaseModel_setCreatedTimeStamp( hBuffer ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   if ( hhaskey( hBuffer, "creado" ) )
      hset( hBuffer, "creado", hb_datetime() )
   end

   if ( hhaskey( hBuffer, "created_at" ) )
      hset( hBuffer, "created_at", hb_datetime() )
   end

RETURN ( hBuffer )



static FUNCTION SQLBaseModel_setUpdatedTimeStamp( hBuffer ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   if ( hhaskey( hBuffer, "modificado" ) )
      hset( hBuffer, "modificado", hb_datetime() )
   end

   if ( hhaskey( hBuffer, "updated_at" ) )
      hset( hBuffer, "updated_at", hb_datetime() )
   end

RETURN ( hBuffer )



static FUNCTION SQLBaseModel_getInsertSentence( hBuffer, lIgnore ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   If( hBuffer == nil, hBuffer := ::hBuffer, ) ;
   If( lIgnore == nil, lIgnore := .F., ) ;

   ::fireEvent( "getingInsertSentence" )

   hBuffer           := ::setCreatedTimeStamp( hBuffer )

   ::cSQLInsert      := "INSERT "

   if lIgnore
      ::cSQLInsert   += "IGNORE "
   end

   ::cSQLInsert      += "INTO " + ::cTableName + " ( "

   hEval( hBuffer, {| k, v | if( k <> ::cColumnKey, ::cSQLInsert += k + ", ", ) } )

   ::cSQLInsert      := chgAtEnd( ::cSQLInsert, " ) VALUES ( ", 2 )

   hEval( hBuffer, {| k, v | if( k <> ::cColumnKey, ::cSQLInsert += toSQLString( ::setAttribute( k, v ) ) + ", ", ) } )

   ::cSQLInsert      := chgAtEnd( ::cSQLInsert, " )", 2 )

   ::fireEvent( "gotInsertSentence" )

RETURN ( ::cSQLInsert )



static FUNCTION SQLBaseModel_getUpdateSentence( hBuffer ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local uValue

   If( hBuffer == nil, hBuffer := ::hBuffer, ) ;

   ::fireEvent( "getingUpdateSentence" )

   hBuffer              := ::setUpdatedTimeStamp( hBuffer )

   ::cSQLUpdate         := "UPDATE " + ::cTableName + " SET "

   for each uValue in hBuffer
      if ( uValue:__enumkey() <> ::cColumnKey ) .AND. ( uValue:__enumkey() <> "id" )
         ::cSQLUpdate  += uValue:__enumKey() + " = " + toSQLString( ::setAttribute( uValue:__enumKey(), uValue ) ) + ", "
      end
   next

   ::cSQLUpdate         := chgAtEnd( ::cSQLUpdate, "", 2 ) + " "

   ::cSQLUpdate         += "WHERE " + ::cColumnKey + " = " + toSQLString( hget( hBuffer, ::cColumnKey ) )

   ::fireEvent( "gotUpdateSentence" )

RETURN ( ::cSQLUpdate )



static FUNCTION SQLBaseModel_getInsertOnDuplicateSentence( hBuffer, lDebug ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local uValue
   local cSQLUpdate

   If( hBuffer == nil, hBuffer := ::hBuffer, ) ;
   If( lDebug == nil, lDebug := .F., ) ;

   hBuffer           := ::setUpdatedTimeStamp( hBuffer )

   cSQLUpdate        := ::getInsertSentence( hBuffer ) + " "

   cSQLUpdate        += "ON DUPLICATE KEY UPDATE "

   hBuffer           := ::setUpdatedTimeStamp( hBuffer )

   for each uValue in hBuffer
      if ( uValue:__enumkey() <> ::cColumnKey )
         cSQLUpdate  += uValue:__enumKey() + " = " + toSQLString( ::setAttribute( uValue:__enumKey(), uValue ) ) + ", "
      end
   next

   cSQLUpdate        := chgAtEnd( cSQLUpdate, "", 2 )

RETURN ( cSQLUpdate )



static FUNCTION SQLBaseModel_getdeleteSentenceByUuid( uUuid ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel


   local cSentence   := "DELETE FROM " + ::cTableName + space( 1 ) +  "WHERE uuid IN ( "

   if hb_isarray( uUuid )
      aeval( uUuid, {| v | cSentence += if( hb_isarray( v ), toSQLString( atail( v ) ), toSQLString( v ) ) + ", " } )
      cSentence      := chgAtEnd( cSentence, " )", 2 )
   end

   if hb_ischar( uUuid )
      cSentence      += quoted( uUuid ) + " )"
   end

RETURN ( cSentence )



static FUNCTION SQLBaseModel_getDeleteSentenceWhereParentUuid( aUuid ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel


   local cSentence   := "DELETE FROM " + ::cTableName + space( 1 ) +  "WHERE parent_uuid IN ( "

   aeval( aUuid, {| v | cSentence += if( hb_isarray( v ), toSQLString( atail( v ) ), toSQLString( v ) ) + ", " } )

   cSentence         := chgAtEnd( cSentence, " )", 2 )

RETURN ( cSentence )



static FUNCTION SQLBaseModel_getDeleteSentenceById( aIds ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cSentence

   if hb_isnumeric( aIds )
      aIds     := { aIds }
   end


   cSentence   := "DELETE FROM " + ::cTableName + space( 1 ) +  "WHERE " + ::cColumnKey + " IN ( "

   aeval( aIds, {| v | cSentence += if( hb_isarray( v ), toSQLString( atail( v ) ), toSQLString( v ) ) + ", " } )

   cSentence   := chgAtEnd( cSentence, " )", 2 )

RETURN ( cSentence )



static FUNCTION SQLBaseModel_aUuidToDelete( aParentsUuid ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel


   local cSentence   := "SELECT uuid FROM " + ::cTableName + space( 1 ) +  "WHERE parent_uuid IN ( "

   aeval( aParentsUuid, {| v | cSentence += if( hb_isarray( v ), toSQLString( atail( v ) ), toSQLString( v ) ) + ", " } )

   cSentence         := chgAtEnd( cSentence, " )", 2 )

RETURN ( ::getDatabase():selectFetchArray( cSentence ) )



static FUNCTION SQLBaseModel_getValueField( cColumn, uValue ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local bValue
   local hColumn

   if !hhaskey( ::hColumns, cColumn )
      RETURN ( uValue )
   end

   hColumn        := hGet( ::hColumns, cColumn )

   if hhaskey( hColumn, "default" )
      RETURN ( uValue )
   end

   bValue         := hGet( hColumn, "default" )

   if !empty( bValue ) .AND. hb_isblock( bValue )
      uValue      := eval( bValue )
   end

RETURN ( uValue )



static FUNCTION SQLBaseModel_getEditValue( cColumn ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local bValue
   local hColumn

   if !hhaskey( ::hColumns, cColumn )
      RETURN ( nil )
   end

   hColumn        := hGet( ::hColumns, cColumn )

   if hhaskey( hColumn, "edit" )
      RETURN ( hGet( hColumn, "edit" ) )
   end

RETURN ( cColumn )



static FUNCTION SQLBaseModel_setAttribute( key, value ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cMethod  := "set" + strtran( key, "_", "" ) + "attribute"

   if __ObjHasMethod( Self, cMethod )
      RETURN ( Self:&( cMethod )( value ) )
   end

RETURN ( value )



static FUNCTION SQLBaseModel_getAttribute( key, value ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cMethod  := "get" + strtran( key, "_", "" ) + "attribute"

   if __ObjHasMethod( Self, cMethod )
      RETURN ( Self:&( cMethod )( value ) )
   end

RETURN ( value )



static FUNCTION SQLBaseModel_getMethod( cMethod ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

RETURN ( {|| Self:&( cMethod ) } )



static FUNCTION SQLBaseModel_loadBlankBuffer( ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   ::hBuffer            := {=>}

   ::fireEvent( "loadingBlankBuffer" )

   ::defaultCurrentBuffer()

   ::fireEvent( "loadedBlankBuffer" )

RETURN ( ::hBuffer )



static FUNCTION SQLBaseModel_loadCurrentBuffer( id ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   ::hBuffer            := {=>}

   ::fireEvent( "loadingCurrentBuffer" )

   ::hBuffer            := ::findById( id )

   ::fireEvent( "loadedCurrentBuffer" )

RETURN ( ::hBuffer )



static FUNCTION SQLBaseModel_loadDuplicateBuffer( id ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   ::hBuffer            := {=>}

   ::fireEvent( "loadingDuplicateBuffer" )

   ::hBuffer            := ::findById( id )

   ::fireEvent( "loadedDuplicateCurrentBuffer" )

   if hhaskey( ::hBuffer, "id" )
      hset( ::hBuffer, "id", 0 )
   end

   if hhaskey( ::hBuffer, "uuid" )
      hset( ::hBuffer, "uuid", win_uuidcreatestring() )
   end

   ::fireEvent( "loadedDuplicateBuffer" )

RETURN ( ::hBuffer )



static FUNCTION SQLBaseModel_defaultCurrentBuffer( ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local h

   for each h in ::getTableColumns()

      if hhaskey( h, "default" ) .AND. hb_isblock( hget( h, "default" ) )

         hset( ::hBuffer, h:__enumkey(), ::getAttribute( h:__enumkey(), eval( hget( h, "default" ) ) ) )

      end

   next

RETURN ( ::hBuffer )



static FUNCTION SQLBaseModel_getSerializeColumns( ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cColumns       := ""

   heval( ::getTableColumns(), {|cColumn| cColumns += alltrim( cColumn ) + ";" } )

RETURN ( cColumns )



STATIC FUNCTION validColumnForNavigator( hash )

RETURN ( hhaskey( hash, "visible" ) .AND. hget( hash, "visible" ) .AND. hhaskey( hash, "header" ) .AND. hhaskey( hash, "width" ) )



static FUNCTION SQLBaseModel_getTableColumns( ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local hColumns    := {=>}

   heval( ::getColumns(), {|k,v| if( hhaskey( v, "create" ), hset( hColumns, k, v ), ) } )

RETURN ( hColumns )



static FUNCTION SQLBaseModel_getColumnsForBrowse( ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local hColumns    := {=>}

   hEval( ::getColumns(), {|k,v| if( validColumnForNavigator( v ), hset( hColumns, k, v ), ) } )

RETURN ( hColumns )



static FUNCTION SQLBaseModel_getHeadersForBrowse( ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local aHeaders    := {}

   hEval( ::getColumns(), {|k,v| if( validColumnForNavigator( v ), aadd( aHeaders, hget( v, "header" ) ), ) } )

RETURN ( aHeaders )



static FUNCTION SQLBaseModel_getValueFromColumn( cColumn, cKey ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local nScan
   local hValue
   local uValue   := ""

   nScan          := hScan( ::hColumns, {|k| k == cColumn } )
   if nScan <> 0

      hValue      := hGetValueAt( ::hColumns, nScan )

      if hb_ishash( hValue ) .AND. hhaskey( hValue, cKey )
         uValue   := hGet( hValue, cKey )
      end

   end

RETURN ( uValue )



static FUNCTION SQLBaseModel_insertBuffer( hBuffer ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local nId

   ::getInsertSentence( hBuffer )

   ::fireEvent( "insertingBuffer" )

   if !empty( ::cSQLInsert )
      ::getDatabase():Execs( ::cSQLInsert )
   end

   nId         := ::getDatabase():LastInsertId()

   ::fireEvent( "insertedBuffer" )

RETURN ( nId )



static FUNCTION SQLBaseModel_insertIgnoreBuffer( hBuffer ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local nId

   ::getInsertIgnoreSentence( hBuffer )

   ::fireEvent( "insertingBuffer" )

   if !empty( ::cSQLInsert )
      ::getDatabase():Execs( ::cSQLInsert )
   end

   nId         := ::getDatabase():LastInsertId()

   ::fireEvent( "insertedBuffer" )

RETURN ( nId )



static FUNCTION SQLBaseModel_updateBuffer( hBuffer ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   ::getUpdateSentence( hBuffer )

   ::fireEvent( "updatingBuffer" )

   if !empty( ::cSQLUpdate )

      ::getDatabase():Execs( ::cSQLUpdate )

   end

   ::fireEvent( "updatedBuffer" )

RETURN ( Self )



static FUNCTION SQLBaseModel_insertOnDuplicate( hBuffer, lTransactional ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   If( lTransactional == nil, lTransactional := .F., ) ;

   ::fireEvent( "insertingOnDuplicatingBuffer" )

   if lTransactional
      ::getDatabase():TransactionalExec( ::getInsertOnDuplicateSentence( hBuffer ) )
   else
      ::getDatabase():Execs( ::getInsertOnDuplicateSentence( hBuffer ) )
   end

   ::fireEvent( "insertedOnDuplicatedBuffer" )

RETURN ( Self )



static FUNCTION SQLBaseModel_deleteSelection( aIds, aUuids ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   ::aRecordsToDelete   := aIds
   ::aUuidsToDelete     := aUuids

   ::fireEvent( "deletingSelection" )

   ::getDatabase():Execs( ::getDeleteSentenceById( aIds, aUuids ) )

   ::fireEvent( "deletedSelection" )

RETURN ( Self )



static FUNCTION SQLBaseModel_deleteById( nId ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   ::fireEvent( "deletingById" )

   ::getDatabase():Execs( ::getDeleteSentenceById( nId ) )

   ::fireEvent( "deletedById" )

RETURN ( Self )



static FUNCTION SQLBaseModel_deleteByUuid( uUuid ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   ::fireEvent( "deletingByUuid" )

   ::getDatabase():Execs( ::getDeleteSentenceByUuid( uUuid ) )

   ::fireEvent( "deletedByUuid" )

RETURN ( Self )



static FUNCTION SQLBaseModel_deleteWhereParentUuid( uUuid ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   ::fireEvent( "deletingWhereParentUuid" )

   ::getDatabase():Execs( ::getDeleteSentenceWhereParentUuid( uUuid ) )

   ::fireEvent( "deletedWhereParentUuid" )

RETURN ( Self )



static FUNCTION SQLBaseModel_getBuffer( cColumn ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   if empty( ::hBuffer )
      RETURN ( nil )
   end

   if !hhaskey( ::hBuffer, cColumn )
      RETURN ( nil )
   end

RETURN ( hget( ::hBuffer, cColumn ) )



static FUNCTION SQLBaseModel_setBuffer( cColumn, uValue ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   if empty( ::hBuffer )
      RETURN ( nil )
   end

   if !hhaskey( ::hBuffer, cColumn )
      RETURN ( nil )
   end

RETURN ( hset( ::hBuffer, cColumn, uValue ) )



static FUNCTION SQLBaseModel_setBufferPadr( cColumn, uValue ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local nLen

   if empty( ::hBuffer )
      RETURN ( nil )
   end

   if !hhaskey( ::hBuffer, cColumn )
      RETURN ( nil )
   end

   nLen           := ::getLenFromColumn( cColumn )
   if empty( nLen )
      RETURN ( hset( ::hBuffer, cColumn, uValue ) )
   end

   uValue         := padr( uValue, nLen )

RETURN ( hset( ::hBuffer, cColumn, uValue ) )



static FUNCTION SQLBaseModel_updateFieldWhereId( id, cField, uValue ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cSql  := "UPDATE " + ::cTableName + " "
   cSql        +=    "SET " + cField + " = " + toSqlString( uValue ) + " "
   cSql        +=    "WHERE id = " + toSqlString( id )

RETURN ( ::getDatabase():Exec( cSql ) )



static FUNCTION SQLBaseModel_updateFieldWhereUuid( uuid, cField, uValue ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cSql  := "UPDATE " + ::cTableName + " "
   cSql        +=    "SET " + cField + " = " + toSqlString( uValue )    + " "
   cSql        +=    "WHERE uuid = " + toSqlString( uuid )

RETURN ( ::getDatabase():Exec( cSql ) )



static FUNCTION SQLBaseModel_updateFieldsWhereUuid( uuid, hFields ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cSql
   local uValue

   cSql           := "UPDATE " + ::cTableName + " SET "

   for each uValue in hFields
      cSql        += uValue:__enumKey() + " = " + toSQLString( uValue ) + ", "
   next

   cSql           := chgAtEnd( cSql, "", 2 ) + " "

   cSql           +=    "WHERE uuid = " + toSqlString( uuid )

RETURN ( ::getDatabase():Exec( cSql ) )



static FUNCTION SQLBaseModel_getField( cField, cBy, cId ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cSql  := "SELECT " + cField                                    + " "
   cSql        +=    "FROM " + ::cTableName                             + " "
   cSql        +=    "WHERE " + cBy + " = " + quoted( cId )             + " "

RETURN ( ::getDatabase():getValue( cSql ) )



static FUNCTION SQLBaseModel_getHash( cBy, cId ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cSql  := "SELECT * "
   cSql        +=    "FROM " + ::cTableName                             + " "
   cSql        +=    "WHERE " + cBy + " = " + quoted( cId )             + " "

RETURN ( atail( ::getDatabase():selectTrimedFetchHash( cSql ) ) )



static FUNCTION SQLBaseModel_getUuidWhereColumn( uValue, cColumn, uDefault ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local uuid
   local cSQL  := "SELECT uuid FROM " + ::getTableName()                + " "
   cSQL        +=    "WHERE " + cColumn + " = " + toSqlString( uValue ) + " "
   cSQL        +=    "LIMIT 1"

   uuid        := ::getDatabase():getValue( cSQL )
   if !empty( uuid )
      RETURN ( uuid )
   end

RETURN ( uDefault )



static FUNCTION SQLBaseModel_getWhereUuid( Uuid ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cSQL  := "SELECT * FROM " + ::getTableName()                         + " "
   cSQL        +=    "WHERE uuid = " + quoted( uuid )                         + " "
   cSQL        +=    "LIMIT 1"

RETURN ( ::getDatabase():firstTrimedFetchHash( cSQL ) )



static FUNCTION SQLBaseModel_getWhereCodigo( cCodigo ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cSQL  := "SELECT * FROM " + ::getTableName()                         + " "
   cSQL        +=    "WHERE codigo = " + quoted( cCodigo )                    + " "
   cSQL        +=    "LIMIT 1"

RETURN ( ::getDatabase():firstTrimedFetchHash( cSQL ) )



static FUNCTION SQLBaseModel_getWhereNombre( cNombre ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cSQL  := "SELECT * FROM " + ::getTableName()                         + " "
   cSQL        +=    "WHERE nombre = " + quoted( cNombre )                    + " "
   cSQL        +=    "LIMIT 1"

RETURN ( ::getDatabase():firstTrimedFetchHash( cSQL ) )



static FUNCTION SQLBaseModel_getColumnWhereId( id, cColumn ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel



   local cSQL     := "SELECT " + cColumn + " FROM " + ::getTableName()  + " " +  "WHERE id = " + quoted( id )                    + " " +  "LIMIT 1"

RETURN ( ::getDatabase():getValue( cSQL ) )



static FUNCTION SQLBaseModel_getColumnWhereUuid( uuid, cColumn ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel



   local cSQL     := "SELECT " + cColumn + " FROM " + ::getTableName()  + " " +  "WHERE uuid = " + quoted( uuid )                + " " +  "LIMIT 1"

RETURN ( ::getDatabase():getValue( cSQL ) )



static FUNCTION SQLBaseModel_getArrayColumns( cColumn ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cSQL     := "SELECT " + cColumn + "  FROM " + ::getTableName()

RETURN ( ::getDatabase():selectFetchArrayOneColumn( cSQL ) )



static FUNCTION SQLBaseModel_getArrayColumnsWithBlank( cColumn ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local aColumns
   local cSQL     := "SELECT " + cColumn + "  FROM " + ::getTableName()

   aColumns       := ::getDatabase():selectFetchArrayOneColumn( cSQL )

   hb_AIns(aColumns,1,"", .T.)

RETURN ( aColumns )



static FUNCTION SQLBaseModel_getSenderControllerParentUuid( ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   if empty( ::oController )
      RETURN ( space( 40 ) )
   end

   if empty( ::oController:getSenderController() )
      RETURN ( space( 40 ) )
   end

RETURN ( ::oController:getSenderController():getUuid() )



static FUNCTION SQLBaseModel_setEvents( aEvents, bEvent ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

RETURN ( aeval( aEvents, {|cEvent| ::setEvent( cEvent, bEvent ) } ) )



static FUNCTION SQLBaseModel_InsertOrUpdateFromUuid( hBuffer ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cSentence   := ""

   if ::existeUuid( hGet( hBuffer, "uuid" ) )

      ::cColumnKey   := "uuid"

      ::getUpdateSentence( hBuffer )

      if !empty( ::cSQLUpdate )
         ::getDatabase():Execs( ::cSQLUpdate )
      end

      ::cColumnKey   := "id"

   else

      ::getInsertSentence( hBuffer )

      if !empty( ::cSQLInsert )
         ::getDatabase():Execs( ::cSQLInsert )
      end

   end

Return ( nil )



static FUNCTION SQLBaseModel_existeUuid( uuid ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local aResult


   local cSql     := "SELECT * "                            +  "FROM " + ::getTableName() + Space(1)  +  "WHERE uuid = " + quoted( uuid )

   aResult        := ::getDatabase():selectFetchArray( cSql )

   if isArray( aResult ) .AND. len( aResult ) > 0
      Return ( .T. )
   end

Return ( .F. )



static FUNCTION SQLBaseModel_lExisteTable( ) ; local Self AS CLASS SQLBaseModel := QSelf() AS CLASS SQLBaseModel

   local cSql     := ""
   local aResult

   cSql           := "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = " + quoted( ::getDatabase():cDatabaseMySQL ) + " AND TABLE_NAME = " + quoted( ::getTableName() )

   aResult        := ::getDatabase():selectFetchArray( cSql )

   if hb_isarray( aResult ) .AND. Len( aResult ) > 0
      Return ( .T. )
   end

   msgstop( "La base de datos " + quoted( ::getTableName() ) + " no existe en la base de datos " + quoted( ::getDatabase():cDatabaseMySQL ) + "." )

Return ( .F. )
