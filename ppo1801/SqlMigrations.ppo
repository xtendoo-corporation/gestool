#line 91 "\fwh1801\include\fiveWin.ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 6 ".\Prg\Services\SqlMigrations.prg"
_HB_CLASS SQLMigrations ; function SQLMigrations ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "SQLMigrations", iif( .F., { }, { @HBObject() } ), @SQLMigrations() ) ) ;

   _HB_MEMBER { hJson } ; oClass:AddMultiData(, {=>}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hJson"}, .F. )

   _HB_MEMBER { aModels } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aModels"}, .F. )

   _HB_MEMBER { aRepositories } ; oClass:AddMultiData(, {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aRepositories"}, .F. )

   _HB_MEMBER Run(); oClass:AddMethod( "Run", @SQLMigrations_Run(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER checkDatabase(); oClass:AddMethod( "checkDatabase", @SQLMigrations_checkDatabase(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER createDatabase(); oClass:AddMethod( "createDatabase", @SQLMigrations_createDatabase(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER readgestoolDatabaseJSON(); oClass:AddMethod( "readgestoolDatabaseJSON", @SQLMigrations_readgestoolDatabaseJSON(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER addModels(); oClass:AddMethod( "addModels", @SQLMigrations_addModels(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER checkModels(); oClass:AddMethod( "checkModels", @SQLMigrations_checkModels(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER checkModel( oModel); oClass:AddMethod( "checkModel", @SQLMigrations_checkModel(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER checkRepositories(); oClass:AddMethod( "checkRepositories", @SQLMigrations_checkRepositories(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER checkRepository( oRepository); oClass:AddMethod( "checkRepository", @SQLMigrations_checkRepository(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getSchemaColumns( cDatabaseMySQL, cTableName); oClass:AddMethod( "getSchemaColumns", @SQLMigrations_getSchemaColumns(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS SQLMigrations ;



static FUNCTION SQLMigrations_checkDatabase( ) ; local Self AS CLASS SQLMigrations := QSelf() AS CLASS SQLMigrations

   getSQLDatabase():ConnectWithoutDataBase()

   if !::readgestoolDatabaseJSON()
      RETURN ( self )
   end

   if hhaskey( ::hJson, "Databases" )

      aeval( hget( ::hJson, "Databases" ), {|hDatabase| ::Run( hget( hDatabase, "Database" ) ) } )
   end

RETURN ( Self )



static FUNCTION SQLMigrations_Run( cDatabaseMySQL ) ; local Self AS CLASS SQLMigrations := QSelf() AS CLASS SQLMigrations

   ::createDatabase( cDatabaseMySQL )

   ::addModels()

   ::checkModels( cDatabaseMySQL )

RETURN ( Self )



static FUNCTION SQLMigrations_createDatabase( cDatabaseMySQL ) ; local Self AS CLASS SQLMigrations := QSelf() AS CLASS SQLMigrations

   If( cDatabaseMySQL == nil, cDatabaseMySQL := getSQLDatabase():cDatabaseMySQL, ) ;

   getSQLDatabase():ExecWithOutParse( "CREATE DATABASE IF NOT EXISTS " + cDatabaseMySQL + ";" )

   getSQLDatabase():ExecWithOutParse( "USE " + cDatabaseMySQL + ";" )

RETURN ( self )



static FUNCTION SQLMigrations_checkModels( cDatabaseMySQL ) ; local Self AS CLASS SQLMigrations := QSelf() AS CLASS SQLMigrations

RETURN ( aeval( ::aModels, {|oModel| ::checkModel( cDatabaseMySQL, oModel ) } ) )



static FUNCTION SQLMigrations_checkModel( cDatabaseMySQL, oModel ) ; local Self AS CLASS SQLMigrations := QSelf() AS CLASS SQLMigrations

   local aSchemaColumns    := ::getSchemaColumns( cDatabaseMySQL, oModel:cTableName )

   if empty( aSchemaColumns )
      getSQLDatabase():Exec( oModel:getCreateTableSentence( cDatabaseMySQL ) )
   else
      getSQLDatabase():Execs( oModel:getAlterTableSentences( cDatabaseMySQL, aSchemaColumns ) )
   end

RETURN ( Self )



static FUNCTION SQLMigrations_checkRepositories( ) ; local Self AS CLASS SQLMigrations := QSelf() AS CLASS SQLMigrations

RETURN ( aeval( ::aRepositories, {|oRepository| ::checkRepository( oRepository ) } ) )



static FUNCTION SQLMigrations_checkRepository( oRepository ) ; local Self AS CLASS SQLMigrations := QSelf() AS CLASS SQLMigrations

   getSQLDatabase():Execs( oRepository:getSQLFunctions() )

RETURN ( Self )



static FUNCTION SQLMigrations_getSchemaColumns( cDatabaseMySQL, cTableName ) ; local Self AS CLASS SQLMigrations := QSelf() AS CLASS SQLMigrations

   local oError
   local cSentence
   local oStatement
   local aSchemaColumns

   If( cDatabaseMySQL == nil, cDatabaseMySQL := getSQLDatabase():cDatabaseMySQL, ) ;

   if empty( cTableName )
      RETURN ( nil )
   end

   if empty( getSQLDatabase():oConexion )
      msgstop( "No hay conexiones disponibles" )
      RETURN ( nil )
   end




   cSentence               := "SELECT COLUMN_NAME "                                       +  "FROM INFORMATION_SCHEMA.COLUMNS "                       +  "WHERE table_schema = " + quoted( cDatabaseMySQL ) + " " +  "AND table_name = " + quoted( cTableName )

   BEGIN SEQUENCE WITH { | oErr | Break( oErr ) }

      oStatement           := getSQLDatabase():oConexion:Query( cSentence )

      aSchemaColumns       := oStatement:fetchAll( 2 )

   RECOVER USING oError

      eval( errorBlock(), oError )

   ALWAYS

      if !empty( oStatement )
        oStatement:free()
      end

   end

   if empty( aSchemaColumns ) .OR. !hb_isarray( aSchemaColumns )
      RETURN ( nil )
   end

RETURN ( aSchemaColumns )



static FUNCTION SQLMigrations_addModels( ) ; local Self AS CLASS SQLMigrations := QSelf() AS CLASS SQLMigrations

RETURN ( ::aModels )



static FUNCTION SQLMigrations_readgestoolDatabaseJSON( ) ; local Self AS CLASS SQLMigrations := QSelf() AS CLASS SQLMigrations

   local hJson
   local cgestoolDatabase     := "gestoolDatabase.json"

   hb_jsonDecode( memoread( cgestoolDatabase ), @hJson )

   if empty( hJson )
      RETURN ( .F. )
   end

   ::hJson                    := hJson

RETURN ( .T. )
