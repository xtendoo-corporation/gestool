#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 6 ".\Prg\Models\SqlStockModel.prg"
_HB_CLASS SQLStockModel ; function SQLStockModel ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "SQLStockModel", iif( .T., { @SQLBaseModel() }, { @HBObject() } ), @SQLStockModel() ) ) ;

   _HB_MEMBER { cTableName } ; oClass:AddMultiData(, "stock", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cTableName"}, .F. )

   _HB_MEMBER getColumns(); oClass:AddMethod( "getColumns", @SQLStockModel_getColumns(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ClearTable(); oClass:AddMethod( "ClearTable", @SQLStockModel_ClearTable(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER RecalculaStock(); oClass:AddMethod( "RecalculaStock", @SQLStockModel_RecalculaStock(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER insertOrUpdate( hBuffer, lSuma); oClass:AddMethod( "insertOrUpdate", @SQLStockModel_insertOrUpdate(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER existeStock( hBuffer, lSuma); oClass:AddMethod( "existeStock", @SQLStockModel_existeStock(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER insertStock( hBuffer, lSuma); oClass:AddMethod( "insertStock", @SQLStockModel_insertStock(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER updateStock( hBuffer, lSuma); oClass:AddMethod( "updateStock", @SQLStockModel_updateStock(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER insertOrUpdateConsolidacion( hBuffer, lSuma); oClass:AddMethod( "insertOrUpdateConsolidacion", @SQLStockModel_insertOrUpdateConsolidacion(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER insertConsolidacion( hBuffer, lSuma); oClass:AddMethod( "insertConsolidacion", @SQLStockModel_insertConsolidacion(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER updateConsolidacion( hBuffer, lSuma); oClass:AddMethod( "updateConsolidacion", @SQLStockModel_updateConsolidacion(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER RollBackStockAnterior( hBuffer); oClass:AddMethod( "RollBackStockAnterior", @SQLStockModel_RollBackStockAnterior(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER sumaRestaStock(); oClass:AddInline( "sumaRestaStock", {|Self, hBuffer | ( ( Self ) ), ( ::sumaStock( hBuffer ), ::restaStock( hBuffer ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER sumaStock(); oClass:AddInline( "sumaStock", {|Self, hBuffer | ( ( Self ) ), ( if( ::lCheckConsolidacion( hBuffer, .T., .F. ), ::insertOrUpdate( hBuffer, .T., .F. ), ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER restaStock(); oClass:AddInline( "restaStock", {|Self, hBuffer | ( ( Self ) ), ( if( ::lCheckConsolidacion( hBuffer, .F., .F. ), ::insertOrUpdate( hBuffer, .F., .F. ), ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER sumaRestaRollBackStock(); oClass:AddInline( "sumaRestaRollBackStock", {|Self, hBuffer | ( ( Self ) ), ( ::sumaRollBackStock( hBuffer ), ::restaRollBackStock( hBuffer ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER sumaRollBackStock(); oClass:AddInline( "sumaRollBackStock", {|Self, hBuffer | ( ( Self ) ), ( if( ::lCheckConsolidacion( hBuffer, .F., .T. ), ::insertOrUpdate( hBuffer, .F., .T. ), ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER restaRollBackStock(); oClass:AddInline( "restaRollBackStock", {|Self, hBuffer | ( ( Self ) ), ( if( ::lCheckConsolidacion( hBuffer, .T., .T. ), ::insertOrUpdate( hBuffer, .T., .T. ), ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getAlmacen( hBuffer, lSuma, lRollBack); oClass:AddMethod( "getAlmacen", @SQLStockModel_getAlmacen(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER lCheckConsolidacion( hBuffer); oClass:AddMethod( "lCheckConsolidacion", @SQLStockModel_lCheckConsolidacion(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getStockArticulo( hBuffer); oClass:AddMethod( "getStockArticulo", @SQLStockModel_getStockArticulo(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER aStockArticulo( cCodigoArticulo, cCodigoAlmacen, cCodigoPrimeraPropiedad, cValorPrimeraPropiedad, cCodigoSegundaPropiedad, cValorSegundaPropiedad, cLote); oClass:AddMethod( "aStockArticulo", @SQLStockModel_aStockArticulo(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER getBufferArticulo( cCodigoArticulo, cCodigoAlmacen, cCodigoPrimeraPropiedad, cValorPrimeraPropiedad, cCodigoSegundaPropiedad, cValorSegundaPropiedad, cLote); oClass:AddMethod( "getBufferArticulo", @SQLStockModel_getBufferArticulo(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER nStockArticulo( cCodigoArticulo, cCodigoAlmacen, cCodigoPrimeraPropiedad, cValorPrimeraPropiedad, cCodigoSegundaPropiedad, cValorSegundaPropiedad, cLote); oClass:AddMethod( "nStockArticulo", @SQLStockModel_nStockArticulo(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER lPutStockActual( cCodigoArticulo, cCodigoAlmacen, cCodigoPrimeraPropiedad, cValorPrimeraPropiedad, cCodigoSegundaPropiedad, cValorSegundaPropiedad, cLote, oGet); oClass:AddMethod( "lPutStockActual", @SQLStockModel_lPutStockActual(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER existePendiente( hBuffer); oClass:AddMethod( "existePendiente", @SQLStockModel_existePendiente(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER insertOrUpdatePendienteEntregar( hBuffer, lRollBack); oClass:AddMethod( "insertOrUpdatePendienteEntregar", @SQLStockModel_insertOrUpdatePendienteEntregar(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER insertPendienteEntregar( hBuffer, lRollback); oClass:AddMethod( "insertPendienteEntregar", @SQLStockModel_insertPendienteEntregar(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER updatePendienteEntregar( hBuffer, lRollBack); oClass:AddMethod( "updatePendienteEntregar", @SQLStockModel_updatePendienteEntregar(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER insertOrUpdatePendienteRecibir( hBuffer, lRollBack); oClass:AddMethod( "insertOrUpdatePendienteRecibir", @SQLStockModel_insertOrUpdatePendienteRecibir(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER insertPendienteRecibir( hBuffer, lRollback); oClass:AddMethod( "insertPendienteRecibir", @SQLStockModel_insertPendienteRecibir(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER updatePendienteRecibir( hBuffer, lRollBack); oClass:AddMethod( "updatePendienteRecibir", @SQLStockModel_updatePendienteRecibir(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS SQLStockModel ;



static FUNCTION SQLStockModel_getColumns( ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel


   hset( ::hColumns, "id",                         {  "create"    => "INTEGER AUTO_INCREMENT UNIQUE"  , "default"   => {|| 0 } }                        )

   ::getEmpresaColumns()


   hset( ::hColumns, "codigo_articulo",            {  "create"    => "VARCHAR( 18 )"                  , "default"   => {|| space( 18 ) } }              )


   hset( ::hColumns, "codigo_almacen",             {  "create"    => "VARCHAR( 16 )"                  , "default"   => {|| space( 16 ) } }              )


   hset( ::hColumns, "codigo_primera_propiedad",   {  "create"    => "VARCHAR(20)"                    , "default"   => {|| space(20) } }                )


   hset( ::hColumns, "valor_primera_propiedad",    {  "create"    => "VARCHAR(200)"                   , "default"   => {|| space(200) } }               )


   hset( ::hColumns, "codigo_segunda_propiedad",   {  "create"    => "VARCHAR(20)"                    , "default"   => {|| space(20) } }                )


   hset( ::hColumns, "valor_segunda_propiedad",    {  "create"    => "VARCHAR(200)"                   , "default"   => {|| space(200) } }               )


   hset( ::hColumns, "lote",                       {  "create"    => "VARCHAR(40)"                    , "default"   => {|| space(40) } }                )


   hset( ::hColumns, "bultos_articulo",            {  "create"    => "DECIMAL(19,6)"                  , "default"   => {|| 0 } }                        )


   hset( ::hColumns, "cajas_articulo",             {  "create"    => "DECIMAL(19,6)"                  , "default"   => {|| 0 } }                        )


   hset( ::hColumns, "unidades_articulo",          {  "create"    => "DECIMAL(19,6)"                  , "default"   => {|| 0 } }                        )


   hset( ::hColumns, "pendiente_entregar",          {  "create"    => "DECIMAL(19,6)"                  , "default"   => {|| 0 } }                        )


   hset( ::hColumns, "pendiente_recibir",          {  "create"    => "DECIMAL(19,6)"                  , "default"   => {|| 0 } }                        )

RETURN ( ::hColumns )



static FUNCTION SQLStockModel_ClearTable( ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local cStm
   local cSentence   := "DELETE FROM " + ::getTableName() + " WHERE empresa_codigo=" + quoted( cCodEmp() )

   getSQLDatabase():Exec( cSentence )

Return ( .T. )



static FUNCTION SQLStockModel_RecalculaStock( aAdsStock ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local cSentence   := ""

   cSentence         := "INSERT INTO " + ::getTableName()
   cSentence         += " ( empresa_codigo, "
   cSentence         += "usuario_codigo, "
   cSentence         += "codigo_articulo, "
   cSentence         += "codigo_almacen, "
   cSentence         += "codigo_primera_propiedad, "
   cSentence         += "valor_primera_propiedad, "
   cSentence         += "codigo_segunda_propiedad, "
   cSentence         += "valor_segunda_propiedad, "
   cSentence         += "lote, "
   cSentence         += "bultos_articulo, "
   cSentence         += "cajas_articulo, "
   cSentence         += "unidades_articulo, "
   cSentence         += "pendiente_entregar, "
   cSentence         += "pendiente_recibir ) "
   cSentence         += "VALUES ( "
   cSentence         += toSQLString( cCodEmp() ) + ", "
   cSentence         += toSQLString( Auth():Codigo() ) + ", "
   cSentence         += toSQLString( aAdsStock:cCodigo ) + ", "
   cSentence         += toSQLString( aAdsStock:cCodigoAlmacen ) + ", "
   cSentence         += toSQLString( aAdsStock:cCodigoPropiedad1 ) + ", "
   cSentence         += toSQLString( aAdsStock:cValorPropiedad1 ) + ", "
   cSentence         += toSQLString( aAdsStock:cCodigoPropiedad2 ) + ", "
   cSentence         += toSQLString( aAdsStock:cValorPropiedad2 ) + ", "
   cSentence         += toSQLString( aAdsStock:cLote ) + ", "
   cSentence         += toSQLString( aAdsStock:nBultos ) + ", "
   cSentence         += toSQLString( aAdsStock:nCajas ) + ", "
   cSentence         += toSQLString( aAdsStock:nUnidades ) + ", "
   cSentence         += toSQLString( aAdsStock:nPendientesEntregar ) + ", "
   cSentence         += toSQLString( aAdsStock:nPendientesRecibir ) + " )"

   getSQLDatabase():Exec( cSentence )

Return ( .T. )



static FUNCTION SQLStockModel_getAlmacen( hBuffer, lSuma, lRollBack ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local cCodigoAlmacen

   if lRollBack

      if lSuma
         cCodigoAlmacen := hGet( hBuffer, "codigo_almacen_salida" )
      else
         cCodigoAlmacen := hGet( hBuffer, "codigo_almacen_entrada" )
      end

   else

      if lSuma
         cCodigoAlmacen := hGet( hBuffer, "codigo_almacen_entrada" )
      else
         cCodigoAlmacen := hGet( hBuffer, "codigo_almacen_salida" )
      end

   end

Return cCodigoAlmacen



static FUNCTION SQLStockModel_existeStock( hBuffer, lSuma, lRollBack ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local nId
   local cSentence         := ""
   local cCodigoAlmacen    := ::getAlmacen( hBuffer, lSuma, lRollBack )

   if Empty( hBuffer )
      Return ( .F. )
   end

   if Empty( hGet( hBuffer, "codigo_articulo" ) ) .OR. Empty( cCodigoAlmacen )
      Return ( .F. )
   end

   cSentence         := "SELECT id FROM " + ::getTableName()
   cSentence         += " WHERE empresa_codigo = " + toSQLString( cCodEmp() ) + " AND "
   cSentence         += " codigo_articulo = " + toSQLString( hGet( hBuffer, "codigo_articulo" ) ) + " AND "
   cSentence         += " codigo_almacen = " + toSQLString( cCodigoAlmacen )
   cSentence         += " AND codigo_primera_propiedad = " + toSQLString( hGet( hBuffer, "codigo_primera_propiedad" ) )
   cSentence         += " AND codigo_segunda_propiedad = " + toSQLString( hGet( hBuffer, "codigo_segunda_propiedad" ) )
   cSentence         += " AND valor_primera_propiedad = " + toSQLString( hGet( hBuffer, "valor_primera_propiedad" ) )
   cSentence         += " AND valor_segunda_propiedad = " + toSQLString( hGet( hBuffer, "valor_segunda_propiedad" ) )
   cSentence         += " AND lote = " + toSQLString( hGet( hBuffer, "lote" ) )

   nId               := getSQLDatabase():getValue( cSentence )

Return ( !Empty( nId ) )



static FUNCTION SQLStockModel_insertStock( hBuffer, lSuma, lRollBack ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local cSentence         := ""
   local cCodigoAlmacen    := ::getAlmacen( hBuffer, lSuma, lRollBack )

   if Empty( hGet( hBuffer, "codigo_articulo" ) ) .OR. Empty( cCodigoAlmacen )
      Return ( .F. )
   end

   cSentence         := "INSERT INTO " + ::getTableName()
   cSentence         += " ( empresa_codigo, "
   cSentence         += "usuario_codigo, "
   cSentence         += "codigo_articulo, "
   cSentence         += "codigo_almacen, "
   cSentence         += "codigo_primera_propiedad, "
   cSentence         += "valor_primera_propiedad, "
   cSentence         += "codigo_segunda_propiedad, "
   cSentence         += "valor_segunda_propiedad, "
   cSentence         += "lote, "
   cSentence         += "bultos_articulo, "
   cSentence         += "cajas_articulo, "
   cSentence         += "unidades_articulo ) "
   cSentence         += "VALUES ( "
   cSentence         += toSQLString( cCodEmp() ) + ", "
   cSentence         += toSQLString( Auth():Codigo() ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "codigo_articulo" ) ) + ", "
   cSentence         += toSQLString( cCodigoAlmacen ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "codigo_primera_propiedad" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "valor_primera_propiedad" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "codigo_segunda_propiedad" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "valor_segunda_propiedad" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "lote" ) ) + ", "

   if lSuma
      cSentence         += toSQLString( hGet( hBuffer, "bultos_articulo" ) ) + ", "
      cSentence         += toSQLString( hGet( hBuffer, "cajas_articulo" ) ) + ", "
      cSentence         += toSQLString( hGet( hBuffer, "unidades_articulo" ) ) + " )"
   else
      cSentence         += toSQLString( ( hGet( hBuffer, "bultos_articulo" ) * - 1 ) ) + ", "
      cSentence         += toSQLString( ( hGet( hBuffer, "cajas_articulo" ) * - 1 ) ) + ", "
      cSentence         += toSQLString( ( hGet( hBuffer, "unidades_articulo" ) * - 1 ) ) + " )"
   end

   getSQLDatabase():Exec( cSentence )

Return ( .T. )



static FUNCTION SQLStockModel_updateStock( hBuffer, lSuma, lRollBack ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local cSentence         := ""
   local cCodigoAlmacen    := ::getAlmacen( hBuffer, lSuma, lRollBack )

   if Empty( hGet( hBuffer, "codigo_articulo" ) ) .OR. Empty( cCodigoAlmacen )
      Return ( .F. )
   end

   cSentence         := "UPDATE " + ::getTableName() + " SET "

   if lSuma
      cSentence      += "bultos_articulo = bultos_articulo + " + toSQLString( hGet( hBuffer, "bultos_articulo" ) ) + ", "
      cSentence      += "cajas_articulo = cajas_articulo + " + toSQLString( hGet( hBuffer, "cajas_articulo" ) ) + ", "
      cSentence      += "unidades_articulo = unidades_articulo + " + toSQLString( hGet( hBuffer, "unidades_articulo" ) )
   else
      cSentence      += "bultos_articulo = bultos_articulo - " + toSQLString( hGet( hBuffer, "bultos_articulo" ) ) + ", "
      cSentence      += "cajas_articulo = cajas_articulo - " + toSQLString( hGet( hBuffer, "cajas_articulo" ) ) + ", "
      cSentence      += "unidades_articulo = unidades_articulo - " + toSQLString( hGet( hBuffer, "unidades_articulo" ) )
   end

   cSentence         += " WHERE "
   cSentence         += "empresa_codigo = " + toSQLString( cCodEmp() ) + " AND "
   cSentence         += "codigo_articulo = " + toSQLString( hGet( hBuffer, "codigo_articulo" ) ) + " AND "
   cSentence         += "codigo_almacen = " + toSQLString( cCodigoAlmacen )
   cSentence         += " AND codigo_primera_propiedad = " + toSQLString( hGet( hBuffer, "codigo_primera_propiedad" ) )
   cSentence         += " AND valor_primera_propiedad = " + toSQLString( hGet( hBuffer, "valor_primera_propiedad" ) )
   cSentence         += " AND codigo_segunda_propiedad = " + toSQLString( hGet( hBuffer, "codigo_segunda_propiedad" ) )
   cSentence         += " AND valor_segunda_propiedad = " + toSQLString( hGet( hBuffer, "valor_segunda_propiedad" ) )
   cSentence         += " AND lote = " + toSQLString( hGet( hBuffer, "lote" ) )

   getSQLDatabase():Exec( cSentence )

Return ( .T. )



static FUNCTION SQLStockModel_insertOrUpdate( hBuffer, lSuma, lRollBack ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   if ::existeStock( hBuffer, lSuma, lRollBack )
      ::updateStock( hBuffer, lSuma, lRollBack )
   else
      ::insertStock( hBuffer, lSuma, lRollBack )
   end

Return ( nil )



static FUNCTION SQLStockModel_lCheckConsolidacion( hBuffer, lSuma, lRollBack ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local lCheck   := .F.









   lCheck         := TStock():lCheckConsolidacion( hGet( hBuffer, "codigo_articulo" ), ::getAlmacen( hBuffer, lSuma, lRollBack ), hGet( hBuffer, "codigo_primera_propiedad" ), hGet( hBuffer, "codigo_segunda_propiedad" ), hGet( hBuffer, "valor_primera_propiedad" ), hGet( hBuffer, "valor_segunda_propiedad" ), hGet( hBuffer, "lote" ), hGet( hBuffer, "fecha" ), hGet( hBuffer, "hora" ) )
Return ( lCheck )



static FUNCTION SQLStockModel_insertOrUpdateConsolidacion( hBuffer, lSuma, lRollBack ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   if ::existeStock( hBuffer, lSuma, lRollBack )
      ::updateConsolidacion( hBuffer, lSuma, lRollBack )
   else
      ::insertConsolidacion( hBuffer, lSuma, lRollBack )
   end

Return ( nil )



static FUNCTION SQLStockModel_insertConsolidacion( hBuffer, lSuma, lRollBack ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local cSentence         := ""
   local cCodigoAlmacen    := ::getAlmacen( hBuffer, lSuma, lRollBack )

   if Empty( hGet( hBuffer, "codigo_articulo" ) ) .OR. Empty( cCodigoAlmacen )
      Return ( .F. )
   end

   cSentence         := "INSERT INTO " + ::getTableName()
   cSentence         += " ( empresa_codigo, "
   cSentence         += "usuario_codigo, "
   cSentence         += "codigo_articulo, "
   cSentence         += "codigo_almacen, "
   cSentence         += "codigo_primera_propiedad, "
   cSentence         += "valor_primera_propiedad, "
   cSentence         += "codigo_segunda_propiedad, "
   cSentence         += "valor_segunda_propiedad, "
   cSentence         += "lote, "
   cSentence         += "bultos_articulo, "
   cSentence         += "cajas_articulo, "
   cSentence         += "unidades_articulo ) "
   cSentence         += "VALUES ( "
   cSentence         += toSQLString( cCodEmp() ) + ", "
   cSentence         += toSQLString( Auth():Codigo() ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "codigo_articulo" ) ) + ", "
   cSentence         += toSQLString( cCodigoAlmacen ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "codigo_primera_propiedad" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "valor_primera_propiedad" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "codigo_segunda_propiedad" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "valor_segunda_propiedad" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "lote" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "bultos_articulo" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "cajas_articulo" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "unidades_articulo" ) ) + " )"

   getSQLDatabase():Exec( cSentence )

Return ( .T. )



static FUNCTION SQLStockModel_updateConsolidacion( hBuffer, lSuma, lRollBack ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local cSentence         := ""
   local cCodigoAlmacen    := ::getAlmacen( hBuffer, lSuma, lRollBack )

   if Empty( hGet( hBuffer, "codigo_articulo" ) ) .OR. Empty( cCodigoAlmacen )
      Return ( .F. )
   end

   cSentence         := "UPDATE " + ::getTableName() + " SET "
   cSentence         += "bultos_articulo = " + toSQLString( hGet( hBuffer, "bultos_articulo" ) ) + ", "
   cSentence         += "cajas_articulo = " + toSQLString( hGet( hBuffer, "cajas_articulo" ) ) + ", "
   cSentence         += "unidades_articulo = " + toSQLString( hGet( hBuffer, "unidades_articulo" ) )
   cSentence         += " WHERE "
   cSentence         += "empresa_codigo = " + toSQLString( cCodEmp() ) + " AND "
   cSentence         += "codigo_articulo = " + toSQLString( hGet( hBuffer, "codigo_articulo" ) ) + " AND "
   cSentence         += "codigo_almacen = " + toSQLString( cCodigoAlmacen )
   cSentence         += " AND codigo_primera_propiedad = " + toSQLString( hGet( hBuffer, "codigo_primera_propiedad" ) )
   cSentence         += " AND valor_primera_propiedad = " + toSQLString( hGet( hBuffer, "valor_primera_propiedad" ) )
   cSentence         += " AND codigo_segunda_propiedad = " + toSQLString( hGet( hBuffer, "codigo_segunda_propiedad" ) )
   cSentence         += " AND valor_segunda_propiedad = " + toSQLString( hGet( hBuffer, "valor_segunda_propiedad" ) )
   cSentence         += " AND lote = " + toSQLString( hGet( hBuffer, "lote" ) )

   getSQLDatabase():Exec( cSentence )

Return ( .T. )



static FUNCTION SQLStockModel_RollBackStockAnterior( hBuffer ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local aStock
   local oStock

   oStock               := TStock():Create( cPatEmp() )
   oStock:lOpenFiles()














   aStock := oStock:aStockArticulo(    hGet( hBuffer, "codigo_articulo" ), hGet( hBuffer, "codigo_almacen_entrada" ), hGet( hBuffer, "lote" ), hGet( hBuffer, "codigo_primera_propiedad" ), hGet( hBuffer, "valor_primera_propiedad" ), hGet( hBuffer, "codigo_segunda_propiedad" ), hGet( hBuffer, "valor_segunda_propiedad" ), , , , , cCodEmp() )

   if !Empty( oStock )
      oStock:end()
   end



   hSet( hBuffer, "bultos_articulo", aStock[1]:nBultos )
   hSet( hBuffer, "cajas_articulo", aStock[1]:nCajas )
   hSet( hBuffer, "unidades_articulo", aStock[1]:nUnidades )



   if ::lCheckConsolidacion( hBuffer, .T., .F. )
      ::insertOrUpdateConsolidacion( hBuffer, .T., .F. )
   end

Return ( .T. )



static FUNCTION SQLStockModel_getStockArticulo( hBuffer ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local aStock      := {}
   local cSentence   := ""

   if Empty( hBuffer )
      return( aStock )
   end

   if !hhaskey( hBuffer, "codigo_articulo" ) .OR. Empty( hGet( hBuffer, "codigo_articulo" ) )
      return( aStock )
   end

   cSentence         := "Select * FROM " + ::getTableName() + space( 1 )
   cSentence         += "WHERE empresa_codigo = " + toSQLString( cCodEmp() ) + " AND codigo_articulo = " + toSQLString( hGet( hBuffer, "codigo_articulo" ) )

   if hhaskey( hBuffer, "codigo_almacen" ) .AND. !Empty( hGet( hBuffer, "codigo_almacen" ) )
      cSentence      += " AND codigo_almacen = " + toSQLString( hGet( hBuffer, "codigo_almacen" ) )
   end

   if hhaskey( hBuffer, "codigo_primera_propiedad" ) .AND. !Empty( hGet( hBuffer, "codigo_primera_propiedad" ) )
      cSentence      += " AND codigo_primera_propiedad = " + toSQLString( hGet( hBuffer, "codigo_primera_propiedad" ) )
   end

   if hhaskey( hBuffer, "valor_primera_propiedad" ) .AND. !Empty( hGet( hBuffer, "valor_primera_propiedad" ) )
      cSentence      += " AND valor_primera_propiedad = " + toSQLString( hGet( hBuffer, "valor_primera_propiedad" ) )
   end

   if hhaskey( hBuffer, "codigo_segunda_propiedad" ) .AND. !Empty( hGet( hBuffer, "codigo_segunda_propiedad" ) )
      cSentence      += " AND codigo_segunda_propiedad = " + toSQLString( hGet( hBuffer, "codigo_segunda_propiedad" ) )
   end

   if hhaskey( hBuffer, "valor_segunda_propiedad" ) .AND. !Empty( hGet( hBuffer, "valor_segunda_propiedad" ) )
      cSentence      += " AND valor_segunda_propiedad = " + toSQLString( hGet( hBuffer, "valor_segunda_propiedad" ) )
   end

   if hhaskey( hBuffer, "lote" ) .AND. !Empty( hGet( hBuffer, "lote" ) )
      cSentence      += " AND lote = " + toSQLString( hGet( hBuffer, "lote" ) )
   end

   cSentence         += " ORDER BY codigo_almacen, valor_primera_propiedad, valor_segunda_propiedad, valor_segunda_propiedad, lote ASC"

   aStock            := getSQLDatabase():selectFetchHash( cSentence )

   if !hb_isArray( aStock )
      aStock         := {}
   end

Return ( aStock )



static FUNCTION SQLStockModel_getBufferArticulo( cCodigoArticulo, cCodigoAlmacen, cCodigoPrimeraPropiedad, cValorPrimeraPropiedad, cCodigoSegundaPropiedad, cValorSegundaPropiedad, cLote ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local hBuffer  := {=>}

   if !Empty( cCodigoArticulo )
      hset( hBuffer, "codigo_articulo", AllTrim( cCodigoArticulo ) )
   end

   if !Empty( cCodigoAlmacen )
      hset( hBuffer, "codigo_almacen", AllTrim( cCodigoAlmacen ) )
   end

   if !Empty( cCodigoPrimeraPropiedad )
      hset( hBuffer, "codigo_primera_propiedad", AllTrim( cCodigoPrimeraPropiedad ) )
   end

   if !Empty( cValorPrimeraPropiedad )
      hset( hBuffer, "valor_primera_propiedad", AllTrim( cValorPrimeraPropiedad ) )
   end

   if !Empty( cCodigoSegundaPropiedad )
      hset( hBuffer, "codigo_segunda_propiedad", AllTrim( cCodigoSegundaPropiedad ) )
   end

   if !Empty( cValorSegundaPropiedad )
      hset( hBuffer, "valor_segunda_propiedad", AllTrim( cValorSegundaPropiedad ) )
   end

   if !Empty( cLote )
      hset( hBuffer, "lote", AllTrim( cLote ) )
   end

RETURN ( hBuffer )



static FUNCTION SQLStockModel_aStockArticulo( cCodigoArticulo, cCodigoAlmacen, cCodigoPrimeraPropiedad, cValorPrimeraPropiedad, cCodigoSegundaPropiedad, cValorSegundaPropiedad, cLote ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

Return ( ::getStockArticulo( ::getBufferArticulo( cCodigoArticulo, cCodigoAlmacen, cCodigoPrimeraPropiedad, cValorPrimeraPropiedad, cCodigoSegundaPropiedad, cValorSegundaPropiedad, cLote ) ) )



static FUNCTION SQLStockModel_nStockArticulo( cCodigoArticulo, cCodigoAlmacen, cCodigoPrimeraPropiedad, cValorPrimeraPropiedad, cCodigoSegundaPropiedad, cValorSegundaPropiedad, cLote ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local aStock         := {}
   local nStockArticulo := 0

   aStock               := ::aStockArticulo( cCodigoArticulo, cCodigoAlmacen, cCodigoPrimeraPropiedad, cValorPrimeraPropiedad, cCodigoSegundaPropiedad, cValorSegundaPropiedad, cLote )

   if hb_isArray( aStock ) .AND. len( aStock ) > 0
      aEval( aStock, {|h| nStockArticulo += hGet( h, "unidades_articulo" ) } )
   end

RETURN ( nStockArticulo )



static FUNCTION SQLStockModel_lPutStockActual( cCodigoArticulo, cCodigoAlmacen, cCodigoPrimeraPropiedad, cCodigoSegundaPropiedad, cValorPrimeraPropiedad, cValorSegundaPropiedad, cLote, oGet ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local nStock   := 0
   local cClass   := ""

   if !uFieldEmpresa( "lNStkAct" )
      nStock      := ::nStockArticulo( cCodigoArticulo, cCodigoAlmacen, cCodigoPrimeraPropiedad, cValorPrimeraPropiedad, cCodigoSegundaPropiedad, cValorSegundaPropiedad, cLote )
   end

   if !empty( oGet )

      cClass      := oGet:ClassName()

      do case
         case cClass == "TGET" .OR. cClass == "TGETHLP" .OR. cClass == "TGRIDGET"
            oGet:cText( nStock )
         case cClass == "TSAY"
            oGet:SetText( nStock )
      end

   end

RETURN ( .T. )







static FUNCTION SQLStockModel_existePendiente( hBuffer ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local nId
   local cSentence         := ""

   if Empty( hBuffer )
      Return ( .F. )
   end

   if Empty( hGet( hBuffer, "codigo_articulo" ) ) .OR. Empty( hGet( hBuffer, "codigo_almacen_salida" ) )
      Return ( .F. )
   end

   cSentence         := "SELECT id FROM " + ::getTableName()
   cSentence         += " WHERE empresa_codigo = " + toSQLString( cCodEmp() ) + " AND "
   cSentence         += " codigo_articulo = " + toSQLString( hGet( hBuffer, "codigo_articulo" ) ) + " AND "
   cSentence         += " codigo_almacen = " + toSQLString( hGet( hBuffer, "codigo_almacen_salida" ) )
   cSentence         += " AND codigo_primera_propiedad = " + toSQLString( hGet( hBuffer, "codigo_primera_propiedad" ) )
   cSentence         += " AND codigo_segunda_propiedad = " + toSQLString( hGet( hBuffer, "codigo_segunda_propiedad" ) )
   cSentence         += " AND valor_primera_propiedad = " + toSQLString( hGet( hBuffer, "valor_primera_propiedad" ) )
   cSentence         += " AND valor_segunda_propiedad = " + toSQLString( hGet( hBuffer, "valor_segunda_propiedad" ) )





   nId               := getSQLDatabase():getValue( cSentence )

Return ( !Empty( nId ) )



static FUNCTION SQLStockModel_insertOrUpdatePendienteEntregar( hBuffer, lRollBack ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   if ::existePendiente( hBuffer )
      ::updatePendienteEntregar( hBuffer, lRollBack )
   else
      ::insertPendienteEntregar( hBuffer, lRollBack )
   end

Return ( nil )



static FUNCTION SQLStockModel_insertPendienteEntregar( hBuffer, lRollback ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local cSentence         := ""

   If( lRollback == nil, lRollback := .F., ) ;

   if Empty( hGet( hBuffer, "codigo_articulo" ) ) .OR. Empty( hGet( hBuffer, "codigo_almacen_salida" ) )
      Return ( .F. )
   end

   cSentence         := "INSERT INTO " + ::getTableName()
   cSentence         += " ( empresa_codigo, "
   cSentence         += "usuario_codigo, "
   cSentence         += "codigo_articulo, "
   cSentence         += "codigo_almacen, "
   cSentence         += "codigo_primera_propiedad, "
   cSentence         += "valor_primera_propiedad, "
   cSentence         += "codigo_segunda_propiedad, "
   cSentence         += "valor_segunda_propiedad, "
   cSentence         += "lote, "
   cSentence         += "bultos_articulo, "
   cSentence         += "cajas_articulo, "
   cSentence         += "unidades_articulo, "
   cSentence         += "pendiente_recibir, "
   cSentence         += "pendiente_entregar ) "
   cSentence         += "VALUES ( "
   cSentence         += toSQLString( cCodEmp() ) + ", "
   cSentence         += toSQLString( Auth():Codigo() ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "codigo_articulo" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "codigo_almacen_salida" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "codigo_primera_propiedad" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "valor_primera_propiedad" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "codigo_segunda_propiedad" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "valor_segunda_propiedad" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "lote" ) ) + ", "
   cSentence         += "0, "
   cSentence         += "0, "
   cSentence         += "0, "
   cSentence         += "0, "

   if !lRollback
      cSentence      += toSQLString( hGet( hBuffer, "pendiente_entregar" ) ) + " )"
   else
      cSentence      += toSQLString( ( hGet( hBuffer, "pendiente_entregar" ) * - 1 ) ) + " )"
   end

   getSQLDatabase():Exec( cSentence )

Return ( .T. )



static FUNCTION SQLStockModel_updatePendienteEntregar( hBuffer, lRollBack ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local cSentence         := ""

   If( lRollback == nil, lRollback := .F., ) ;

   if Empty( hGet( hBuffer, "codigo_articulo" ) ) .OR. Empty( hGet( hBuffer, "codigo_almacen_salida" ) )
      Return ( .F. )
   end

   cSentence         := "UPDATE " + ::getTableName() + " SET "

   if !lRollback
      cSentence      += "pendiente_entregar = pendiente_entregar + " + toSQLString( hGet( hBuffer, "pendiente_entregar" ) )
   else
      cSentence      += "pendiente_entregar = pendiente_entregar - " + toSQLString( hGet( hBuffer, "pendiente_entregar" ) )
   end

   cSentence         += " WHERE "
   cSentence         += "empresa_codigo = " + toSQLString( cCodEmp() ) + " AND "
   cSentence         += "codigo_articulo = " + toSQLString( hGet( hBuffer, "codigo_articulo" ) ) + " AND "
   cSentence         += "codigo_almacen = " + toSQLString( hGet( hBuffer, "codigo_almacen_salida" ) )
   cSentence         += " AND codigo_primera_propiedad = " + toSQLString( hGet( hBuffer, "codigo_primera_propiedad" ) )
   cSentence         += " AND valor_primera_propiedad = " + toSQLString( hGet( hBuffer, "valor_primera_propiedad" ) )
   cSentence         += " AND codigo_segunda_propiedad = " + toSQLString( hGet( hBuffer, "codigo_segunda_propiedad" ) )
   cSentence         += " AND valor_segunda_propiedad = " + toSQLString( hGet( hBuffer, "valor_segunda_propiedad" ) )





   getSQLDatabase():Exec( cSentence )

Return ( .T. )



static FUNCTION SQLStockModel_insertOrUpdatePendienteRecibir( hBuffer, lRollBack ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   if ::existePendiente( hBuffer )
      ::updatePendienteRecibir( hBuffer, lRollBack )
   else
      ::insertPendienteRecibir( hBuffer, lRollBack )
   end

Return ( nil )



static FUNCTION SQLStockModel_insertPendienteRecibir( hBuffer, lRollback ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local cSentence         := ""

   If( lRollback == nil, lRollback := .F., ) ;

   if Empty( hGet( hBuffer, "codigo_articulo" ) ) .OR. Empty( hGet( hBuffer, "codigo_almacen_salida" ) )
      Return ( .F. )
   end

   cSentence         := "INSERT INTO " + ::getTableName()
   cSentence         += " ( empresa_codigo, "
   cSentence         += "usuario_codigo, "
   cSentence         += "codigo_articulo, "
   cSentence         += "codigo_almacen, "
   cSentence         += "codigo_primera_propiedad, "
   cSentence         += "valor_primera_propiedad, "
   cSentence         += "codigo_segunda_propiedad, "
   cSentence         += "valor_segunda_propiedad, "
   cSentence         += "lote, "
   cSentence         += "bultos_articulo, "
   cSentence         += "cajas_articulo, "
   cSentence         += "unidades_articulo, "
   cSentence         += "pendiente_entregar, "
   cSentence         += "pendiente_recibir ) "
   cSentence         += "VALUES ( "
   cSentence         += toSQLString( cCodEmp() ) + ", "
   cSentence         += toSQLString( Auth():Codigo() ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "codigo_articulo" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "codigo_almacen_salida" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "codigo_primera_propiedad" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "valor_primera_propiedad" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "codigo_segunda_propiedad" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "valor_segunda_propiedad" ) ) + ", "
   cSentence         += toSQLString( hGet( hBuffer, "lote" ) ) + ", "
   cSentence         += "0, "
   cSentence         += "0, "
   cSentence         += "0, "
   cSentence         += "0, "

   if !lRollback
      cSentence         += toSQLString( hGet( hBuffer, "pendiente_recibir" ) ) + " )"
   else
      cSentence         += toSQLString( ( hGet( hBuffer, "pendiente_recibir" ) * - 1 ) ) + " )"
   end

   getSQLDatabase():Exec( cSentence )

Return ( .T. )



static FUNCTION SQLStockModel_updatePendienteRecibir( hBuffer, lRollBack ) ; local Self AS CLASS SQLStockModel := QSelf() AS CLASS SQLStockModel

   local cSentence         := ""

   If( lRollback == nil, lRollback := .F., ) ;

   if Empty( hGet( hBuffer, "codigo_articulo" ) ) .OR. Empty( hGet( hBuffer, "codigo_almacen_salida" ) )
      Return ( .F. )
   end

   cSentence         := "UPDATE " + ::getTableName() + " SET "

   if !lRollback
      cSentence      += "pendiente_recibir = pendiente_recibir + " + toSQLString( hGet( hBuffer, "pendiente_recibir" ) )
   else
      cSentence      += "pendiente_recibir = pendiente_recibir - " + toSQLString( hGet( hBuffer, "pendiente_recibir" ) )
   end

   cSentence         += " WHERE "
   cSentence         += "empresa_codigo = " + toSQLString( cCodEmp() ) + " AND "
   cSentence         += "codigo_articulo = " + toSQLString( hGet( hBuffer, "codigo_articulo" ) ) + " AND "
   cSentence         += "codigo_almacen = " + toSQLString( hGet( hBuffer, "codigo_almacen_salida" ) )
   cSentence         += " AND codigo_primera_propiedad = " + toSQLString( hGet( hBuffer, "codigo_primera_propiedad" ) )
   cSentence         += " AND valor_primera_propiedad = " + toSQLString( hGet( hBuffer, "valor_primera_propiedad" ) )
   cSentence         += " AND codigo_segunda_propiedad = " + toSQLString( hGet( hBuffer, "codigo_segunda_propiedad" ) )
   cSentence         += " AND valor_segunda_propiedad = " + toSQLString( hGet( hBuffer, "valor_segunda_propiedad" ) )





   getSQLDatabase():Exec( cSentence )

Return ( .T. )
