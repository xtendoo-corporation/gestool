#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 16 ".\.\Prg\TFTPLinux.prg"
_HB_CLASS TFtpLinux ; function TFtpLinux ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TFtpLinux", iif( .F., { }, { @HBObject() } ), @TFtpLinux() ) ) ;

   _HB_MEMBER { oFTP } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oFTP"}, .F. )
   _HB_MEMBER { cError } ; oClass:AddMultiData(, "", nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cError"}, .F. )

   _HB_MEMBER { lHasSSL } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lHasSSL"}, .F. )

   _HB_MEMBER { TComercioConfig } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"TComercioConfig"}, .F. )

   _HB_MEMBER { cServer } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cServer"}, .F. )
   _HB_MEMBER { cUser } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cUser"}, .F. )
   _HB_MEMBER { cPassword } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cPassword"}, .F. )
   _HB_MEMBER { nPort } ; oClass:AddMultiData(, 21, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nPort"}, .F. )

   _HB_MEMBER { lPassive } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lPassive"}, .F. )

   _HB_MEMBER new( cUser, cPassword, cServer, nPort); oClass:AddMethod( "new", @TFtpLinux_new(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER newPrestashopConfig( TComercioConfig); oClass:AddMethod( "newPrestashopConfig", @TFtpLinux_newPrestashopConfig(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER createConexion(); oClass:AddMethod( "createConexion", @TFtpLinux_createConexion(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER endConexion(); oClass:AddMethod( "endConexion", @TFtpLinux_endConexion(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER setPassive(); oClass:AddInline( "setPassive", {|Self, lPassive | ( ( Self ) ), ( if( hb_islogical( lPassive ), ::lPassive := lPassive, ::lPassive ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getError(); oClass:AddInline( "getError", {|Self | ( ( Self ) ), ( ::cError ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER createDirectory( cCarpeta); oClass:AddMethod( "createDirectory", @TFtpLinux_createDirectory(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER createDirectoryRecursive( cCarpeta); oClass:AddMethod( "createDirectoryRecursive", @TFtpLinux_createDirectoryRecursive(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER returnDirectory( cCarpeta); oClass:AddMethod( "returnDirectory", @TFtpLinux_returnDirectory(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER createFile( cFile, cDirectory); oClass:AddMethod( "createFile", @TFtpLinux_createFile(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )





   _HB_MEMBER say(); oClass:AddInline( "say", {|Self | ( ( Self ) ), ( msgInfo( "Server : "    + ::TComercioConfig:getFtpServer()   + Chr(13)+Chr(10) +  "User : "      + ::TComercioConfig:getFtpUser()     + Chr(13)+Chr(10) +  "Password : "  + ::TComercioConfig:getFtpPassword() + Chr(13)+Chr(10) +  if( ::TComercioConfig:getFtpPassive(), "Passive", "No passive" ),  "ClassName : " + ::ClassName() ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TFtpLinux ;



static FUNCTION TFtpLinux_new( cUser, cPassword, cServer, nPort ) ; local Self AS CLASS TFtpLinux := QSelf() AS CLASS TFtpLinux

   If( nPort == nil, nPort := 21, ) ;

   ::cUser        := cUser
   ::cPassword    := cPassword
   ::cServer      := cServer
   ::nPort        := nPort

RETURN ( Self )



static FUNCTION TFtpLinux_newPrestashopConfig( TComercioConfig ) ; local Self AS CLASS TFtpLinux := QSelf() AS CLASS TFtpLinux

   ::TComercioConfig  := TComercioConfig

   ::New( ::TComercioConfig:getFtpUser(), ::TComercioConfig:getFtpPassword(), ::TComercioConfig:getFtpServer(), ::TComercioConfig:getFtpPort() )

RETURN ( Self )



static FUNCTION TFtpLinux_createConexion( ) ; local Self AS CLASS TFtpLinux := QSelf() AS CLASS TFtpLinux

   local cStr
   local cUrl
   local oUrl
   local lOpen             := .F.

   if !empty( ::TComercioConfig:getFtpServer() )

      cUrl                 := "ftp://" + ::cUser + ":" + ::cPassword + "@" + ::cServer













      lOpen                := ::oFTP:Open()
      if !lOpen

         ::cError          := "Could not connect to FTP server " + oURL:cServer
         if empty( ::oFTP:SocketCon )
            ::cError       += hb_eol() + "Connection not initialized"
         elseif hb_inetErrorCode( ::oFTP:SocketCon ) == 0
            ::cError       += hb_eol() + "Server response:" + " " + ::oFTP:cReply
         else
            ::cError       += hb_eol() + "Error in connection:" + " " + hb_inetErrorDesc( ::oFTP:SocketCon )
         endif

         msgStop( ::cError )

      end

   end

RETURN ( lOpen )



static FUNCTION TFtpLinux_endConexion( ) ; local Self AS CLASS TFtpLinux := QSelf() AS CLASS TFtpLinux

   if !empty( ::oFTP )
      ::oFTP:Close()
   end

Return( nil )



static FUNCTION TFtpLinux_createDirectory( cCarpeta ) ; local Self AS CLASS TFtpLinux := QSelf() AS CLASS TFtpLinux

   if !empty( ::oFtp )
      ::oFtp:MKD( cCarpeta )
      ::oFtp:CWD( cCarpeta )
   end

RETURN ( .T. )



static FUNCTION TFtpLinux_createDirectoryRecursive( cCarpeta ) ; local Self AS CLASS TFtpLinux := QSelf() AS CLASS TFtpLinux

   local n

   for n := 1 to len( cCarpeta )
      ::CreateDirectory( substr( cCarpeta, n, 1 ) )
   next

RETURN ( .T. )



static FUNCTION TFtpLinux_createFile( cFile ) ; local Self AS CLASS TFtpLinux := QSelf() AS CLASS TFtpLinux

   local lCreate  := .F.

   if !empty( ::oFtp )
      lCreate     := ::oFtp:UploadFile( cFile )
   end

RETURN ( lCreate )



static FUNCTION TFtpLinux_returnDirectory( cCarpeta ) ; local Self AS CLASS TFtpLinux := QSelf() AS CLASS TFtpLinux

   local n

   if !empty( ::oFtp )
      for n := 1 to len( cCarpeta )
         ::oFtp:CWD( ".." )
      next
   end

RETURN ( nil )













_HB_CLASS TFTPWindows ; function TFTPWindows ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TFTPWindows", iif( .T., { @TFtpLinux() }, { @HBObject() } ), @TFTPWindows() ) ) ;

   _HB_MEMBER { oInt } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oInt"}, .F. )

   _HB_MEMBER createConexion(); oClass:AddMethod( "createConexion", @TFTPWindows_createConexion(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER endConexion(); oClass:AddMethod( "endConexion", @TFTPWindows_endConexion(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER createDirectory( cCarpeta); oClass:AddMethod( "createDirectory", @TFTPWindows_createDirectory(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER returnDirectory( cCarpeta); oClass:AddMethod( "returnDirectory", @TFTPWindows_returnDirectory(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER createFile( cFile, cDirectory); oClass:AddMethod( "createFile", @TFTPWindows_createFile(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TFTPWindows ;



static FUNCTION TFTPWindows_createConexion( ) ; local Self AS CLASS TFTPWindows := QSelf() AS CLASS TFTPWindows

   local lCreate     := .F.

   if !empty( ::cServer )

      ::oInt         := TInternet():New()
      ::oFtp         := TFtp():New( ::cServer, ::oInt, ::cUser, ::cPassword, ::lPassive )

      if !empty( ::oFtp )
         lCreate     := ( ::oFtp:hFtp <> 0 )
      end

   end

RETURN ( lCreate )



static FUNCTION TFTPWindows_endConexion( ) ; local Self AS CLASS TFTPWindows := QSelf() AS CLASS TFTPWindows

   if !empty( ::oInt )
      ::oInt:end()
   end

   if !empty( ::oFtp )
      ::oFtp:end()
   end

Return( nil )



static FUNCTION TFTPWindows_createDirectory( cCarpeta ) ; local Self AS CLASS TFTPWindows := QSelf() AS CLASS TFTPWindows

   if !empty( ::oFtp )
      ::oFtp:CreateDirectory( cCarpeta )
      ::oFtp:SetCurrentDirectory( cCarpeta )
   end

RETURN ( .T. )



static FUNCTION TFTPWindows_createFile( cFile, oMeter ) ; local Self AS CLASS TFTPWindows := QSelf() AS CLASS TFTPWindows

   local oFile
   local nBytes
   local hSource
   local lPutFile    := .F.
   local cBuffer     := Space( 20000 )
   local nTotalBytes := 0
   local nWriteBytes := 0

   if !file( cFile )
      msgStop( "No existe el fichero " + alltrim( cFile ) )
      RETURN ( .F. )
   end

   oFile             := TFtpFile():New( cNoPath( cFile ), ::oFtp )
   oFile:OpenWrite()

   hSource           := fOpen( cFile )
   if ferror() == 0

      fseek( hSource, 0, 0 )

      while ( nBytes := fread( hSource, @cBuffer, 20000 ) ) > 0
         nWriteBytes += nBytes
         oFile:write( substr( cBuffer, 1, nBytes ) )
         sysrefresh()
      end

      lPutFile       := .T.

   end

   oFile:End()

   fClose( hSource )

   sysrefresh()

RETURN ( lPutFile )



static FUNCTION TFTPWindows_returnDirectory( cCarpeta ) ; local Self AS CLASS TFTPWindows := QSelf() AS CLASS TFTPWindows

   local n

   for n := 1 to len( cCarpeta )
      ::oFtp:SetCurrentDirectory( ".." )
   next

RETURN ( .T. )














_HB_CLASS TFTPCurl ; function TFTPCurl ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TFTPCurl", iif( .T., { @TFtpLinux() }, { @HBObject() } ), @TFTPCurl() ) ) ;

   _HB_MEMBER { idCurl } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"idCurl"}, .F. )
   _HB_MEMBER { cInitialDirectory } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cInitialDirectory"}, .F. )
   _HB_MEMBER { cRecursiveDirectory } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cRecursiveDirectory"}, .F. )

   _HB_MEMBER testConexion(); oClass:AddMethod( "testConexion", @TFTPCurl_testConexion(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER createConexion(); oClass:AddMethod( "createConexion", @TFTPCurl_createConexion(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER endConexion(); oClass:AddInline( "endConexion", {|Self | ( ( Self ) ), ( curl_global_cleanup() ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER createDirectory( cDirectory) ; oClass:AddVirtual( "createDirectory" )
   _HB_MEMBER createDirectoryRecursive( cDirectory) ; oClass:AddVirtual( "createDirectoryRecursive" )
   _HB_MEMBER returnDirectory( cCarpeta) ; oClass:AddVirtual( "returnDirectory" )

   _HB_MEMBER createFile( cFile, cDirectory); oClass:AddMethod( "createFile", @TFTPCurl_createFile(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER downloadFile( cFile, cDirectory); oClass:AddMethod( "downloadFile", @TFTPCurl_downloadFile(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER listFiles(); oClass:AddMethod( "listFiles", @TFTPCurl_listFiles(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER deleteFile( cFile); oClass:AddMethod( "deleteFile", @TFTPCurl_deleteFile(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TFTPCurl ;



static FUNCTION TFTPCurl_createConexion( ) ; local Self AS CLASS TFTPCurl := QSelf() AS CLASS TFTPCurl

   curl_global_init()

   ::idCurl             := curl_easy_init()

RETURN ( !empty( ::idCurl ) )



static FUNCTION TFTPCurl_testConexion( ) ; local Self AS CLASS TFTPCurl := QSelf() AS CLASS TFTPCurl

   local cURL
   local lConnected        := .F.

   if ::createConexion()

      cURL                 := "ftp://" + ::cUser + ":" + ::cPassword + "@" + ::cServer + "/"

      curl_easy_setopt( ::idCurl, 2, cURL )
      curl_easy_setopt( ::idCurl, 141, 1 )

      lConnected           := ( curl_easy_perform( ::idCurl ) == 0 )

      curl_easy_reset( ::idCurl )

   end

RETURN ( lConnected )



static FUNCTION TFTPCurl_createFile( cFile, cDirectory ) ; local Self AS CLASS TFTPCurl := QSelf() AS CLASS TFTPCurl

   local cURL
   local createFile     := .F.

   If( cDirectory == nil, cDirectory := "", ) ;

   if empty( ::idCurl )
      RETURN .F.
   endif

   if !file( cFile )
      msgStop( "El fichero " + cFile + " no se ha encontrado" )
      RETURN .F.
   endif

   if !Empty( cDirectory )
      cDirectory        := cLeftPath( cDirectory )
   end

   cURL                 := "ftp://" + ::cServer + "/" + cDirectory + cNoPath( cFile )

   curl_easy_setopt( ::idCurl, 46 )
   curl_easy_setopt( ::idCurl, 2, cURL )
   curl_easy_setopt( ::idCurl, 5, ::cUser + ":" + ::cPassword )

   curl_easy_setopt( ::idCurl, 1003, cFile )
   curl_easy_setopt( ::idCurl, 14, hb_fsize( cFile ) )
   curl_easy_setopt( ::idCurl, 110, .T. )

   createFile           := curl_easy_perform( ::idCurl )

   curl_easy_getinfo( ::idCurl, 1 )
   curl_easy_getinfo( ::idCurl, 5 )

   curl_easy_reset( ::idCurl )

RETURN ( createFile )



static FUNCTION TFTPCurl_downloadFile( cRemoteFile, cLocalFile ) ; local Self AS CLASS TFTPCurl := QSelf() AS CLASS TFTPCurl

   local cURL
   local cFile
   local downloadFile  := .F.

   if empty( ::idCurl )
      RETURN .F.
   endif

   cURL                 := "ftp://" + ::cServer + "/" + cRemoteFile

   curl_easy_setopt( ::idCurl, 1001 )
   curl_easy_setopt( ::idCurl, 2, cURL )
   curl_easy_setopt( ::idCurl, 1005, cLocalFile )
   curl_easy_setopt( ::idCurl, 5, ::cUser +  ":" + ::cPassword )
   curl_easy_setopt( ::idCurl, 41, .T. )

   downloadFile         := curl_easy_perform( ::idCurl )

   curl_easy_reset( ::idCurl )

RETURN ( downloadFile )



static FUNCTION TFTPCurl_listFiles( ) ; local Self AS CLASS TFTPCurl := QSelf() AS CLASS TFTPCurl

   local cURL
   local listFiles

   if empty( ::idCurl )
      RETURN .F.
   endif

   cURL                 := "ftp://" + ::cUser + ":" + ::cPassword + "@" + ::cServer + if( Right( ::cServer, 1 ) <> "/", "/", "" )

   curl_easy_setopt( ::idCurl, 1001 )
   curl_easy_setopt( ::idCurl, 48 )
   curl_easy_setopt( ::idCurl, 2, cURL )
   curl_easy_setopt( ::idCurl, 1008 )
   curl_easy_perform( ::idCurl )
   curl_easy_dl_buff_get( ::idCurl )
   curl_easy_setopt( ::idCurl, 1009, @listFiles )

   listFiles         := hb_atokens( listFiles, Chr(13)+Chr(10) )

   curl_easy_reset( ::idCurl )

RETURN ( listFiles )



static FUNCTION TFTPCurl_deleteFile( cFile ) ; local Self AS CLASS TFTPCurl := QSelf() AS CLASS TFTPCurl

   local cURL
   local listFiles
   local deleteFile   := .F.

   if empty( ::idCurl )
      RETURN .F.
   endif

   cURL                 := "ftp://" + ::cUser + ":" + ::cPassword + "@" + ::cServer + if( Right( ::cServer, 1 ) <> "/", "/", "" )

   curl_easy_setopt( ::idCurl, 2, cURL )
   curl_easy_setopt( ::idCurl, 39, { "DELE " + cFile } )

   deleteFile         := curl_easy_perform( ::idCurl )

   curl_easy_reset( ::idCurl )

RETURN ( deleteFile )







_HB_CLASS TSFTPCurl ; function TSFTPCurl ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TSFTPCurl", iif( .T., { @TFTPCurl() }, { @HBObject() } ), @TSFTPCurl() ) ) ;

   _HB_MEMBER testConexion(); oClass:AddMethod( "testConexion", @TSFTPCurl_testConexion(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER UrlAllEncode( cStr); oClass:AddMethod( "UrlAllEncode", @TSFTPCurl_UrlAllEncode(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER createFile( cFile, cDirectory); oClass:AddMethod( "createFile", @TSFTPCurl_createFile(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TSFTPCurl ;



static FUNCTION TSFTPCurl_testConexion( ) ; local Self AS CLASS TSFTPCurl := QSelf() AS CLASS TSFTPCurl

   local cURL
   local lConnected        := .F.
   local curlErr

   if ::createConexion()

      cURL              := "sftp://" + UrlAllEncode( ::cUser ) + ":" +  UrlAllEncode( ::cPassword ) + "@" + ::cServer

      curl_easy_reset( ::idCurl )
      curl_easy_setopt( ::idCurl, 2, cURL )
      curl_easy_setopt( ::idCurl, 141, 1 )

      lConnected           := ( curl_easy_perform( ::idCurl ) == 0 )

      curl_easy_reset( ::idCurl )

   end

RETURN ( lConnected )



static FUNCTION TSFTPCurl_UrlAllEncode( cStr ) ; local Self AS CLASS TSFTPCurl := QSelf() AS CLASS TSFTPCurl

   If( cStr == nil, cStr := "", ) ;

   cStr   := StrTran( cStr, "@", "%40" )
   cStr   := StrTran( cStr, "#", "%23" )
   cStr   := StrTran( cStr, "?", "%3F" )
   cStr   := StrTran( cStr, "\", Chr( 47 ) )
   cStr   := StrTran( cStr, "/", Chr( 47 ) )

Return cStr



static FUNCTION TSFTPCurl_createFile( cFile, cDirectory, lMessage ) ; local Self AS CLASS TSFTPCurl := QSelf() AS CLASS TSFTPCurl

   local cSftpURL
   local cErrorB
   local curlErr
   local cResultado

   If( lMessage == nil, lMessage := .F., ) ;

   if empty( cFile )
      if( lMessage, MsgStop( "No existe el fichero." ), )
      Return .F.
   endif

   if ::createConexion()





      cSftpURL := "sftp://" + UrlAllEncode( ::cUser ) + ":" +  UrlAllEncode( ::cPassword ) + "@" +  ::cServer + Chr( 47 ) +  UrlAllEncode( cDirectory ) +  cFileNoPath( cFile )

      curl_easy_reset( ::idCurl )
      curl_easy_setopt( ::idCurl, 46, 1 )
      curl_easy_setopt( ::idCurl, 50, 1 )
      curl_easy_setopt( ::idCurl, 2, cSftpURL)
      curl_easy_setopt( ::idCurl, 181, hb_bitShift( 1, 5 ))
      curl_easy_setopt( ::idCurl, 3, ::nPort)
      curl_easy_setopt( ::idCurl, 41, 1 )
      curl_easy_setopt( ::idCurl, 45, 1 )
      curl_easy_setopt( ::idCurl, 10, cErrorB )
      curl_easy_setopt( ::idCurl, 110, 1 )
      curl_easy_setopt( ::idCurl, 1003, cFile)
      curl_easy_setopt( ::idCurl, 115, FileSize( cFile ) )
      curlErr := curl_easy_perform( ::idCurl )

      if lMessage

         if !empty( curlErr )
            MsgInfo(  curl_easy_strerror( curlErr ) + " / " + cErrorB )
         else
            MsgInfo( "Fichero subido correctamente" )
         end

      end

      if !empty( ::idCurl )
         curl_easy_reset( ::idCurl )
         curl_global_cleanup( ::idCurl )
         ::idCurl    := nil
      endif

   end

RETURN ( curlErr )
