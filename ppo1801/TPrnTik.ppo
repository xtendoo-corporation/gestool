#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 36 ".\.\Prg\TPrnTik.prg"
_HB_CLASS TPort ; function TPort ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TPort", iif( .F., { }, { @HBObject() } ), @TPort() ) ) ;

   _HB_MEMBER { cPort } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cPort"}, .F. )
   _HB_MEMBER { AS LOGIC lCreated } ; oClass:AddMultiData( "LOGIC", .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lCreated"}, .F. )
   _HB_MEMBER { AS NUMERIC nHComm } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nHComm"}, .F. )
   _HB_MEMBER { cLastError } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cLastError"}, .F. )
   _HB_MEMBER { AS NUMERIC nBitsSec } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBitsSec"}, .F. )
   _HB_MEMBER { AS NUMERIC nBitsParada } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBitsParada"}, .F. )
   _HB_MEMBER { AS NUMERIC nBitsDatos } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBitsDatos"}, .F. )
   _HB_MEMBER { AS NUMERIC nBitsParidad } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBitsParidad"}, .F. )

   _HB_MEMBER New( cPort, nBitsSec, nBitsParada, nBitsDatos, nBitsParidad) AS CLASS TPort; oClass:AddMethod( "New", @TPort_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER OpenCommError(); oClass:AddMethod( "OpenCommError", @TPort_OpenCommError(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER End(); oClass:AddInline( "End", {|Self | ( ( Self ) ), ( fClose( ::nHComm ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Write( cTexto); oClass:AddMethod( "Write", @TPort_Write(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TPort ;



static FUNCTION TPort_New( cPort, nBitsSec, nBitsParada, nBitsDatos, nBitsParidad, lMessage ) ; local Self AS CLASS TPort := QSelf() AS CLASS TPort

   local fDCB

   If( cPort == nil, cPort := "COM1", ) ;
   If( nBitsSec == nil, nBitsSec := "9600", ) ;
   If( nBitsDatos == nil, nBitsDatos := "8", ) ;
   If( nBitsParada == nil, nBitsParada := "0", ) ;
   If( nBitsParidad == nil, nBitsParidad := "Sin paridad", ) ;
   If( lMessage == nil, lMessage := .F., ) ;

   ::cPort              := Rtrim( cPort )





   if ValType( nBitsSec ) == "C"
      ::nBitsSec        := Val( nBitsSec )
   else
      ::nBitsSec        := nBitsSec
   end





   if ValType( nBitsDatos ) == "C"
      ::nBitsDatos      := Val( nBitsDatos )
   else
      ::nBitsDatos      := nBitsDatos
   end





   if ValType( ::nBitsParada ) == "C"
      ::nBitsParada     := Val( nBitsParada )
   else
      ::nBitsParada     := nBitsParada
   end





   nBitsParidad         := Rtrim( nBitsParidad )

   do case
      case nBitsParidad == "Sin paridad"
         ::nBitsParidad := 0
      case nBitsParidad == "Paridad par"
         ::nBitsParidad := 1
      case nBitsParidad == "Paridad impar"
         ::nBitsParidad := 2
   end

   ::nHComm             := fCreate( ::cPort )

   if ::nHComm > 0

      ::OpenCommError()






      msgStop( "Puerto  : " + cValToChar( ::cPort )          + Chr(13)+Chr(10) + "Bits    : " + cValToChar( ::nBitsSec )       + Chr(13)+Chr(10) + "Parada  : " + cValToChar( ::nBitsParada )    + Chr(13)+Chr(10) + "Datos   : " + cValToChar( ::nBitsDatos )     + Chr(13)+Chr(10) + "Paridad : " + cValToChar( ::nBitsParidad ), ::cLastError )

      ::lCreated        := .F.

   end

RETURN Self



static FUNCTION TPort_OpenCommError( ) ; local Self AS CLASS TPort := QSelf() AS CLASS TPort

   if ( ::nHComm >= 0 )
      ::cLastError         := "No error"
    else
        do case
         case ::nHComm == -1
            ::cLastError   := "ID: Inválido o no soportado"
         case ::nHComm == -12
            ::cLastError   := "BAUDIOS: No soportado"
         case ::nHComm == -11
            ::cLastError   := "BYTE: Tamaño no válido"
         case ::nHComm == -5
            ::cLastError   := "Valores por defecto son erroneos"
         case ::nHComm == -10
            ::cLastError   := "HARDWARE: No presente"
         case ::nHComm == -4
            ::cLastError   := "MEMORIA: Insuficiente"
         case ::nHComm == -3
            ::cLastError   := "HARDWARE: Dispositivo no abierto"
         case ::nHComm == -2
            ::cLastError   := "HARDWARE: Dispositivo ya abierto"
            otherwise
            ::cLastError   := "Error no determinado"
        endcase
    endif

return ::nHComm



static FUNCTION TPort_Write( cTexto, nRetardo ) ; local Self AS CLASS TPort := QSelf() AS CLASS TPort

   local lWrite      := .T.
   local nLenTexto   := len( cTexto )

   If( nRetardo == nil, nRetardo := 0, ) ;

   fWrite( ::nHComm, cTexto, nLenTexto )

   if nRetardo <> 0
      DlgWait( nRetardo )
   end



return ( lWrite )
