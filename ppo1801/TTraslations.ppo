#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 9 ".\.\Prg\TTraslations.prg"
Function getConfigTraslation( key, default )

Return ( TConfig():getInstance():getTraslation( key, default ) )



Function getConfigUser( key, default )

Return ( TConfig():getInstance():getUser( key, default ) )



Function setConfigUser( key, value )

Return ( TConfig():getInstance():setUser( key, value ) )



Function getConfigEmpresa( key, default )

Return ( TConfig():getInstance():getEmpresa( key, default ) )



Function setConfigEmpresa( key, value )

Return ( TConfig():getInstance():setEmpresa( key, value ) )



_HB_CLASS TConfig ; function TConfig ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TConfig", iif( .F., { }, { @HBObject() } ), @TConfig() ) ) ;

   _HB_MEMBER { oInstance } ; oClass:AddMultiClsData(,, nScope + iif( .F., 16, 0 ) + iif( .T., 32, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oInstance"}, .F. )
   _HB_MEMBER { hJSON } ; oClass:AddMultiClsData(, {=>}, nScope + iif( .F., 16, 0 ) + iif( .T., 32, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hJSON"}, .F. )

   _HB_MEMBER { idEmpresa } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"idEmpresa"}, .F. )

   _HB_MEMBER New() AS CLASS TConfig; oClass:AddMethod( "New", @TConfig_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getInstance(); oClass:AddMethod( "getInstance", @TConfig_getInstance(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER destroyInstance(); oClass:AddInline( "destroyInstance", {|Self | ( ( Self ) ), ( ::oInstance := nil ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER loadJSON(); oClass:AddMethod( "loadJSON", @TConfig_loadJSON(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER saveJSON(); oClass:AddMethod( "saveJSON", @TConfig_saveJSON(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER get( node, key, default); oClass:AddMethod( "get", @TConfig_get(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getTraslation(); oClass:AddInline( "getTraslation", {|Self, key, default | ( ( Self ) ), ( ::get( "Traslations", key, default ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getUser(); oClass:AddInline( "getUser", {|Self, key, default | ( ( Self ) ), ( ::get( Auth():Codigo(), key, default ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER getEmpresa(); oClass:AddInline( "getEmpresa", {|Self, key, default | ( ( Self ) ), ( ::get( "Empresa", key, default ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER set( node, key, value); oClass:AddMethod( "set", @TConfig_set(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER setTraslation(); oClass:AddInline( "setTraslation", {|Self, key, value | ( ( Self ) ), ( ::set( "Traslations", key, value ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER setUser(); oClass:AddInline( "setUser", {|Self, key, value | ( ( Self ) ), ( ::set( Auth():Codigo(), key, value ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER setEmpresa(); oClass:AddInline( "setEmpresa", {|Self, key, default | ( ( Self ) ), ( ::set( "Empresa", key, default ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER getFullFileName(); oClass:AddMethod( "getFullFileName", @TConfig_getFullFileName(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TConfig ;



static FUNCTION TConfig_New( idEmpresa ) ; local Self AS CLASS TConfig := QSelf() AS CLASS TConfig

   If( idEmpresa == nil, idEmpresa := cCodEmp(), ) ;

   ::idEmpresa          := idEmpresa

   ::LoadJSON()

Return ( Self )



static FUNCTION TConfig_getInstance( ) ; local Self AS CLASS TConfig := QSelf() AS CLASS TConfig

   if empty( ::oInstance )
      ::oInstance       := ::New()
   end

RETURN ( ::oInstance )



static FUNCTION TConfig_get( node, key, default ) ; local Self AS CLASS TConfig := QSelf() AS CLASS TConfig

   local hNode

   If( default == nil, default := key, ) ;

   if hhaskey( ::hJSON, node )
      hNode          := hget( ::hJSON, node )
      if hhaskey( hNode, key )
         Return ( hget( hNode, key ) )
      end
   end

   ::set( node, key, default )

Return ( default )



static FUNCTION TConfig_set( node, key, value ) ; local Self AS CLASS TConfig := QSelf() AS CLASS TConfig

   local hNode

   if isnil( ::hJSON )
      Return ( .F. )
   end

   if hhaskey( ::hJSON, node )
      hNode       := hget( ::hJSON, node )
      if !empty( hNode )
         hset( hNode, key, value )
      end
   else
      hset( ::hJSON, node, { key => value } )
   end

   ::saveJSON()

Return ( .T. )



static FUNCTION TConfig_loadJSON( ) ; local Self AS CLASS TConfig := QSelf() AS CLASS TConfig

   local hJSON
   local cConfig
   local cFullFileName        := ::getFullFileName()

   if file( cFullFileName )

      cConfig                 := memoread( cFullFileName )

      hb_jsonDecode( cConfig, @hJSON )

      if !empty( hJSON )
         ::hJSON              := hJSON
      end

   end

Return ( Self )



static FUNCTION TConfig_saveJSON( ) ; local Self AS CLASS TConfig := QSelf() AS CLASS TConfig

   memowrit( ::getFullFileName(), hb_jsonencode( ::hJSON, .T. ) )

Return ( Self )



static FUNCTION TConfig_getFullFileName( ) ; local Self AS CLASS TConfig := QSelf() AS CLASS TConfig

Return ( cPatConfig() + ::idEmpresa + "\config.json" )
