#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 23 ".\.\Prg\Tdbarray.prg"
static __aTDbV := {}





function TDbVirtual( cAlias, cClassName )

    local n := 0
    local hCls := 0
    local __oDb


    local TVCls := "T" + upper( if( empty( cClassName ),  Alias( xArea( cAlias ) ), cClassName ) )

    if ( n := AScan( __aTDbV, { |aClass| aClass[ 1 ] == TVCls } ) ) == 0
        _HB_CLASS TVCls
        __oDb := HbClass():New( TVCls, { "TDBARRAY" } )
        __oDb:Create()
        hCls := __oDb:hClass
        AAdd( __aTDbV, { TVCls, hCls, 1 } )
    else
        ++__aTDbV[ n, 3 ]
        hCls := __aTDbV[ n, 2 ]
    endif
    return( __clsInst( hCls ) )



static function GenData( o, cName, i, aType )

local nClassH

    nClassH := o:ClassH


    __clsAddMsg( nClassH, cName,  { | o | o:aRecords[ o:RecNo, i ] }, 3 )

    __clsAddMsg( nClassH, "_" + cName,  { | o, Val | o:aRecords[ o:RecNo, i ] := Val }, 3 )

return( o )



































_HB_CLASS TDbArray ; function TDbArray ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TDbArray", iif( .F., { }, { @HBObject() } ), @TDbArray() ) ) ;

    _HB_MEMBER { oDbf } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oDbf"}, .F. )

    _HB_MEMBER { bFilter } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bFilter"}, .F. )




    _HB_MEMBER { AS ARRAY aFields, aRecords, aBlank, aStatus } ; oClass:AddMultiData( "ARRAY",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aFields", "aRecords", "aBlank", "aStatus"}, .F. )



    _HB_MEMBER { AS LOGICAL Eof, Bof, Used } ; oClass:AddMultiData( "LOGICAL",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Eof", "Bof", "Used"}, .F. )


    _HB_MEMBER { cAlias, cComment } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cAlias", "cComment"}, .F. )




    _HB_MEMBER { AS NUMERIC nRecIni, RecNo, LastRec, FCount } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nRecIni", "RecNo", "LastRec", "FCount"}, .F. )

    _HB_MEMBER New( cAlias, aRecords, lDatas, cComment) AS CLASS TDbArray; oClass:AddMethod( "New", @TDbArray_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER DefNew( cComment) AS CLASS TDbArray; oClass:AddMethod( "DefNew", @TDbArray_DefNew(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER AddField( cName, cType, nLen, nDec); oClass:AddMethod( "AddField", @TDbArray_AddField(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Activate(); oClass:AddMethod( "Activate", @TDbArray_Activate(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER Append(); oClass:AddMethod( "Append", @TDbArray_Append(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Update( aVal); oClass:AddMethod( "Update", @TDbArray_Update(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Insert(); oClass:AddInline( "Insert", {|Self, aVal | ( ( Self ) ), ::Append():Update( aVal ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER Delete(); oClass:AddMethod( "Delete", @TDbArray__Delete(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Zap(); oClass:AddMethod( "Zap", @TDbArray__Zap(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER GoTo( n); oClass:AddMethod( "GoTo", @TDbArray_GoTo(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER GoTop(); oClass:AddInline( "GoTop", {|Self | ( ( Self ) ), ::GoTo( 1 ), Self }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER GoBottom(); oClass:AddInline( "GoBottom", {|Self | ( ( Self ) ), ::GoTo( ::LastRec ), Self }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER Skip( n); oClass:AddMethod( "Skip", @TDbArray_Skip(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Skipper( n); oClass:AddMethod( "Skipper", @TDbArray_Skipper(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER Record(); oClass:AddInline( "Record", {|Self | ( ( Self ) ), ::aRecords[ ::RecNo ] }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER RecCount(); oClass:AddInline( "RecCount", {|Self | ( ( Self ) ), len( ::aRecords ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER Eval(); oClass:AddInline( "Eval", {|Self, bBlock | ( ( Self ) ), AEval( ::aRecords, bBlock ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER SetBrowse( oBrw); oClass:AddMethod( "SetBrowse", @TDbArray_SetBrowse(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER Load( bFor, bWhile); oClass:AddMethod( "Load", @TDbArray_Load(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER RecLoad( nRec, lNew); oClass:AddMethod( "RecLoad", @TDbArray_RecLoad(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER Save(); oClass:AddMethod( "Save", @TDbArray_Save(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER RecSave( nRec); oClass:AddMethod( "RecSave", @TDbArray_RecSave(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER Clean(); oClass:AddInline( "Clean", {|Self | ( ( Self ) ), ::aRecords := {} }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER Syncronize(); oClass:AddInline( "Syncronize", {|Self | ( ( Self ) ), ( ::oDbf:Goto( ::nRecIni ), Self ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER FieldGet(); oClass:AddInline( "FieldGet", {|Self, nFld | ( ( Self ) ), ( if( ::RecNo == 0, ::aBlank[ nFld ], ::aRecords[ ::RecNo, nFld ] ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER FieldPut(); oClass:AddInline( "FieldPut", {|Self, nFld, Val | ( ( Self ) ), ::aRecords[ ::RecNo, nFld ] := Val }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER FieldPos( cName); oClass:AddMethod( "FieldPos", @TDbArray_FieldPos(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER FieldName(); oClass:AddInline( "FieldName", {|Self, nFld | ( ( Self ) ), ::aFields[ nFld, 1 ] }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER FieldType(); oClass:AddInline( "FieldType", {|Self, nFld | ( ( Self ) ), ::aFields[ nFld, 2 ] }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER FieldLen(); oClass:AddInline( "FieldLen", {|Self, nFld | ( ( Self ) ), ::aFields[ nFld, 3  ] }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER FieldDec(); oClass:AddInline( "FieldDec", {|Self, nFld | ( ( Self ) ), ::aFields[ nFld, 4  ] }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER DbCore( cFileName); oClass:AddMethod( "DbCore", @TDbArray_DbCore(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER Clone( lNew) ; oClass:AddVirtual( "Clone" )

    _HB_MEMBER Destroy(); oClass:AddMethod( "Destroy", @TDbArray_Destroy(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )





    _HB_MEMBER OrdKeyNo(); oClass:AddInline( "OrdKeyNo", {|Self | ( ( Self ) ), ( ::RecNo ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER LoadArray( aArray); oClass:AddMethod( "LoadArray", @TDbArray_LoadArray(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER Seek( xVal, nField); oClass:AddMethod( "Seek", @TDbArray_Seek(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER GetStatus(); oClass:AddMethod( "GetStatus", @TDbArray_GetStatus(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER SetStatus(); oClass:AddMethod( "SetStatus", @TDbArray_SetStatus(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TDbArray ;



static FUNCTION TDbArray_New( oDbf, aRecords, lDatas, cComment ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local i     := 0
    local nLen  := 0
    local nRec  := 0

    lDatas := If( lDatas == nil, .F., lDatas );



    ::oDbf     := oDbf
    ::cAlias   := "ARRAY"
    ::aRecords := if( ValType( aRecords ) == "A", oClone( aRecords ), {} )
    ::Eof      := .F.
    ::Bof      := .F.
    ::RecNo    := 0
    ::nRecIni  := 1
    ::cComment := if( ValType( cComment ) == "C", cComment, "" )
    ::aBlank   := {}
    ::aFields  := {}

    if ::oDbf:Used()


        nRec   := ::oDbf:RecNo()
        nLen   := len( ::oDbf:aTField )

        ::aFields := Array( nLen )

        ::oDbf:GoTo( 0 )
        for i := 1 TO nLen
            aAdd( ::aBlank, ::oDbf:aTField[ i ]:GetVal() )
            if lDatas
                GenData( Self, ::oDbf:aTField[ i ]:cName, i, ::oDbf:aTField[ i ]:cType )
            end
        next

        ::FCount := len( ::aBlank )
        ::oDbf:GoTo( nRec )

    endif

return( Self )



static FUNCTION TDbArray_DefNew( cComment ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    ::cAlias   := "ARRAY"
    ::RecNo    := 0
    ::nRecIni  := 1
    ::LastRec  := 0
    ::FCount   := 0
    ::aFields  := {}
    ::aRecords := {}
    ::aBlank   := {}
    ::Eof      := .F.
    ::Bof      := .F.
    ::Used     := .F.
    ::cComment := if( ValType( cComment ) == "C", cComment, ::cAlias )

return( Self )



static FUNCTION TDbArray_AddField( cName, cType, nLen, nDec ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local aRow := {}

    cName := upper( cName )
    cType := upper( cType )

    AAdd( aRow, cName )
    AAdd( aRow, cType )
    AAdd( aRow, nLen )
    AAdd( aRow, nDec )

    AAdd( ::aFields, aRow )

return( aRow )



static FUNCTION TDbArray_Activate( ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local xVal
    local nFld := 0
    local cType := "C"
    local nCount := ::FCount := len( ::aFields )

    FOR nFld := 1 TO nCount

        cType := ::FieldType( nFld )

        Self:aFields[ nFld, 3  ] := If( Self:aFields[ nFld, 3  ] == nil, 10, Self:aFields[ nFld, 3  ] );
        Self:aFields[ nFld, 4 ] := If( Self:aFields[ nFld, 4 ] == nil, 0, Self:aFields[ nFld, 4 ] );

        DO CASE

           CASE cType == "C"
                xVal := space( ::FieldLen( nFld ) )

           CASE cType  == "N"
                xVal  := replicate( "0", ::FieldLen( nFld ) )
                if ::FieldDec( nFld ) > 0

                  xVal := Stuff( xVal,  ( ::FieldLen( nFld ) - ::FieldDec( nFld ) ), 1, "." )
                endif
                xVal := Val( xVal )

           CASE cType == "L"
                xVal := .F.
                ::aFields[ nFld, 3 ] := 1
                ::aFields[ nFld, 4 ] := 0

           CASE cType == "D"
                xVal  := CToD( "" )
                ::aFields[ nFld, 3 ] := 8
                ::aFields[ nFld, 4 ] := 0

           CASE cType == "M"
                xVal := space( 10 )
                ::aFields[ nFld, 3 ] := 10
                ::aFields[ nFld, 4 ] := 0

        ENDCASE

        AAdd( ::aBlank, xVal )
        GenData( Self, ::FieldName( nFld ), nFld, aType( cType ) )
    NEXT

return( Self )



static FUNCTION TDbArray_GoTo( n ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

   local nRec  := ::RecNo

   if ValType( n ) == "N" .AND. n > 0
      ::Eof := .F.
      ::Bof := .F.
      if n > ::LastRec
         ::RecNo := ::LastRec
         ::Eof := .T.
      else
         ::RecNo := n
      end
   end

return( nRec )



static FUNCTION TDbArray__Delete( ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    ADel( ::aRecords, ::RecNo )
    ASize( ::aRecords, --::LastRec )

    ::GoTo( ::RecNo )

return( Self )



static FUNCTION TDbArray__Zap( ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    ::GoTop()
    while !::Eof()
       ::Delete()
       ::Skip()
    end

return( Self )



static FUNCTION TDbArray_Update( aVal ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local lRet := .F.

    if ValType( aVal ) == "A"
        aSize( aVal )
        AEval( ::aRecords[ ::RecNo ], { | v, i | v := aVal[ i ] } )
        lRet := .T.
    endif

return( lRet )



static FUNCTION TDbArray_Append( ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    AAdd( ::aRecords, aClone( ::aBlank ) )
    ::RecNo := ++::LastRec
    ::Eof   := ::Bof := .F.

return( Self )



static FUNCTION TDbArray_Skip( n ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

   local nPos  := 0

   n := If( n == nil, 1, n );

   ::Eof       := .F.
   ::Bof       := .F.

   nPos        := ::RecNo + n
   if nPos > ::LastRec
      ::GoBottom()
      ::Eof    := .T.
   elseif nPos < 1
      ::GoTop()
      ::Bof    := .T.
   else
      ::RecNo  := nPos
   endif

return( Self )



static FUNCTION TDbArray_Skipper( nSkip ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local nSkipped := 0

    nSkipped   := Min( Max( nSkip, 1 - ::RecNo ), ::LastRec - ::RecNo )

    ::RecNo    += nSkipped

return( nSkipped )



static FUNCTION TDbArray_SetBrowse( oBrw ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    if upper( oBrw:ClassName() ) $ "TBROWSE TDBBRW"
        oBrw:goTopBlock    := { || ::GoTop() }
        oBrw:goBottomBlock := { || ::GoBottom() }
        oBrw:SkipBlock     := { | n | ::Skipper( n ) }
    elseif upper( oBrw:ClassName() ) $ "TWBROWSE TCBROWSE TGRID"
        oBrw:bGoTop    := { || ::GoTop() }
        oBrw:bGoBottom := { || ::GoBottom() }
        oBrw:bSkip     := { | n | ::Skipper( n ) }
        oBrw:bLogicLen := { || ::LastRec }
        oBrw:Refresh()
    endif

return( oBrw )



static FUNCTION TDbArray_Load( bFor, bWhile, bOnPreLoad, bOnPostLoad ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local i          := 0
    local aRec       := {}
    local nLen       := ::FCount
    local lTrigger

    ::nRecIni        := ::oDbf:RecNo()

    bFor             := if( ValType( bFor )   <> "B", { || .T. }, bFor )
    bWhile           := if( ValType( bWhile ) <> "B", { || !::oDbf:Eof() }, bWhile )

    while eval( bWhile, Self )

       if eval( bFor, Self )

          if bOnPreLoad <> nil
             lTrigger := Eval( bOnPreLoad, Self )
             if Valtype( lTrigger ) == "L" .AND. !lTrigger
                return .F.
             end
          end

          aRec := {}
          for i := 1 TO nLen
              aAdd( aRec, ::oDbf:aTField[ i ]:GetVal() )
          next
          aAdd( ::aRecords, aRec )

          ::RecNo    := 1

          if bOnPostLoad <> nil
             lTrigger := Eval( bOnPostLoad, Self )
             if Valtype( lTrigger ) == "L" .AND. !lTrigger
                return .F.
             end
          end

       endif

       ::oDbf:Skip( 1 )

    end

    ::Syncronize()

    ::Eof := ::Bof := ( ( ::LastRec := ::RecCount() ) == 0 )

return( Self )



static FUNCTION TDbArray_FieldPos( cName ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray
return( AScan( ::aFields, { | aRow | aRow[ 1 ] == upper( cName ) } ) )



static FUNCTION TDbArray_RecLoad( nRec, lAdd, bOnPreLoad, bOnPostLoad ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local i    := 0
    local aRec := {}
    local nLen := ::FCount
    local lTrigger

    nRec := If( nRec == nil, ::oDbf:RecNo(), nRec );
    lAdd := If( lAdd == nil, .F., lAdd );

    ::oDbf:Goto( nRec )

    if bOnPreLoad <> nil
       lTrigger := Eval( bOnPreLoad, Self )
       if Valtype( lTrigger ) == "L" .AND. !lTrigger
          return .F.
       end
    end

    for i := 1 TO nLen
       aAdd( aRec, ::oDbf:aTField[ i ]:GetVal() )
    next

    if lAdd
       AAdd( ::aRecords, aRec )
       ::RecNo := ++::LastRec
    else
       ::Update( aRec )
    end

    if bOnPostLoad <> nil
       return Eval( bOnPostLoad, Self )
    end

return ( Self )



static FUNCTION TDbArray_Save( lAppend, bFor ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local i    := 0
    local nRec := ::FCount

    bFor := if( ValType( bFor ) <> "B", { || .T. }, bFor )
    lAppend := if( ValType( lAppend ) <> "L", .T., lAppend )

    if lAppend
        while !::Eof()
            if eval( bFor )
                ( ::nArea )->( DbAppend() )
                FOR i := 1 TO nRec
                    ( ::nArea )->( FieldPut( i, ::FieldGet( i ) ) )
                NEXT
            endif
            ::Skip( 1 )
        end
    else
        ::Syncronize()
        while !::Eof()
            if eval( bFor )
                ( ::nArea )->( DbSkip( 1 ) )
                ( ::nArea )->( if( Eof(), DbAppend(), ) )
                FOR i := 1 TO nRec
                    ( ::nArea )->( FieldPut( i, ::FieldGet( i ) ) )
                NEXT
            endif
            ::Skip( 1 )
        end
    endif

return( Self )



static FUNCTION TDbArray_RecSave( lAppend ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local i    := 0
    local nLen := ::FCount

    lAppend    := if( ValType( lAppend ) <> "L", .T., lAppend )

    if lAppend
        ::oDbf:Append()
    else
        ::oDbf:Load()
    end

    for i := 1 TO nLen
        if !::oDbf:aTField[ i ]:lCalculate
            ::oDbf:FldPut( i, ::FieldGet( i ) )
        end
    next

    ::oDbf:Save()

return( Self )



static FUNCTION TDbArray_DbCore( cFileName ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    local lRet := .F.

    if ValType( cFileName ) == "C"
        DbCreate( cFileName, ::aFields )
        DbUseArea( .T.,, cFileName )
        ::nArea := Select()
        ::GoTop()
        ::Save( .T. )
        lRet := .T.
    endif

return( lRet )



static FUNCTION TDbArray_Destroy( ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    ::aRecords := {}
    ::aBlank   := {}
    ::aFields  := {}

    Self       := nil

return( .T. )



static FUNCTION TDbArray_LoadArray( aArray ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

   ::aRecords  := aArray
   ::RecNo     := 1
   ::LastRec   := ::RecCount()

return( Self )



static FUNCTION TDbArray_Seek( xVal, nField ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

   local nScan       := 0
   local nLen        := len( xVal )

   nField := If( nField == nil, 1, nField );

   nScan := AScan( ::aRecords, { | aRow | SubStr( aRow[ nField ], 1, nLen ) == xVal } )
   if nScan <> 0
      ::GoTo( nScan )
   end

return ( nScan <> 0 )



static FUNCTION TDbArray_GetStatus( ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    ::aStatus := {}

    AAdd( ::aStatus, ::Recno )

return( Self )



static FUNCTION TDbArray_SetStatus( ) ; local Self AS CLASS TDbArray := QSelf() AS CLASS TDbArray

    ::Goto( ::aStatus[ 1 ] )

return( Self )
