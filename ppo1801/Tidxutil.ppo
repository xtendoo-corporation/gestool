


















function iCounter( _DB_, nSkip )

    local nSkipped := 0

    msgStop( nSkip, "COUNTER" )

    DO CASE
    CASE nSkip > 0
        if _DB_:lScope
            while nSkipped < nSkip .AND. eval( _DB_:oIndex:bBottom, _DB_ )
                ( _DB_:nArea )->( DbSkip( 1 ) )
                ++nSkipped
            end
        else
            while nSkipped < nSkip .AND. !( _DB_:nArea )->( Eof() )
                ( _DB_:nArea )->( DbSkip( 1 ) )
                ++nSkipped
            end
        endif
    CASE nSkip < 0
        if _DB_:lScope
            while nSkipped > nSkip .AND. eval( _DB_:oIndex:bTop, _DB_ )
                ( _DB_:nArea )->( DbSkip( -1 ) )
                --nSkipped
            end
        else
            while nSkipped > nSkip .AND. !( _DB_:nArea )->( Bof() )
                ( _DB_:nArea )->( DbSkip( -1 ) )
                --nSkipped
            end
        endif
    end

return( nSkipped )






function GetIdxNone( oDbf )

    local oIdxNone := TIndex()

    oIdxNone:oDbf     := oDbf
    oIdxNone:cFile    := ""
    oIdxNone:cName    := "_NONE_"
    oIdxNone:cComment := "NATURAL ORDER _NONE_"
    oIdxNone:cFor     := ".t."
    oIdxNone:cKey     := "RecNo()"
    oIdxNone:bKey     := { || RecNo() }
    oIdxNone:bFor     := { || .T. }
    oIdxNone:bWhile   := { || .T. }
    oIdxNone:bTop     := { || .T. }
    oIdxNone:bBottom  := { || .T. }
    oIdxNone:bRange   := { || .T. }
    oIdxNone:bOption  := { || nil }
    oIdxNone:lScope   := .F.
    oIdxNone:lUniq    := .T.
    oIdxNone:lDes     := .F.
    oIdxNone:nStep    := 0
    oIdxNone:uTop     := NIL
    oIdxNone:uBottom  := NIL
    oIdxNone:Cargo    := NIL

return( oIdxNone )



function iScpTop( _DB_ )

    ( _DB_:nArea )->( DbSeek( _DB_:oIndex:uTop, .T. ) )

    if !eval( _DB_:oIndex:bBottom, _DB_ )
        ( _DB_:nArea )->( DbGoTo( 0 ) )
        _DB_:Eof := .T.
    endif

return( _DB_ )



function iScpBottom( _DB_ )

    ( _DB_:nArea )->( DbSeek( NextVal( _DB_:oIndex:uBottom ), .T. ) )
    ( _DB_:nArea )->( DbSkip( -1 ) )

    if !eval( _DB_:oIndex:bBottom, _DB_ )
        ( _DB_:nArea )->( DbGoTo( 0 ) )
        _DB_:Eof := .T.
    endif

return( _DB_ )
