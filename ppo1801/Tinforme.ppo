#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 10 ".\.\Prg\Tinforme.prg"
_HB_CLASS TInforme ; function TInforme ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TInforme", iif( .F., { }, { @HBObject() } ), @TInforme() ) ) ;

   _HB_MEMBER { AS NUMERIC nDevice } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nDevice"}, .F. )
   _HB_MEMBER { cTitle } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cTitle"}, .F. )
   _HB_MEMBER { cSubTitle } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cSubTitle"}, .F. )
   _HB_MEMBER { AS ARRAY aDbfTmp } ; oClass:AddMultiData( "ARRAY", {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aDbfTmp"}, .F. )
   _HB_MEMBER { cIndex } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cIndex"}, .F. )
   _HB_MEMBER { AS ARRAY aStru } ; oClass:AddMultiData( "ARRAY", {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aStru"}, .F. )
   _HB_MEMBER { bRedefine } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bRedefine"}, .F. )
   _HB_MEMBER { AS ARRAY aCols } ; oClass:AddMultiData( "ARRAY", {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aCols"}, .F. )
   _HB_MEMBER { bFilter } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bFilter"}, .F. )
   _HB_MEMBER { uFrom } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"uFrom"}, .F. )
   _HB_MEMBER { uTo } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"uTo"}, .F. )
   _HB_MEMBER { AS NUMERIC nSize } ; oClass:AddMultiData( "NUMERIC", 12, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nSize"}, .F. )
   _HB_MEMBER { AS ARRAY aOrd } ; oClass:AddMultiData( "ARRAY", {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aOrd"}, .F. )
   _HB_MEMBER { cAlias } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cAlias"}, .F. )
   _HB_MEMBER { AS LOGIC lOpen } ; oClass:AddMultiData( "LOGIC", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lOpen"}, .F. )
   _HB_MEMBER { AS ARRAY aoCols } ; oClass:AddMultiData( "ARRAY", {}, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aoCols"}, .F. )
   _HB_MEMBER { bHelp } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bHelp"}, .F. )
   _HB_MEMBER { AS OBJECT oIni } ; oClass:AddMultiData( "OBJECT",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oIni"}, .F. )
   _HB_MEMBER { AS LOGIC lSave2Exit } ; oClass:AddMultiData( "LOGIC", .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lSave2Exit"}, .F. )

   _HB_MEMBER New( aoCols, aOrd, bHelp, cTitle, cSubTitle, uAlias) AS CLASS TInforme; oClass:AddMethod( "New", @TInforme_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Activate(); oClass:AddMethod( "Activate", @TInforme_Activate(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Generate( nDevice); oClass:AddMethod( "Generate", @TInforme_Generate(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER lResources(); oClass:AddMethod( "lResources", @TInforme_lResources(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ChgIndex(); oClass:AddInline( "ChgIndex", {|Self, oCmb | ( ( Self ) ), ( ::cAlias )->( OrdSetFocus( oCmb:nAt ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Redefine(); oClass:AddInline( "Redefine", {|Self | ( ( Self ) ), Eval( ::bRedefine, self ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER UpColumn( oBrw); oClass:AddMethod( "UpColumn", @TInforme_UpColumn(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER DwColumn( oBrw); oClass:AddMethod( "DwColumn", @TInforme_DwColumn(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Default(); oClass:AddMethod( "Default", @TInforme_Default(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Save(); oClass:AddMethod( "Save", @TInforme_Save(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Filter(); oClass:AddInline( "Filter", {|Self | ( ( Self ) ), msgInfo( "Filter" ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER End(); oClass:AddMethod( "End", @TInforme_End(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TInforme ;



static FUNCTION TInforme_New( aoCols, aOrd, bHelp, cTitle, cSubTitle, uAlias, uAliasDet ) ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme

   If( aoCols == nil, aoCols := {}, ) ;
   If( cTitle == nil, cTitle := "Titulo del informe", ) ;
   If( cSubTitle == nil, cSubTitle := "Subtitulo del informe", ) ;
   If( aOrd == nil, aOrd := {""}, ) ;
   If( uAlias == nil, uAlias := Alias(), ) ;
   If( bHelp == nil, bHelp := {|| msginfo( "No definida ayuda." ) }, ) ;

   ::aoCols          := aoCols
   ::cAlias          := if( Valtype( uAlias ) == "O", uAlias:cAlias, uAlias )
   ::aOrd            := aOrd
   ::cTitle          := cTitle
   ::cSubTitle       := cSubTitle
   ::bHelp           := bHelp





   ::Default()






RETURN Self



static FUNCTION TInforme_Activate( ) ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme









RETURN ::Resources()



static FUNCTION TInforme_End( ) ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme

   if ::lSave2Exit
      ::Save()
   end

RETURN .T.



static FUNCTION TInforme_lResources( ) ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme

   local oDlg
   local oOrdCmb
   local cOrdCmb
   local oFrom
   local oTo
   local oSayFrom
   local uSayFrom    := ""
   local oSayTo
   local uSayTo      := ""
   local oBmp        := LoadBitmap( 0, 32760 )
   local oBrwCol

   ( ::cAlias )->( dbGoTop() )
   ::uFrom           := ( ::cAlias )->( OrdKeyVal() )
   ( ::cAlias )->( dbGoBottom() )
   ::uTo             := ( ::cAlias )->( OrdKeyVal() )
   ( ::cAlias )->( dbGoTop() )

   oDlg = TDialog():New(,,,,, "REP_STD",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )




   oOrdCmb := TComboBox():ReDefine( 100, { | u | If( PCount()==0, cOrdCmb, cOrdCmb:= u ) }, ::aOrd, oDlg,,,,,,, .F.,,,,,,, "oOrdCmb",,,,,,, )

      oOrdCmb:bChange := {|| ::ChgIndex( oOrdCmb ) }




   oFrom := TGet():ReDefine( 110, { | u | If( PCount()==0, ::uFrom, ::uFrom:= u ) }, oDlg,,, {||    lRetFld( ::uFrom, ::cAlias, oSayFrom )},,,,,, .F.,,, .F., .F.,,,,,,, "::uFrom",,,, )

      oFrom:bHelp := ::bHelp




   oSayFrom := TGet():ReDefine( 120, { | u | If( PCount()==0, uSayFrom, uSayFrom:= u ) }, oDlg,,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,,, "uSayFrom",,,, )




   oTo := TGet():ReDefine( 130, { | u | If( PCount()==0, ::uTo, ::uTo:= u ) }, oDlg,,, {||    lRetFld( ::uTo, ::cAlias, oSayTo )},,,,,, .F.,,, .F., .F.,,,,,,, "::uTo",,,, )

      oTo:bHelp   := ::bHelp




   oSayTo := TGet():ReDefine( 140, { | u | If( PCount()==0, uSayTo, uSayTo:= u ) }, oDlg,,,,,,,,, .F., {||     .F.},, .F., .F.,,,,,,, "uSayTo",,,, )








   TGet():ReDefine( 160, { | u | If( PCount()==0, ::nSize, ::nSize:= u ) }, oDlg,, "@E 99", {||    ::nSize >= 6 .AND. ::nSize <= 72},,,,,, .F.,,, .F., .T.,,, {||      6}, {||      72},,, "::nSize",,,, )



   TGet():ReDefine( 170, { | u | If( PCount()==0, ::cTitle, ::cTitle:= u ) }, oDlg,,,,,,,,, .F.,,, .F., .F.,,,,,,, "::cTitle",,,, )



   TGet():ReDefine( 180, { | u | If( PCount()==0, ::cSubTitle, ::cSubTitle:= u ) }, oDlg,,,,,,,,, .F.,,, .F., .F.,,,,,,, "::cSubTitle",,,, )




   TCheckBox():ReDefine( 190, { | u | If( PCount()==0, ::lOpen, ::lOpen:= u ) }, oDlg,, {||( setSize( oDlg, ::lOpen ) )},,,,, .F.,, )



   TCheckBox():ReDefine( 191, { | u | If( PCount()==0, ::lSave2Exit, ::lSave2Exit:= u ) }, oDlg,,,,,,, .F.,, )










   oBrwCol := TWBrowse():ReDefine( 200, {|| { if( ::aoCols[ oBrwCol:nAt ]:lSelect, oBmp, "" ), ::aoCols[ oBrwCol:nAt ]:cTitle } }, oDlg, {"S", "Columna"}, {14, 40},,,,,,,,,,,, .F.,,,,, )

      oBrwCol:SetArray( ::aoCols )




   TButton():ReDefine( 538, {||::UpColumn( oBrwCol )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 539, {||::DwColumn( oBrwCol )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 514, {||( ::aoCols[ oBrwCol:nAt ]:Select(), oBrwCol:SetFocus(), oBrwCol:Refresh() )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 540, {||( ::aoCols[ oBrwCol:nAt ]:UnSelect(), oBrwCol:SetFocus(), oBrwCol:Refresh() )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 501, {||( ::aoCols[ oBrwCol:nAt ]:lEditCol(), oBrwCol:Refresh() )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 531, {||( ::Filter() )}, oDlg,,, .F.,,,, .F. )




   TButton():ReDefine( 508, {||( ::Generate( 1 ) )}, oDlg,,, .F.,,,, .F. )




    TButton():ReDefine( 505, {||( ::Generate( 2 ) )}, oDlg,,, .F.,,,, .F. )




    TButton():ReDefine( 510, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

   oDlg:bStart := {|| SetSize( oDlg, ::lOpen ), oFrom:lValid(), oTo:lValid() }

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   DeleteObject( oBmp )

RETURN ( oDlg:nResult == 1 )



static function lRetFld( uSearch, Alias, oSay, nFld )

   local lReturn  := .T.

   If( nFld == nil, nFld := 2, ) ;

   if valtype( uSearch ) == "C"
      uSearch     := Upper( uSearch )
   end

   if ( Alias )->( dbSeek( uSearch ) )
      oSay:cText( ( Alias )->( fieldGet( nFld ) ) )
   else
      msgStop( "Registro no encontrado" )
      lReturn     := .F.
   end

return lReturn



static function setSize( oDlg, lOpen )

   local aRect := GetWndRect( oDlg:hWnd )

   if lOpen
      oDlg:Move( aRect[1], aRect[2], 675, oDlg:nHeight, .T. )
   else
      oDlg:Move( aRect[1], aRect[2], 390, oDlg:nHeight, .T. )
   end

return nil






static FUNCTION TInforme_Generate( nDevice ) ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme

   local nFor
   local oFnt1
   local oFnt2
   local oReport

   ( ::cAlias )->( DbGoTop() )

   oFnt1 := TFont():New( "Arial", 0, - ( ::nSize ),, .T.,,,,,,,,,,,, )
   oFnt2 := TFont():New( "Arial", 0, - ( ::nSize ),,,,,,,,,,,,,, )

   IF nDevice == 1








      oReport := RptBegin({{||    Rtrim( ::cTitle    )}, {|| Rtrim( ::cSubTitle )}}, {{||   "Fecha : " + dtoc(date())}}, {{||     "Página : " + str( oReport:nPage, 3 )}}, {oFnt1, oFnt2}, {}, .F.,,,, .T.,,, Rtrim( ::cTitle ),, UPPER("RIGHT"), UPPER("CENTERED"), )

   ELSE








      oReport := RptBegin({{||    Rtrim( ::cTitle    )}, {|| Rtrim( ::cSubTitle )}}, {{||   "Fecha : " + dtoc(date())}}, {{||     "Página : " + str( oReport:nPage, 3 )}}, {oFnt1, oFnt2}, {}, .F.,,, .T., .F.,,, Rtrim( ::cTitle ),, UPPER("RIGHT"), UPPER("CENTERED"), )

   end

   for nFor := 1 to len( ::aoCols )

      if ::aoCols[ nFor ]:lSelect












         RptAddColumn(  { bHeaders( nFor, Self ) } , , { bFlds( nFor, Self ) } , ::aoCols[ nFor ]:nSize , { ::aoCols[ nFor ]:bPict } , {|| 2 } , ::aoCols[ nFor ]:lTotal , nil , nil , ::aoCols[ nFor ]:lSombra , ::aoCols[ nFor ]:lSeparador , nil )

      end

   next

   RptEnd()

   IF !Empty( oReport ) .AND.  oReport:lCreated
      oReport:Margin( 0, 2, 2)
      oReport:bSkip  := {|| ( ::cAlias )->( DbSkip( 1 ) ) }
   end




   oReport:Activate({||   ( ::cAlias )->( fieldGet( 1 ) ) >= ::uFrom .AND.  ( ::cAlias )->( fieldGet( 1 ) ) <= ::uTo}, {|| !( ::cAlias )->( eof() )},,,,,,,,,,,, )

   oFnt1:end()
   oFnt2:end()

RETURN NIL



static function bHeaders( nFor, Self )
return {|| ::aoCols[ nFor ]:cTitle }



static function bFlds( nFor, Self )

   if valType( ::aoCols[ nFor ] ) == "B"
      return ::aoCols[ nFor ]
   end

return ( ::aoCols[ nFor ]:bFld )



static FUNCTION TInforme_UpColumn( oBrw ) ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme

   local nPos  := oBrw:nAt

   if nPos <= len( ::aoCols ) .AND. nPos > 1

      SwapUpArray( ::aoCols, nPos )

      oBrw:GoUp()
      oBrw:Refresh()
      oBrw:SetFocus()

   end

return nil



static FUNCTION TInforme_DwColumn( oBrw ) ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme

   local nPos  := oBrw:nAt

   if nPos < len( ::aoCols ) .AND. nPos > 0

      SwapDwArray( ::aoCols, nPos )

      oBrw:GoDown()
      oBrw:Refresh()
      oBrw:SetFocus()

   end

return nil






static FUNCTION TInforme_Default( ) ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme




























RETURN ( SELF )



static FUNCTION TInforme_Save( ) ; local Self AS CLASS TInforme := QSelf() AS CLASS TInforme

















RETURN ( SELF )
