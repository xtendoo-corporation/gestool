#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 5 ".\.\Prg\TiposImpresoras.prg"
static oWndBrw
static bEdit      := { |aTmp, aGet, dbfTImp, oBrw, bWhen, bValid, nMode | EdtRec( aTmp, aGet, dbfTImp, oBrw, bWhen, bValid, nMode ) }
static dbfTImp





STATIC FUNCTION OpenFiles()

   local lOpen    := .T.
   local oBlock   := ErrorBlock( {| oError | ApoloBreak( oError ) } )

   BEGIN SEQUENCE

      DisableAcceso()

      if !lExistTable( cPatDat() + "TIPIMP.DBF" )
         mkTipImp( cPatDat() )
      end

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TIPIMP.DBF" ), ( cCheckArea( "TIPIMP", @dbfTImp ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TIPIMP.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end

      EnableAcceso()

   RECOVER

      msgStop( "Imposible abrir todas las bases de datos" )

      EnableAcceso()

      CloseFiles ()

      lOpen       := .F.

   end

   ErrorBlock( oBlock )

RETURN ( lOpen )






STATIC FUNCTION CloseFiles()

   DisableAcceso()

   if dbfTImp <> nil
      ( dbfTImp )->( dbCloseArea() )
   end

   dbfTImp  := nil
   oWndBrw  := nil

   EnableAcceso()

RETURN .T.







FUNCTION TipoImpresoras( oMenuItem, oWnd )

   local nLevel

   If( oMenuItem == nil, oMenuItem := "tipos_de_impresoras", ) ;
   If( oWnd == nil, oWnd := oWnd(), ) ;

   if oWndBrw == NIL





      nLevel            := Auth():Level( oMenuItem )

      if nAnd( nLevel, 1 ) == 0
         msgStop( "Acceso no permitido." )
         return nil
      end





      if oWnd <> nil
         SysRefresh(); oWnd:CloseAll(); SysRefresh()
      end





      if !OpenFiles()
         return Nil
      end

      DisableAcceso()





      AddMnuNext( "Tipos de impresoras", ProcName() )











      oWndBrw := TShell():New( 2, 10, 18, 70, "Tipos de impresoras",, oWnd,,, .F.,,, ( dbfTImp ),,,,, {"Tipos de impresoras"}, {||( WinAppRec( oWndBrw:oBrw, bEdit, dbfTImp ) )},, {||( WinDelRec( oWndBrw:oBrw, dbfTImp ) )},, nil, nLevel, "gc_printer2_16", ( 104 + ( 0 * 256 ) + ( 63 * 65536 ) ),,, .T. )

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Tipo de impresora"
         :cSortOrder       := "cTipImp"
         :bEditValue       := {|| ( dbfTImp )->cTipImp }
         :nWidth           := 800
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      oWndBrw:CreateXFromCode()





      oWndBrw:NewAt( "BUS",,, {||( oWndBrw:SearchSetFocus() )}, "(B)uscar", "B",,,,, .F. )

      oWndBrw:AddSeaBar()








      oWndBrw:NewAt( "NEW",,, {||( oWndBrw:RecAdd() )}, "(A)ñadir", "A",,, 2,, .F. )







      oWndBrw:NewAt( "ZOOM",,, {||( WinZooRec( oWndBrw:oBrw, bEdit, dbfTImp ) )}, "(Z)oom", "Z",,, 8,, .F. )







      oWndBrw:NewAt( "DEL",,, {||( oWndBrw:RecDel() )}, "(E)liminar", "E",,, 16,, .F. )





      oWndBrw:NewAt( "END",,, {||( oWndBrw:end() )}, "(S)alir", "S",,,,, .F. )

      oWndBrw:Activate(, oWndBrw:bLClicked, oWndBrw:bRClicked, oWndBrw:bMoved, oWndBrw:bResized, oWndBrw:bPainted, oWndBrw:bKeyDown, oWndBrw:bInit,,,,,,,,, {|| ( CloseFiles() )},, oWndBrw:bLButtonUp, .F. )

      EnableAcceso()

   else

      oWndBrw:SetFocus()

   end

RETURN NIL






STATIC FUNCTION EdtRec( aTmp, aGet, dbfTImp, oBrw, bWhen, bValid, nMode )

   local oDlg

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "tipos de impresoras", "TIPO_IMPRESORA",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )





   aGet[ ( dbfTImp )->( FieldPos( "cTipImp" ) ) ] := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, aTmp[ ( dbfTImp )->( FieldPos( "cTipImp" ) ) ], aTmp[ ( dbfTImp )->( FieldPos( "cTipImp" ) ) ]:= u ) }, oDlg,,,,,,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )





   TButton():ReDefine( 1, {||( EndTrans( aTmp, aGet, dbfTImp, oBrw, nMode, oDlg ) )}, oDlg,,, .F., {||     ( nMode <> 3 )},,, .F. )





   TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )



   if nMode <> 3
      oDlg:AddFastKey( 116, {|| EndTrans( aTmp, aGet, dbfTImp, oBrw, nMode, oDlg ) } )
   end

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

RETURN ( oDlg:nResult == 1 )






STATIC FUNCTION EndTrans( aTmp, aGet, dbfSitua, oBrw, nMode, oDlg )

   if nMode == 1 .OR. nMode == 4
      if Existe( Upper( aTmp[ ( dbfTImp )->( FieldPos( "cTipImp" ) ) ] ), dbfTImp, "cTipImp" )
         msgStop( "Tipo de impresora existente" )
         aGet[ ( dbfTImp )->( FieldPos( "cTipImp" ) ) ]:SetFocus()
         return nil
      end
   end

   if Empty( aTmp[ ( dbfTImp )->( FieldPos( "cTipImp" ) ) ] )
      MsgStop( "El tipo de impresora no puede estar vacío" )
      aGet[ ( dbfTImp )->( FieldPos( "cTipImp" ) ) ]:SetFocus()
      return nil
   end

   WinGather( aTmp, aGet, dbfTImp, oBrw, nMode )

RETURN ( oDlg:end( 1 ) )



FUNCTION mkTipImp( cPath, lAppend, cPathOld, oMeter )

   local dbfTImp

   If( cPath == nil, cPath := cPatDat(), ) ;
   If( lAppend == nil, lAppend := .F., ) ;

   if !lExistTable( cPatDat() + "TipImp.Dbf" )
      dbCreate( cPatDat() + "TipImp.Dbf", { { "cTipImp", "C", 50, 0 } }, cDriver() )
   end

   if lExistIndex( cPatDat() + "TipImp.Cdx" )
      fErase( cPatDat() + "TipImp.Cdx" )
   end

   if !lExistTable( cPath + "TipImp.Dbf" )
      dbCreate( cPath + "TipImp.Dbf", { { "cTipImp", "C", 50, 0 } }, cDriver() )
   end

   if lExistIndex( cPath + "TipImp.Cdx" )
      fErase( cPath + "TipImp.Cdx" )
   end

   if lAppend .AND. file( cPathOld + "TipImp.Dbf" )
      dbUseArea( .T., cDriver(), "TipImp.Dbf", cCheckArea( "TipImp", @dbfTImp ), .F. )
      ( dbfTImp )->( __dbApp( cPathOld + "TipImp.Dbf" ) )
      ( dbfTImp )->( dbCloseArea() )
   end

   rxTipImp( cPath )

RETURN .T.



FUNCTION rxTipImp( cPath, oMeter )

   local dbfTImp

   If( cPath == nil, cPath := cPatDat(), ) ;

   if !lExistTable( cPatDat() + "TipImp.Dbf" )
      dbCreate( cPatDat() + "TipImp.Dbf", { { "cTipImp", "C", 50, 0 } }, cDriver() )
   end

   if lExistIndex( cPatDat() + "TipImp.Cdx" )
      fErase( cPatDat() + "TipImp.Cdx" )
   end

   if !lExistTable( cPath + "TipImp.DBF" )
      dbCreate( cPath + "TipImp.Dbf", { { "cTipImp", "C", 50, 0 } }, cDriver() )
   end

   if lExistIndex( cPath + "TIPIMP.CDX" )
      fErase( cPath + "TIPIMP.CDX" )
   end

   if lExistTable( cPath + "TIPIMP.DBF" )

      dbUseArea( .T., cDriver(), cPath + "TIPIMP.DBF", cCheckArea( "TIPIMP", @dbfTImp ), .F. )

      if !( dbfTImp )->( neterr() )
         ( dbfTImp )->( __dbPack() )

         ( dbfTImp )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
         ( dbfTImp )->( ordCreate( cPath + "TIPIMP.CDX", "cTipImp", "Upper( Field->cTipImp )", {|| Upper( Field->cTipImp ) } ) )

         ( dbfTImp )->( dbCloseArea() )
      else

         msgStop( "Imposible abrir en modo exclusivo tipos de impresoras" )

      end

   end

RETURN NIL



FUNCTION cTipoImpresora( oGet, dbfTImp )

   local oBlock
   local oError
   local lClose      := .F.
   local lValid      := .F.
   local xValor      := oGet:varGet()

   if Empty( xValor )
      return .T.
   end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      if Empty( dbfTImp )
         dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TIPIMP.DBF" ), ( cCheckArea( "TIPIMP", @dbfTImp ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
         if !lAIS() ; ordListAdd( ( cPatDat() + "TIPIMP.CDX" ) ) ; else ; ordSetFocus( 1 ) ; end
         lClose      := .T.
      end

      if ( dbfTImp )->( dbSeek( Padr( Upper( xValor ), 50 ) ) )

         oGet:cText( ( dbfTImp )->cTipImp )

         lValid      := .T.

      else

         msgStop( "Código de tipo de impresora no encontrado" )

      end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   IF lClose
      ( dbfTImp )->( dbCloseArea() )
   end

RETURN lValid



FUNCTION BrwTipoImpresora( oGet, lBigStyle )

   local oDlg
   local oGet1
   local cGet1
   local oBrw
   local nOrd        := GetBrwOpt( "BrwTipImpresora" )
   local oCbxOrd
   local aCbxOrd     := { "Tipo" }
   local cCbxOrd
   local nLevel      := Auth():Level( "tipos_de_impresoras" )
   local cResource   := "HELPENTRYTACTILIMP"

   If( lBigStyle == nil, lBigStyle := .F., ) ;

   if !OpenFiles()
      return .F.
   end

   if lBigStyle
      nOrd           := ( dbfTImp )->( OrdSetFocus( "cTipImp" ) )
      ( dbfTImp )->( dbGoTop() )
   else
      nOrd           := Min( Max( nOrd, 1 ), len( aCbxOrd ) )
      cCbxOrd        := aCbxOrd[ nOrd ]
   end

   if lBigStyle

      if GetSysMetrics( 1 ) == 560

         oDlg = TDialog():New(,,,, "Seleccionar tipo de impresora", "HELPENTRYTACTILIMP_1024x576",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )

      else

         oDlg = TDialog():New(,,,, "Seleccionar tipo de impresora", cResource,, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )

      end

   else

      oDlg = TDialog():New(,,,, "Seleccionar tipo de impresora", "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )

   end

   if !lBigStyle






      oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,, {||    ( OrdClearScope( oBrw, dbfTImp ) )},,,,,, .F.,, {|nKey,nFlags,Self| ( AutoSeek( nKey, nFlags, Self, oBrw, dbfTImp ) ) }, .F., .F.,,,,,, nil, "FIND",, )






      oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, aCbxOrd, oDlg,,, {|Self|( ( dbfTImp )->( OrdSetFocus( oCbxOrd:nAt ) ), oBrw:Refresh(), oGet1:SetFocus() )},,,, .F.,,,,,,, "oCbxOrd",,,,,,, )

   end

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:cAlias          := dbfTImp
      oBrw:lHScroll        := .F.
      oBrw:nMarqueeStyle   := 5
      oBrw:cName           := "Browse.TipoImpresora"

      if lBigStyle
         oBrw:nRowHeight   := 36
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Código"
         :cSortOrder       := "cTipImp"
         :bEditValue       := {|| ( dbfTImp )->cTipImp }
         :nWidth           := 400
         if !lBigStyle
            :bLClickHeader := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
         end
      end

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }
      oBrw:bRClicked       := {| nRow, nCol, nFlags | oBrw:RButtonDown( nRow, nCol, nFlags ) }

      oBrw:CreateFromResource( 105 )

      if lBigStyle





      TButtonBmp():ReDefine( 140, {||( oBrw:GoUp() )}, oDlg,,, .F.,,,, .F., "UP32",,, .F. )





      TButtonBmp():ReDefine( 150, {||( oBrw:GoDown() )}, oDlg,,, .F.,,,, .F., "DOWN32",,, .F. )





      TButtonBmp():ReDefine( 1, {||( oDlg:end(1) )}, oDlg,,, .F.,,,, .F., "gc_check_32",,, .F. )





      TButtonBmp():ReDefine( 2, {||( oDlg:End() )}, oDlg,,, .F.,,,, .F., "Delete_32",,, .F. )

      else




      TButton():ReDefine( 1, {||( oDlg:end( 1 ) )}, oDlg,,, .F.,,,, .F. )





      TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .T. )

      end

      if !lBigStyle






      TButton():ReDefine( 500, {||( WinAppRec( oBrw, bEdit, dbfTImp ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 2 ) <> 0 .AND. !IsReport() )},,, .F. )




      TButton():ReDefine( 501, {||( WinEdtRec( oBrw, bEdit, dbfTImp ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 4 ) <> 0 .AND. !IsReport() )},,, .F. )

      if nAnd( nLevel, 2 ) <> 0 .AND. !IsReport()
         oDlg:AddFastKey( 113,    {|| WinAppRec( oBrw, bEdit, dbfTImp ) } )
      end

      if nAnd( nLevel, 4 ) <> 0 .AND. !IsReport()
         oDlg:AddFastKey( 114,    {|| WinEdtRec( oBrw, bEdit, dbfTImp ) } )
      end

      end

      oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )
      oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if oDlg:nResult == 1

      oGet:cText( ( dbfTImp )->cTipImp )
      oGet:lValid()

   end

   oGet:SetFocus()

   DestroyFastFilter( dbfTImp )

   SetBrwOpt( "BrwTipImpresora", ( dbfTImp )->( OrdNumber() ) )

   CloseFiles()

RETURN ( oDlg:nResult == 1 )






Function aTiposImpresoras()

   local aTipImp  := {}

   if !OpenFiles()
      return .F.
   end

   aAdd( aTipImp, "No imprimir" )

   ( dbfTImp )->( dbGoTop() )
   while !( dbfTImp )->( Eof() )
      aAdd( aTipImp, AllTrim( ( dbfTImp )->cTipImp ) )
      ( dbfTImp )->( dbSkip() )
   end

   CloseFiles()

Return aTipImp
