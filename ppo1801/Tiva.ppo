#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 27 ".\.\Prg\Tiva.prg"
static bEdit      := { | aTemp, aoGet, dbfTIva, oBrw, bWhen, bValid, nMode | EdtRec( aTemp, aoGet, dbfTIva, oBrw, bWhen, bValid, nMode ) }



static dbfTIva
static oWndBrw



Static Function OpenFiles()

   local oError
   local oBlock
   local lOpen    := .T.

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TIva.Dbf" ), ( cCheckArea( "TIVA", @dbfTIva ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
   if !lAIS() ; ordListAdd( ( cPatDat() + "TIva.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

  RECOVER

      msgStop( "Imposible abrir todas las bases de datos" )
      CloseFiles()
      lOpen          := .F.

   end
   ErrorBlock( oBlock )

RETURN ( lOpen )



STATIC FUNCTION CloseFiles()

   if dbfTiva <> nil
      ( dbfTiva )->( dbCloseArea() )
   end

   dbfTiva    := nil
   oWndBrw    := nil

RETURN .T.





FUNCTION TIva( oMenuItem, oWnd )

   local oBlock
   local oError
   local nLevel

   If( oMenuItem == nil, oMenuItem := "01036", ) ;
   If( oWnd == nil, oWnd := oWnd(), ) ;

   if Empty( oWndBrw )





      nLevel            := Auth():Level( oMenuItem )
      if nAnd( nLevel, 1 ) == 0
         msgStop( "Acceso no permitido." )
         return nil
      end





      if oWnd <> nil
         SysRefresh(); oWnd:CloseAll(); SysRefresh()
      end

      IF !OpenFiles()
         RETURN NIL
      end





      AddMnuNext( "Tipos de " + cImp(), ProcName() )















      oWndBrw := TShell():New( 2, 10, 18, 70, "Tipos de " + cImp(),, oWnd,,, .F.,,, ( dbfTIva ),,,,, {"Código", "Nombre", "%" + cImp()}, {||WinAppRec( oWndBrw:oBrw, bEdit, dbfTIva )}, {||WinEdtRec( oWndBrw:oBrw, bEdit, dbfTIva )}, {||WinDelRec( oWndBrw:oBrw, dbfTIva )}, {||WinDupRec( oWndBrw:oBrw, bEdit, dbfTIva )}, nil, nLevel, "gc_moneybag_16", ( 104 + ( 0 * 256 ) + ( 63 * 65536 ) ),,, .T. )

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Envio"
         :nHeadBmpNo       := 3
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( dbfTIva )->lSndDoc }
         :nWidth           := 20
         :SetCheck( { "gc_mail2_12", "Nil16" } )
         :AddResource( "gc_mail2_16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Publicar"
         :nHeadBmpNo       := 3
         :bStrData         := {|| "" }
         :bEditValue       := {|| ( dbfTIva )->lPubInt }
         :nWidth           := 20
         :SetCheck( { "gc_earth_12", "Nil16" } )
         :AddResource( "gc_earth_16" )
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Código"
         :cSortOrder       := "Tipo"
         :bEditValue       := {|| ( dbfTIva )->Tipo }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "DescIva"
         :bEditValue       := {|| ( dbfTIva )->DescIva }
         :nWidth           := 200
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "%" + cImp()
         :cSortOrder       := "TPIva"
         :bEditValue       := {|| Trans( ( dbfTIva )->TpIva, "@E 999.99" ) }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oWndBrw:ClickOnHeader( oCol ) }
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      with object ( oWndBrw:AddXCol() )
         :cHeader          := "%R.E."
         :bEditValue       := {|| Trans( ( dbfTIva )->nRecEq, "@E 999.999" ) }
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      oWndBrw:lAutoPos     := .F.
      oWndBrw:cHtmlHelp    := "Tipo de " + cImp()

      oWndBrw:CreateXFromCode()





      oWndBrw:NewAt( "BUS",,, {||( oWndBrw:SearchSetFocus() )}, "(B)uscar", "B",,,,, .F. )

      oWndBrw:AddSeaBar()








      oWndBrw:NewAt( "NEW",,, {||( oWndBrw:RecAdd() )}, "(A)ñadir", "A",,, 2,, .F. )







        oWndBrw:NewAt( "DUP",,, {||( oWndBrw:RecDup() )}, "(D)uplicar", "D",,, 2,, .F. )







        oWndBrw:NewAt( "EDIT",,, {||( oWndBrw:RecEdit() )}, "(M)odificar", "M",,, 4,, .F. )







        oWndBrw:NewAt( "ZOOM",,, {||( WinZooRec( oWndBrw:oBrw, bEdit, dbfTIva ) )}, "(Z)oom", "Z",,, 8,, .F. )







        oWndBrw:NewAt( "DEL",,, {||( oWndBrw:RecDel() )}, "(E)liminar", "E",,, 16,, .F. )








      oWndBrw:NewAt( "Lbl",, "Seleccionar registros para ser enviados", {||ChangelSndDoc()}, "En(v)iar", "V",, {|This|This:Toggle()}, 4,, .F. )






      oWndBrw:NewAt( "SNDINT",,, {||( ChangePublicar() )}, "P(u)blicar", "U",,, 4,, .F. )








      oWndBrw:NewAt( "IMP",,, {||( InfTipIva():New( "Listado de tipos de " + cImp() ):Play() )}, "(L)istado", "L",,, 32,, .F. )








      oWndBrw:NewAt( "GC_RECYCLE_",,, {||( ActTiposIva() )}, "Ac(t)ualización", "T",,, 4,, .F. )





      oWndBrw:NewAt( "END",,, {||( oWndBrw:End() )}, "(S)alir", "S",,,,, .F. )



      oWndBrw:Activate(, oWndBrw:bLClicked, oWndBrw:bRClicked, oWndBrw:bMoved, oWndBrw:bResized, oWndBrw:bPainted, oWndBrw:bKeyDown, oWndBrw:bInit,,,,,,,,, {||   ( CloseFiles() )},, oWndBrw:bLButtonUp, .F. )
    ELSE

        oWndBrw:SetFocus()

    end

RETURN NIL



STATIC FUNCTION lPreSave ( aTemp, aoGet, dbfTIva, oBrw, nMode, oDlg )

   if nMode == 1 .OR. nMode == 4

      if dbSeekInOrd( aTemp[ 1 ], "Tipo", dbfTIva )
         MsgStop( "Código ya existe " + Rtrim( aTemp[ 1 ] ) )
         return nil
      end

   end

   if Empty( aTemp[ 2 ] )
      MsgStop( "La descripción del tipo de " + cImp() + " no puede estar vacía." )
      Return nil
   end

   aTemp[ 9 ] := .T.

   WinGather( aTemp, aoGet, dbfTIva, oBrw, nMode )

Return ( oDlg:end( 1 ) )



FUNCTION cTIva( oGet, dbfTIva, oGet2 )

   local oBlock
   local oError
   local nTag
   local nRec
    local lClose     := .F.
    local lValid    := .F.
    local xValor     := oGet:varGet()

    IF Empty( xValor )
        RETURN .T.
    end

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

    If dbfTIva == NIL
      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TIva.Dbf" ), ( cCheckArea( "TIVA", @dbfTIva ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TIva.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end
        lClose    := .T.
   else
      nTag        := ( dbfTIva )->( OrdSetFocus( 1 ) )
      nRec        := ( dbfTIva )->( RecNo() )
    end

   If ( dbfTIva )->( dbSeek( xValor ) )

      oGet:cText( ( dbfTIva )->Tipo )

        If oGet2 <> NIL
         oGet2:cText( ( dbfTIva )->DescIva )
        end

      lValid   := .T.

    Else

      msgStop( "Tipo de " + cImp() + " no encontrado" )

    end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

    If lClose
      ( dbfTIva )->( dbCloseArea() )
   else
      ( dbfTIva )->( OrdSetFocus( nTag  ) )
      ( dbfTIva )->( dbGoTo( nRec ) )
    end

RETURN lValid



STATIC FUNCTION EdtRec( aTemp, aoGet, dbfTIva, oBrw, bWhen, bValid, nMode )

    local oDlg
    local oGet
    local cGet

   oDlg = TDialog():New(,,,, LblTitle( nMode ) + "tipos de " + cImp(), "TipoIva",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )






      aoGet[ 1 ] := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, aTemp[ 1 ], aTemp[ 1 ]:= u ) }, oDlg,,, {||    ( NotValid( aoGet[ 1 ], dbfTIva, .T., "0" ) )}, "N/W*",,,,, .F., {||     ( nMode == 1 .OR. nMode == 4 )},, .F., .F.,,,,,, nil,,, )





      TGetHlp():ReDefine( 120, { | u | If( PCount()==0, aTemp[ 2 ], aTemp[ 2 ]:= u ) }, oDlg,,,, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )









      TGetHlp():ReDefine( 130, { | u | If( PCount()==0, aTemp[ 3 ], aTemp[ 3 ]:= u ) }, oDlg,, "@E 99.99",, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .T.,,, {||      0}, {||      99},, nil,,, )









      TGetHlp():ReDefine( 140, { | u | If( PCount()==0, aTemp[ 4 ], aTemp[ 4 ]:= u ) }, oDlg,, "@E 99.999",, "N/W*",,,,, .F., {||         ( nMode <> 3 )},, .F., .T.,,, {||      0}, {||      99},, nil,,, )






      TGetHlp():ReDefine( 170, { | u | If( PCount()==0, aTemp[ 6 ], aTemp[ 6 ]:= u ) }, oDlg,, "9",, "N/W*",,,,, .F., {||     ( nMode <> 3 )},, .F., .F.,,,,,, nil,,, )




      TCheckBox():ReDefine( 180, { | u | If( PCount()==0, aTemp[ 8 ], aTemp[ 8 ]:= u ) }, oDlg,,,,,,, .F., {||     ( nMode <> 3 )}, .F. )




      TCheckBox():ReDefine( 190, { | u | If( PCount()==0, aTemp[ 13 ], aTemp[ 13 ]:= u ) }, oDlg,,,,,,, .F., {||     ( nMode <> 3 )}, .F. )





      TButton():ReDefine( 1, {||( if( nMode == 4, if( aoGet[ 1 ]:lValid(), lPreSave ( aTemp, aoGet, dbfTIva, oBrw, nMode, oDlg ), ), lPreSave ( aTemp, aoGet, dbfTIva, oBrw, nMode, oDlg ) ) )}, oDlg,,, .F., {||         ( nMode <> 3 )},,, .F. )




        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )

      if nMode <> 3
         oDlg:AddFastKey( 116, {|| if( nMode == 4, if( aoGet[ 1 ]:lValid(), lPreSave ( aTemp, aoGet, dbfTIva, oBrw, nMode, oDlg ), ), lPreSave ( aTemp, aoGet, dbfTIva, oBrw, nMode, oDlg ) ) } )
      end

   oDlg:AddFastKey ( 112, {|| GoHelp() } )

   oDlg:bStart := {|| aoGet[ 1 ]:SetFocus() }

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

RETURN ( oDlg:nResult == 1 )







FUNCTION nTiva( cTipoIva, nPctIva, nPctReq )

   local oBlock
   local oError
    local dbfTIva
   local cTemp    := 0

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TIva.Dbf" ), ( cCheckArea( "TIVA", @dbfTIva ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
   if !lAIS() ; ordListAdd( ( cPatDat() + "TIva.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

   if ( dbfTIva )->( dbSeek( cTipoIva ) )

      cTemp       := ( dbfTIva )->TpIva

      if nPctIva <> nil
         nPctIva  := ( dbfTIva )->TpIva
      end

      if nPctReq <> nil
         nPctReq  := ( dbfTIva )->nRecEq
      end

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

    ( dbfTIva )->( dbCloseArea() )

RETURN cTemp






FUNCTION nTReq( cTipoIva )

   local oBlock
   local oError
    local dbfTIva
    local cTemp

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TIva.Dbf" ), ( cCheckArea( "TIVA", @dbfTIva ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
   if !lAIS() ; ordListAdd( ( cPatDat() + "TIva.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

    IF (dbfTIva)->( DBSEEK( cTipoIva ) )
        cTemp = (dbfTIva)->NRECEQ
    ELSE
        cTemp = 0
    end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

    (dbfTIva)->( dbCloseArea() )

RETURN cTemp






FUNCTION cCodTerIva( cTipoIva, dbfIva )

   local cTemp    := Space( 1 )

   IF ( dbfIva )->( DbSeek( cTipoIva ) )
      cTemp       := (dbfIva)->CodTer
   end

RETURN cTemp






FUNCTION nIvaCodTer( cCodTer, dbfIva )

   local nTmp     := 0
   local nOrd     := ( dbfIva )->( OrdSetFocus( "CodTer" ) )

   IF ( dbfIva )->( DbSeek( cCodTer ) )
      nTmp        := ( dbfIva )->TpIva
   end

   ( dbfIva )->( OrdSetFocus( nOrd ) )

RETURN nTmp






FUNCTION nReqCodTer( cCodTer, dbfIva )

   local nTmp     := 0
   local nOrd     := ( dbfIva )->( OrdSetFocus( 4 ) )

   if ( dbfIva )->( dbSeek( cCodTer ) )
      nTmp        := ( dbfIva )->nRecEq
   end

   ( dbfIva )->( OrdSetFocus( nOrd ) )

RETURN nTmp







FUNCTION cCodTerToCodIva( cCodTer, dbfIva )

   local cTmp     := Space(1)
   local nOrd     := ( dbfIva )->( OrdSetFocus( "CodTer" ) )

   if ( dbfIva )->( DbSeek( cCodTer ) )
      cTmp        := ( dbfIva )->Tipo
   end

   ( dbfIva )->( OrdSetFocus( nOrd ) )

RETURN cTmp



FUNCTION BrwIva( oGet, dbfTIva, oGetNombre, lTipo )

   local oBlock
   local oError
   local oDlg
    local oGet1
    local cGet1
    local oBrw
   local nOrd     := GetBrwOpt( "BrwIva" )
    local oCbxOrd
   local aCbxOrd  := { "Código", "Nombre" }
   local cCbxOrd
   local lClose   := .F.
   local nLevel   := Auth():Level( "01036" )
   local cReturn  := Space( 1 )

   If( lTipo == nil, lTipo := .F., ) ;

   nOrd           := Min( Max( nOrd, 1 ), len( aCbxOrd ) )
   cCbxOrd        := aCbxOrd[ nOrd ]

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if Empty( dbfTIva )
      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TIva.Dbf" ), ( cCheckArea( "TIVA", @dbfTIva ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TIva.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClose      := .T.
   end

   nOrd           := ( dbfTIva )->( OrdSetFocus( nOrd ) )

   ( dbfTIva )->( dbGoTop() )

   oDlg = TDialog():New(,,,, "Tipos de " + cImp(), "HELPENTRY",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )





        oGet1 := TGetHlp():ReDefine( 104, { | u | If( PCount()==0, cGet1, cGet1:= u ) }, oDlg,,,,,,,,, .F.,, {|nKey,nFlags,Self| AutoSeek( nKey, nFlags, Self, oBrw, dbfTIva ) }, .F., .F.,,,,,, nil, "FIND",, )






        oCbxOrd := TComboBox():ReDefine( 102, { | u | If( PCount()==0, cCbxOrd, cCbxOrd:= u ) }, { "Código", "Nombre" }, oDlg,,, {|Self|( ( dbfTiva )->( OrdSetFocus( oCbxOrd:nAt ) ), oBrw:refresh(), oGet1:SetFocus() )},,,, .F.,,,,,,, "oCbxOrd",,,,,,, )

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:cAlias          := dbfTIva
      oBrw:nMarqueeStyle   := 5
      oBrw:cName           := "Browse.tipo " + cImp()

      with object ( oBrw:AddCol() )
         :cHeader          := "Código"
         :cSortOrder       := "Tipo"
         :bEditValue       := {|| ( dbfTIva )->Tipo }
         :nWidth           := 80
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Nombre"
         :cSortOrder       := "DescIva"
         :bEditValue       := {|| ( dbfTIva )->DescIva }
         :nWidth           := 200
         :bLClickHeader    := {| nMRow, nMCol, nFlags, oCol | oCbxOrd:Set( oCol:cHeader ) }
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "% " + cImp()
         :bEditValue       := {|| Trans( ( dbfTIva )->TpIva, "@E 999.99") }
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }
      oBrw:bRClicked       := {| nRow, nCol, nFlags | oBrw:RButtonDown( nRow, nCol, nFlags ) }

      oBrw:CreateFromResource( 105 )




        TButton():ReDefine( 1, {||( oDlg:end(1) )}, oDlg,,, .F.,,,, .F. )




        TButton():ReDefine( 2, {||( oDlg:end() )}, oDlg,,, .F.,,,, .F. )






        TButton():ReDefine( 500, {||( WinAppRec( oBrw, bEdit, dbfTIva ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 2 ) <> 0 .AND. !IsReport() )},,, .F. )




        TButton():ReDefine( 501, {||( WinEdtRec( oBrw, bEdit, dbfTIva ) )}, oDlg,,, .F., {||     ( nAnd( nLevel, 4 ) <> 0 .AND. !IsReport() )},,, .F. )

   if nAnd( nLevel, 2 ) <> 0 .AND. !IsReport()
      oDlg:AddFastKey( 113, {|| WinAppRec( oBrw, bEdit, dbfTIva ) } )
   end

   if nAnd( nLevel, 4 ) <> 0 .AND. !IsReport()
      oDlg:AddFastKey( 114, {|| WinEdtRec( oBrw, bEdit, dbfTIva ) } )
   end

   oDlg:AddFastKey( 116,       {|| oDlg:end( 1 ) } )
   oDlg:AddFastKey( 13,   {|| oDlg:end( 1 ) } )

   oDlg:bStart    := {|| oBrw:Load() }

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if oDlg:nResult == 1

      if lTipo
         cReturn  := ( dbfTIva )->TpIva
      else
         cReturn  := ( dbfTIva )->Tipo
      end

      if IsObject( oGet )
         oGet:cText( cReturn )
      end

      if IsObject( oGetNombre )
         oGetNombre:cText( ( dbfTIva )->DescIva )
      end

   end

   SetBrwOpt( "BrwIva", ( dbfTIva )->( OrdNumber() ) )

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClose
        ( dbfTIva )->( dbCloseArea() )
   else
      ( dbfTIva )->( OrdSetFocus( nOrd  ) )
   end

RETURN ( cReturn )



FUNCTION BigBrwIva( oGet, dbfTIva )

   local oBlock
   local oError
   local oDlg
   local oBrw
   local nOrd
   local cReturn  := Space( 1 )
   local nRec
   local oFont

   oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   nRec           := ( dbfTIva )->( Recno() )
   nOrd           := ( dbfTIva )->( OrdSetFocus( "Tipo" ) )

   ( dbfTIva )->( dbGoTop() )

   oFont := TFont():New( "Verdana", 0, -14,,,,,,,,,,,,,, )

   oDlg = TDialog():New(,,,, "Tipos de " + cImp(), "HELPENTRYTACTILIVA",, .F.,,,,,, .F.,,,,,, .F.,, "oDlg", nil, )

      oBrw                 := IXBrowse():New( oDlg )

      oBrw:bClrSel         := {|| { 0, ( 229 + ( 229 * 256 ) + ( 229 * 65536 ) ) } }
      oBrw:bClrSelFocus    := {|| { 0, ( 167 + ( 205 * 256 ) + ( 240 * 65536 ) ) } }

      oBrw:cAlias          := dbfTIva
      oBrw:nMarqueeStyle   := 5
      oBrw:cName           := "Browse.Bigtipo " + cImp()
      oBrw:nRowHeight      := 36
      oBrw:oFont           := oFont

      with object ( oBrw:AddCol() )
         :cHeader          := "Código"
         :bEditValue       := {|| ( dbfTIva )->Tipo }
         :nWidth           := 80
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "Nombre"
         :bEditValue       := {|| ( dbfTIva )->DescIva }
         :nWidth           := 200
      end

      with object ( oBrw:AddCol() )
         :cHeader          := "% " + cImp()
         :bEditValue       := {|| Trans( ( dbfTIva )->TpIva, "@E 999.99") }
         :nWidth           := 80
         :nDataStrAlign    := 1
         :nHeadStrAlign    := 1
      end

      oBrw:bLDblClick      := {|| oDlg:end( 1 ) }

      oBrw:CreateFromResource( 105 )





      TButtonBmp():ReDefine( 140, {||( oBrw:GoUp() )}, oDlg,,, .F.,,,, .F., "UP32",,, .F. )





      TButtonBmp():ReDefine( 150, {||( oBrw:GoDown() )}, oDlg,,, .F.,,,, .F., "DOWN32",,, .F. )





      TButtonBmp():ReDefine( 1, {||( oDlg:end(1) )}, oDlg,,, .F.,,,, .F., "gc_check_32",,, .F. )





      TButtonBmp():ReDefine( 2, {||( oDlg:End() )}, oDlg,,, .F.,,,, .F., "Delete_32",,, .F. )

   oDlg:bStart    := {|| oBrw:Load() }

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )

   if oDlg:nResult == 1

      cReturn  := ( dbfTIva )->TpIva

      if IsObject( oGet )
         oGet:cText( cReturn )
      end

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if !Empty( oFont )
      oFont:End()
   end

   ( dbfTIva )->( OrdSetFocus( nOrd  ) )

   ( dbfTIva )->( dbGoTo( nRec ) )

RETURN ( cReturn )






FUNCTION cCodigoIva( dbfIva, nPctIva )

   local cTemp       := Space( 1 )

   if dbSeekInOrd( Str( nPctIva, 6, 2 ), "TPIva", dbfIva )
      cTemp          := ( dbfIva )->Tipo
   else
      if dbSeekInOrd( Str( nPctIva, 6, 2 ), "nOldIva", dbfIva )
         cTemp       := ( dbfIva )->Tipo
      end
   end

RETURN cTemp






FUNCTION nPorcentajeRE( dbfIva, nPctIva )

   local nTemp       := 0

   if dbSeekInOrd( Str( nPctIva, 6, 2 ), "TPIva", dbfIva )
      nTemp          := ( dbfIva )->nRecEQ
   else
      if dbSeekInOrd( Str( nPctIva, 6, 2 ), "nOldIva", dbfIva )
         nTemp       := ( dbfIva )->nRecEQ
      end
   end

RETURN nTemp



FUNCTION retGrpAsc( nCodIva, dbfTiva, cRuta, cCodEmp )

   local nLenSubCta

   If( cRuta == nil, cRuta := cRutCnt(), ) ;
   If( cCodEmp == nil, cCodEmp := cEmpCnt( "A" ), ) ;

   nLenSubCta        := nLenCuentaContaplus( cRuta, cCodEmp )

RETURN ( Replicate( "0", nLenSubCta ) )







_HB_CLASS pdaTIvaSenderReciver ; function pdaTIvaSenderReciver ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "pdaTIvaSenderReciver", iif( .F., { }, { @HBObject() } ), @pdaTIvaSenderReciver() ) ) ;

   _HB_MEMBER CreateData(); oClass:AddMethod( "CreateData", @pdaTIvaSenderReciver_CreateData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS pdaTIvaSenderReciver ;



static FUNCTION pdaTIvaSenderReciver_CreateData( oPgrActual, oSayStatus, cPatPreVenta ) ; local Self AS CLASS pdaTIvaSenderReciver := QSelf() AS CLASS pdaTIvaSenderReciver

   local dbfIva
   local tmpIva
   local lExist      := .F.
   local cFileName
   local cPatPc      := if( Empty( cPatPreVenta ), AllTrim( cNombrePc() ), cPatPreVenta )

   dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TIva.Dbf" ), ( cCheckArea( "TIva", @dbfIva ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
   if !lAIS() ; ordListAdd( ( cPatDat() + "TIva.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

   dbUseArea( .T., cDriver(), cPatPc + "Datos\TIva.Dbf", cCheckArea( "TIva", @tmpIva ), .T. )
   ( tmpIva )->( ordListAdd( cPatPc + "Datos\TIva.Cdx" ) )

   if !Empty( oPgrActual )
      oPgrActual:SetRange( 0, ( tmpIva )->( OrdKeyCount() ) )
   end

   ( tmpIva )->( dbGoTop() )
   while !( tmpIva )->( eof() )

      if ( dbfIva )->( dbSeek( ( tmpIva )->Tipo ) )
         dbPass( tmpIva, dbfIva, .F. )
      else
         dbPass( tmpIva, dbfIva, .T. )
      end

      ( tmpIva )->( dbSkip() )

      if !Empty( oSayStatus )
         oSayStatus:SetText( "Sincronizando Tipos de " + cImp() + Alltrim( Str( ( tmpIva )->( OrdKeyNo() ) ) ) + " de " + Alltrim( Str( ( tmpIva )->( OrdKeyCount() ) ) ) )
      end

      SysRefresh()

      if !Empty( oPgrActual )
         oPgrActual:SetPos( ( tmpIva )->( OrdKeyNo() ) )
      end

      SysRefresh()

   end

   ( tmpIva )->( dbCloseArea() )
   ( dbfIva )->( dbCloseArea() )

Return ( Self )







Function IsIva()

   local oError
   local oBlock
   local dbfIva

   if !lExistTable( cPatDat() + "TIva.Dbf" )
      mkTiva( cPatDat() )
   end

   if !lExistIndex( cPatDat() + "TIva.Cdx" )
      rxTiva( cPatDat() )
   end

   oBlock                     := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TIva.Dbf" ), ( cCheckArea( "TIVA", @dbfIva ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TIva.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

      ( dbfIva )->( __dbLocate( { || ( dbfIva )->Tipo == "G" } ) )
      if!( dbfIva )->( Found() )
         ( dbfIva )->( dbAppend() )
         ( dbfIva )->Tipo     := "G"
         ( dbfIva )->DescIva  := "General"
         ( dbfIva )->TpIva    := 21
         ( dbfIva )->nRecEq   := 5.2
         ( dbfIva )->( dbUnLock() )
      end

      ( dbfIva )->( __dbLocate( { || ( dbfIva )->Tipo == "N" } ) )
      if!( dbfIva )->( Found() )
         ( dbfIva )->( dbAppend() )
         ( dbfIva )->Tipo     := "N"
         ( dbfIva )->DescIva  := "Reducido"
         ( dbfIva )->TpIva    := 10
         ( dbfIva )->nRecEq   := 1.4
         ( dbfIva )->( dbUnLock() )
      end

      ( dbfIva )->( __dbLocate( { || ( dbfIva )->Tipo == "R" } ) )
      if!( dbfIva )->( Found() )
         ( dbfIva )->( dbAppend() )
         ( dbfIva )->Tipo     := "R"
         ( dbfIva )->DescIva  := "Super reducido"
         ( dbfIva )->TpIva    := 4
         ( dbfIva )->nRecEq   := 0.5
         ( dbfIva )->( dbUnLock() )
      end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   ( dbfIva )->( dbCloseArea() )

Return ( .T. )



FUNCTION mkTiva( cPath, lAppend, cPathOld )

    local dbfTIva

   If( lAppend == nil, lAppend := .F., ) ;

   if !lExistTable( cPath + "TIva.Dbf" )
      dbCreate( cPath + "TIva.Dbf", aSqlStruct( aItmTIva() ), cDriver() )
   end

   if lAppend .AND. lIsDir( cPathOld )
      dbUseArea( .T., cDriver(), cPath + "TIva.Dbf", cCheckArea( "TIVA", @dbfTIva ), .F. )
      if !( dbfTIva )->( neterr() )
         ( dbfTIva )->( __dbApp( cPathOld + "TIva.Dbf" ) )
         ( dbfTIva )->( dbCloseArea() )
      end
   end

   rxTiva( cPath )

RETURN .T.



FUNCTION rxTiva( cPath )

    local dbfTIva

   If( cPath == nil, cPath := cPatDat(), ) ;

   if !lExistTable( cPath + "TIva.Dbf" )
      dbCreate( cPath + "TIva.Dbf", aSqlStruct( aItmTIva() ), cDriver() )
   end

   if lExistIndex( cPath + "TIva.Cdx" )
      fErase( cPath + "TIva.Cdx" )
   end

   dbUseArea( .T., cDriver(), cPath + "TIva.Dbf", cCheckArea( "TIVA", @dbfTIva ), .F. )

   if !( dbfTIva )->( neterr() )

      ( dbfTIva )->( __dbPack() )

      ( dbfTIva )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfTIva )->( ordCreate( cPath + "TIva.Cdx", "Tipo", "Field->Tipo", {|| Field->Tipo } ) )

      ( dbfTIva )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfTIva )->( ordCreate( cPath + "TIva.Cdx", "DescIva", "Upper( Field->DescIva )", {|| Upper( Field->DescIva ) } ) )

      ( dbfTIva )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfTIva )->( ordCreate( cPath + "TIva.Cdx", "TpIva", "Str( Field->TpIva, 6, 2 )", {|| Str( Field->TpIva, 6, 2 ) } ) )

      ( dbfTIva )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfTIva )->( ordCreate( cPath + "TIva.Cdx", "nOldIva", "Str( Field->nOldIva, 6, 2 )", {|| Str( Field->nOldIva, 6, 2 ) } ) )

      ( dbfTIva )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfTIva )->( ordCreate( cPath + "TIva.Cdx", "CodTer", "Field->CodTer", {|| Field->CodTer } ) )

      ( dbfTIva )->( ordCondSet("!Deleted()", {||!Deleted()}  ) )
      ( dbfTIva )->( ordCreate( cPath + "TIva.Cdx", "cCodWeb", "Str( Field->cCodWeb, 11 )", {|| Str( Field->cCodWeb, 11 ) } ) )

      ( dbfTIva )->( dbCloseArea() )

   else

      msgStop( "Imposible abrir en modo exclusivo la tabla de tipos de " + cImp() )

   end

RETURN NIL



function aItmTIva()

   local aItmTIva := {}

   aAdd( aItmTIva, { "Tipo",     "C",  1,  0 , "Código del tipo de impuesto",             "",   "", "( cDbf )" } )
   aAdd( aItmTIva, { "DescIva",  "C", 30,  0 , "Descripción del tipo de impuesto" ,       "",   "", "( cDbf )" } )
   aAdd( aItmTIva, { "TpIva",    "N",  6,  2 , "Tipo de impuesto" ,                       "",   "", "( cDbf )" } )
   aAdd( aItmTIva, { "nRecEq",   "N", 16,  6 , "Recargo de equivalencia" ,                "",   "", "( cDbf )" } )
   aAdd( aItmTIva, { "GrpAsc",   "C",  9,  0 , "Grupo de venta asociado" ,                "",   "", "( cDbf )" } )
   aAdd( aItmTIva, { "CodTer",   "C",  1,  0 , "Código para terminales" ,                 "",   "", "( cDbf )" } )
   aAdd( aItmTIva, { "cCodWeb",  "N", 11,  0 , "Código de la web" ,                       "",   "", "( cDbf )" } )
   aAdd( aItmTIva, { "lPubInt",  "L",  1,  0 , "Lógico para publicar en internet (S/N)",  "",   "", "( cDbf )" } )
   aAdd( aItmTIva, { "lSndDoc",  "L",  1,  0 , "Lógico para envios" ,                     "",   "", "( cDbf )" } )
   aAdd( aItmTIva, { "nOldIva",  "N",  6,  2 , "Tipo de impuesto anterior" ,              "",   "", "( cDbf )" } )
   aAdd( aItmTIva, { "nOldRec",  "N",  6,  2 , "Recargo de equivalencia anterior" ,       "",   "", "( cDbf )" } )
   aAdd( aItmTIva, { "cGrpWeb",  "N", 11,  0 , "Código del grupo de la web" ,             "",   "", "( cDbf )" } )
   aAdd( aItmTIva, { "lIgic",    "L",  1,  0 , "Lógico tipo igic" ,                       "",   "", "( cDbf )" } )

return ( aItmTIva )



FUNCTION nPReq( dbfTIva, nCodIva )

    local nTemp            := 0

   if dbSeekInOrd( Str( nCodIva, 6, 2 ), "TPIva", dbfTIva )
      nTemp          := ( dbfTIva )->nRecEq
   end

RETURN nTemp



FUNCTION nReq( dbfTIva, cCodIva )

    local cTemp         := 0

   if dbSeekInOrd( cCodIva, "Tipo", dbfTIva )
      cTemp          := ( dbfTIva )->nRecEq
   end

RETURN cTemp







FUNCTION nIva( dbfTIva, cCodIva )

   local oBlock
   local oError
   local nOrdFocus
   local lClose      := .F.
    local cTemp         := 0

   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if Empty( dbfTIva )
      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TIva.Dbf" ), ( cCheckArea( "TIVA", @dbfTIva ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TIva.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClose         := .T.
   end

   do case
   case ValType( dbfTIva ) == "C"

      nOrdFocus      := ( dbfTIva )->( OrdSetFocus( "TIPO" ) )

      if ( dbfTIva )->( dbSeek( cCodIva ) )
         cTemp       := ( dbfTIva )->TPIva
      end

      ( dbfTIva )->( OrdSetFocus( nOrdFocus ) )

   case ValType( dbfTIva ) == "O"

      nOrdFocus      := dbfTIva:OrdSetFocus( "TIPO" )

      if dbfTIva:Seek( cCodIva )
         cTemp       := dbfTIva:TPIva
      end

      dbfTIva:OrdSetFocus( nOrdFocus )

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClose
        ( dbfTIva )->( dbCloseArea() )
   end

RETURN cTemp



FUNCTION lTIva( uTipoIva, uPctIva, nPctReq )

   local oBlock
   local oError
   local nPctIva
   local lReturn        := .F.
   local lClose         := .F.

   oBlock               := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   if Empty( uTipoIva )
      dbUseArea( .T., ( cDriver() ), ( cPatDat() + "TIva.Dbf" ), ( cCheckArea( "TIVA", @uTipoIva ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
      if !lAIS() ; ordListAdd( ( cPatDat() + "TIva.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end
      lClose            := .T.
   end

   if IsObject( uPctIva )
      nPctIva           := uPctIva:VarGet()
   else
      nPctIva           := uPctIva
   end

   do case
      case IsObject( uTipoIva )

         if uTipoIva:SeekInOrd( Str( nPctIva, 6, 2 ), "TPIva" )

            if nPctReq <> nil
               nPctReq  := uTipoIva:nRecEq
            end

            lReturn     := .T.

         else

            if uTipoIva:SeekInOrd( Str( nPctIva, 6, 2 ), "nOldIva" ) .AND. uTipoIva:nOldIva <> 0

               if nPctReq <> nil
                  nPctReq  := uTipoIva:nRecEq
               end

               lReturn     := .T.

            else



               MsgStop( "Tipo de " + cImp() + " inexistente" )
               lReturn     := .F.



            end

         end

      case IsChar( uTipoIva )

         if dbSeekInOrd( Str( nPctIva, 6, 2 ), "TPIva", uTipoIva )

            if nPctReq <> nil
               nPctReq  := ( uTipoIva )->nRecEq
            end

            lReturn     := .T.

         else

            if dbSeekInOrd( Str( nPctIva, 6, 2 ), "nOldIva", uTipoIva ) .AND. ( uTipoIva )->nOldIva <> 0

               if nPctReq <> nil
                  nPctReq  := ( uTipoIva )->nRecEq
               end

               lReturn     := .T.

            else



            MsgStop( "Tipo de " + cImp() + " inexistente" )
            lReturn     := .F.



            end

         end

      end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

   if lClose
      ( uTipoIva )->( dbCloseArea() )
   end

RETURN lReturn



Static Function ChangePublicar()

   if ( dbfTIva )->( dbRLock() )
      ( dbfTIva )->lPubInt   := !( dbfTIva )->lPubInt
      ( dbfTIva )->lSndDoc   := ( dbfTIva )->lPubInt
      ( dbfTIva )->( dbUnLock() )
   end

   oWndBrw:Refresh()

Return nil



Static Function ChangelSndDoc( aTmp )

   if ( dbfTIva )->( dbRLock() )
      ( dbfTIva )->lSndDoc   := !( dbfTIva )->lSndDoc
      ( dbfTIva )->( dbUnLock() )
   end

   oWndBrw:Refresh()

Return nil



Static Function ActTiposIva()

   local cFileTiposIva
   local cConfigTiposIva
   local hConfigTiposIva

   cFileTiposIva                 := cPatConfig() + "\tiposiva.json"

   if !file( cFileTiposIva )
      MsgInfo( "No existe el ficheo de configuración" )
      RETURN nil
   end

   cConfigTiposIva               := memoread( cFileTiposIva )

   hb_jsonDecode( cConfigTiposIva, @hConfigTiposIva )

   if empty( hConfigTiposIva )
      msgStop( "Fichero " + cFileTiposIva + " formato no valido" )
      RETURN ( nil )
   end

   aeval( hConfigTiposIva, {|h| TiposIvaModel():InsertTiposIva(h) } )

   MsgInfo( "Proceso finalizado con éxito" )

RETURN ( nil )
