#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 6 ".\.\Prg\Tmasdet.prg"
static aObjBmps



_HB_CLASS TMasDet ; function TMasDet ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TMasDet", iif( .T., { @TMant() }, { @HBObject() } ), @TMasDet() ) ) ;

   _HB_MEMBER { oParent } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oParent"}, .F. )

   _HB_MEMBER { oDbfVir } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oDbfVir"}, .F. )

   _HB_MEMBER { cFirstKey } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cFirstKey"}, .F. )

   _HB_MEMBER { cSerDoc } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cSerDoc"}, .F. )
   _HB_MEMBER { cNumDoc } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cNumDoc"}, .F. )
   _HB_MEMBER { cSufDoc } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cSufDoc"}, .F. )

   _HB_MEMBER { aBmp } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aBmp"}, .F. )

   _HB_MEMBER { aIva } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aIva"}, .F. )

   _HB_MEMBER { aGetVir } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aGetVir"}, .F. )

   _HB_MEMBER { oBrwDet } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oBrwDet"}, .F. )

   _HB_MEMBER { bWhile } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bWhile"}, .F. )

   _HB_MEMBER { bOnPreAppend, bOnPostAppend } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnPreAppend", "bOnPostAppend"}, .F. )
   _HB_MEMBER { bOnPreEdit, bOnPostEdit } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnPreEdit", "bOnPostEdit"}, .F. )
   _HB_MEMBER { bOnPreDelete, bOnPostDelete } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnPreDelete", "bOnPostDelete"}, .F. )
   _HB_MEMBER { bOnPreSave, bOnPostSave } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnPreSave", "bOnPostSave"}, .F. )
   _HB_MEMBER { bOnPreLoad, bOnPostLoad } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnPreLoad", "bOnPostLoad"}, .F. )
   _HB_MEMBER { bDefaultValues } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bDefaultValues"}, .F. )

   _HB_MEMBER { bOnPreInsertDetail } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnPreInsertDetail"}, .F. )
   _HB_MEMBER { bOnPreAppendDetail, bOnPostAppendDetail } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnPreAppendDetail", "bOnPostAppendDetail"}, .F. )
   _HB_MEMBER { bOnPreEditDetail, bOnPostEditDetail } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnPreEditDetail", "bOnPostEditDetail"}, .F. )
   _HB_MEMBER { bOnPreDeleteDetail, bOnPostDeleteDetail } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnPreDeleteDetail", "bOnPostDeleteDetail"}, .F. )
   _HB_MEMBER { bOnPreSaveDetail, bOnPostSaveDetail } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnPreSaveDetail", "bOnPostSaveDetail"}, .F. )
   _HB_MEMBER { bOnPreLoadDetail, bOnPostLoadDetail } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnPreLoadDetail", "bOnPostLoadDetail"}, .F. )



   _HB_MEMBER { oRadSelect } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oRadSelect"}, .F. )
   _HB_MEMBER { AS NUMERIC nRadSelect } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nRadSelect"}, .F. )
   _HB_MEMBER { oChkSelect } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oChkSelect"}, .F. )
   _HB_MEMBER { AS LOGIC lChkSelect } ; oClass:AddMultiData( "LOGIC", .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lChkSelect"}, .F. )
   _HB_MEMBER { oChkUnSelect } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oChkUnSelect"}, .F. )
   _HB_MEMBER { AS LOGIC lChkUnSelect } ; oClass:AddMultiData( "LOGIC", .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lChkUnSelect"}, .F. )
   _HB_MEMBER { oDlgSelect } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oDlgSelect"}, .F. )
   _HB_MEMBER { oTreeSelect } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oTreeSelect"}, .F. )
   _HB_MEMBER { oMtrSelect } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oMtrSelect"}, .F. )
   _HB_MEMBER { cSerDocIni } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cSerDocIni"}, .F. )
   _HB_MEMBER { cSerDocFin } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cSerDocFin"}, .F. )
   _HB_MEMBER { nNumDocIni } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nNumDocIni"}, .F. )
   _HB_MEMBER { nNumDocFin } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nNumDocFin"}, .F. )
   _HB_MEMBER { cSufDocIni } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cSufDocIni"}, .F. )
   _HB_MEMBER { cSufDocFin } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cSufDocFin"}, .F. )

   _HB_MEMBER { oBtnCancel } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oBtnCancel"}, .F. )

   _HB_MEMBER { nLenDocIni } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nLenDocIni"}, .F. )

   _HB_MEMBER { AS LOGIC lNumDocChr } ; oClass:AddMultiData( "LOGIC", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lNumDocChr"}, .F. )

   _HB_MEMBER { AS LOGIC lMoveDlgSelect } ; oClass:AddMultiData( "LOGIC", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lMoveDlgSelect"}, .F. )

   _HB_MEMBER { cSerDocKey } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cSerDocKey"}, .F. )
   _HB_MEMBER { cNumDocKey } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cNumDocKey"}, .F. )
   _HB_MEMBER { cSufDocKey } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cSufDocKey"}, .F. )

   _HB_MEMBER { AS LOGIC lAutoActions } ; oClass:AddMultiData( "LOGIC", .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lAutoActions"}, .F. )

   _HB_MEMBER { AS LOGIC lMinimize } ; oClass:AddMultiData( "LOGIC", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lMinimize"}, .F. )

   _HB_MEMBER { AS LOGIC lFecha } ; oClass:AddMultiData( "LOGIC", .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lFecha"}, .F. )
   _HB_MEMBER { AS DATE dFechaDesde } ; oClass:AddMultiData( "DATE", CtoD( "01/01/" + Str( Year( Date() ) ) ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"dFechaDesde"}, .F. )
   _HB_MEMBER { AS DATE dFechaHasta } ; oClass:AddMultiData( "DATE", Date(), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"dFechaHasta"}, .F. )

   _HB_MEMBER NewDetail( cPath, oParent); oClass:AddMethod( "NewDetail", @TMasDet_NewDetail(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Load(); oClass:AddMethod( "Load", @TMasDet_Load(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER LoadAppend(); oClass:AddInline( "LoadAppend", {|Self | ( ( Self ) ), ( ::Load( .T. ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Cancel(); oClass:AddMethod( "Cancel", @TMasDet_Cancel(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Save(); oClass:AddMethod( "Save", @TMasDet_Save(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER LoadDetails(); oClass:AddMethod( "LoadDetails", @TMasDet_LoadDetails(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER End(); oClass:AddMethod( "End", @TMasDet_End(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER EndResource( nMode); oClass:AddMethod( "EndResource", @TMasDet_EndResource(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Append(); oClass:AddMethod( "Append", @TMasDet_Append(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER EndAppend(); oClass:AddMethod( "EndAppend", @TMasDet_EndAppend(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Dup(); oClass:AddMethod( "Dup", @TMasDet_Dup(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER EndDup(); oClass:AddMethod( "EndDup", @TMasDet_EndDup(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Edit(); oClass:AddMethod( "Edit", @TMasDet_Edit(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER EndEdit(); oClass:AddMethod( "EndEdit", @TMasDet_EndEdit(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Zoom(); oClass:AddMethod( "Zoom", @TMasDet_Zoom(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Del(); oClass:AddMethod( "Del", @TMasDet_Del(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Next( oBrw); oClass:AddMethod( "Next", @TMasDet_Next(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Prior( oBrw); oClass:AddMethod( "Prior", @TMasDet_Prior(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER AppendDet(); oClass:AddMethod( "AppendDet", @TMasDet_AppendDet(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER EditDet(); oClass:AddMethod( "EditDet", @TMasDet_EditDet(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ZoomDet(); oClass:AddMethod( "ZoomDet", @TMasDet_ZoomDet(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER DeleteDet(); oClass:AddMethod( "DeleteDet", @TMasDet_DeleteDet(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER DelDetail(); oClass:AddMethod( "DelDetail", @TMasDet_DelDetail(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER MultiDeleteDet(); oClass:AddMethod( "MultiDeleteDet", @TMasDet_MultiDeleteDet(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER DupDet() ; oClass:AddVirtual( "DupDet" )

   _HB_MEMBER Detalle( nMode) ; oClass:AddVirtual( "Detalle" )

   _HB_MEMBER StartSelect( cChkTitle); oClass:AddMethod( "StartSelect", @TMasDet_StartSelect(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SelectRec( bAction, cDlgTitle, cChkTitle); oClass:AddMethod( "SelectRec", @TMasDet_SelectRec(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER EvalSelect( bAction); oClass:AddMethod( "EvalSelect", @TMasDet_EvalSelect(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER RollBack(); oClass:AddMethod( "RollBack", @TMasDet_RollBack(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SaveDetails(); oClass:AddMethod( "SaveDetails", @TMasDet_SaveDetails(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER CancelDetails(); oClass:AddMethod( "CancelDetails", @TMasDet_CancelDetails(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER DefineDetails() ; oClass:AddVirtual( "DefineDetails" )

   _HB_MEMBER ReportDetails(); oClass:AddMethod( "ReportDetails", @TMasDet_ReportDetails(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER GetNewCount() ; oClass:AddVirtual( "GetNewCount" )
   _HB_MEMBER PutNewCount() ; oClass:AddVirtual( "PutNewCount" )

   _HB_MEMBER GetFirstKey(); oClass:AddInline( "GetFirstKey", {|Self | ( ( Self ) ), ( if( ::bFirstKey <> nil, ::cFirstKey := Eval( ::bFirstKey, Self ), ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER OpenService( lExclusive, cPath); oClass:AddMethod( "OpenService", @TMasDet_OpenService(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER CloseService(); oClass:AddMethod( "CloseService", @TMasDet_CloseService(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER CloseFiles(); oClass:AddMethod( "CloseFiles", @TMasDet_CloseFiles(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER AddDetail( oDetail); oClass:AddMethod( "AddDetail", @TMasDet_AddDetail(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Activate(); oClass:AddMethod( "Activate", @TMasDet_Activate(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER oDefDiv( nId, nIdBmp, nIdChg, oDlg, nMode); oClass:AddMethod( "oDefDiv", @TMasDet_oDefDiv(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER OpenDetails(); oClass:AddInline( "OpenDetails", {|Self | ( ( Self ) ), ( aSend( ::oDbfDet, "OpenFiles()" ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER CloseDetails(); oClass:AddInline( "CloseDetails", {|Self | ( ( Self ) ), ( aSend( ::oDbfDet, "CloseFiles()" ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER nRegisterToProcess(); oClass:AddMethod( "nRegisterToProcess", @TMasDet_nRegisterToProcess(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TMasDet ;



static FUNCTION TMasDet_NewDetail( cPath, oParent ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   If( cPath == nil, cPath := cPatEmp(), ) ;

   ::cPath              := cPath
   ::oParent            := oParent

RETURN ( Self )



static FUNCTION TMasDet_Load( lAppend ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   If( lAppend == nil, lAppend := .F., ) ;

   if Empty( ::oDbfVir )
      ::oDbfVir      := ::DefineFiles( cPatTmp(), cLocalDriver(), .T. )
   end

   if !( ::oDbfVir:Used() )
      ::oDbfVir:Activate( .F., .F. )
   end

   if ::oParent:cFirstKey <> nil

      if ( lAppend ) .AND. ::oDbf:Seek( ::oParent:cFirstKey )

         while !Empty( ::oDbf:OrdKeyVal() ) .AND. ( ::oDbf:OrdKeyVal() <= ::oParent:cFirstKey ) .AND. !::oDbf:Eof()

            if ::bOnPreLoad <> nil
               Eval( ::bOnPreLoad, Self )
            end

            ::oDbfVir:AppendFromObject( ::oDbf )

            if ::bOnPostLoad <> nil
               Eval( ::bOnPostLoad, Self )
            end

            ::oDbf:Skip()

         end

      end

   end

   ::oDbfVir:GoTop()

RETURN ( Self )



static FUNCTION TMasDet_Save( ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   ::oDbfVir:OrdSetFocus( 0 )

   ::oDbfVir:GoTop()
   while !::oDbfVir:eof()

      if ::bOnPreSaveDetail <> nil
         Eval( ::bOnPreSaveDetail, Self )
      end

      ::oDbf:AppendFromObject( ::oDbfVir )








      if ::bOnPostSaveDetail <> nil
         Eval( ::bOnPostSaveDetail, Self )
      endif

      ::oDbfVir:Skip()

   end

   ::Cancel()

RETURN ( Self )



static FUNCTION TMasDet_Cancel( ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local cFileName   := ::oDbfVir:cPath + ::oDbfVir:cName

   if !Empty( ::oDbfVir ) .AND. ::oDbfVir:Used()
      ::oDbfVir:Zap()
      ::oDbfVir:End()
   end

   dbfErase( cFileName )

RETURN ( Self )



static FUNCTION TMasDet_LoadDetails( lAppend ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   If( lAppend == nil, lAppend := .F., ) ;

   CursorWait()

   ::GetFirstKey()

   if ::cFirstKey <> nil

      do case
         case ValType( ::oDbfDet ) == "O"

            ::oDbfVir         := ::DefineDetails( cPatTmp(), cLocalDriver(), .T. )

            if ::oDbfVir <> nil

               ::oDbfVir:Activate( .F., .F. )

               if !lAppend .AND. ::bDefaultValues <> nil
                  Eval( ::bDefaultValues, Self )
               end

               if ( lAppend ) .AND. ::oDbfDet:Seek( ::cFirstKey )

                  while !Empty( ::oDbfDet:OrdKeyVal() ) .AND. ( ::oDbfDet:OrdKeyVal() <= ::cFirstKey ) .AND. !::oDbfDet:Eof()

                     if ::bOnPreLoad <> nil
                        Eval( ::bOnPreLoad, Self )
                     end

                     ::oDbfVir:AppendFromObject( ::oDbfDet )

                     if ::bOnPostLoad <> nil
                        Eval( ::bOnPostLoad, Self )
                     end

                     ::oDbfDet:Skip()

                  end

                  ::oDbfVir:GoTop()

               end

            end

         case ValType( ::oDbfDet ) == "A"

            if lAppend
               aSend( ::oDbfDet, "LoadAppend()" )
            else
               aSend( ::oDbfDet, "Load()" )
            end

      end

   end

   CursorWE()

RETURN ( Self )



static FUNCTION TMasDet_RollBack( ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   ::GetFirstKey()

   if ::cFirstKey <> nil

      do case
         case IsObject( ::oDbfDet )

            while ::oDbfDet:Seek( ::cFirstKey )

               if ::bOnPreDeleteDetail <> nil
                  Eval( ::bOnPreDeleteDetail, Self )
               end

               ::oDbfDet:Delete( .F. )

               if ::bOnPostDeleteDetail <> nil
                  Eval( ::bOnPostDeleteDetail, Self )
               end

            end

         case IsArray( ::oDbfDet )

            aSend( ::oDbfDet, "RollBack()" )

         case IsNil( ::oDbfDet )

            if ::oParent:cFirstKey <> nil

               while ::oDbf:Seek( ::oParent:cFirstKey )

                  if ::bOnPreDeleteDetail <> nil
                     Eval( ::bOnPreDeleteDetail, Self )
                  end

                  ::oDbf:Delete( .F. )

                  if ::bOnPostDeleteDetail <> nil
                     Eval( ::bOnPostDeleteDetail, Self )
                  end

               end

            end

      end

   end

RETURN ( Self )



static FUNCTION TMasDet_SaveDetails( ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local nOrd



   do case
      case IsObject( ::oDbfDet )

         nOrd     := ::oDbfVir:OrdSetFocus( 0 )

         ::oDbfVir:GoTop()
         while !::oDbfVir:eof()

            if ::bOnPreSaveDetail <> nil
               Eval( ::bOnPreSaveDetail, Self )
            end

            ::oDbfDet:AppendFromObject( ::oDbfVir )

            if ::bOnPostSaveDetail <> nil
               Eval( ::bOnPostSaveDetail, Self )
            endif

            ::oDbfVir:Skip()

         end

      case IsArray( ::oDbfDet )

         aSend( ::oDbfDet, "Save()" )

   end

   dbCommitAll()



RETURN ( Self )



static FUNCTION TMasDet_CancelDetails( ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local cFileName

   do case
      case IsObject( ::oDbfDet )

         cFileName   := ::oDbfVir:cPath + ::oDbfVir:cName

         if !Empty( ::oDbfVir ) .AND. ::oDbfVir:Used()
            ::oDbfVir:Zap()
            ::oDbfVir:End()
         end

         dbfErase( cFileName )

      case IsArray( ::oDbfDet )

         aSend( ::oDbfDet, "Cancel()" )

   end

RETURN ( Self )



static FUNCTION TMasDet_OpenService( lExclusive, cPath ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local lOpen          := .T.
   local oError
   local oBlock         := ErrorBlock( {| oError | ApoloBreak( oError ) } )

   If( lExclusive == nil, lExclusive := .F., ) ;

   BEGIN SEQUENCE

      if Empty( ::oDbf )
         ::oDbf         := ::DefineFiles( cPath )
      end

      ::oDbf:Activate( .F., !( lExclusive ) )

   RECOVER USING oError

      lOpen             := .F.

      msgStop( ErrorMessage( oError ), "Imposible abrir todas las bases de datos" )

      ::CloseService()

   end

   ErrorBlock( oBlock )

RETURN ( lOpen )



static FUNCTION TMasDet_CloseService( ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if !Empty( ::oDbf ) .AND. ::oDbf:Used()
      ::oDbf:End()
   end

   ::oDbf            := nil

RETURN ( .T. )



static FUNCTION TMasDet_ReportDetails( ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local n
   local aPrompt     := {}
   local aoCols      := {}
   local oDbfDet

   ::oDbf:GetStatus()

   do case
      case ValType( ::oDbfDet ) == "O"
         oDbfDet     := ::oDbfDet
         ::oDbfDet:GetStatus()
      case ValType( ::oDbfDet ) == "A"
         oDbfDet     := ::oDbfDet[ 1 ]:oDbf
         aSend( ::oDbfDet, "GetStatus()" )
   end





   for n := 1 to oDbfDet:FCount()

      if !oDbfDet:aTField[ n ]:lCalculate









         aAdd( aoCols, {   oDbfDet:aTField[ n ]:cName, oDbfDet:aTField[ n ]:cType, oDbfDet:aTField[ n ]:nLen, oDbfDet:aTField[ n ]:nDec, oDbfDet:aTField[ n ]:cPict, SubStr( oDbfDet:aTField[ n ]:cComment, 1, oDbfDet:aTField[ n ]:nLen + oDbfDet:aTField[ n ]:nDec ), !oDbfDet:aTField[ n ]:lHide, oDbfDet:aTField[ n ]:cComment, oDbfDet:aTField[ n ]:nLen + oDbfDet:aTField[ n ]:nDec } )

      endif

   next

   for n := 1 to len( oDbfDet:aTIndex )
      aAdd( aPrompt, { oDbfDet:aTIndex[ n ]:cComment } )
   next

   ::oReport            := TInfGen():New( ::oDbf:cComment, aoCols )

   ::oReport:lDefDivInf := .F.
   ::oReport:lDefSerInf := .F.
   ::oReport:lDefFecInf := .F.

   ::oReport:oParent    := Self
   ::oReport:oDbfMai    := ::oDbf
   ::oReport:oDbfDet    := oDbfDet

   ::oReport:AddTmpIndex( "cName", oDbfDet:OrdKey(), "!Deleted()" )

   ::oReport:AddGroup( {|| ::oReport:oDbfMai:OrdKeyVal() }, {|| "Grupo : " + ::oReport:oDbfMai:OrdKeyVal() } )

   ::oReport:StdResource()
   ::oReport:oDefDesHas()

   ::oReport:Activate()
   ::oReport:End()

   do case
      case ValType( ::oDbfDet ) == "O"
         ::oDbfDet:SetStatus()

      case ValType( ::oDbfDet ) == "A"
         aSend( ::oDbfDet, "SetStatus()" )

   end

   ::oDbf:SetStatus()

RETURN NIL



static FUNCTION TMasDet_Append( oBrw ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local lAppend
   local lTrigger

   if ::lMinimize
      if( ::oWndBrw <> nil, ::oWndBrw:Minimize(), )
   end

   if ::bOnPreAppend <> nil
      lTrigger := Eval( ::bOnPreAppend, Self )
      if Valtype( lTrigger ) == "L" .AND. !lTrigger
         return .F.
      end
   end

   ::nMode        := 1

   ::oDbf:Blank()
   ::oDbf:SetDefault()

   ::LoadDetails( .T. )

   lAppend       := ::Resource( 1 )

   if ::lAutoActions
      ::EndAppend( lAppend )
   end

   if ::lMinimize
      if( ::oWndBrw <> nil, ( ::oWndBrw:Maximize(), ::oWndBrw:Refresh() ), )
   end

   if lAppend .AND. !Empty( oBrw )
      oBrw:Refresh()
   end

   if ::bOnPostAppend <> nil
      Eval( ::bOnPostAppend, Self )
   end

return ( lAppend )



static FUNCTION TMasDet_EndAppend( lAppend ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if lAppend

      ::GetNewCount()

      ::oDbf:Insert()

      ::SaveDetails( 1 )

      if( ::oWndBrw <> nil, ::oWndBrw:Refresh(), )

   else

      ::oDbf:Cancel()

      if( ::oWndBrw <> nil, ::oWndBrw:Refresh(), )

   end

   ::CancelDetails()

return ( lAppend )



static FUNCTION TMasDet_Edit( oBrw ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local lEdit
   local lTrigger

   if ::oDbf:OrdKeyCount() == 0
      return .F.
   end

   if ::lMinimize
      if ( ::oWndBrw <> nil, ::oWndBrw:Minimize(), )
   end

   ::nMode        := 2

   if ::oDbf:RecLock()

      if ::bOnPreEdit <> nil
         lTrigger    := Eval( ::bOnPreEdit, Self )
         if Valtype( lTrigger ) == "L" .AND. !lTrigger
            ::oDbf:UnLock()
            return .F.
         end
      end

      ::oDbf:Load( .F. )

      ::LoadDetails( .T. )

      lEdit          := ::Resource( 2 )

      if ::lAutoActions
         ::EndEdit( lEdit )
      end

      if lEdit .AND. !Empty( oBrw )
         oBrw:Refresh()
      end

      if ::bOnPostEdit <> nil
         lTrigger    := Eval( ::bOnPostEdit, Self )
      end

      ::oDbf:UnLock()

   end

   if ::lMinimize
      if ( ::oWndBrw <> nil, ::oWndBrw:Maximize(), )
   end

   if ( ::oWndBrw <> nil, ::oWndBrw:Refresh(), )

RETURN ( .T. )



static FUNCTION TMasDet_EndEdit( lEdit ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if lEdit

      ::RollBack()

      ::oDbf:Save( .F. )

      ::SaveDetails( 2 )

   else

      ::oDbf:Cancel()

   end

   ::CancelDetails()

Return ( lEdit )



static FUNCTION TMasDet_Zoom( oBrw ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   ::nMode        := 3

   ::GetFirstKey()

   if ::oDbf:RecLock()

      ::oDbf:Load()

      ::LoadDetails( .T. )

      ::Resource( 3 )

      ::CancelDetails()

      ::oDbf:Cancel()

      ::oDbf:UnLock()

   end

   if !Empty( oBrw )
      oBrw:Refresh()
   end

RETURN ( .T. )



static FUNCTION TMasDet_Del( lHead, lDetail ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local nRec
   local cTxt
   local lDel        := .F.
   local nMarked
   local lTrigger

   If( lHead == nil, lHead := .T., ) ;
   If( lDetail == nil, lDetail := .T., ) ;

   if ::bOnPreDelete <> nil
      lTrigger       := Eval( ::bOnPreDelete, Self )
      if IsLogic( lTrigger ) .AND. !lTrigger
         return .F.
      end
   end

   if !empty( ::oWndBrw ) .AND. !empty( ::oWndBrw:oBrw ) .AND. ( "XBROWSE" $ ::oWndBrw:oBrw:ClassName() ) .AND. ( len( ::oWndBrw:oBrw:aSelected ) > 1 )

      cTxt           := "¿ Desea eliminar definitivamente " + AllTrim( Trans( len( ::oWndBrw:oBrw:aSelected ), "999999" ) ) + " registros ?"

      if RolesModel():getRolNoConfirmacionEliminacion( Auth():rolUuid() ) .OR. ApoloMsgNoYes( cTxt, "Confirme supresión" )

         CursorWait()

         for each nRec in ( ::oWndBrw:oBrw:aSelected )

            ::oDbf:GoTo( nRec )

            if lDetail
               ::RollBack()
            end

            if lHead
               ::oDbf:Delete()
            end

            lDel     := .T.

         next

         CursorWE()

      end

   else

      if RolesModel():getRolNoConfirmacionEliminacion( Auth():rolUuid() ) .OR. apoloMsgNoYes("¿Desea eliminar el registro en curso?", "Confirme supresión" )

         CursorWait()

         if lDetail
            ::RollBack()
         end

         if lHead
            ::oDbf:Delete()
         end

         lDel     := .T.

         CursorWE()

      end

      if ::bOnPostDelete <> nil
         return Eval( ::bOnPostDelete, Self )
      end

   end

RETURN ( lDel )



static FUNCTION TMasDet_Dup( oBrw ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local lAppend
   local lTrigger

   if ::bOnPreAppend <> nil
      lTrigger := Eval( ::bOnPreAppend, Self )
      if Valtype( lTrigger ) == "L" .AND. !lTrigger
         return .F.
      end
   end

   ::oDbf:Load()

   ::LoadDetails( .T. )

   lAppend       := ::Resource( 1 )

   if ::lAutoActions
      ::EndDup( lAppend )
   end

   if lAppend .AND. !Empty( oBrw )
      oBrw:Refresh()
   end

   if ::bOnPostAppend <> nil
      return ( Eval( ::bOnPostAppend, Self ) )
   end

RETURN ( lAppend )



static FUNCTION TMasDet_EndDup( lAppend ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if lAppend

      ::GetNewCount()

      ::oDbf:Insert()

      ::SaveDetails( 1 )

      if( ::oWndBrw <> nil, ::oWndBrw:Refresh(), )

   else

      ::oDbf:Cancel()

      if( ::oWndBrw <> nil, ::oWndBrw:Refresh(), )

   end

   ::CancelDetails()

RETURN ( lAppend )



static FUNCTION TMasDet_Next( nMode, oBrw ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local nRecno
   local lTrigger

   if ::oDbf:OrdKeyCount() == 0
      return .F.
   end

   nRecno      := ::oDbf:Recno()





   ::RollBack()

   ::oDbf:Save()

   ::SaveDetails( 2 )

   ::oDbf:UnLock()

   ::oDbf:Next()

   if !::oDbf:Eof()

      if ::oDbf:RecLock()

         if ::bOnPreEdit <> nil

            lTrigger    := Eval( ::bOnPreEdit, Self )
            if IsLogic( lTrigger ) .AND. !lTrigger
               ::oDbf:UnLock()
               return .F.
            end

         end

         ::oDbf:Load()

         ::LoadDetails( .T. )

      end

   else

      ::oDbf:GoTo( nRecno )

      RETURN ( .F. )

   end

   if ( ::oWndBrw <> nil, ::oWndBrw:Refresh(), )

RETURN ( .T. )



static FUNCTION TMasDet_Prior( nMode, oBrw ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local nRecno
   local lTrigger

   if ::oDbf:OrdKeyCount() == 0
      return .F.
   end

   nRecno      := ::oDbf:Recno()





   ::RollBack()

   ::oDbf:Save()

   ::SaveDetails( 2 )

   ::oDbf:UnLock()

   ::oDbf:Prior()

   if !::oDbf:Bof()

      if ::oDbf:RecLock()

         if ::bOnPreEdit <> nil

            lTrigger    := Eval( ::bOnPreEdit, Self )
            if IsLogic( lTrigger ) .AND. !lTrigger
               ::oDbf:UnLock()
               return .F.
            end

         end

         ::oDbf:Load()

         ::LoadDetails( .T. )

      end

   else

      ::oDbf:GoTo( nRecno )

      RETURN ( .F. )

   end

   if ( ::oWndBrw <> nil, ::oWndBrw:Refresh(), )

RETURN ( .T. )



static FUNCTION TMasDet_AppendDet( ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local lTrigger

   while .T.

      if ::bOnPreAppendDetail <> nil
         lTrigger := Eval( ::bOnPreAppendDetail, Self )
         if Valtype( lTrigger ) == "L" .AND. !lTrigger
            return .F.
         end
      end

      ::oDbfVir:Blank()

      if ::Detalle( 1 )

         ::oDbfVir:Insert()

         if ::oBrwDet <> nil
            ::oBrwDet:Refresh()
         end

         if ::bOnPostAppendDetail <> nil
            Eval( ::bOnPostAppendDetail, Self )
         end

         if lEntCon()
            loop
         else
            exit
         end

      else

         ::oDbfVir:Cancel()

         if ::oBrwDet <> nil
            ::oBrwDet:Refresh()
         end

         exit

      end

   end

RETURN ( Self )



static FUNCTION TMasDet_EditDet( ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if ::oDbfVir:Recno() == 0
      Return ( Self )
   end

   ::oDbfVir:Load()

   if ::Detalle( 2 )

      ::oDbfVir:Save()

      if ::bOnPostEditDetail <> nil
         Eval( ::bOnPostEditDetail, Self )
      end

   else

      ::oDbfVir:Cancel()

   end

   if( ::oBrwDet <> nil, ::oBrwDet:Refresh(), )

RETURN ( Self )



static FUNCTION TMasDet_ZoomDet( ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if ::oDbfVir:Recno() == 0
      Return ( Self )
   end

   ::oDbfVir:Load()
   ::Detalle( 3 )
   ::oDbfVir:Cancel()

Return ( Self )



static FUNCTION TMasDet_DeleteDet( lMessage ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   If( lMessage == nil, lMessage := .T., ) ;

   if ::oDbfVir:Recno() == 0
      RETURN ( Self )
   end

   if RolesModel():getRolNoConfirmacionEliminacion( Auth():rolUuid() ) .OR. if( lMessage, ApoloMsgNoYes("¿ Desea eliminar definitivamente este registro ?", "Confirme supersión" ), .T. )

      ::oDbfVir:Delete( .T. )

      if ::bOnPostDeleteDetail <> nil
         Eval( ::bOnPostDeleteDetail, Self )
      end

      if( ::oBrwDet <> nil, ::oBrwDet:Refresh(), )

   end

RETURN ( Self )



static FUNCTION TMasDet_MultiDeleteDet( ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local nSelected
   local aSelected  := ::oBrwDet:aSelected


   if RolesModel():getRolNoConfirmacionEliminacion( Auth():rolUuid() ) .OR.  ApoloMsgNoYes( "¿ Desea eliminar definitivamente " + alltrim( str( len( aSelected ) ) ) + " registro(s) ?", "Confirme supersión" )

      for each nSelected in aSelected
         ::oDbfVir:GoTo( nSelected )
         ::DeleteDet( .F. )
      next

   end

Return ( self )



static FUNCTION TMasDet_DelDetail( ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if ::oDbfVir:Recno() == 0
      Return ( Self )
   end

   if ::cFirstKey <> nil

      while ::oDbfVir:Seek( ::cFirstKey )

         ::oDbfVir:Delete( .F. )

         if ::bOnPostDeleteDetail <> nil
            Eval( ::bOnPostDeleteDetail, Self )
         end

      end

   end

RETURN ( Self )



static FUNCTION TMasDet_SelectRec( bAction, cDlgTitle, cChkTitle, lClose ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local oSerDocIni
   local oNumDocIni
   local oSufDocIni
   local oBtnDocIni
   local oSerDocFin
   local oNumDocFin
   local oSufDocFin
   local oBtnDocFin
   local nMtrInf     := 0
   local cPicture    := "999999999"
   local oImageList

   If( bAction == nil, bAction := {|| msgStop( "bAction no pasado" ) }, ) ;
   If( cDlgTitle == nil, cDlgTitle := "", ) ;
   If( cChkTitle == nil, cChkTitle := "", ) ;
   If( lClose == nil, lClose := .F., ) ;

   if !Empty( ::oWndBrw:oBrw ) .AND. len( ::oWndBrw:oBrw:aSelected ) > 1
      ::nRadSelect   := 1
   else
      ::nRadSelect   := 2
   end

   oImageList        := TImageList():New( 16, 16 )
   oImageList:AddMasked( TBitmap():Define( "bRed" ), ( 255 + ( 0 * 256 ) + ( 255 * 65536 ) ) )
   oImageList:AddMasked( TBitmap():Define( "bGreen" ), ( 255 + ( 0 * 256 ) + ( 255 * 65536 ) ) )

   if ::cSerDocKey <> nil
      ::cSerDocIni   := ::cSerDocFin   := ::oDbf:FieldGetName( ::cSerDocKey )
   end

   ::nNumDocIni      := ::nNumDocFin   := ::oDbf:FieldGetName( ::cNumDocKey )
   ::cSufDocIni      := ::cSufDocFin   := ::oDbf:FieldGetName( ::cSufDocKey )

   if ValType( ::nNumDocIni ) == "C"
      ::lNumDocChr   := .T.
      ::nLenDocIni   := Len( ::nNumDocIni )
      ::nNumDocIni   := Val( Trans( ::nNumDocIni, cPicture ) )
      ::nNumDocFin   := Val( Trans( ::nNumDocFin, cPicture ) )
   else
      ::nLenDocIni   := Len( Str( ::nNumDocIni ) )
   end

   cPicture          := Replicate( "9", ::nLenDocIni )

   ::oDlgSelect = TDialog():New(,,,, cDlgTitle, "SelectRango",, .F.,,,,,, .F.,,,,,, .F.,, "::oDlgSelect", nil, )



   ::oRadSelect := TRadMenu():Redefine( { | u | If( PCount()==0, ::nRadSelect, ::nRadSelect:= u ) }, ::oDlgSelect,, { 80, 81 },,,,, .F.,, )









   oSerDocIni := TGetHlp():ReDefine( 100, { | u | If( PCount()==0, ::cSerDocIni, ::cSerDocIni:= u ) }, ::oDlgSelect,, "@!", {||    ( ::cSerDocIni >= "A" .AND. ::cSerDocIni <= "Z"  )},,,,,, .F., {||     ( ::nRadSelect == 2 )},, .F., .T., {||    ( UpSerie( oSerDocIni ) )}, {||  ( DwSerie( oSerDocIni ) )},,,, nil,,, )






   oBtnDocIni := TBtnBmp():ReDefine( 101, "Up16",,,,,, ::oDlgSelect, .F.,, .F.,,,,,, !.T.,, .F.,,, .F., !.F.,, .F. )
   oBtnDocIni:bAction   := {|| dbFirst( ::oDbf:cAlias, ::cNumDocKey, oNumDocIni, ::cSerDocIni ) }






   oNumDocIni := TGetHlp():ReDefine( 120, { | u | If( PCount()==0, ::nNumDocIni, ::nNumDocIni:= u ) }, ::oDlgSelect,, cPicture,,,,,,, .F., {||     ( ::nRadSelect == 2 )},, .F., .T.,,,,,, nil,,, )






   oBtnDocFin := TBtnBmp():ReDefine( 111, "Down16",,,,,, ::oDlgSelect, .F.,, .F.,,,,,, !.T.,, .F.,,, .F., !.F.,, .F. )
   oBtnDocFin:bAction   := {|| dbLast( ::oDbf:cAlias, ::cNumDocKey, oNumDocFin, ::cSerDocFin ) }




   oSufDocIni := TGetHlp():ReDefine( 140, { | u | If( PCount()==0, ::cSufDocIni, ::cSufDocIni:= u ) }, ::oDlgSelect,,,,,,,,, .F., {||     ( ::nRadSelect == 2 )},, .F., .F.,,,,,, nil,,, )









   oSerDocFin := TGetHlp():ReDefine( 110, { | u | If( PCount()==0, ::cSerDocFin, ::cSerDocFin:= u ) }, ::oDlgSelect,, "@!", {||    ( ::cSerDocFin >= "A" .AND. ::cSerDocFin <= "Z"  )},,,,,, .F., {||     ( ::nRadSelect == 2 )},, .F., .T., {||    ( UpSerie( oSerDocFin ) )}, {||  ( DwSerie( oSerDocFin ) )},,,, nil,,, )






   oNumDocFin := TGetHlp():ReDefine( 130, { | u | If( PCount()==0, ::nNumDocFin, ::nNumDocFin:= u ) }, ::oDlgSelect,, cPicture,,,,,,, .F., {||     ( ::nRadSelect == 2 )},, .F., .T.,,,,,, nil,,, )




   oSufDocFin := TGetHlp():ReDefine( 150, { | u | If( PCount()==0, ::cSufDocFin, ::cSufDocFin:= u ) }, ::oDlgSelect,,,,,,,,, .F., {||     ( ::nRadSelect == 2 )},, .F., .F.,,,,,, nil,,, )







   TCheckBox():ReDefine( 300, { | u | If( PCount()==0, ::lFecha, ::lFecha:= u ) }, ::oDlgSelect,,,,,,, .F.,, .F. )





   TGetHlp():ReDefine( 310, { | u | If( PCount()==0, ::dFechaDesde, ::dFechaDesde:= u ) }, ::oDlgSelect,,,,,,,,, .F., {||     ( !::lFecha )},, .F., .T.,,,,,, nil,,, )





   TGetHlp():ReDefine( 320, { | u | If( PCount()==0, ::dFechaHasta, ::dFechaHasta:= u ) }, ::oDlgSelect,,,,,,,,, .F., {||     ( !::lFecha )},, .F., .T.,,,,,, nil,,, )



   ::oChkSelect := TCheckBox():ReDefine( 160, { | u | If( PCount()==0, ::lChkSelect, ::lChkSelect:= u ) }, ::oDlgSelect,,,,,,, .F.,, .F. )



   ::oChkUnSelect := TCheckBox():ReDefine( 180, { | u | If( PCount()==0, ::lChkUnSelect, ::lChkUnSelect:= u ) }, ::oDlgSelect,,,,,,, .F.,, .F. )

   ::oTreeSelect  := TTreeView():Redefine( 170, ::oDlgSelect )




   TButton():ReDefine( 1, {||( ::EvalSelect( bAction, ::oMtrSelect ), if( lClose, ::oDlgSelect:end(), if( !Empty( ::oWndBrw:oBrw ), ::oWndBrw:oBrw:Refresh(), ) ) )}, ::oDlgSelect,,, .F.,,,, .F. )




   ::oBtnCancel := TButton():ReDefine( 2, {||( ::oDlgSelect:end() )}, ::oDlgSelect,,, .F.,,,, .F. )






   ::oMtrSelect := TApoloMeter():ReDefine( 200, { | u | If( PCount()==0, nMtrInf, nMtrInf:= u ) }, ::oDbf:LastRec(), ::oDlgSelect, .F.,, "Proceso", .F.,,,, )

   ::oDlgSelect:AddFastKey( 116, {|| ::EvalSelect( bAction, ::oMtrSelect ), if( lClose, ::oDlgSelect:end(), if( !Empty( ::oWndBrw:oBrw ), ::oWndBrw:oBrw:Refresh(), ) ) } )

   ::oDlgSelect:bStart := {|| ::StartSelect( cChkTitle, oSerDocIni, oSerDocFin, oImageList ), ::oTreeSelect:SetImageList( oImageList ) }

   ::oDlgSelect:Activate( ::oDlgSelect:bLClicked, ::oDlgSelect:bMoved, ::oDlgSelect:bPainted, .T.,,,, ::oDlgSelect:bRClicked,,, )

RETURN ( Self )



static FUNCTION TMasDet_StartSelect( cChkTitle, oSerDocIni, oSerDocFin, oImageList ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   ::oTreeSelect:SetImageList( oImageList )

   if Empty( cChkTitle )
      ::oChkSelect:Hide()
   else
      SetWindowText( ::oChkSelect:hWnd, cChkTitle )
      ::oChkSelect:Refresh()
   end

   ::oChkUnSelect:Hide()

   if Empty( ::cSerDocKey )
      oSerDocIni:Hide()
      oSerDocFin:Hide()
   end

RETURN ( Self )



static FUNCTION TMasDet_EvalSelect( bAction ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local nPos
   local aPos
   local cSeek
   local bCond
   local lWhile   := .T.
   local lresult





   if ::lMoveDlgSelect
      aPos        := { 0, 0 }
      ClientToScreen( ::oDlgSelect:hWnd, aPos )
      ::oDlgSelect:Move( aPos[ 1 ] - 26, aPos[ 2 ] - 510 )
   end

   ::oDbf:GetStatus()

   ::oDlgSelect:Disable()

   ::oTreeSelect:Enable()
   ::oTreeSelect:DeleteAll()

   ::oBtnCancel:bAction := {|| lWhile := .F. }
   ::oBtnCancel:Enable()

   if ::nRadSelect == 1

      for each nPos in ( ::oWndBrw:oBrw:aSelected )

         ::oDbf:GoTo( nPos )

         Eval( bAction, ::lChkSelect )

         ::oMtrSelect:Set( ::oDbf:OrdKeyNo() )

         SysRefresh()

         if !lWhile
            exit
         end

      next

      ::oMtrSelect:Set( ::oDbf:LastRec() )

   else





      if ::cSerDocKey == nil

         cSeek       := Str( ::nNumDocIni, ::nLenDocIni ) + ::cSufDocIni





         if ::lNumDocChr


            bCond    := {||   ::oDbf:FieldGetName( ::cNumDocKey ) + ::oDbf:FieldGetName( ::cSufDocKey ) >= Str( ::nNumDocIni, ::nLenDocIni ) + ::cSufDocIni .AND. ::oDbf:FieldGetName( ::cNumDocKey ) + ::oDbf:FieldGetName( ::cSufDocKey ) <= Str( ::nNumDocFin, ::nLenDocIni ) + ::cSufDocFin }

         else



            bCond    := {||   Str( ::oDbf:FieldGetName( ::cNumDocKey ), ::nLenDocIni ) + ::oDbf:FieldGetName( ::cSufDocKey ) >= Str( ::nNumDocIni, ::nLenDocIni ) + ::cSufDocIni .AND. Str( ::oDbf:FieldGetName( ::cNumDocKey ), ::nLenDocIni ) + ::oDbf:FieldGetName( ::cSufDocKey ) <= Str( ::nNumDocFin, ::nLenDocIni ) + ::cSufDocFin .AND. !::oDbf:Eof() }

         end

      else

         cSeek       := ::cSerDocIni + Str( ::nNumDocIni, ::nLenDocIni ) + ::cSufDocIni

         bCond       := {|| ::oDbf:FieldGetName( ::cSerDocKey ) + Str( ::oDbf:FieldGetName( ::cNumDocKey ), ::nLenDocIni ) + ::oDbf:FieldGetName( ::cSufDocKey ) >= Str( ::nNumDocIni, ::nLenDocIni ) + ::cSufDocIni .AND. ::oDbf:FieldGetName( ::cSerDocKey ) + Str( ::oDbf:FieldGetName( ::cNumDocKey ), ::nLenDocIni ) + ::oDbf:FieldGetName( ::cSufDocKey ) <= Str( ::nNumDocFin, ::nLenDocIni ) + ::cSufDocFin }

      end

      lResult        := ::oDbf:Seek( cSeek, .T. )

      ::oMtrSelect:Set( ::oDbf:OrdKeyNo() )

      while ( lWhile ) .AND. Eval( bCond ) .AND. !::oDbf:eof()

         Eval( bAction, ::lChkSelect )

         ::oDbf:Skip()

         ::oMtrSelect:Set( ::oDbf:OrdKeyNo() )

      end

      ::oMtrSelect:Set( ::oDbf:LastRec() )

   end

   ::oDbf:SetStatus()

   ::oBtnCancel:bAction := {|| ::oDlgSelect:End() }

   if ::lMoveDlgSelect
      WndCenter( ::oDlgSelect:hWnd )
   end

   ::oDlgSelect:Enable()

RETURN NIL



static FUNCTION TMasDet_AddDetail( oDetail ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if ::oDbfDet == nil
      ::oDbfDet   := {}
   end

   aAdd( ::oDbfDet, oDetail )

RETURN ( Self )



static FUNCTION TMasDet_Activate( ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if nAnd( ::nLevel, 1 ) == 0
      msgStop( "Acceso no permitido." )
      RETURN ( Self )
   end





   if ::oWndParent <> nil
      ::oWndParent:CloseAll()
   end

   if Empty( ::oDbf )
      if !::OpenFiles()
         return nil
      end
   end





   if !::lCreateShell
      ::CreateShell( ::nLevel )
   end

   if ::lAutoButtons
      ::oWndBrw:AutoButtons( Self )
   end

   if ::cHtmlHelp <> nil
      ::oWndBrw:cHtmlHelp  := ::cHtmlHelp
   end

   ::oWndBrw:Activate(  nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, {|| ::CloseFiles() } )

RETURN ( Self )



static FUNCTION TMasDet_oDefDiv( nId, nIdBmp, nIdChg, oDlg, nMode ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local oCodDiv
   local oVdvDiv

   local This        := Self

   If( nId == nil, nId := 1130, ) ;
   If( nIdBmp == nil, nIdBmp := 1131, ) ;
   If( nIdChg == nil, nIdChg := 1132, ) ;
   If( oDlg == nil, oDlg := ::oFld:aDialogs[1], ) ;
   If( nMode == nil, nMode := 1, ) ;

   if Empty( ::oDbfDiv )
      ::oDbfDiv := DbfServer( "DIVISAS.DBF", ):NewOpen( "DIVISAS.DBF",, ( cDriver() ),, ( cPatDat() ), .F., .T., .F., .F. ) ; ::oDbfDiv:AddBag( "DIVISAS.CDX" ) ; ::oDbfDiv:AddBag( ) ; ::oDbfDiv:AutoIndex()
   end

   if Empty( ::oBandera )
      ::oBandera     := TBandera():New()
   end

   if Empty( ::oDbf:cCodDiv )
      ::oDbf:cCodDiv := cDivEmp()
   end








   oCodDiv := TGetHlp():ReDefine( ( nId ), { | u | If( PCount()==0, ::oDbf:cCodDiv, ::oDbf:cCodDiv:= u ) }, oDlg,, "@!", {||    ( This:lLoadDivisa() )},,,,,, .F., {||     ( nMode == 1 )},, .F., .F.,,,,, {|Self|( BrwDiv( oCodDiv, This:oBmpDiv, oVdvDiv, This:oDbfDiv:cAlias, This:oBandera ), This:lLoadDivisa() )}, nil, "LUPA",, )




   ::oBmpDiv := TBitmap():ReDefine( ( nIdBmp ), "BAN_EURO",, oDlg,,, .F., .F.,,, .F.,,, .F. )





   oVdvDiv := TGetHlp():ReDefine( ( nIdChg ), { | u | If( PCount()==0, ::oDbf:nVdvDiv, ::oDbf:nVdvDiv:= u ) }, oDlg,, "@E 999,999.9999",,,,,,, .F., {||     ( .F. )},, .F., .F.,,,,,, nil,,, )

   ::lLoadDivisa()

RETURN ( Self )



static FUNCTION TMasDet_CloseFiles( ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if !Empty( ::oDbf ) .AND. ::oDbf:Used()
      ::oDbf:End()
   end

   if isArray( ::oDbfDet )
      aSend( ::oDbfDet, "End()" )
   else
      if !Empty( ::oDbfDet ) .AND. ::oDbfDet:Used()
         ::oDbfDet:End()
      end
   end

RETURN ( .T. )



static FUNCTION TMasDet_End( ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if ::oDbfDiv <> nil .AND. ::oDbfDiv:Used()
      ::oDbfDiv:End()
      ::oDbfDiv   := nil
   end

   if ::oBandera <> nil
      ::oBandera:End()
   end

   ::Super:End()

RETURN ( .T. )



static FUNCTION TMasDet_EndResource( lOk, nMode, oDlg ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   if !Empty( oDlg )
      oDlg:Disable()
   end

   do case
      case nMode == 1
         ::EndAppend( lOk )

      case nMode == 4
         ::EndDup( lOk )

      case nMode == 2
         ::EndEdit( lOk )

   end

   if !Empty( oDlg )
      oDlg:Enable()
   end

Return ( lOk )



static FUNCTION TMasDet_nRegisterToProcess( ) ; local Self AS CLASS TMasDet := QSelf() AS CLASS TMasDet

   local nRegisterToProcess   := 0

   do case
      case IsObject( ::oDbfDet )
         nRegisterToProcess   += ::oDbfDet:nRegisterLoaded
         nRegisterToProcess   += ::oDbfVir:LastRec()

      case IsArray( ::oDbfDet )
         aEval( ::oDbfDet, {|o| nRegisterToProcess += o:nRegisterLoaded } )
         aEval( ::oDbfDet, {|o| nRegisterToProcess += o:oDbfVir:LastRec() } )

   end

RETURN ( nRegisterToProcess )



function oCopy( oDbfOrg, oDbfDes, lApp )

    local i
   local nField   := oDbfOrg:FCount()

    If( lApp == nil, lApp := .F., ) ;

   if lApp
      ( oDbfOrg:nArea )->( dbAppend() )
   else
      ( oDbfDes:nArea )->( dbRLock() )
   end

    for i = 1 to nField
      ( oDbfDes:nArea )->( FieldPut( i, ( oDbfOrg )->( FieldGet( i ) ) ) )
    next

RETURN NIL



function ObjInspect( oObject, cTitle )

   local oIco
   local oBrw
   local oWndObj
   local aObjInfo
   local nItem       := 1

   CursorWait()











   If( aObjBmps == nil, aObjBmps := {  "Array"    , "Block"    , "Chain"    , "Date"     , "Logic"    , "Number"   , "Memo"     , "Object"   , "Undefined", "SmallBug" , "NoInfo"   }, ) ;

   if ValType( oObject ) == "O"
      aObjInfo = aOData( oObject )

      AEval( aObjInfo, { | cData, n | aObjInfo[ n ] := cChr2Data( cData ) } )
   endif



   If( cTitle == nil, cTitle := If( ValType( oObject ) == "O", "Object Inspector", "Array Inspector" ), ) ;

   oIco := TIcon():New( ,, "Objects",, )





   oWndObj := TMdiChild():New( 1, 1, 23, 33, If( ValType( oObject ) == "O", "Object Inspector: ", "Array Inspector: " ) + cTitle,,, oWnd(), oIco, .F.,,,,, .F., .F.,,, !.F., !.F., !.F., !.F.,, )






   oBrw := TWBrowse():New( 0, 0, 400, 400, {|| {"" } }, {"  ", "Data", "Value"}, {16, 90, 300}, oWndObj,,,,, {|nRow,nCol,nFlags|DataInspect( oObject, nItem, aObjInfo, cTitle )},,,,,,, .F.,, .F.,, .F.,,, )

   oBrw:bLine = { || aGetData( oObject, nItem, aObjInfo, cTitle ) }



   oBrw:bGoTop    = { || nItem := 1 }
   oBrw:bGoBottom = { || nItem := Eval( oBrw:bLogicLen ) }



   oBrw:bSkip     = { | nWant, nOld | nOld := nItem, nItem += nWant, nItem := Max( 1, Min( nItem, Eval( oBrw:bLogicLen ) ) ), nItem - nOld }


   oBrw:bLogicLen = { || If( ValType( oObject ) == "O", Len( aObjInfo ), Len( oObject ) ) }
   oBrw:cAlias    = "Array"

   oWndObj:SetControl( oBrw )

   oWndObj:Activate(, oWndObj:bLClicked, oWndObj:bRClicked, oWndObj:bMoved, oWndObj:bResized, oWndObj:bPainted, oWndObj:bKeyDown, oWndObj:bInit,,,,,,,,,,, oWndObj:bLButtonUp, .F. )

return nil



static function cGetData( uData, cType )

   local cResult := ""

   do case
      case cType == "B"
           cResult = "{ || ... }"

      case cType == "A"
           cResult = "[ ... ]"

      case cType == "O"
           cResult = "Object"

      case cType == "U"
           cResult = "Undefined"

      otherwise
           cResult = cValToChar( uData )
   endcase

return cResult



static function DataInspect( oObject, nItem, aObjInfo, cTitle )

   local cType := ValType( oObject )
   local cData, uData

   do case
      case cType == "A"
           cData = "[ " + AllTrim( Str( nItem ) ) + " ]"
           if Len( oObject[ nItem ] ) > 0
              ObjInspect( oObject[ nItem ], cTitle + cData )
           else
              MsgInfo( "Array is empty!", "Attention" )
           endif

      case cType == "O"
           cData = aObjInfo[ nItem ]
           uData = OSend( oObject, cData )
           if ValType( uData ) $ "AO"
              ObjInspect( OSend( oObject, cData ), cTitle + ":" + cData )
           else
              MsgInfo( "I don't find an Object or an Array there!", "Attention" )
           endif
   endcase

return nil



static function aGetData( oObject, nItem, aObjInfo )

   local uData, cData, cType

   do case
      case ValType( oObject ) == "A"
           uData = oObject[ nItem ]
           cData = "[ " + AllTrim( Str( nItem ) ) + " ]"

      case ValType( oObject ) == "O"
           uData = OSend( oObject, aObjInfo[ nItem ] )
           cData = aObjInfo[ nItem ]
   endcase

   cType = ValType( uData )

return { aObjBmps[ At( cType, "ABCDLNMOU" ) ], cData, cGetData( uData, cType ) }



static function cGetHierarchy( oObject )

   local nClass   := oObject:ClassH
   local cClasses := "Class Hierarchy:" + Chr(13)+Chr(10)
   local n := 1

   while n < nClass
      if oObject:ChildLevel( __ClassIns( n ) ) <> 0
         cClasses += __ClassNam( n ) + Chr(13)+Chr(10)
      endif
      n++
   end

   cClasses += oObject:ClassName()

return cClasses
