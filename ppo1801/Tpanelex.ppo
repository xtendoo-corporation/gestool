#line 91 "\fwh1801\include\fivewin.ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 17 ".\.\Prg\Tpanelex.prg"
_HB_CLASS TPanelEx ; function TPanelEx ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TPanelEx", iif( .T., { @TPanel() }, { @HBObject() } ), @TPanelEx() ) ) ;

      _HB_MEMBER { lVScroll } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lVScroll"}, .F. )
      _HB_MEMBER { WM_RESETPOS } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"WM_RESETPOS"}, .F. )
      _HB_MEMBER { nClrBorder } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nClrBorder"}, .F. )

      _HB_MEMBER { AS LOGICAL lRegistered } ; oClass:AddMultiClsData( "LOGICAL",, nScope + iif( .F., 16, 0 ) + iif( .T., 32, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lRegistered"}, .F. )

      _HB_MEMBER New( nTop, nLeft, nBottom, nRight, oWnd, nClrPane, lVScroll) AS CLASS TPanelEx; oClass:AddMethod( "New", @TPanelEx_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER Paint(); oClass:AddMethod( "Paint", @TPanelEx_Paint(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Display(); oClass:AddInline( "Display", {|Self | ( ( Self ) ), ::BeginPaint(), ::Paint(), ::EndPaint(),0 }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER VScroll( nWParam, nLParam); oClass:AddMethod( "VScroll", @TPanelEx_VScroll(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER MouseWheel( nKey, nDelta, nXPos, nYPos); oClass:AddMethod( "MouseWheel", @TPanelEx_MouseWheel(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER HandleEvent( nMsg, nWParam, nLParam); oClass:AddMethod( "HandleEvent", @TPanelEx_HandleEvent(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER Disable(); oClass:AddMethod( "Disable", @TPanelEx_Disable(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Enable(); oClass:AddMethod( "Enable", @TPanelEx_Enable(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER Destroy(); oClass:AddMethod( "Destroy", @TPanelEx_Destroy(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER GetText(); oClass:AddInline( "GetText", {|Self | ( ( Self ) ), ::cCaption }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TPanelEx ;



static FUNCTION TPanelEx_New( nTop, nLeft, nBottom, nRight, oWnd, nClrPane, lVScroll ) ; local Self AS CLASS TPanelEx := QSelf() AS CLASS TPanelEx


   If( nTop == nil, nTop := 0, ) ; If( nLeft == nil, nLeft := 0, ); If( nBottom == nil, nBottom := 100, ); If( nRight == nil, nRight := 100, ); If( oWnd == nil, oWnd := GetWndDefault(), ); If( nClrPane == nil, nClrPane := 16777215, ); If( lVScroll == nil, lVScroll := .F., );

   ::nTop      := nTop
   ::nLeft     := nLeft
   ::nBottom   := nBottom
   ::nRight    := nRight
   ::oWnd      := oWnd
   ::nStyle    := nOr( 1073741824, 268435456, 67108864, 33554432, 2097152 )
   ::lDrag     := .F.
   ::nClrPane  := nClrPane
   ::aControls := {}
   ::lVScroll  := lVScroll
   ::cCaption  := ""





   ::Register()
   ::SetColor( 0, nClrPane )

   if ! Empty( ::oWnd:hWnd )
      ::Create()
      ::oWnd:AddControl( Self )
   else
      ::oWnd:DefControl( Self )
   endif

   ::oVScroll := TScrollBar():WinNew( ,,, .T., self )
   ::oVScroll:SetRange(0,0)

   ::WM_RESETPOS := RegisterWindowMessage( "WM_RESETPOS" )

   ShowScrollBar( ::hWnd, 1, .F. )

return Self



static FUNCTION TPanelEx_Destroy( ) ; local Self AS CLASS TPanelEx := QSelf() AS CLASS TPanelEx

return ::Super:Destroy()



static FUNCTION TPanelEx_HandleEvent( nMsg, nWParam, nLParam ) ; local Self AS CLASS TPanelEx := QSelf() AS CLASS TPanelEx


local n, nLen

   do case
      case nMsg == 20
           return 1

      case nMsg == ::WM_RESETPOS
           nLen := len( ::aControls )
           for n := 1 to nLen
               ::aControls[n]:Move(0,0,,,.T.)
           next
           ::oVScroll:SetPos(0)
           ::Refresh()
   endcase

return ::Super:HandleEvent( nMsg, nWParam, nLParam )


   static FUNCTION TPanelEx_Paint( ) ; local Self AS CLASS TPanelEx := QSelf() AS CLASS TPanelEx

local cText
local hFont
local hOldFont
local nHLen
local n, nLen
local nHeight := ::nHeight
local nMaxB := 0
local nMinTop    := int(nHeight / 2)
local nMaxBottom := int(nHeight / 2)
local rc := GetClientRect(::hWnd)

::Super:Paint()

if ::lVScroll

   nLen := len( ::aControls )

   for n := 1 to nLen
       if IsWindowVisible( ::aControls[n]:hWnd )
          nMinTop    := min( WndTop( ::aControls[n]:hWnd ), nMinTop )
          nMaxBottom := max( WndTop( ::aControls[n]:hWnd )+ ::aControls[n]:nHeight, nMaxBottom )
       endif
   next

   if nMinTop < 0 .OR. nMaxBottom > nHeight
      ::oVScroll:SetRange( 0, 10 )
   else
      ::oVScroll:SetRange( 0, 0 )
   endif

endif

if ::nClrPane <> nil
   FillSolidRect( ::hDC, rc, ::nClrPane )
endif

if ::nClrBorder <> nil
   Box( ::hDC, {rc[1],rc[2],rc[3]-1,rc[4]-1},::nClrBorder )
endif

if ::bPainted <> nil
   Eval( ::bPainted, ::hDC, self )
endif

return nil


  static FUNCTION TPanelEx_VScroll( nWParam, nLParam ) ; local Self AS CLASS TPanelEx := QSelf() AS CLASS TPanelEx



   local nScrollCode := nLoWord( nWParam )
   local nPos := nHiWord( nWParam )
   local n, nLen
   local nTop
   local nLeft
   local n2, nLen2

   do case
      case nScrollCode == 0

           ::oVScroll:GoUp()
           nPos := ::oVScroll:GetPos()

           nLen := len( ::aControls )
           for n := 1 to nLen
               nTop  := -(((::aControls[n]:nHeight - GetClientRect(::hWnd )[3])/10)*nPos)
               if nTop > 3
                  nTop := 0
               endif
               nLeft := ::aControls[n]:nLeft
               ::aControls[n]:Move( nTop,nLeft,,,.T. )
               ::aControls[n]:Refresh()
           next

           return 0

      case nScrollCode == 1

           ::oVScroll:GoDown()
           nPos := ::oVScroll:GetPos()

           nLen := len( ::aControls )
           for n := 1 to nLen
               nTop  := -(((::aControls[n]:nHeight - GetClientRect(::hWnd )[3])/10)*nPos)
               if nTop > 3
                  nTop := 0
               endif
               nLeft := ::aControls[n]:nLeft
               ::aControls[n]:Move( nTop,nLeft,,,.T. )
               ::aControls[n]:Refresh()

           next

           return 0

      case nScrollCode == 2

           ::oVScroll:PageUp()
           nPos := ::oVScroll:GetPos()

           nLen := len( ::aControls )
           for n := 1 to nLen
               nTop  := -(((::aControls[n]:nHeight - GetClientRect(::hWnd )[3])/10)*nPos)
               if nTop > 3
                  nTop := 0
               endif
               nLeft := ::aControls[n]:nLeft
               ::aControls[n]:Move( nTop,nLeft,,,.T. )
           next

           return 0


      case nScrollCode == 3

           ::oVScroll:PageDown()
           nPos := ::oVScroll:GetPos()

           nLen := len( ::aControls )
           for n := 1 to nLen
               nTop  := -(((::aControls[n]:nHeight - GetClientRect(::hWnd )[3])/10)*nPos)
               if nTop > 3
                  nTop := 0
               endif
               nLeft := ::aControls[n]:nLeft
               ::aControls[n]:Move( nTop,nLeft,,,.T. )

           next


      case nScrollCode == 6

           ::oVScroll:GoTop()
           nPos = ::oVScroll:nMin
           ::oVScroll:SetPos(nPos)
           nLen := len( ::aControls )
           for n := 1 to nLen
               nTop  := -(((::aControls[n]:nHeight - GetClientRect(::hWnd )[3])/10)*nPos)
               if nTop > 3
                  nTop := 0
               endif
               nLeft := ::aControls[n]:nLeft
               ::aControls[n]:Move( nTop,nLeft,,,.T. )

           next

           ::Refresh( .F. )
           ::Refresh( .F. )

      case nScrollCode == 7
           nPos = ::oVScroll:nMax
           ::oVScroll:SetPos(nPos)
           nLen := len( ::aControls )
           for n := 1 to nLen
               nTop  := -(((::aControls[n]:nHeight - GetClientRect(::hWnd )[3])/10)*nPos)
               if nTop > 3
                  nTop := 0
               endif
               nLeft := ::aControls[n]:nLeft
               ::aControls[n]:Move( nTop,nLeft,,,.T. )

           next

           ::Refresh( .F. )
           return 0

       case nScrollCode == 5

           nPos := GetScrollInfoPos( ::hWnd, 1 )

           nLen := len( ::aControls )
           for n := 1 to nLen
               nTop  := -(((::aControls[n]:nHeight - GetClientRect(::hWnd )[3])/10)*nPos)
               if nTop > 3
                  nTop := 0
               endif
               nLeft := ::aControls[n]:nLeft
               ::aControls[n]:Move( nTop,nLeft,,,.T. )
           next

       case nScrollCode == 4

           ::oVScroll:ThumbPos( nPos )

      otherwise
           return nil
   endcase


   ::oVScroll:SetPos( nPos )

return 0


  static FUNCTION TPanelEx_MouseWheel( nKeys, nDelta, nXPos, nYPos ) ; local Self AS CLASS TPanelEx := QSelf() AS CLASS TPanelEx


if ::lVScroll
   if nDelta < 0
      ::VScroll( nMakeLong( 0, 0 ),0)
   else
      ::VScroll( nMakeLong( 1, 0 ),0)
   endif
endif

return nil


      static FUNCTION TPanelEx_Disable( ) ; local Self AS CLASS TPanelEx := QSelf() AS CLASS TPanelEx

   local hCtrl := GetWindow( ::hWnd, 5 )
   local oCtrl

   while hCtrl <> 0
         oCtrl := oWndFromhWnd( hCtrl )
         if oCtrl <> nil
            oCtrl:Disable()
            oCtrl:Refresh()
         endif
         hCtrl = GetWindow( hCtrl, 2 )
   end

return 0



      static FUNCTION TPanelEx_Enable( ) ; local Self AS CLASS TPanelEx := QSelf() AS CLASS TPanelEx


   local hCtrl := GetWindow( ::hWnd, 5 )
   local oCtrl

   while hCtrl <> 0
         oCtrl := oWndFromhWnd( hCtrl )
         if oCtrl <> nil
            oCtrl:Enable()
            oCtrl:Refresh()
         endif
         hCtrl = GetWindow( hCtrl, 2 )
   end

return 0



#pragma BEGINDUMP

#include <windows.h>
#include <hbapi.h>

HB_FUNC( SHOWSCROLLBAR )
{
    hb_retl( ShowScrollBar( (HWND) hb_parnl( 1 ), hb_parni( 2 ), hb_parl( 3 ) ) );
}

#pragma ENDDUMP
