#line 91 "\fwh1801\include\FiveWin.ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 12 ".\.\Prg\Treeitem.prg"
static aLines



_HB_CLASS TTreeItem ; function TTreeItem ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TTreeItem", iif( .F., { }, { @HBObject() } ), @TTreeItem() ) ) ;

   _HB_MEMBER { cDraw, cPrompt } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cDraw", "cPrompt"}, .F. )
   _HB_MEMBER { oPrev, oNext } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oPrev", "oNext"}, .F. )
   _HB_MEMBER { oTree } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oTree"}, .F. )
   _HB_MEMBER { lOpened } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lOpened"}, .F. )
   _HB_MEMBER { nLevel } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nLevel"}, .F. )
   _HB_MEMBER { hBmpOpen, hBmpClose } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hBmpOpen", "hBmpClose"}, .F. )
   _HB_MEMBER { bAction } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bAction"}, .F. )
   _HB_MEMBER { Cargo } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Cargo"}, .F. )

   _HB_MEMBER New( cPrompt, nLevel, hBmpOpen, hBmpClose) AS CLASS TTreeItem; oClass:AddMethod( "New", @TTreeItem_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER Open(); oClass:AddInline( "Open", {|Self | ( ( Self ) ), If( ! ::lOpened .AND. ::oTree <> nil, ::lOpened := .T.,) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Close(); oClass:AddInline( "Close", {|Self | ( ( Self ) ), If( ::lOpened, ::lOpened := .F.,) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Skip( @n); oClass:AddMethod( "Skip", @TTreeItem_Skip(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ItemNo(); oClass:AddMethod( "ItemNo", @TTreeItem_ItemNo(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER GetNext(); oClass:AddInline( "GetNext", {|Self | ( ( Self ) ), If( ::lOpened, ::oTree:oFirst, ::oNext ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GetPrev(); oClass:AddMethod( "GetPrev", @TTreeItem_GetPrev(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER GetText(); oClass:AddInline( "GetText", {|Self | ( ( Self ) ), If( ::oTree <> nil .AND. ::lOpened, " - ",  If( ::oTree <> nil, " + ", "   " ) ) + ::cDraw + ::cPrompt }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER GetLabel(); oClass:AddMethod( "GetLabel", @TTreeItem_GetLabel(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Draw( cPrevDraw); oClass:AddMethod( "Draw", @TTreeItem_Draw(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER SetNext(); oClass:AddInline( "SetNext", {|Self, oItem | ( ( Self ) ), ::oNext := oItem, If( ::oTree <> nil, ::oTree:oLast:SetNext( oItem ),) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )






   _HB_MEMBER SetTree(); oClass:AddInline( "SetTree", {|Self, oTree | ( ( Self ) ), If( oTree:nCount() > 0,  ( oTree:oFirst:oPrev   := Self,  oTree:oLast:SetNext( ::oNext ),  oTree:SetLevel( ::nLevel + 1 ),  ::oTree  := oTree,  .T. ), .F. ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Toggle(); oClass:AddInline( "Toggle", {|Self | ( ( Self ) ), If( ::lOpened, ::Close(), ::Open() ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ColSizes(); oClass:AddMethod( "ColSizes", @TTreeItem_ColSizes(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Delete( oRoot); oClass:AddMethod( "Delete", @TTreeItem_Delete(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Add( cPrompt); oClass:AddMethod( "Add", @TTreeItem_Add(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER AddChild( ocItem); oClass:AddMethod( "AddChild", @TTreeItem_AddChild(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SetText(); oClass:AddInline( "SetText", {|Self, cPrompt | ( ( Self ) ), ::cPrompt := cPrompt }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER MoveUp( oRoot); oClass:AddMethod( "MoveUp", @TTreeItem_MoveUp(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER MoveDown( oRoot); oClass:AddMethod( "MoveDown", @TTreeItem_MoveDown(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Promote(); oClass:AddMethod( "Promote", @TTreeItem_Promote(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Demote(); oClass:AddMethod( "Demote", @TTreeItem_Demote(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Sort( oRoot); oClass:AddMethod( "Sort", @TTreeItem_Sort(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Parent(); oClass:AddMethod( "Parent", @TTreeItem_Parent(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER EvalParents( bAction); oClass:AddMethod( "EvalParents", @TTreeItem_EvalParents(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER End(); oClass:AddMethod( "End", @TTreeItem_End(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TTreeItem ;



static FUNCTION TTreeItem_New( cPrompt, nLevel, hBmpOpen, hBmpClose, bAction, uCargo ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   If( aLines == nil, aLines := aTreeBmps(), ) ;

   ::cDraw     = ""
   ::cPrompt   = cPrompt
   ::lOpened   = .F.
   ::nLevel    = nLevel
   ::hBmpOpen  = hBmpOpen
   ::hBmpClose = hBmpClose
   ::bAction   = bAction
   ::Cargo     = uCargo

return Self



static FUNCTION TTreeItem_Skip( n ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local nCount := 0
   local oItem  := Self

   if n > 0
      while nCount < n .AND. oItem:GetNext() <> nil
          oItem = oItem:GetNext()
          nCount++
      end
      n = nCount
   endif

   if n < 0
      while nCount < -n .AND. oItem:GetPrev() <> nil
         oItem = oItem:GetPrev()
         nCount++
      end
      n = -nCount
   endif

return oItem



static FUNCTION TTreeItem_ItemNo( ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local nRec  := - 10000

   ::Skip( @nRec )

return -nRec + 1



static FUNCTION TTreeItem_GetPrev( ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   if ::oPrev <> nil
      if ::oPrev:nLevel < ::nLevel
         return ::oPrev
      else
         if ::oPrev:lOpened
            return ::oPrev:oTree:GetLast()
         else
            return ::oPrev
         endif
      endif
   endif

return nil



static FUNCTION TTreeItem_Draw( cPrevDraw ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   If( cPrevDraw == nil, cPrevDraw := "", ) ;








   ::cDraw = cPrevDraw +  If( ::oPrev <> nil, If( ::oNext <> nil .AND. ::oNext:nLevel == ::nLevel, If( ::oTree <> nil, If( ::lOpened, Chr( 5 ), Chr( 4 ) ), Chr( 2 ) ), If( ::oTree <> nil, If( ::lOpened, Chr( 7 ), Chr( 6 ) ), Chr( 3 ) ) ), Chr( 2 ) )

   If ::oTree <> nil



      ::oTree:Draw( cPrevDraw + If( ::oNext <> nil, If( ::oNext:nLevel < ::nLevel,  if( ::lOpened, Chr( 1 ), Chr( 0 )), Chr( 1 ) ), Chr( 0 ) ) )
   endif

return nil



static FUNCTION TTreeItem_GetLabel( ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local aLabel := Array( ::nLevel + 1 )
   local n, nLine

   AFill( aLabel, 0 )
   AAdd( aLabel, ::cPrompt )

   for n = 1 to Len( ::cDraw )
       nLine = Asc( SubStr( ::cDraw, n, 1 ) )
       if nLine <> 0
          aLabel[ n ] = aLines[ nLine ]
       endif
   next

   if ::oTree <> nil
      if ::oNext <> nil
         if ::oNext:nLevel < ::nLevel
            aLabel[ ::nLevel ] = If( ::lOpened, aLines[ 7 ], aLines[ 6 ] )
         else
            aLabel[ ::nLevel ] = If( ::lOpened, aLines[ 5 ], aLines[ 4 ] )
         endif
      else
         aLabel[ ::nLevel ] = If( ::lOpened, aLines[ 7 ], aLines[ 6 ] )
      endif
   endif



   aLabel[ ::nLevel + 1 ] = If( ::lOpened, If( ::hBmpClose <> nil, ::hBmpClose, 0 ), If( ::hBmpOpen <> nil, ::hBmpOpen, 0 ) )

return aLabel



static FUNCTION TTreeItem_ColSizes( ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local aCols := Array( ::nLevel + 1 )

   AFill( aCols, 16 )
   AAdd( aCols, 300 )

return aCols



static FUNCTION TTreeItem_Delete( oRoot ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local oParent  := ::Parent()
   local oTree    := If( oParent == nil, oRoot, oParent:oTree )

   if ( ::oPrev == nil .OR. ::oNext == nil ) .AND. oRoot == nil
      return .F.
   endif


   if ( ::oPrev == nil .OR. ::oPrev:nLevel < ::nLevel ) .AND.  ( ::oNext == nil .OR. ::oNext:nLevel < ::nLevel )

      if oParent == nil
         oRoot:oFirst := oRoot:oLast := nil
         return .T.
      else
         oParent:Close()
         oParent:oTree  := nil
         return .T.
      endif
   endif

   if ::oPrev == nil .OR. ::oPrev:nLevel < ::nLevel
      ::oNext:oPrev     := oParent
      oTree:oFirst      := ::oNext
   else
      ::oPrev:SetNext( ::oNext )
   endif

   if ::oNext == nil .OR. ::oNext:nLevel < ::nLevel
      oTree:oLast       := ::oPrev
   else
      ::oNext:oPrev     := ::oPrev
   endif

   if ::oTree <> nil
      ::oTree:oLast:oNext  := nil
   endif

return .T.



static FUNCTION TTreeItem_Add( cPrompt ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local oItem := TTreeItem():New( cPrompt, ::nLevel )
   local oParent  := ::Parent()

   if ValType( cPrompt ) == "O"
      if cPrompt:IsKindOf( "TTREEITEM" )
         oItem          := cPrompt
         oItem:nLevel   := ::nLevel
         if oItem:oTree <> nil
            oItem:oTree:SetLevel( ::nLevel + 1 )
         endif
      else
         return nil
      endif
   else
      oItem := TTreeItem():New( cPrompt, ::nLevel )
   endif

   oItem:oPrev   = Self
   oItem:SetNext( ::oNext )
   ::SetNext( oItem )

   if oItem:oNext <> nil
      if oItem:oNext:nLevel == ::nLevel
         oItem:oNext:oPrev       = oItem
      elseif oItem:oNext:nLevel < ::nLevel
         oParent:oTree:oLast     = oItem
      endif
   endif

return oItem



static FUNCTION TTreeItem_AddChild( ocItem, lFirst ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local oItem, oTree

   if ValType( ocItem ) == "O"
      if ocItem:IsKindOf( "TTREEITEM" )
         oItem          := ocItem
         oItem:nLevel   := ::nLevel + 1
         if oItem:oTree <> nil
            oItem:oTree:SetLevel( ::nLevel + 2 )
         endif
      else
         return nil
      endif
   else
      oItem := TTreeItem():New( ocItem, ::nLevel + 1 )
   endif

   if ::oTree == nil
      oTree          := TLinkList():New()
      oTree:oFirst   := oItem
      oTree:oLast    := oItem
      ::SetTree( oTree )
   else
      if lFirst == .T.
         oItem:oPrev             := ::oTree:oFirst:oPrev
         oItem:SetNext( ::oTree:oFirst )
         ::oTree:oFirst:oPrev    := oItem
         ::oTree:oFirst          := oItem
      else
         ::oTree:oLast:Add( oItem )
      endif
   endif

return oItem



static FUNCTION TTreeItem_MoveUp( oRoot ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local oAfter

   if ::oPrev <> nil .AND. ::oPrev:nLevel == ::nLevel
      oAfter      := ::oPrev:oPrev
      if oAfter == nil
         if oRoot <> nil
            ::Delete( oRoot )
            ::SetNext( ::oPrev )
            ::oPrev:oPrev  := Self
            ::oPrev        := nil
            oRoot:oFirst   := Self
            return .T.
         endif
      else
         ::Delete( oRoot )
         if oAfter:nLevel == ::nLevel
            oAfter:Add( Self )
         else
            oAfter:AddChild( Self, .T. )
         endif
         return .T.
      endif
   endif

return .F.



static FUNCTION TTreeItem_MoveDown( oRoot ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local oAfter   := ::oNext

   if oAfter <> nil .AND. oAfter:nLevel == ::nLevel
      if ::Delete( oRoot )
         oAfter:Add( Self )
         return .T.
      endif
   endif

return .F.



static FUNCTION TTreeItem_Promote( ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local oParent  := ::Parent()

   if oParent <> nil
      ::Delete()
      oParent:Add( Self )
      return .T.
   endif

return .F.



static FUNCTION TTreeItem_Demote( ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local oPrev := ::oPrev

   if ::oPrev <> nil .AND. ::oPrev:nLevel == ::nLevel
      ::Delete()
      oPrev:AddChild( Self )
      oPrev:Open()
      return .T.
   endif

return .F.



static FUNCTION TTreeItem_Sort( oRoot ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local oParent  := ::Parent()
   local oTree    := If( oParent == nil, oRoot, oParent:oTree )

   if oTree <> nil
      oTree:Sort()
   endif

return Self



static FUNCTION TTreeItem_Parent( nParent ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local oItem

   if ::nLevel > 1
      If( nParent == nil, nParent := ::nLevel - 1, ) ;
      if nParent < 0
         nParent        := ::nLevel + nParent
      endif
      nParent           := Max( 1, Min( nParent, ::nLevel - 1 ) )
      oItem             := Self
      while ( oItem := oItem:GetPrev() ):nLevel > nParent
      enddo
   endif

return oItem



static FUNCTION TTreeItem_EvalParents( bAction ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   local oParent := ::Parent()

   while oParent <> nil
      Eval( bAction, oParent, Self )
      oParent  := oParent:Parent()
   enddo

return Self



static FUNCTION TTreeItem_End( ) ; local Self AS CLASS TTreeItem := QSelf() AS CLASS TTreeItem

   if ! Empty( ::hBmpOpen )
      DeleteObject( ::hBmpOpen )
      ::hBmpOpen = 0
   endif

   if ! Empty( ::hBmpClose )
      DeleteObject( ::hBmpClose )
      ::hBmpClose = 0
   endif

return nil



function GetTreeBmps()

   local aTemp := aLines

   aLines = nil

return aTemp
