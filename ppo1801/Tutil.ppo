#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 19 ".\.\Prg\Tutil.prg"
function lSetBuffer( oDbf, cOnOff )

    local lBuf := .F.
    local cType := "C"

    if ValType( oDbf ) == "O"
        lBuf := oDbf:lBuffer
        if cOnOff == nil
            lBuf := .F.
        else
            cType := ValType( cOnOff )
            if cType == "C"
                cOnOff := upper( cOnOff )
                if cOnOff $ "ON TRUE ACTIVE"
                    lBuf := .T.
                elseif cOnOff $ "OFF FALSE DEACTIVE"
                    lBuf := .F.
                endif
            elseif cType == "L"
                lBuf := cOnOff
            endif
        endif
        oDbf:SetBuffer( lBuf )
    endif

return( lBuf )




Function DbRow( oDb )

    loca aRet := {}

    AEval( oDb:aTField, { | oFld | AAdd( aRet, oFld:AsString ) } )

return( aRet )






Function OrdListLen()

    local nRet := 0
    local n    := 0

    while !empty( OrdName( ++n ) )
        ++nRet
    end

return( nRet )





function GetRecord( nRec )

   local nRecNo  := RecNo()
   local nHeader := Header()
   local nLenRec := RecSize()
   local nHdl    := DbfHdl()
   local nOffSet := 0
   local cBuffer := space( nLenRec )

   nRec := if( ValType( nRec ) <> "N", RecNo(), nRec )
   nOffSet := ( nLenRec * ( nRec - 1 ) ) + nHeader

   FSeek( nHdl, nOffSet, 0 )
   FRead( nHdl, @cBuffer, nLenRec )

   DbGoTo( nRecNo )

return( cBuffer )






function lCheckDbf( oDbf, bRecord )

   local i
   local nPos
   local lMemo
   local nCount
   local cFileNew
   local cMemoNew
   local cFileName
   local cMemoName

   if !IsObject( oDbf )
      return .F.
   end

   nCount            := 0
   lMemo             := oDbf:lMemo
   cFileName         := Upper( oDbf:cFile )
   cMemoName         := StrTran( Upper( oDbf:cFile ), ".DBF", ".FPT" )


   while lExistTable( cFileNew := oDbf:cPath + "FNew" + PadL( ++nCount, 3, "0" ) + ".DBF" ) .OR.  lExistTable( cMemoNew := oDbf:cPath + "FNew" + PadL( nCount, 3, "0" ) + ".FPT" )
   end





   if oDbf:Used()
      oDbf:Close()
   end





   oDbf:IdxFDel()





   if fRenameTable( cFileName, cFileNew, oDbf:cRDD ) <> 0
      return .F.
   end

   if isTrue( lMemo ) .AND. fRenameTable( cMemoName, cMemoNew, oDbf:cRDD ) <> 0
      return .F.
   end





   oDbf:Activate( .F., .F. )

   if File( cFileNew )

      dbUseArea( .T., oDbf:cRDD, cFileNew, "_WNew", .F. )

      nCount := oDbf:fCount()

      while !_WNew->( Eof() )

         ( oDbf:nArea )->( DbAppend() )

         for i := 1 to nCount
            nPos  := _WNew->( FieldPos( ( oDbf:nArea )->( FieldName( i ) ) ) )
            if nPos <> 0
               ( oDbf:nArea )->( FieldPut( i, _WNew->( FieldGet( nPos ) ) ) )
            end
         next

         if( ValType( bRecord ) == "B", Eval( bRecord, oDbf ), )

         _WNew->( dbSkip() )

      end

      _WNew->( dbCloseArea() )

   end

   if lExistTable( cFileNew, oDbf:cRDD )
      fEraseTable( cFileNew, oDbf:cRDD )
   end

   if isTrue( lMemo ) .AND. lExistTable( cMemoNew, oDbf:cRDD )
      fEraseTable( cMemoNew, oDbf:cRDD )
   end

   oDbf:Close()

return( .T. )



function xArea( uWA )

    local nArea := 0
    local nType := ValType( uWA )

    if nType == "O"
        nArea := uWA:nArea
    elseif nType == "C"
        nArea := Select( uWA )
    else
        nArea := Select()
    endif

return( nArea )



function aType( cType )

    local aTipo   := { "ALL" }

    cType         := upper( cType )

    do case
        case cType $ "CM"
            aTipo := { "CHARACTER" }
        case cType == "N"
            aTipo := { "NUMERIC" }
        case cType == "D"
            aTipo := { "DATE" }
        case cType == "L"
            aTipo := { "BOOL" }
        case cType == "B"
            aTipo := { "BLOCK" }
    end

return( aTipo )



Function UpTime( oGet )

  local cTime    := oGet:VarGet()
  local nHora    := Val( SubStr( cTime, 1, 2 ) )
  local nMinuto  := Val( SubStr( cTime, 3, 2 ) )

  ++nMinuto

  if nMinuto > 59
      nMinuto     := 0
      ++nHora
      if nHora > 23
         nHora    := 0
      end
  end

  oGet:cText( StrZero( nHora, 2 ) + StrZero( nMinuto, 2 ) )

Return ( .T. )



Function DwTime( oGet )

   local cTime    := oGet:VarGet()
   local nHora    := Val( SubStr( cTime, 1, 2 ) )
   local nMinuto  := Val( SubStr( cTime, 3, 2 ) )

   --nMinuto

   if nMinuto < 0
      nMinuto     := 59
      --nHora
      if nHora < 0
         nHora    := 23
      end
   end

   oGet:cText( StrZero( nHora, 2 ) + StrZero( nMinuto, 2 ) )

Return ( .T. )



Function nElapTime( cTimeInicial, cTimeFinal )

   local nTotalMinutos  := 0

   nTotalMinutos        := ( Val( SubStr( cTimeFinal, 1, 2 ) ) * 60 ) + Val( SubStr( cTimeFinal, 3, 2 ) )
   nTotalMinutos        -= ( Val( SubStr( cTimeInicial, 1, 2 ) ) * 60 ) + Val( SubStr( cTimeInicial, 3, 2 ) )

   if nTotalMinutos < 0
      nTotalMinutos  += 1440
   end

Return ( nTotalMinutos )






Function nTiempoEntreFechas( dFecInicio, dFecFin, cTimeInicio, cTimeFin )

   local nTotalHoras    := 0
   local nTotalMinutos  := 0
   local nDiferencia    := 0

   nDiferencia          := dFecFin - dFecInicio

   nTotalMinutos        := ( Val( SubStr( cTimeFin, 1, 2 ) ) * 60 ) + Val( SubStr( cTimeFin, 3, 2 ) )
   nTotalMinutos        -= ( Val( SubStr( cTimeInicio, 1, 2 ) ) * 60 ) + Val( SubStr( cTimeInicio, 3, 2 ) )


   if nDiferencia == 0
      nTotalHoras       := ( nDiferencia ) * 24
   else
      if nTotalMinutos  >= 0
         nTotalHoras       := ( nDiferencia ) * 24
      else
         nTotalHoras       := ( nDiferencia - 1 ) * 24
      end

   end

   if nTotalMinutos < 0
      nTotalHoras          += ( ( nTotalMinutos + 1440 ) / 60 )
   else
      nTotalHoras          += ( nTotalMinutos / 60 )
   end

Return ( nTotalHoras )




Function cFormatoDDHHMM( nHoras )

   local nDias       := 0
   local nHor        := 0
   local nMinutos    := 0
   local nCalculo    := 0
   local cFormato    := ""

   if nHoras > 0

      nCalculo       := nHoras / 24
      nDias          := Int( nCalculo )
      nCalculo       := ( nCalculo - Int( nCalculo ) ) * 24
      nHor           := Int( nCalculo )
      nCalculo       := ( nCalculo - Int( nCalculo ) ) * 60
      nMinutos       := Int( Round( nCalculo, 0 ) )

      do case
         case nDias > 1
         cFormato    := AllTrim( Str( nDias ) ) + " días, " + AllTrim( Str( nHor ) ) + "h " + AllTrim( Str( nMinutos ) ) + " min"
         case nDias == 1
         cFormato    := AllTrim( Str( nDias ) ) + " día, " + AllTrim( Str( nHor ) ) + "h " + AllTrim( Str( nMinutos ) ) + " min"
         case nDias < 1
         cFormato    := AllTrim( Str( nHor ) ) + "h " + AllTrim( Str( nMinutos ) ) + " min"
      end

   end

Return ( cFormato )



Function cAllTrimer( cCadena )

Return ( StrTran( cCadena, " ", "" ) )




Function MsgBeepYesNo( cText, cTitle )

    ArtBeep()

Return ApoloMsgNoYes( cText, cTitle )




Function MsgBeepStop( cText, cTitle )

  If( cText == nil, cText := "Stop", ) ;
  If( cTitle == nil, cTitle := "Stop", ) ;

    if !File( cFileSoundError() )
    ArtBeep()
  else
    SndPlaySound( cFileSoundError() )
  endif

Return MsgStop( cText, cTitle )



Function cFileSoundError()

Return ( FullCurDir() + "error.wav" )




Function MsgBeepWait( cText, cTitle, nTime )

    ArtBeep()

Return MsgWait( cText, cTitle, nTime )



Function ArtBeep()

    Tone( 100, 1 )
    Tone( 300, 1 )
    Tone( 100, 1 )
    Tone( 300, 1 )

Return .T.








Function c2Block( cExp )

   local bExp

   if !Empty( cExp )
      bExp     := &( "{|| " + cExp + " }" )
   end

Return ( bExp )




function GetFileNoExt( cFullFile )

   local cNameFile := alltrim( GetFileName( cFullFile ) )
   local n         := at( ".", cNameFile )

return alltrim( if( n > 0, left( cNameFile, n - 1 ), cNameFile ) )




function GetFileName( cFullFile )

   local nPos  := Rat( "\", cFullFile )
   local cFile := ""

   if !empty( cFullFile )
      if nPos == 0
         nPos  := At( ":", cFullFile )
      endif
      cFile    := SubStr( cFullFile, nPos + 1 )
   endif

return( cFile )



function GetPathFileNoExt( cFullFile )

   local cNameFile := alltrim( cFullFile )
   local n         := at( ".", cNameFile )

return alltrim( if( n > 0, left( cNameFile, n - 1 ), cNameFile ) )



function lChkSer( cSer, aSer )

   if Empty( cSer )
      cSer     := "A"
   end

return ( aSer[ Min( Max( Asc( cSer ) - 64, 1 ), len( aSer ) ) ] )



function retFld( cCod, cAlias, xFld, nOrd )

   local nRec
   local nAnt
   local xRet     := ""

   if Empty( cAlias )
      return xRet
   end

   if Empty( xFld )
      xFld        := 2
   end
   if Empty( nOrd )
      nOrd        := 1
   end

   nAnt           := ( cAlias )->( OrdSetFocus( nOrd ) )
   nRec           := ( cAlias )->( Recno() )



   ( cAlias )->( dbgotop() )
   if !( cAlias )->( dbSeek( cCod ) )
       ( cAlias )->( dbGoBottom() )
       ( cAlias )->( dbSkip() )
   endif

   if ( valType( xFld ) == "N" )
      xRet        := ( cAlias )->( fieldget( xFld ) )
   elseif ( valType( xFld ) == "C" )
      xFld        := ( cAlias )->( fieldpos( xFld ) )
      xRet        := ( cAlias )->( fieldget( xFld ) )
   endif

   ( cAlias )->( OrdSetFocus( nAnt ) )
   ( cAlias )->( dbGoTo( nRec ) )

return ( xRet )




function GetPath( cFile )

    local nPos := 0
    local cPath := ""

    if ( nPos := rat( "\", cFile ) ) <> 0
        cPath := upper( SubStr( cFile, 1, nPos ) )
    endif

return( cPath )





function GetFileExt( cFullFile )

   local cExt := AllTrim( GetFileName( cFullFile ) )
   local n    := rat( ".", cExt )
   local nLen := len( cExt )

return AllTrim( if( n > 0 .AND. nLen > n, right( cExt, nLen - n ), "" ) )





function NextVal( uVal )

   local nLen

   if ValType( uVal ) == "C"
      nLen  := Len( uVal )
      uVal  := Val( uVal )
      uVal  := AllTrim( Str( ++uVal ) )
      uVal  := Padr( uVal, nLen )
   else
      uVal++
   end

return( uVal )





function NextKey( uVal, uAlias, cChar, nLen )

   local nRec
   local nOrd

   if IsChar( ValType( uVal ) )

      if IsChar( uAlias )

         if IsNil( nLen )
            nLen  := Len( uVal )
         end

         nOrd     := ( uAlias )->( ordsetfocus( 1 ) )
         nRec     := ( uAlias )->( OrdKeyNo() )

         ( uAlias )->( OrdKeyGoto( ( uAlias )->( OrdKeyCount() ) ) )

         if ( uAlias )->( OrdKeyVal() ) <> nil
            uVal  := ( uAlias )->( OrdKeyVal() )
         else
            uVal  := ""
         end

         while .T.

            uVal     := AllTrim( Str( Val( uVal ) + 1 ) )

            if !Empty( cChar )
               uVal  := rjust( uVal, cChar, nLen )
            end

            if ( uAlias )->( dbSeek( uVal ) )
               loop
            else
               exit
            end

         end

         ( uAlias )->( ordsetfocus( nOrd ) )
         ( uAlias )->( OrdKeyGoTo( nRec ) )

      else

         nOrd     := uAlias:ordsetfocus( 1 )
         nRec     := uAlias:OrdKeyNo()

         uAlias:OrdKeyGoto( uAlias:OrdKeyCount() )

         if uAlias:OrdKeyVal() <> nil
            uVal  := uAlias:OrdKeyVal()
         else
            uVal  := ""
         end

         uVal     := AllTrim( Str( Val( uVal ) + 1 ) )

         uAlias:ordsetfocus( nOrd )
         uAlias:OrdKeyGoTo( nRec )

      end

      uVal     := Padr( uVal, nLen )

   else

      if IsChar( Valtype( uAlias ) )
         uVal  := ( uAlias )->( OrdKeyCount() ) + 1
      else
         uVal  := uAlias:OrdKeyCount() + 1
      end

   end

return ( uVal )





function oRetFld( cCod, oDbf, xFld, nOrd )

   local nRec
   local nAnt
   local xRet     := ""

   if Empty( oDbf )
      return xRet
   end

   if xFld == nil
      xFld        := 2
   end

   if empty( nOrd )
      nOrd        := 1
   end

   nRec           := oDbf:recno()

   if nOrd <> nil
      nAnt        := oDbf:ordsetfocus( nOrd )
   end






   if !oDbf:Seek( cCod )

       oDbf:GoBottom()

       oDbf:Skip()

   end

   if ( valType( xFld ) == "N" )

       xRet  := oDbf:FieldGet( xFld )

   elseif ( valType( xFld ) == "C" )

       xFld  := oDbf:FieldPos( xFld )
       xRet  := oDbf:FieldGet( xFld )

   end

   oDbf:GoTo( nRec )

   if nAnt <> nil
      oDbf:ordsetfocus( nAnt )
   end

return ( xRet )



function cGetFilename( cExt, cText, oGet )

   local cPathFile

   If( cExt == nil, cExt := "Doc ( *.* ) | *.*", ) ;
   If( cText == nil, cText := "Seleccione el nombre del fichero", ) ;

   cPathFile         := cGetFile( cExt, cText )

   if !Empty( cPathFile ) .AND. !Empty( oGet )
      oGet:cText( Padr( cPathFile, len( oGet:VarGet() ) )  )
   end

return ( cPathFile )



function GetFileDateTime( cFile )

   if !file( cFile )
      Return ""
   end

Return ( dtos( FileDate( cFile ) ) + FileTime( cFile ) )



function getFieldFromDatabase( id, uField, cDatabase, uOrder )

   local workArea
   local fieldFromDatabase       := ""

   if empty( id )
      Return ( fieldFromDatabase )
   end

   if empty( cDatabase )
      Return ( fieldFromDatabase )
   end

   If( uField == nil, uField := 2, ) ;
   If( uOrder == nil, uOrder := 1, ) ;

   dbUseArea( .T., cDriver(), cDatabase, cCheckArea( "workArea", @workArea ), .T. )
   ( workArea )->( ordListAdd( cDatabase ) )

   if ( workArea )->( used() )

      ( workArea )->( ordsetfocus( uOrder ) )

      if ( workArea )->( dbseek( id ) )
         if ( isnum( uField ) )
            fieldFromDatabase   := ( workArea )->( fieldget( uField ) )
         else
            fieldFromDatabase   := ( workArea )->( fieldget( fieldpos( uField ) ) )
         end
      else
         fieldFromDatabase      := "valor no encontrado"
      end

      ( workArea )->( dbclosearea() )

   end

return ( fieldFromDatabase )
