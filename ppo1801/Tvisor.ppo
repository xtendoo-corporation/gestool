#line 91 "\fwh1801\include\FiveWin.Ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 26 ".\.\Prg\Tvisor.prg"
_HB_CLASS TVisor ; function TVisor ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TVisor", iif( .F., { }, { @HBObject() } ), @TVisor() ) ) ;

   _HB_MEMBER { AS LOGIC lCreated } ; oClass:AddMultiClsData( "LOGIC", .F., nScope + iif( .F., 16, 0 ) + iif( .T., 32, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lCreated"}, .F. )

   _HB_MEMBER { oPrn } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oPrn"}, .F. )

   _HB_MEMBER { cPort } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cPort"}, .F. )
   _HB_MEMBER { nBitsSec } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBitsSec"}, .F. )
   _HB_MEMBER { nBitsParada } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBitsParada"}, .F. )
   _HB_MEMBER { nBitsDatos } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBitsDatos"}, .F. )
   _HB_MEMBER { nBitsParidad } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBitsParidad"}, .F. )
   _HB_MEMBER { AS NUMERIC nHComm } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nHComm"}, .F. )
   _HB_MEMBER { cLastError } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cLastError"}, .F. )
   _HB_MEMBER { AS NUMERIC nLineas } ; oClass:AddMultiData( "NUMERIC", 2, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nLineas"}, .F. )
   _HB_MEMBER { AS NUMERIC nChrLineas } ; oClass:AddMultiData( "NUMERIC", 20, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nChrLineas"}, .F. )
   _HB_MEMBER { cRetroceso } ; oClass:AddMultiData(, Space( 50 ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cRetroceso"}, .F. )
   _HB_MEMBER { cAvanceChr } ; oClass:AddMultiData(, Space( 50 ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cAvanceChr"}, .F. )
   _HB_MEMBER { cAvanceLinea } ; oClass:AddMultiData(, Space( 50 ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cAvanceLinea"}, .F. )
   _HB_MEMBER { cReset } ; oClass:AddMultiData(, Space( 50 ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cReset"}, .F. )
   _HB_MEMBER { cActiveCursor } ; oClass:AddMultiData(, Space( 50 ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cActiveCursor"}, .F. )
   _HB_MEMBER { cInactiveCursor } ; oClass:AddMultiData(, Space( 50 ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cInactiveCursor"}, .F. )
   _HB_MEMBER { cNormalWrite } ; oClass:AddMultiData(, Space( 50 ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cNormalWrite"}, .F. )
   _HB_MEMBER { cOffsetWrite } ; oClass:AddMultiData(, Space( 50 ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cOffsetWrite"}, .F. )
   _HB_MEMBER { AS NUMERIC nPosInit } ; oClass:AddMultiData( "NUMERIC", 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nPosInit"}, .F. )
   _HB_MEMBER { AS NUMERIC nPosEnd } ; oClass:AddMultiData( "NUMERIC", 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nPosEnd"}, .F. )
   _HB_MEMBER { AS NUMERIC nFirstRow } ; oClass:AddMultiData( "NUMERIC", 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nFirstRow"}, .F. )
   _HB_MEMBER { AS NUMERIC nFirstCol } ; oClass:AddMultiData( "NUMERIC", 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nFirstCol"}, .F. )
   _HB_MEMBER { cWellcomeLine1 } ; oClass:AddMultiData(, Space( 50 ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cWellcomeLine1"}, .F. )
   _HB_MEMBER { cWellcomeLine2 } ; oClass:AddMultiData(, Space( 50 ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cWellcomeLine2"}, .F. )
   _HB_MEMBER { AS NUMERIC nInact } ; oClass:AddMultiData( "NUMERIC", 10, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nInact"}, .F. )
   _HB_MEMBER { AS NUMERIC nRetardo } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nRetardo"}, .F. )

   _HB_MEMBER { aTextLine } ; oClass:AddMultiData(, Array( 2 ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aTextLine"}, .F. )

   _HB_MEMBER { oTimer } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oTimer"}, .F. )

   _HB_MEMBER Create() AS CLASS TVisor; oClass:AddMethod( "Create", @TVisor_Create(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER New( cPort, nBitsSec, nBitsParada, nBitsDatos, nBitsParidad, cApertura); oClass:AddMethod( "New", @TVisor_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Wellcome(); oClass:AddMethod( "Wellcome", @TVisor_Wellcome(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Say( cWellcomeLine1, cWellcomeLine2); oClass:AddMethod( "Say", @TVisor_Say(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SetBufferLine( cTextLine, nLine); oClass:AddMethod( "SetBufferLine", @TVisor_SetBufferLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER WriteBufferLine(); oClass:AddMethod( "WriteBufferLine", @TVisor_WriteBufferLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER End(); oClass:AddMethod( "End", @TVisor_End(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TVisor ;



static FUNCTION TVisor_Create( cCodImp ) ; local Self AS CLASS TVisor := QSelf() AS CLASS TVisor

   local oBlock
   local oError
   local dbfVisor



   oBlock            := ErrorBlock( {| oError | ApoloBreak( oError ) } )
   BEGIN SEQUENCE

   dbUseArea( .T., ( cDriver() ), ( cPatDat() + "Visor.Dbf" ), ( cCheckArea( "Visor", @dbfVisor ) ), iif( .T. .OR. .F., ! .F., NIL ), .F. )
   if !lAIS() ; ordListAdd( ( cPatDat() + "Visor.Cdx" ) ) ; else ; ordSetFocus( 1 ) ; end

   if !Empty( cCodImp ) .AND. ( dbfVisor )->( dbSeek( cCodImp ) )



      ::cPort              := ( dbfVisor )->cPort
      ::nBitsSec           := Str( ( dbfVisor )->nBitSec )
      ::nBitsParada        := Str( ( dbfVisor )->nBitPar )
      ::nBitsDatos         := Str( ( dbfVisor )->nBitDat )
      ::nBitsParidad       := ( dbfVisor )->cBitPari
      ::nLineas            := ( dbfVisor )->nLinea
      ::nChrLineas         := ( dbfVisor )->nChaLin
      ::cRetroceso         := ( dbfVisor )->cRetro
      ::cAvanceChr         := ( dbfVisor )->cAvCha
      ::cAvanceLinea       := ( dbfVisor )->cAvLin
      ::cReset             := ( dbfVisor )->cReset
      ::cActiveCursor      := ""
      ::cInactiveCursor    := ""
      ::cNormalWrite       := ( dbfVisor )->cEscNor
      ::cOffsetWrite       := ( dbfVisor )->cEscDes
      ::nPosInit           := ( dbfVisor )->cPosIni
      ::nPosEnd            := ( dbfVisor )->cPosFin
      ::nFirstRow          := ( dbfVisor )->cPriFil
      ::nFirstCol          := ( dbfVisor )->cPriCol
      ::cWellcomeLine1     := Rtrim( ( dbfVisor )->cText1 )
      ::cWellcomeLine2     := Rtrim( ( dbfVisor )->cText2 )
      ::nInact             := ( dbfVisor )->nInact

   else



      ::cPort              := "COM1"
      ::nBitsSec           := "9600"
      ::nBitsParada        := "0"
      ::nBitsDatos         := "8"
      ::nBitsParidad       := "Sin paridad"
      ::nLineas            := 2
      ::nChrLineas         := 20
      ::cRetroceso         := ""
      ::cAvanceChr         := ""
      ::cAvanceLinea       := ""
      ::cReset             := "20"
      ::cActiveCursor      := ""
      ::cInactiveCursor    := ""
      ::cNormalWrite       := ""
      ::cOffsetWrite       := ""
      ::nPosInit           := ""
      ::nPosEnd            := ""
      ::nFirstRow          := ""
      ::nFirstCol          := ""
      ::cWellcomeLine1     := ""
      ::cWellcomeLine2     := ""
      ::nInact             := 20

   end



   if dbfVisor <> nil
      ( dbfVisor )->( dbCloseArea() )
   end

   dbfVisor                := nil



   ::cReset                := RetChr( ::cReset )

   ::oPrn                  := TCommPort():New( ::cPort, ::nBitsSec, ::nBitsParada, ::nBitsDatos, ::nBitsParidad, .F. )

   if ::oPrn:lCreated

      ::lCreated           := .T.

      if ::nInact <> 0
         ::oTimer          := TTimer():New( ::nInact * 1000, {|| ::Wellcome() } )
      end

   end

   RECOVER USING oError

      msgStop( "Imposible abrir todas las bases de datos " + Chr(13)+Chr(10) + ErrorMessage( oError ) )

   end

   ErrorBlock( oBlock )

RETURN Self



static FUNCTION TVisor_New( cPort, nBitsSec, nBitsParada, nBitsDatos, nBitsParidad, lMessage ) ; local Self AS CLASS TVisor := QSelf() AS CLASS TVisor

   If( lMessage == nil, lMessage := .F., ) ;





   ::oPrn               := TCommPort():New( ::cPort, nBitsSec, nBitsParada, nBitsDatos, nBitsParidad, .F. )

   if ::oPrn:lCreated

      ::lCreated        := .T.

      if !Empty( ::oTimer )
         ::oTimer:Activate()
      end

   end

Return ( ::lCreated )




static FUNCTION TVisor_Wellcome( ) ; local Self AS CLASS TVisor := QSelf() AS CLASS TVisor

   if ::lCreated

      if !Empty( ::cReset )
         ::oPrn:Write( ::cReset )
      end


      ::oPrn:Write(  PadC( ::cWellcomeLine1, ::nChrLineas ) +  PadC( ::cWellcomeLine2, ::nChrLineas ) )
   end

RETURN ( Self )



static FUNCTION TVisor_Say( cTxtLine1, cTxtLine2 ) ; local Self AS CLASS TVisor := QSelf() AS CLASS TVisor

   if ::lCreated

      if ::oTimer <> nil
         ::oTimer:DeActivate()
      end

      if !Empty( ::cReset )
         ::oPrn:Write( ::cReset )
      end

      ::oPrn:Write( PadR( cTxtLine1, ::nChrLineas ) + PadL( cTxtLine2, ::nChrLineas ) )

      if ::oTimer <> nil
         ::oTimer:Activate()
      end

   end

Return ( Self )



static FUNCTION TVisor_End( ) ; local Self AS CLASS TVisor := QSelf() AS CLASS TVisor

   if !Empty( ::oPrn )
      ::oPrn:End()
   end

   if ::oTimer <> nil
      ::oTimer:End()
   end

Return ( Self )



static FUNCTION TVisor_SetBufferLine( cTxtLine, nLine ) ; local Self AS CLASS TVisor := QSelf() AS CLASS TVisor

   local nLen

   If( nLine == nil, nLine := 1, ) ;

   if Valtype( cTxtLine ) == "A"

      nLen                 := Len( AllTrim( cTxtLine[ 2 ] ) ) + 1

      ::aTextLine[ nLine ] := PadR( cTxtLine[ 1 ], ::nChrLineas - nLen ) + PadL( AllTrim( cTxtLine[ 2 ] ), nLen )

   else

      ::aTextLine[ nLine ] := PadR( cTxtLine, ::nChrLineas )

   end

Return ( Self )



static FUNCTION TVisor_WriteBufferLine( ) ; local Self AS CLASS TVisor := QSelf() AS CLASS TVisor

   ::Say( ::aTextLine[ 1 ], ::aTextLine[ 2 ] )

Return ( Self )
