#line 91 "\fwh1801\include\FiveWin.ch"
         EXTERNAL FW_GT
















extern errorsys









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































static aFwStack      := {}
#line 121 ".\.\Prg\Xbrowse.prg"
static lExcelInstl, lCalcInstl
static nxlLangID, cxlTrue := "=(1=1)", cxlFalse := "=(1=0)", cxlSum, lxlEnglish := .F., hLib

static bXBrowse



_HB_CLASS TXBrowse ; function TXBrowse ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TXBrowse", iif( .T., { @TControl() }, { @HBObject() } ), @TXBrowse() ) ) ;





   _HB_MEMBER { oVScroll, oHScroll, oCapCol, oSeek, oDbf } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oVScroll", "oHScroll", "oCapCol", "oSeek", "oDbf"}, .F. )




   _HB_MEMBER { aCols, aDisplay, aSelected, aArrayData } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aCols", "aDisplay", "aSelected", "aArrayData"}, .F. )

   _HB_MEMBER { aSortBmp } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aSortBmp"}, .F. )




















   _HB_MEMBER { bGoTop, bGoBottom, bSkip, bBof, bEof, bKeyNo, bKeyCount, bBookMark, bSeek, bPastEof } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bGoTop", "bGoBottom", "bSkip", "bBof", "bEof", "bKeyNo", "bKeyCount", "bBookMark", "bSeek", "bPastEof"}, .F. )
   _HB_MEMBER { bPopUp } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bPopUp"}, .F. )









   _HB_MEMBER { bClrHeader, bClrFooter, bClrGrad, bClrStd, bClrSel, bClrSelFocus, bClrRowFocus } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bClrHeader", "bClrFooter", "bClrGrad", "bClrStd", "bClrSel", "bClrSelFocus", "bClrRowFocus"}, .F. )

   _HB_MEMBER { bColClass } ; oClass:AddMultiData(, { || TxBrwColumn() }, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bColClass"}, .F. )



   _HB_MEMBER { AS CHARACTER cAlias, cSeek } ; oClass:AddMultiData( "CHARACTER",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cAlias", "cSeek"}, .F. )





   _HB_MEMBER { AS NUMERIC nRowSel, nColSel, nFreeze, nColOffset } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nRowSel", "nColSel", "nFreeze", "nColOffset"}, .F. )




   _HB_MEMBER { AS NUMERIC nHeaderLines, nFooterLines, nDataLines } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nHeaderLines", "nFooterLines", "nDataLines"}, .F. )


   _HB_MEMBER { AS NUMERIC nDataType } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nDataType"}, .F. )





   _HB_MEMBER { nHeaderHeight, nFooterHeight, nRowHeight, nRecSelColor } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nHeaderHeight", "nFooterHeight", "nRowHeight", "nRecSelColor"}, .F. )



   _HB_MEMBER { AS NUMERIC nRowDividerStyle, nColDividerStyle } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nRowDividerStyle", "nColDividerStyle"}, .F. )








   _HB_MEMBER { AS NUMERIC nMarqueeStyle } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nMarqueeStyle"}, .F. )








   _HB_MEMBER { AS NUMERIC nMoveType } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nMoveType"}, .F. )











   _HB_MEMBER { AS NUMERIC nLen, nDataRows, nCaptured, nArrayAt, nLastEditCol } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nLen", "nDataRows", "nCaptured", "nArrayAt", "nLastEditCol"}, .F. )


   _HB_MEMBER { AS NUMERIC nVScrollPos } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nVScrollPos"}, .F. )

   _HB_MEMBER { AS NUMERIC nRecSelWidth } ; oClass:AddMultiData( "NUMERIC", 25, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nRecSelWidth"}, .F. )






   _HB_MEMBER { hBtnShadowPen, hWhitePen, hColPen, hRowPen, hBmpRecSel, hBrushRecSel } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hBtnShadowPen", "hWhitePen", "hColPen", "hRowPen", "hBmpRecSel", "hBrushRecSel"}, .F. )



















   _HB_MEMBER { AS LOGICAL lCreated, lAdjusted, lRecordSelector, lHScroll, lVScroll, lAllowRowSizing, lAllowColSwapping, lAllowColHiding, lColDividerComplete, lFullGrid, lFastEdit, lEditMode, lEdit, lRefreshOnlyData, l2007, lFlatStyle } ; oClass:AddMultiData( "LOGICAL",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lCreated", "lAdjusted", "lRecordSelector", "lHScroll", "lVScroll", "lAllowRowSizing", "lAllowColSwapping", "lAllowColHiding", "lColDividerComplete", "lFullGrid", "lFastEdit", "lEditMode", "lEdit", "lRefreshOnlyData", "l2007", "lFlatStyle"}, .F. )


   _HB_MEMBER { hMultiSelect } ; oClass:AddMultiData(,, 2 + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hMultiSelect"}, .F. )

   _HB_MEMBER lMultiSelect(); oClass:AddInline( "lMultiSelect", {|Self| ( ( Self ) ), IfNil( ::hMultiSelect, ( ::nMarqueeStyle == 6 .OR.  ::nMarqueeStyle == 7 ) )}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER _lMultiSelect( lSet); oClass:AddInline( "_lMultiSelect", {|Self , lSet| ( ( Self ) ), ( ::hMultiSelect := lSet )}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER { bOnMultiSelect } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnMultiSelect"}, .F. )


   _HB_MEMBER { AS LOGICAL lFormulaEdit } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lFormulaEdit"}, .F. )
   _HB_MEMBER { AS LOGICAL lEnterKey2Edit } ; oClass:AddMultiData( "LOGICAL", .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lEnterKey2Edit"}, .F. )
   _HB_MEMBER { AS LOGICAL lF2KeyToEdit } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lF2KeyToEdit"}, .F. )
   _HB_MEMBER { AS LOGICAL lFreezeLikeExcel } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lFreezeLikeExcel"}, .F. )


   _HB_MEMBER { AS LOGICAL lSeekWild } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lSeekWild"}, .F. )
   _HB_MEMBER { AS LOGICAL lIncrFilter } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lIncrFilter"}, .F. )
   _HB_MEMBER { bFilterExp } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bFilterExp"}, .F. )
   _HB_MEMBER { cFilterFld } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cFilterFld"}, .F. )



   _HB_MEMBER { lSqlRDD } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lSqlRDD"}, .F. )
   _HB_MEMBER { AS NUMERIC nSqlRddMode } ; oClass:AddMultiData( "NUMERIC", 0, nScope + iif( .T., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nSqlRddMode"}, .F. )

   _HB_MEMBER { AS LOGICAL lRelyOnKeyNo } ; oClass:AddMultiData( "LOGICAL", .T., nScope + iif( .T., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lRelyOnKeyNo"}, .F. )

   _HB_MEMBER { AS ARRAY aBookMarks } ; oClass:AddMultiData( "ARRAY", Array(0), nScope + iif( .T., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aBookMarks"}, .F. )

   _HB_MEMBER { AS LOGICAL lVThumbTrack } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lVThumbTrack"}, .F. )
   _HB_MEMBER { AS LOGICAL lColChangeNotify } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lColChangeNotify"}, .F. )
   _HB_MEMBER { AS LOGICAL lAutoSort } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lAutoSort"}, .F. )
   _HB_MEMBER { AS LOGICAL lSortDescend } ; oClass:AddMultiData( "LOGICAL", .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lSortDescend"}, .F. )
   _HB_MEMBER { AS LOGICAL lAllowCopy } ; oClass:AddMultiData( "LOGICAL", .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lAllowCopy"}, .F. )
   _HB_MEMBER { AS LOGICAL lCanPaste } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lCanPaste"}, .F. )
   _HB_MEMBER { AS LOGICAL lExcelCellWise } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lExcelCellWise"}, .F. )
   _HB_MEMBER { AS LOGICAL lMergeVert } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lMergeVert"}, .F. )
   _HB_MEMBER { AS LOGICAL lExitGetOnTypeOut } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lExitGetOnTypeOut"}, .F. )
   _HB_MEMBER { AS LOGICAL lOemAnsi } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lOemAnsi"}, .F. )

   _HB_MEMBER { AS LOGICAL lAutoAppend } ; oClass:AddMultiData( "LOGICAL", .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lAutoAppend"}, .F. )



   _HB_MEMBER { lHeader, lFooter, lGrpHeader } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lHeader", "lFooter", "lGrpHeader"}, .F. )
   _HB_MEMBER { lAllowColReGroup } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lAllowColReGroup"}, .F. )
   _HB_MEMBER { lDisplayZeros } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lDisplayZeros"}, .F. )

   _HB_MEMBER { nSaveMarq } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nSaveMarq"}, .F. )

   _HB_MEMBER { oRS } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oRS"}, .F. )
   _HB_MEMBER { lRsCanResync } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lRsCanResync"}, .F. )
   _HB_MEMBER { AS LOGICAL lAdoOverRideConflicts } ; oClass:AddMultiData( "LOGICAL", .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lAdoOverRideConflicts"}, .F. )

   _HB_MEMBER { oMysql } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oMysql"}, .F. )
   _HB_MEMBER { oTree, oTreeItem } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oTree", "oTreeItem"}, .F. )
   _HB_MEMBER { oColToolTip } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oColToolTip"}, .F. )
   _HB_MEMBER { nRowToolTip } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nRowToolTip"}, .F. )
   _HB_MEMBER { bOnRowLeave } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnRowLeave"}, .F. )
   _HB_MEMBER { bOnSkip } ; oClass:AddMultiData(, { || nil }, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnSkip"}, .F. )
   _HB_MEMBER { lEdited } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lEdited"}, .F. )
   _HB_MEMBER { bLock } ; oClass:AddMultiData(, { || .T. }, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bLock"}, .F. )
   _HB_MEMBER { bUnLock } ; oClass:AddMultiData(, { || nil }, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bUnLock"}, .F. )
   _HB_MEMBER { bSaveData } ; oClass:AddMultiData(, { || .T. }, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bSaveData"}, .F. )
   _HB_MEMBER { bDelete, bEdit } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bDelete", "bEdit"}, .F. )
   _HB_MEMBER { aStretchInfo } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aStretchInfo"}, .F. )
   _HB_MEMBER { nStretchCol } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nStretchCol"}, .F. )
   _HB_MEMBER { bOnSwapCol } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnSwapCol"}, .F. )
   _HB_MEMBER { nRightMargin } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nRightMargin"}, .F. )
   _HB_MEMBER { nBottomMargin } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBottomMargin"}, .F. )
   _HB_MEMBER { bOnRefresh } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnRefresh"}, .F. )



   _HB_MEMBER { aHeaderTop, nHeader } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aHeaderTop", "nHeader"}, .F. )

   _HB_MEMBER { lContrastClr } ; oClass:AddMultiData(, .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lContrastClr"}, .F. )
   _HB_MEMBER { AS LOGICAL lReadOnly } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lReadOnly"}, .F. )







   _HB_MEMBER { nStartMRow, nEndMRow, nRowAdvance, nColAdvance, nStartTime, nEllapsed } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nStartMRow", "nEndMRow", "nRowAdvance", "nColAdvance", "nStartTime", "nEllapsed"}, .F. )

   _HB_MEMBER { lDown } ; oClass:AddMultiData(, .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lDown"}, .F. )
   _HB_MEMBER { lPressed } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lPressed"}, .F. )
   _HB_MEMBER { lMoved } ; oClass:AddMultiData(, .F., 2 + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lMoved"}, .F. )
   _HB_MEMBER { AS NUMERIC nStopRatio } ; oClass:AddMultiData( "NUMERIC", 4, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nStopRatio"}, .F. )
   _HB_MEMBER { AS NUMERIC nMaxRowToAdvance } ; oClass:AddMultiData( "NUMERIC", 40, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nMaxRowToAdvance"}, .F. )
   _HB_MEMBER { AS NUMERIC nMinVelocity } ; oClass:AddMultiData( "NUMERIC", 50, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nMinVelocity"}, .F. )
   _HB_MEMBER { AS LOGICAL lDrawSelected } ; oClass:AddMultiData( "LOGICAL", .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lDrawSelected"}, .F. )
   _HB_MEMBER { hCursorHand } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hCursorHand"}, .F. )

   _HB_MEMBER { AS LOGICAL lKineticBrw } ; oClass:AddMultiData( "LOGICAL", .T., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lKineticBrw"}, .F. )


   _HB_MEMBER { aBitmaps } ; oClass:AddMultiData(, Array( 0 ), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aBitmaps"}, .F. )
   _HB_MEMBER { nSizePen } ; oClass:AddMultiData(, 1, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nSizePen"}, .F. )
   _HB_MEMBER { nColorPen } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nColorPen"}, .F. )

   _HB_MEMBER { oActive } ; oClass:AddMultiClsData(,, nScope + iif( .F., 16, 0 ) + iif( .T., 32, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oActive"}, .F. )
   _HB_MEMBER { AS LOGICAL lKinetic } ; oClass:AddMultiClsData( "LOGICAL", SetKinetic(), nScope + iif( .F., 16, 0 ) + iif( .T., 32, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lKinetic"}, .F. )
   _HB_MEMBER { AS LOGICAL lRegistered } ; oClass:AddMultiClsData( "LOGICAL",, nScope + iif( .F., 16, 0 ) + iif( .T., 32, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lRegistered"}, .F. )

   _HB_MEMBER New( oWnd); oClass:AddMethod( "New", @TXBrowse_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Destroy(); oClass:AddMethod( "Destroy", @TXBrowse_Destroy(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER nAt(); oClass:AddInline( "nAt", {|Self | ( ( Self ) ), ::colpos( ::SelectedCol() ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER EraseBkGnd(); oClass:AddInline( "EraseBkGnd", {|Self, hDC | ( ( Self ) ), 1 }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER cGenPrg(); oClass:AddMethod( "cGenPrg", @TXBrowse_cGenPrg(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SetRDD( lAddColumns, lAutoSort, aFldNames, aRows); oClass:AddMethod( "SetRDD", @TXBrowse_SetRDD(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetArray( aData, lAutoSort, nColOrder, aCols, bOnSkip); oClass:AddMethod( "SetArray", @TXBrowse_SetArray(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetoDbf( oDbf, aCols, lAutoSort, lAutoCols, aRows); oClass:AddMethod( "SetoDbf", @TXBrowse_SetoDbf(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetExcelRange( oRange, lHeaders, aCols); oClass:AddMethod( "SetExcelRange", @TXBrowse_SetExcelRange(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetAdo( oRs, lAddCols, lAutoOrder, aFldNames); oClass:AddMethod( "SetAdo", @TXBrowse_SetAdo(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetTree( oTree, aResource, bOnSkip, aCols); oClass:AddMethod( "SetTree", @TXBrowse_SetTree(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetColsForTree( uData); oClass:AddMethod( "SetColsForTree", @TXBrowse_SetColsForTree(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER GetColsData( cData, lByCreationOrder); oClass:AddMethod( "GetColsData", @TXBrowse_GetColsData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetColsData( cData, aValues, lByCreationOrder); oClass:AddMethod( "SetColsData", @TXBrowse_SetColsData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SetGroupHeader( cGrpHdr, nFrom, nUpto, oFont); oClass:AddMethod( "SetGroupHeader", @TXBrowse_SetGroupHeader(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetGroupTotal( aCols, cHead, nType, oFont); oClass:AddMethod( "SetGroupTotal", @TXBrowse_SetGroupTotal(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ClearBlocks(); oClass:AddMethod( "ClearBlocks", @TXBrowse_ClearBlocks(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetColFromADO( cnCol, lAutoOrder, aColNames, lJet); oClass:AddMethod( "SetColFromADO", @TXBrowse_SetColFromADO(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ArrCell( nRow, nCol, cFmt); oClass:AddMethod( "ArrCell", @TXBrowse_ArrCell(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ArrCellSet( nRow, nCol, uNewVal); oClass:AddMethod( "ArrCellSet", @TXBrowse_ArrCellSet(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SetDolphin( oMysql, lAddCols, lAutoOrder, aFldNames); oClass:AddMethod( "SetDolphin", @TXBrowse_SetDolphin(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetMySql( oMysql, lAddCols, lAutoOrder, aFldNames); oClass:AddMethod( "SetMySql", @TXBrowse_SetMySql(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetColFromMySQL( cnCol, cHeader); oClass:AddMethod( "SetColFromMySQL", @TXBrowse_SetColFromMySQL(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER aJustify( aJust); _HB_MEMBER _aJustify( aJust); oClass:AddMethod( "aJustify", @TXBrowse_aJustify(), nScope + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) ) ; oClass:AddMethod( "_aJustify", @TXBrowse_aJustify(), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER AddCol(); oClass:AddMethod( "AddCol", @TXBrowse_AddCol(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER InsCol( nPos); oClass:AddMethod( "InsCol", @TXBrowse_InsCol(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER DelCol( nPos); oClass:AddMethod( "DelCol", @TXBrowse_DelCol(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER AddColumn(); oClass:AddMethod( "AddColumn", @TXBrowse_AddColumn(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SwapCols( xCol1, xCol2, lRefresh); oClass:AddMethod( "SwapCols", @TXBrowse_SwapCols(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER MoveCol( xFrom, xTo, lRefresh, lUser); oClass:AddMethod( "MoveCol", @TXBrowse_MoveCol(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ReArrangeCols( aSeq, lRetainRest); oClass:AddMethod( "ReArrangeCols", @TXBrowse_ReArrangeCols(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER CreateFromCode(); oClass:AddMethod( "CreateFromCode", @TXBrowse_CreateFromCode(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER CreateFromResource( nId); oClass:AddMethod( "CreateFromResource", @TXBrowse_CreateFromResource(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SelectCol( nCol, lOffSet); oClass:AddMethod( "SelectCol", @TXBrowse_SelectCol(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoToCol( oCol); oClass:AddMethod( "GoToCol", @TXBrowse_GoToCol(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoLeft( lOffset, lRefresh); oClass:AddMethod( "GoLeft", @TXBrowse_GoLeft(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoRight( lOffset, lRefresh); oClass:AddMethod( "GoRight", @TXBrowse_GoRight(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoLeftMost(); oClass:AddMethod( "GoLeftMost", @TXBrowse_GoLeftMost(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoRightMost(); oClass:AddMethod( "GoRightMost", @TXBrowse_GoRightMost(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER GoUp( nLines); oClass:AddMethod( "GoUp", @TXBrowse_GoUp(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoDown( nLines); oClass:AddMethod( "GoDown", @TXBrowse_GoDown(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER PageUp( nLines); oClass:AddMethod( "PageUp", @TXBrowse_PageUp(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER PageDown( nLines); oClass:AddMethod( "PageDown", @TXBrowse_PageDown(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoTop(); oClass:AddMethod( "GoTop", @TXBrowse_GoTop(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoBottom(); oClass:AddMethod( "GoBottom", @TXBrowse_GoBottom(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER HandleEvent( nMsg, nWParam, nLParam); oClass:AddMethod( "HandleEvent", @TXBrowse_HandleEvent(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )




   _HB_MEMBER KeyCount(); oClass:AddInline( "KeyCount", {|Self | ( ( Self ) ), ( ::nLen := Eval( ::bKeyCount ), iif(::oVScroll <> nil , ( ::VSetRange( 1, ::nLen ), ::VUpdatePos() ), ), ::nLen ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER BookMark(); oClass:AddInline( "BookMark", {|Self| ( ( Self ) ), Eval( ::bBookMark )}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER _BookMark( u); oClass:AddInline( "_BookMark", {|Self , u| ( ( Self ) ), ( Eval( ::bBookMark, u ), Eval( ::bBookMark ) )}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER KeyNo(); oClass:AddInline( "KeyNo", {|Self| ( ( Self ) ), Eval( ::bKeyNo, nil, Self )}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER _Keyno( n); oClass:AddInline( "_Keyno", {|Self , n| ( ( Self ) ), ( Eval( ::bKeyNo, n, Self ), Eval( ::bKeyNo, nil, Self ) )}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Skip(); oClass:AddInline( "Skip", {|Self, n | ( ( Self ) ), Eval( ::bSkip, n ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Bof(); oClass:AddInline( "Bof", {|Self | ( ( Self ) ), Eval( ::bBof ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Eof(); oClass:AddInline( "Eof", {|Self | ( ( Self ) ), Eval( ::bEof ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SaveState( aData); oClass:AddMethod( "SaveState", @TXBrowse_SaveState(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER RestoreState( cInfo); oClass:AddMethod( "RestoreState", @TXBrowse_RestoreState(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER OldRestoreState( cInfo); oClass:AddMethod( "OldRestoreState", @TXBrowse_OldRestoreState(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Lock(); oClass:AddInline( "Lock", {|Self | ( ( Self ) ), If( ::bLock == nil,  .T.,  Eval( ::bLock ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER UnLock(); oClass:AddInline( "UnLock", {|Self | ( ( Self ) ), If( ::bUnLock == nil, nil, Eval( ::bUnLock ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SaveData(); oClass:AddInline( "SaveData", {|Self | ( ( Self ) ), If( ::bSaveData == nil, .T., Eval( ::bSaveData, Self ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Seek( cSeek); oClass:AddMethod( "Seek", @TXBrowse_Seek(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER RddIncrSeek( cseek, uSeek); oClass:AddMethod( "RddIncrSeek", @TXBrowse_RddIncrSeek(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER RddIncrFilter( cExpr, uSeek); oClass:AddMethod( "RddIncrFilter", @TXBrowse_RddIncrFilter(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ArrayIncrSeek( cSeek); oClass:AddMethod( "ArrayIncrSeek", @TXBrowse_ArrayIncrSeek(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ArrayIncrFilter( cSeek, nGoTo); oClass:AddMethod( "ArrayIncrFilter", @TXBrowse_ArrayIncrFilter(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER AdoIncrSeek( cSeek); oClass:AddMethod( "AdoIncrSeek", @TXBrowse_AdoIncrSeek(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Select( nOperation); oClass:AddMethod( "Select", @TXBrowse_Select(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )





   _HB_MEMBER SelectAll(); oClass:AddInline( "SelectAll", {|Self | ( ( Self ) ), ::Select( 4 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SelectNone(); oClass:AddInline( "SelectNone", {|Self | ( ( Self ) ), ::Select( 0 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Adjust(); oClass:AddMethod( "Adjust", @TXBrowse_Adjust(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER CheckSize(); oClass:AddMethod( "CheckSize", @TXBrowse_CheckSize(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Resize(); oClass:AddInline( "Resize", {|Self, nSizeType, nWidth, nHeight | ( ( Self ) ), ( ::MakeBrush(), ::ColStretch(), ::Super:ReSize( nSizeType, nWidth, nHeight ), If( ::lAdjusted, ::Refresh(), ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Change( lRow); oClass:AddMethod( "Change", @TXBrowse_Change(), 2 + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER MakeTotals( aCols); oClass:AddMethod( "MakeTotals", @TXBrowse_MakeTotals(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Eval( bBlock, bFor, bWhile, nNext, nRec, lRest); oClass:AddMethod( "Eval", @TXBrowse_Eval(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Report( cTitle, lPreview, lModal, bSetUp, aGroupBy, cPDF); oClass:AddMethod( "Report", @TXBrowse_Report(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ToExcel( bProgress, nGroupBy, aCols); oClass:AddMethod( "ToExcel", @TXBrowse_ToExcel(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ToCalc( bProgress, nGroupBy, nPasteMode, aSaveAs, aCols); oClass:AddMethod( "ToCalc", @TXBrowse_ToCalc(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ToDbf( cFile, bProgress, aCols, lPrompt); oClass:AddMethod( "ToDbf", @TXBrowse_ToDbf(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER CurrentRow(); oClass:AddMethod( "CurrentRow", @TXBrowse_CurrentRow(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER AddBitmap(); oClass:AddInline( "AddBitmap", {|Self, uBmp | ( ( Self ) ), fnAddBitmap( Self, uBmp ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER aBitmap(); oClass:AddInline( "aBitmap", {|Self, n | ( ( Self ) ), ( n := Abs( IfNil( n, 0  ) ), If( n > 0 .AND. n <= Len( ::aBitmaps ), ::aBitmaps[ n ], nil ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER Initiate( hDlg); oClass:AddMethod( "Initiate", @TXBrowse_Initiate(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Display(); oClass:AddMethod( "Display", @TXBrowse_Display(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Paint(); oClass:AddMethod( "Paint", @TXBrowse_Paint(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER PaintHeader( hDC, aCols, nLast, hWhitePen, hGrayPen, hColPen); oClass:AddMethod( "PaintHeader", @TXBrowse_PaintHeader(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER PaintFooter( hDC, nBrwWidth, nBrwHeight, hWhitePen, hGrayPen); oClass:AddMethod( "PaintFooter", @TXBrowse_PaintFooter(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Refresh( lComplete); oClass:AddMethod( "Refresh", @TXBrowse_Refresh(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER CalcRowSelPos(); oClass:AddMethod( "CalcRowSelPos", @TXBrowse_CalcRowSelPos(), 2 + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER DelRePos(); oClass:AddMethod( "DelRePos", @TXBrowse_DelRePos(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER DrawLine( lSelected, nRowLine); oClass:AddMethod( "DrawLine", @TXBrowse_DrawLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER FullPaint(); oClass:AddInline( "FullPaint", {|Self | ( ( Self ) ), ( ::lTransparent .OR. ::lMergeVert .OR.  ::nMarqueeStyle == 7 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER GotFocus(); oClass:AddInline( "GotFocus", {|Self, hCtlFocus | ( ( Self ) ), ( ::oActive := Self, ::Super:GotFocus( hCtlFocus ), If( GetParent( hCtlFocus ) <> ::hWnd, ::Super:Refresh( .F. ),) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER LostFocus(); oClass:AddInline( "LostFocus", {|Self, hCtlFocus | ( ( Self ) ), ( ::Super:LostFocus( hCtlFocus ), If( GetParent( hCtlFocus ) <> ::hWnd, ::Super:Refresh( .F. ), ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER GetDlgCode( nLastKey); oClass:AddMethod( "GetDlgCode", @TXBrowse_GetDlgCode(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER HasBorder(); oClass:AddInline( "HasBorder", {|Self, lEx | ( ( Self ) ), If( lEx == .T.,  lAnd( GetWindowLong( ::hWnd, -20 ), 0X200 ),  lAnd( GetWindowLong( ::hWnd, -16 ), 8388608 ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER LButtonDown( nRow, nCol, nKeyFlags); oClass:AddMethod( "LButtonDown", @TXBrowse_LButtonDown(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER LButtonUp( nRow, nCol, nKeyFlags); oClass:AddMethod( "LButtonUp", @TXBrowse_LButtonUp(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER MouseMove( nRow, nCol, nKeyFlags); oClass:AddMethod( "MouseMove", @TXBrowse_MouseMove(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER LDblClick( nRow, nCol, nKeyFlags); oClass:AddMethod( "LDblClick", @TXBrowse_LDblClick(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER RButtonDown( nRow, nCol, nKeyFlags); oClass:AddMethod( "RButtonDown", @TXBrowse_RButtonDown(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER MouseWheel( nKeys, nDelta, nXPos, nYPos); oClass:AddMethod( "MouseWheel", @TXBrowse_MouseWheel(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER HorzLine( nRow, nOperation); oClass:AddMethod( "HorzLine", @TXBrowse_HorzLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER MouseAtHeader( nRow, nCol); oClass:AddMethod( "MouseAtHeader", @TXBrowse_MouseAtHeader(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER MouseAtFooter( nRow, nCol); oClass:AddMethod( "MouseAtFooter", @TXBrowse_MouseAtFooter(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER MouseColPos( nCol); oClass:AddMethod( "MouseColPos", @TXBrowse_MouseColPos(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER MouseRowPos( nRow); oClass:AddMethod( "MouseRowPos", @TXBrowse_MouseRowPos(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER EraseData( nRow); oClass:AddMethod( "EraseData", @TXBrowse_EraseData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER KeyDown( nKey, nFlags); oClass:AddMethod( "KeyDown", @TXBrowse_KeyDown(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER KeyChar( nKey, nFlags); oClass:AddMethod( "KeyChar", @TXBrowse_KeyChar(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER HScroll( nWParam, nLParam); oClass:AddMethod( "HScroll", @TXBrowse_HScroll(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER VScroll( nWParam, nLParam); oClass:AddMethod( "VScroll", @TXBrowse_VScroll(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER VUpdatePos(); oClass:AddInline( "VUpdatePos", {|Self | ( ( Self ) ), ::VSetPos( ::KeyNo() ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER VUpdateAll(); oClass:AddInline( "VUpdateAll", {|Self | ( ( Self ) ), ::KeyCount() }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER VSetPos( nPos); oClass:AddMethod( "VSetPos", @TXBrowse_VSetPos(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER VThumbPos(); oClass:AddInline( "VThumbPos", {|Self, nPos | ( ( Self ) ), ::nVScrollPos := ::VGetThumbPos( nPos ), ::oVScroll:SetPos( nPos ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER VGetPos(); oClass:AddInline( "VGetPos", {|Self | ( ( Self ) ), ::nVScrollPos }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER VSetRange(); oClass:AddInline( "VSetRange", {|Self, nMin, nMax | ( ( Self ) ), ::oVScroll:SetRange( Min( 1, nMin ), Max( Min( 10000, nMax ), 2 ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER VGetMax(); oClass:AddInline( "VGetMax", {|Self | ( ( Self ) ), ::oVScroll:nMax * iif( ::nLen <= 10000, 1, ::nLen / 10000 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER VGoDown(); oClass:AddInline( "VGoDown", {|Self | ( ( Self ) ), ::VSetPos( ::nVScrollPos + 1 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER VGoUp(); oClass:AddInline( "VGoUp", {|Self | ( ( Self ) ), ::VSetPos( ::nVScrollPos - 1 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER VGetThumbPos(); oClass:AddInline( "VGetThumbPos", {|Self, nPos | ( ( Self ) ), iif( ::nLen <= 10000, nPos, Int( nPos * ::nLen / 10000 ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER VGoBottom(); oClass:AddInline( "VGoBottom", {|Self | ( ( Self ) ), ::VSetPos( ::nLen ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER VGoTop(); oClass:AddInline( "VGoTop", {|Self | ( ( Self ) ), ::VSetPos( 1 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER GetDisplayCols(); oClass:AddMethod( "GetDisplayCols", @TXBrowse_GetDisplayCols(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GetVisibleCols(); oClass:AddMethod( "GetVisibleCols", @TXBrowse_GetVisibleCols(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GetDisplayColsWidth( aOptionalReturnedSizes); oClass:AddMethod( "GetDisplayColsWidth", @TXBrowse_GetDisplayColsWidth(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ColAtPos(); oClass:AddInline( "ColAtPos", {|Self, nPos | ( ( Self ) ), ::aCols[ ::aDisplay[ Min( Max( If( nPos == nil .OR. nPos == 0, 1, nPos ), 1 ), Len( ::aDisplay ) ) ] ] }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ColPos( oCol); oClass:AddMethod( "ColPos", @TXBrowse_ColPos(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SelectedCol(); oClass:AddInline( "SelectedCol", {|Self | ( ( Self ) ), ::ColAtPos( ::nColSel ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER IsDisplayPosVisible( nPos, lComplete); oClass:AddMethod( "IsDisplayPosVisible", @TXBrowse_IsDisplayPosVisible(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER LastDisplayPos(); oClass:AddMethod( "LastDisplayPos", @TXBrowse_LastDisplayPos(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )








   _HB_MEMBER BrwWidth(); oClass:AddInline( "BrwWidth", {|Self | ( ( Self ) ), GetClientRect( ::hWnd )[ 4 ] }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER BrwHeight(); oClass:AddInline( "BrwHeight", {|Self | ( ( Self ) ), GetClientRect( ::hWnd )[ 3 ] }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER HeaderHeight(); oClass:AddInline( "HeaderHeight", {|Self | ( ( Self ) ), If( ::nHeaderHeight == nil, 0, ::nHeaderHeight ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER FooterHeight(); oClass:AddInline( "FooterHeight", {|Self | ( ( Self ) ), If( ::nFooterHeight == nil, 0, ::nFooterHeight ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER CalcHdrHeight(); oClass:AddMethod( "CalcHdrHeight", @TXBrowse_CalcHdrHeight(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER RowCount(); oClass:AddInline( "RowCount", {|Self | ( ( Self ) ), ( If( ::nRowHeight == nil, ::Adjust(),), Int( ( ::BrwHeight() - ::HeaderHeight() - ::FooterHeight() ) / ::nRowHeight ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER FirstRow(); oClass:AddInline( "FirstRow", {|Self | ( ( Self ) ), ::HeaderHeight() }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER LastRow(); oClass:AddInline( "LastRow", {|Self | ( ( Self ) ), ::BrwHeight() - ::FooterHeight() - ::nRowHeight + 1 }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER FooterRow(); oClass:AddInline( "FooterRow", {|Self | ( ( Self ) ), ::BrwHeight() - ::FooterHeight() + 1 }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER DataHeight(); oClass:AddInline( "DataHeight", {|Self | ( ( Self ) ), ::nRowHeight - iif(::nRowDividerStyle > 0, 1, 0) -  If(::nRowDividerStyle >= 5, 1, 0) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER BrwFitSize( lReSize); oClass:AddMethod( "BrwFitSize", @TXBrowse_BrwFitSize(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER CancelEdit(); oClass:AddMethod( "CancelEdit", @TXBrowse_CancelEdit(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetColumns(); oClass:AddMethod( "SetColumns", @TXBrowse_SetColumns(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER GoNextCtrl(); oClass:AddMethod( "GoNextCtrl", @TXBrowse_GoNextCtrl(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoPrevCtrl() ; oClass:AddVirtual( "GoPrevCtrl" )

   _HB_MEMBER SelFont(); oClass:AddMethod( "SelFont", @TXBrowse_SelFont(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER FontSize( nPlus); oClass:AddMethod( "FontSize", @TXBrowse_FontSize(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER DrawSelect(); oClass:AddInline( "DrawSelect", {|Self | ( ( Self ) ), ::DrawLine( .T. ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER RefreshCurrent(); oClass:AddInline( "RefreshCurrent", {|Self | ( ( Self ) ), ::DrawLine( .T. ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER aRow(); oClass:AddInline( "aRow", {|Self | ( ( Self ) ), ( ::aArrayData[ ::nArrayAt ] )}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER oCol( cHeader); oClass:AddMethod( "oCol", @TXBrowse_oCol(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER RefreshFooters(); oClass:AddInline( "RefreshFooters", {|Self | ( ( Self ) ), If( Empty( ::nFooterHeight ),,AEval( ::aCols, { | oCol | oCol:RefreshFooter() } ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ClpRow(); oClass:AddMethod( "ClpRow", @TXBrowse_ClpRow(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Copy(); oClass:AddMethod( "Copy", @TXBrowse_Copy(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Paste( cText); oClass:AddMethod( "Paste", @TXBrowse_Paste(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER aCellCoor( nRow, nCol); oClass:AddMethod( "aCellCoor", @TXBrowse_aCellCoor(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER CellBitmap( nRow, nCol); oClass:AddMethod( "CellBitmap", @TXBrowse_CellBitmap(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetPos( nRow, nCol, lPixel); oClass:AddMethod( "SetPos", @TXBrowse_SetPos(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SetBackGround( uBack, nBckMode); oClass:AddMethod( "SetBackGround", @TXBrowse_SetBackGround(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER MakeBrush(); oClass:AddMethod( "MakeBrush", @TXBrowse_MakeBrush(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER DataRect(); oClass:AddMethod( "DataRect", @TXBrowse_DataRect(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER cBmpAdjBrush( cImage); _HB_MEMBER _cBmpAdjBrush( cImage); oClass:AddMethod( "cBmpAdjBrush", @TXBrowse_cBmpAdjBrush(), nScope + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) ) ; oClass:AddMethod( "_cBmpAdjBrush", @TXBrowse_cBmpAdjBrush(), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ColStretch( nStretchCol); oClass:AddMethod( "ColStretch", @TXBrowse_ColStretch(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER DestroyToolTip(); oClass:AddMethod( "DestroyToolTip", @TXBrowse_DestroyToolTip(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER NcMouseMove( nHitTestCode, nRow, nCol); oClass:AddMethod( "NcMouseMove", @TXBrowse_NcMouseMove(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER MouseLeave(); oClass:AddMethod( "MouseLeave", @TXBrowse_MouseLeave(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER uDataSource(); oClass:AddInline( "uDataSource", {|Self| ( ( Self ) ), IfNil( ::oRs, ::oMySql, ::oDbf, ::oTree, ::cAlias, ::aArrayData )}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER DataRow( lNew, cFieldList, lSourceData); oClass:AddMethod( "DataRow", @TXBrowse_DataRow(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER EditSource(); oClass:AddInline( "EditSource", {|Self, lNew, cFieldList | ( ( Self ) ), ::Edit( lNew, cFieldList, .T. ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Edit( lNew, cFieldList, lSourceData); oClass:AddMethod( "Edit", @TXBrowse_Edit(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Delete(); oClass:AddInline( "Delete", {|Self | ( ( Self ) ), If( ::lReadOnly .OR. ::nLen < 1 .OR. ::bDelete == nil, nil,  ( Eval( ::bDelete, Self ), ::Refresh(), ::SetFocus() ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetChecks( aBmp, lEdit, aPrompt); oClass:AddMethod( "SetChecks", @TXBrowse_SetChecks(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER OnError(); oClass:SetOnError( @TXBrowse_OnError() )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TXBrowse ;



static FUNCTION TXBrowse_New( oWnd ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local hBmp

   BrwClasses( ::ClassName )

   If( oWnd == nil, oWnd := GetWndDefault(), ) ;

   ::oWnd  := oWnd









   ::GetFont()

   ::l2007        := ( ColorsQty() > 256 )
   ::lFlatStyle   := .F.
   ::aCols        := {}
   ::aSelected    := {}







   ::bClrHeader   :=  ::bClrFooter   := {|| { GetSysColor( 18 ), If( ::l2007, nRGB( 231, 242, 255 ), GetSysColor( 15 ) ),  nRGB( 125, 165, 224 ), nRGB( 203, 225, 252 ) } }
   ::bClrStd      := {|| { 0, GetSysColor( 5 )} }

   ::bClrSel      := {|| { GetSysColor( 19 ), GetSysColor( 3 )} }
   ::bClrSelFocus := {|| { 16777215, GetSysColor( 13 )} }






   ::cCaption := ""
   ::cAlias   := ""
   ::cSeek    := ""

   ::nDataType := 0

   ::nTop     := 0
   ::nLeft    := 0
   ::nBottom  := oWnd:nHeight
   ::nRight   := oWnd:nWidth

   ::nStyle := nOr( 1073741824, 8388608, 268435456, 65536 )

   ::SetColor( 0, GetSysColor( 5 ) )

   ::lDrag     := .F.
   ::lFocused  := .F.
   ::lHScroll  := .T.
   ::lVScroll  := .T.

   ::lRecordSelector     := .T.
   ::lAllowRowSizing     := .T.
   ::lColDividerComplete := .F.
   ::lAllowColSwapping   := .T.
   ::lAllowColHiding     := .T.
   ::lFastEdit           := .F.
   ::lTransparent        := .F.

   ::nRowSel      := 1
   ::nColSel      := 1
   ::nColOffset   := 1
   ::nFreeze      := 0
   ::nCaptured    := 0
   ::nLastEditCol := 0

   ::nRowDividerStyle := 0
   ::nColDividerStyle := 0
   ::nMarqueeStyle    := 2

   ::nMoveType := 6

   ::nHeaderLines := 1
   ::nFooterLines := 1
   ::nDataLines   := 1

   ::hBmpRecSel := FwRArrow()

   ::lHeader          := .T.
   ::lFooter          := .F.
   ::lRefreshOnlyData := .F.

   ::aSortBmp    := {}
   hBmp        := FWBmpAsc()
   AAdd( ::aSortBmp, { hBmp, 0, nBmpWidth( hBmp ), nBmpHeight( hBmp ), nil, .F. } )
   hBmp        := FWBmpDes()
   AAdd( ::aSortBmp, { hBmp, 0, nBmpWidth( hBmp ), nBmpHeight( hBmp ), nil, .F. } )







   ::bClrGrad := { | lInvert | If( lInvert,  { { 1/3, nRGB( 255, 253, 222 ), nRGB( 255, 231, 151 ) },  { 2/3, nRGB( 255, 215,  84 ), nRGB( 255, 233, 162 ) }   },  { { 1/3, nRGB( 219, 230, 244 ), nRGB( 207, 221, 239 ) },  { 2/3, nRGB( 201, 217, 237 ), nRGB( 231, 242, 255 ) }   } ) }

   ::nHeader          := 0
   ::aHeaderTop       := {}

   ::hCursorHand      := CursorOpenHand()
   ::lKineticBrw      := ::lKinetic
   ::lAdjusted        := .F.

return Self



static FUNCTION TXBrowse_Destroy( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nFor

   if ::oActive == Self
      ::oActive   := nil
   endif

   ::lMoved = .F.


   if ::oBrush:hBitmap <> 0 .AND. ValType( ::oBrush:Cargo ) == "N" .AND.  ::oBrush:hBrush <> ::oBrush:Cargo

      DeleteObject( ::oBrush:Cargo )
   endif

   for nFor := 1 to Len( ::aCols )
      ::aCols[ nFor ]:End()
   next

   for nFor := 1 to Len( ::aBitmaps )
      PalBmpFree( ::aBitmaps[ nFor, 1 ], ::aBitmaps[ nFor, 2 ] )
   next

   DeleteObject( ::hBmpRecSel )
   DeleteObject( ::hBrushRecSel )

   DeleteObject( ::aSortBmp[ 1 ][ 1 ] )
   DeleteObject( ::aSortBmp[ 2 ][ 1 ] )

   if ::hBtnShadowPen <> nil
      DeleteObject( ::hBtnShadowPen )
      ::hBtnShadowPen := nil
   endif

   if ::hWhitePen <> nil
      DeleteObject( ::hWhitePen )
      ::hWhitePen := nil
   endif

   if ::hColPen <> nil
      DeleteObject( ::hColPen )
      ::hColPen := nil
   endif

   if ::hRowPen <> nil
      DeleteObject( ::hRowPen )
      ::hRowPen := nil
   endif

   ::oRs := ::oMySql := ::oDbf := nil

return ::Super:Destroy()



static FUNCTION TXBrowse_CreateFromCode( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   if ::lCreated
      return Self
   endif

   ::nId := ::GetNewId()

   ::Register( nOr( 1, 2, 8 ) )

   if ::lDesign
      ::nStyle := nOr( ::nStyle, 67108864 )
   endif

   if ::lVScroll
      ::nStyle := nOr( ::nStyle, 2097152 )
   endif

   if ::lHScroll
      ::nStyle := nOr( ::nStyle, 1048576 )
   endif

   if ! Empty( ::oWnd:hWnd )
      ::Create()

      if ::oFont <> nil
         ::SetFont( ::oFont )
      endif

      ::Initiate()

      ::lVisible := .T.

      ::oWnd:AddControl( Self )
   else
      ::lVisible := .F.
      ::oWnd:DefControl( Self )
   endif

   If( ::cVarName == nil, ::cVarName := "oBrw" + ::GetCtrlIndex(), ) ;

return Self



static FUNCTION TXBrowse_CreateFromResource( nId ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   if ::lCreated
      return Self
   endif





   ::nId := nId

   ::Register( nOr( 1, 2, 8 ) )

   ::oWnd:DefControl( Self )

return Self



static FUNCTION TXBrowse_cGenPrg( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local cCode := ""
   local n







   cCode += Chr(13)+Chr(10) + "   @ " + Str( ::nTop, 3 ) + ", " + Str( ::nLeft, 3 ) +  " XBROWSE " + ::cVarName +  " OF " + ::oWnd:cVarName +  "; " + Chr(13)+Chr(10) +  "      SIZE " +  AllTrim( Str( ::nWidth ) ) + ", " +  AllTrim( Str( ::nHeight ) ) + " PIXEL DESIGN" + Chr(13)+Chr(10) + Chr(13)+Chr(10)

   cCode += "   " + ::cVarName + ":CreateFromCode()" + Chr(13)+Chr(10)

return cCode



static FUNCTION TXBrowse_Initiate( hDlg ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oBrush

   if ::oBrush <> nil
      oBrush := ::oBrush
      ::oBrush := nil
   endif

   if hDlg <> nil
      ::Super:Initiate( hDlg )

   endif

   if ::lVScroll .OR. lAnd( GetWindowLong( ::hWnd, -16 ), 2097152 )
      ::oVScroll := TScrollBar():WinNew(,,, (!.F.) .OR. .T., Self,,,,,,,,, .F.,, )
   endif

   if ::lHScroll .OR. lAnd( GetWindowLong( ::hWnd, -16 ), 1048576 )
      ::oHScroll := TScrollBar():WinNew(,,, (!.T.), Self,,,,,,,,, .F.,, )
   endif

   if Empty( ::nDataType ) .OR. Empty( ::aCols )

      if ! Empty( ::aArrayData )
         if lAnd( ::nDataType, 1 )
            ::SetRDD( .T., nil, nil, ::aArrayData )
         elseif lAnd( ::nDataType, 16 ) .AND. !Empty( ::oDbf )
            ::SetODbf( ::oDbf, nil, nil, .T., ::aArrayData )
         else
            ::SetArray( ::aArrayData )
         endif
      elseif ! Empty( ::oRs )
         ::SetADO( ::oRs )
      elseif ! Empty( ::oMysql ) .AND. ::oMysql:IsKindOf( "TMYSQLQUERY" )
         ::SetMysql( ::oMysql )
      elseif ! Empty( ::oMysql ) .AND. ::oMysql:IsKindOf( "TDOLPHINQRY" )
         ::SetDolphin( ::oMysql )
      elseif ! Empty ( ::oDbf )
         ::SetoDbf( ::oDbf,,, Empty( ::aCols ) )
      elseif ! Empty( ::cAlias ) .OR. ! Empty( Alias() )
         ::SetRDD()
      endif
      if Empty( ::nDataType )

         ::bBof   := ::bEof := { || .T. }
         ::bKeyCount := ::bKeyNo := ::bBookMark := { || 0 }
      endif

   endif

   if ( ! Empty( ::cAlias ) ) .AND. ( Empty( ::bKeyCount ) .OR. Empty( ::bKeyNo ) )
      ::SetRdd()
   endif

   if Empty( ::aCols )
      ::AddCol():bStrData     := { || "" }
      ::aCols[ 1 ]:cHeader    := "A"
      ::nStretchCol := 1
   endif

   ::lCreated := .T.

   if oBrush <> nil
      if ::oBrush <> nil
         ::oBrush:End()
      endif
      ::oBrush = oBrush
   endif

   ::Adjust()

   ::MakeBrush()

return Self



static FUNCTION TXBrowse_CheckSize( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aRect

   if ( ::nRightMargin <> nil .OR. ::nBottomMargin <> nil ) .AND. !( ::oWnd:oClient == Self )
      aRect    := GetClientRect( ::oWnd:hWnd )
      if ::nRightMargin <> nil
         ::nWidth       := aRect[ 4 ] - ::nRightMargin - ::nLeft
      endif
      if ::nBottomMargin <> nil
         ::nHeight      := aRect[ 3 ] - ::nBottomMargin - ::nTop
      endif

   endif

return Self



static FUNCTION TXBrowse_BrwFitSize( lReSize, nMaxRows ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oRect, nX, nY
   local nWidth      := ::nWidth
   local nHeight     := ::nHeight

   if ::lAdjusted

      If( lReSize == nil, lReSize := .F., ) ; If( nMaxRows == nil, nMaxRows := ::RowCount(), );

      oRect    := ::GetCliRect()
      nX             := nWidth  - oRect:nWidth
      nY             := nHeight - oRect:nHeight

      nWidth         := ::GetDisplayColsWidth() + 1 + nX


      nHeight        := Max( 3, Min( nMaxRows, ::KeyCount() ) ) * ::nRowHeight +  If( ::lHeader, ::nHeaderHeight, 0 ) +  If( ::lFooter, ::nFooterHeight, 0 ) + 1 + nY

      if lReSize
         oRect := ::oWnd:GetCliRect()
         ::nWidth    := Min( nWidth, oRect:nWidth - IfNil( ::nRightMargin, 0 ) * 2 )
         ::nHeight   := nHeight
         if ! Empty( ::nRightMargin )
            ::nLeft  := oRect:nRight - ::nRightMargin - nWidth + 1
         endif
         if ! Empty( ::nBottomMargin )
            ::nTop   := oRect:nBottom - ::nBottomMargin - nHeight + 1
         endif
      endif

   endif

return { nWidth, nHeight }



static FUNCTION TXBrowse_Adjust( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nFor, nLen, nHeight, nStyle, nTemp, oCol, h

   if ::nMarqueeStyle == 7
      if ValType( Eval( ::bClrSelFocus )[ 2 ] ) <> "A"

         ::bClrSelFocus := { || { 0, { { 1, ( 220 + ( 235 * 256 ) + ( 252 * 65536 ) ),  ( 193 + ( 219 * 256 ) + ( 252 * 65536 ) ) } } } }
      endif
      if ValType( Eval( ::bClrSel )[ 2 ] ) <> "A"
         ::bClrSel := ::bClrSelFocus
      endif
   endif

   if ::lFlatStyle
      ::l2007  := .F.
   endif

   ::CheckSize()

   nLen    := Len( ::aCols )
   nHeight := 0

   if ! Empty( ::nHeader )
      nTemp      := 0
      for nFor := 1 to nLen
         WITH OBJECT ::aCols[ nFor ]
            if :nHeaderType > 0

               if :nHeaderType == 2 .OR. :nHeaderType == 4
                  nTemp++
               endif
               if nTemp <= Len( ::aHeaderTop )
                  :cGrpHdr   := ::aHeaderTop[ nTemp ]
               endif
            endif
         END
      next
   endif

   ::GetDC()

   for nFor := 1 to nLen
      ::aCols[ nFor ]:Adjust()
   next
   ::ReleaseDC()

   ::CalcHdrHeight()

   if ::lFooter .AND. ::nFooterHeight == nil
      nHeight := 0
      for nFor := 1 to nLen
         nHeight := Max( nHeight, ::aCols[ nFor ]:FooterHeight() )
      next
      ::nFooterHeight := ( nHeight * ::nFooterLines ) + 4 + 3
   endif

   for each oCol in ::aCols
      if ! Empty( oCol:aRows )
         AEval( oCol:aRows, { |o| oCol:nWidth := Max( oCol:nWidth, o:nWidth ) } )
         AEval( oCol:aRows, { |o| o:nWidth := oCol:nWidth } )
      endif
   next

   if ::nRowHeight == nil
      nHeight := 0
      for nFor := 1 to nLen
         nHeight := Max( nHeight, ::aCols[ nFor ]:DataHeight() )
      next

      for each oCol in ::aCols
         if ! Empty( oCol:aRows )
            h  := 0
            AEval( oCol:aRows, { |o| h += o:nCellHeight } )
            nHeight  := Max( nHeight, Ceiling( h / ::nDataLines ) )
         endif
      next

      ::nRowHeight := ( nHeight * ::nDataLines ) + 4
      if ::nRowDividerStyle <> 0
         ::nRowHeight++
      endif
      if ::nRowDividerStyle >= 5
         ::nRowHeight++
      endif
   endif


   If( ::hBtnShadowPen == nil, ::hBtnShadowPen := CreatePen( 0, 1, GetSysColor( 16 ) ), ) ; If( ::hWhitePen == nil, ::hWhitePen := CreatePen( 0, 1, GetSysColor( 20 ) ), );

   if ::hColPen <> nil
      DeleteObject( ::hColPen )
      ::hColPen := nil
   endif

   nStyle := ::nColDividerStyle

   do case
   case nStyle == 1 .OR. nStyle == 6 .OR. nStyle == 5
      ::hColPen := CreatePen( 0, ::nSizePen, ::nColorPen )
   case nStyle == 2
      ::hColPen := CreatePen( 0, ::nSizePen, 8421504 )
   case nStyle == 3
      ::hColPen := CreatePen( 0, ::nSizePen, ::nClrText )
   case nStyle == 4
      ::hColPen := CreatePen( 0, ::nSizePen, 12632256 )

   end

   nStyle := ::nRowDividerStyle

   do case
   case nStyle == 1 .OR. nStyle == 6 .OR. nStyle == 5
      ::hRowPen := CreatePen( 0, ::nSizePen, ::nColorPen )
   case nStyle == 2
      ::hRowPen := CreatePen( 0, ::nSizePen, 8421504 )
   case nStyle == 3
      ::hRowPen := CreatePen( 0, ::nSizePen, ::nClrText )
   case nStyle == 4
      ::hRowPen := CreatePen( 0, ::nSizePen, 12632256 )

   end

   if ::nRecSelColor == nil
      ::nRecSelColor := If( ::l2007, nRGB( 231, 242, 255 ), Eval( ::bClrHeader )[ 2 ] )
   endif

   if ::hBrushRecSel <> nil
      DeleteObject( ::hBrushRecSel )
   endif
   ::hBrushRecSel = CreateSolidBrush( ::nRecSelColor )

   ::GetDisplayCols()

   ::KeyCount()

   if ::lMultiSelect
      ::Select(1)
   endif

   if ::oVScroll <> nil
      ::VSetRange( 1, ::nLen )
      ::VSetPos( ::KeyNo() )
   endif

   ::lAdjusted    := .T.
   ::ColStretch()

return nil



static FUNCTION TXBrowse_CalcHdrHeight( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nFor, nLen, nGrp, nCol, oCol, nHeight
   local cGrpHdr
   local aGroup, aBitmap

   if ::lHeader

      nLen           := Len( ::aCols )
      nHeight        := 0
      ::aHeaderTop   := {}
      if ::lGrpHeader == nil
         ::lGrpHeader   := .F.
         for nFor := 1 to nLen
            if ! Empty( ::aCols[ nFor ]:cGrpHdr )
               ::lGrpHeader := .T.
            endif
         next
      endif
      if ::lGrpHeader .OR. ::nHeaderHeight == nil
         if ::lGrpHeader
            nHeight     := 0
            for nFor := 1 to nLen
               oCol     := ::aCols[ nFor ]
               if oCol:cGrpHdr <> cGrpHdr
                  if aGroup <> nil
                     AAdd( ::aHeaderTop, aGroup )
                     for nCol := aGroup[ 3 ] to aGroup[ 4 ]
                        ::aCols[ nCol ]:nGrpHeight := aGroup[ 5 ]
                     next
                     aGroup  := nil
                  endif
                  cGrpHdr     := oCol:cGrpHdr
                  if ! Empty( oCol:cGrpHdr )


                     aGroup      := { oCol:cGrpHdr, oCol, nFor, nFor, oCol:HeaderHeight( .T. ),  oCol:aBitmap( oCol:nGrpBmpNo ) }
                  endif
               else

                  if ! Empty( oCol:cGrpHdr )
                     aGroup[ 2 ]      := oCol
                     aGroup[ 4 ]      := nFor
                     aGroup[ 5 ]      := Max( aGroup[ 5 ], oCol:HeaderHeight( .T. ) )
                     if ! Empty( oCol:nGrpBmpNo )
                        aGroup[ 6 ]    := oCol:aBitmap( oCol:nGrpBmpNo )
                     endif
                  endif
               endif
            next
            if aGroup <> nil
               AAdd( ::aHeaderTop, aGroup )
               for nCol := aGroup[ 3 ] to aGroup[ 4 ]
                  ::aCols[ nCol ]:nGrpHeight := aGroup[ 5 ]
               next
               aGroup  := nil
            endif
         endif

         for nFor := 1 to nLen
            nHeight  := Max( nHeight, ::aCols[ nFor ]:HeaderHeight() )
         next
         if ::nHeaderLines > 1
            nHeight  := Max( nHeight, FontHeight( Self, ::oWnd:oFont ) * ::nHeaderLines )
         endif
         ::nHeaderHeight := nHeight + 4 + 3
      endif
   endif

return ::nHeaderHeight



static FUNCTION TXBrowse_Change( lRow ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   If( lRow == nil, lRow := .T., ) ;

   if ::bChange <> nil

      if lRow .OR. ::lColChangeNotify
         Eval( ::bChange, Self, lRow )
      endif

   endif

return nil



static FUNCTION TXBrowse_Refresh( lComplete ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nKeyNo, nMaxRows, nBookMark, nTemp

   If( lComplete == nil, lComplete := .F., ) ;

   ::KeyCount()

   if lComplete
      ::nRowSel      := 1
      ::nArrayAt     := Min( 1, ::nLen )
   else
      ::DelRepos()
      nKeyNo         := ::KeyNo()
      if hb_isNumeric( nKeyNo ) .AND. ( nKeyNo > ::nLen )
         ::KeyNo     := ::nLen
         nKeyNo      := ::nLen
      endif
      if ::nArrayAt == 0 .AND. ::nLen > 0

         ::nArrayAt  := 1
      endif
   endif

   ::CalcRowSelPos()
   ::GetDisplayCols()

   if ::bOnRefresh <> nil
      Eval( ::bOnRefresh, Self )
   endif

return ::Super:Refresh( .T. )



static FUNCTION TXBrowse_CalcRowSelPos( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nKeyNo, nMaxRows, nBookMark, nSkipped

   nMaxRows    := ::RowCount()
   if ::lRelyOnKeyNo
      nKeyNo      := ::KeyNo()
      if ::nLen <= nMaxRows
         ::nRowSel   := nKeyNo
      else
         if ( ::nLen - nKeyNo  ) < ( nMaxRows - ::nRowSel )
            ::nRowSel   := nMaxRows - ( ::nLen - nKeyNo )
         endif
         ::nRowSel   := Max( 1, Min( ::nRowSel, nKeyNo ) )
      endif
   else
      nBookMark   := ::BookMark
      nSkipped    := ::Skip( nMaxRows - ::nRowSel )
      ::nRowSel   := Max( ::nRowSel, nMaxRows - nSkipped )
      ::BookMark  := nBookMark
      ::nRowSel   := 1 - ::Skip( 1 - ::nRowSel )
      ::BookMark  := nBookMark
   endif

return nil



static FUNCTION TXBrowse_DelRePos( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local lRepos := .F.
   local cFilter, bFilter

   if ( ::nDataType == 1 ) .AND. ::nLen > 0
      if ( Set( 11 ) .AND. ( ::cAlias )->( Deleted() ) )









            ( ::cAlias )->( dbSkip( 1 ) )
            if ( ::cAlias )->( eof() )
               ( ::cAlias )->( DbGoBottom() )
            endif
            lRepos := .T.
      endif

   endif

return lRepos



static FUNCTION TXBrowse_Display( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   if !::lCreated
      return nil
   endif

   ::BeginPaint()
   ::Paint()
   ::EndPaint()

return 0



static FUNCTION TXBrowse_Paint( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aCols, aColors, oRect
   local oCol
   local nFor, nLen, nRow, nCol, nHeight, nLast, nTemp, nTemp2, nKeyNo
   local nBrwWidth, nBrwHeight, nWidth
   local hBrush, hDC, hGrayPen, hWhitePen, hColPen, hRowPen, hSelBrush
   local nFirstRow, nLastRow, nMaxRows, nRowStyle, nColStyle, nRowPos, nRowHeight, nBookMark, nMarqStyle, nScan
   local lRecSel, lOnlyData, lHighLite
   local aInfo

   if ::nRecSelWidth < 25
      ::nRecSelWidth    := 25
   endif

   if ::SelectedCol():oEditLbx <> nil
      return nil
   endif

   aInfo := ::DispBegin()
   ::CheckSize()


   if ::lTransparent .AND. Empty( ::oBrush:hBitmap )
      if ! Empty( ::oWnd:oBrush:hBitmap )

         SetBrushOrgEx( ::hDC, nBmpWidth( ::oWnd:oBrush:hBitmap ) - ::nLeft,  nBmpHeight( ::oWnd:oBrush:hBitmap ) - ::nTop )
      endif
      FillRect( ::hDC, GetClientRect( ::hWnd ), ::oWnd:oBrush:hBrush )
   else
      oRect       := ::DataRect()
      SetBrushOrgEx( ::hDC, oRect:nLeft, oRect:nTop )
      FillRect( ::hDC, oRect:aRect, ::oBrush:hBrush )
   endif


   while ! ::IsDisplayPosVisible( ::nColSel ) .AND. ::nColSel > 1
      ::nColSel--
      ::nColOffSet++
      ::GetDisplayCols()
   end

   nLen       := Len( ::aDisplay )
   aCols      := Array( nLen + 1 )
   nBrwWidth  := ::BrwWidth()
   nBrwHeight := ::BrwHeight()
   nRow       := 0
   nCol       := 0
   nFirstRow  := 0
   nLastRow   := nBrwHeight
   nLast      := ::LastDisplayPos()
   nMarqStyle := ::nMarqueeStyle
   nRowStyle  := ::nRowDividerStyle
   nColStyle  := ::nColDividerStyle
   hDC        := ::hDC
   hGrayPen   := ::hBtnShadowPen
   hWhitePen  := ::hWhitePen
   hColPen    := ::hColPen
   hRowPen    := ::hRowPen
   lRecSel    := ::lRecordSelector
   lOnlyData  := ::lRefreshOnlyData
   lHighLite  := .F.





   if lRecSel
      nCol += ::nRecSelWidth
      if !lOnlyData
         FillRect( hDC, {0, 0, nLastRow + 3, nCol }, ::hBrushRecSel )
         nHeight := ::HeaderHeight()
         nTemp   := nBrwHeight - ::FooterHeight() + 3
         if ::lFlatStyle
            DrawVert( hDC, nCol - 2, nHeight, nTemp, hColPen )
            DrawVert( hDC, 0,        0,       nBrwHeight + 3, hColPen )
         else
            DrawVert( hDC, nCol - 3, nHeight, nTemp,          hWhitePen )
            DrawVert( hDC, nCol - 2, nHeight, nTemp,          hGrayPen )
            DrawVert( hDC, 0,        0,       nBrwHeight + 3, hGrayPen )
            DrawVert( hDC, 1,        0,       nBrwHeight + 3, hWhitePen )
         endif
      endif


   endif

   for nFor := 1 to nLast
      aCols[ nFor ] := nCol
      oCol := ::ColAtPos( nFor )
      nCol += oCol:nWidth + 2
   next

   aCols[ nFor ] := nCol


   if ::lHeader
      if !lOnlyData
         ::PaintHeader( hDC, aCols, nLast, hWhitePen, hGrayPen, hColPen )
      endif
      nFirstRow += ::nHeaderHeight
   endif


   if ::lFooter
      if !lOnlyData
         ::PaintFooter( hDC, aCols, nLast, nBrwWidth, nBrwHeight, hWhitePen, hGrayPen )
      endif
      nLastRow -= ::nFooterHeight
   endif





   ::lRefreshOnlyData := .F.

   if ::nLen == 0
      ::EraseData( nFirstRow  )
      ::DispEnd( aInfo )
      return nil
   endif

   nRowHeight := ::nRowHeight
   nHeight    := ::DataHeight()
   nMaxRows   := ::RowCount()
   nRowPos    := 1
   nRow       := nFirstRow

   BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
   nBookMark  := ::BookMark
   RECOVER
   END

   ::nRowSel   := Max( 1, Min( ::nRowSel, nMaxRows ) )
   if Empty( ::nDataRows )
      ::CalcRowSelPos()
   endif
   ::nRowSel   := 1 - ::Skip( 1 - ::nRowSel )

   if nMarqStyle > 3
      if ::hWnd == GetFocus()
         hSelBrush := CreateColorBrush( Eval( If( ::bClrRowFocus == nil, ::bClrSelFocus, ::bClrRowFocus ) )[ 2 ] )
      else
         hSelBrush := CreateColorBrush( Eval( ::bClrSel )[ 2 ] )
      endif
   endif

   ::aBookMarks   := {}
   while nRowPos <= nMaxRows



      if hSelBrush <> nil

         lHighLite := ::lMultiSelect .AND. ( Ascan( ::aSelected, Eval( ::bBookMark ) ) > 0 )

         if aCols[ nLast + 1 ] < nBrwWidth
            nTemp     := nRow + nHeight
            nTemp2    := aCols[nLast + 1]
            if nColStyle < 5
               nTemp2--
            endif
            if lHighLite .AND. ::nMarqueeStyle <> 7
               FillRect( hDC, {nRow, nTemp2, nTemp, nBrwWidth }, hSelBrush )
            elseif nMarqStyle >= 4
               if ! ::lTransparent
                  hBrush := CreateColorBrush( Eval( ::bClrStd )[ 2 ] )
                  FillRect( hDC, {nRow, nTemp2, nTemp, nBrwWidth }, hBrush )
                  DeleteObject( hBrush )
               endif
            endif
         endif

      endif

      AAdd( ::aBookMarks, ::BookMark )
      for nFor := 1 to nLast
         if aCols[ nFor ] > nBrwWidth
            exit
         endif
         oCol := ::ColAtPos( nFor )
         oCol:PaintData( nRow, aCols[ nFor ], nHeight, lHighLite, .F., nFor, nRowPos )
      next

      nRowPos++
      nRow += nRowHeight
      if ::Skip() == 0
         exit
      endif

   enddo

   if nMarqStyle <= 3 .AND. aCols[ nLast + 1 ] < nBrwWidth .AND. ! ::lTransparent
      hBrush := CreateColorBrush( ::nClrPane )
      nTemp  := aCols[nLast + 1] - 1
      FillRect( hDC, {nFirstRow, nTemp, ::BrwHeight() - ::FooterHeight(), nBrwWidth }, hBrush )
      DeleteObject( hBrush )
   endif

   if hSelBrush <> nil
      DeleteObject( hSelBrush )
   endif

   ::nDataRows := nRowPos - 1


   if nRow < nLastRow
      ::EraseData( nRow  )
   endif

   ::BookMark     := nBookMark
   ::DrawLine( .T. )





   do case
   case nColStyle == 0
      nTemp := 2
   case nColStyle < 5
      nTemp := 1
   otherwise
      nTemp := 0
   end

   if nColStyle > 0
      if ::lColDividerComplete
         nHeight := nLastRow
      else
         nHeight := ( ::nRowHeight * ( nRowPos - 1 ) ) + nFirstRow
      endif
      for nFor := 2 to nLast + 1
         nCol := acols[ nFor ]
         oCol := ::aCols[ nFor - 1 ]
         hColPen     := IfNil( oCol:hColPen, ::hColPen )
         nColStyle   := IfNil( oCol:nColDividerStyle, ::nColDividerStyle )
         if nColStyle == 0

         elseif nColStyle <> 6
            DrawVert( hDC, nCol - 2, nFirstRow, nHeight, hColPen )
         else
            DrawVert( hDC, nCol - 2, nFirstRow, nHeight, hWhitePen )
            DrawVert( hDC, nCol - 1, nFirstRow, nHeight, hColPen )
         endif
         if nColStyle = 5
            DrawVert( hDC, nCol - 1, nFirstRow, nHeight, hWhitePen )
         endif
      next
      if ! lRecSel .AND. ::lVScroll .AND. ::nColDividerStyle > 0 .AND. ::lColDividerComplete
         DrawVert( hDC, 0, 0, nBrwHeight + 3, hGrayPen )
      endif

   endif

   if nRowStyle > 0
      nRow   := ::HeaderHeight() - 1
      nTemp2 := If( ::lFullGrid, nMaxRows, ::nDataRows )
      while nTemp2-- > 0
         nRow += nRowHeight
         if lRecSel
            DrawHorz( hDC, nRow,     2, ::nRecSelWidth - 4, hGrayPen  )
            DrawHorz( hDC, nRow + 1, 2, ::nRecSelWidth - 4, hWhitePen )
         endif
         for nFor := 1 to nLast
            if ::aCols[ nFor ]:HasBorder( ::nDataRows - nTemp2 )
               nCol   := acols[ nFor ] - If( nFor <> 1, nTemp, 0 )
               nWidth := nCol + ::ColAtPos( nFor ):nWidth + If( nFor <> 1, nTemp, 0 )
               if nRowStyle <> 6
                  DrawHorz( hDC, nRow, nCol, nWidth, hRowPen )
               else
                  DrawHorz( hDC, nRow,     nCol, nWidth, hWhitePen )
                  DrawHorz( hDC, nRow - 1, nCol, nWidth, hRowPen   )
               endif
               if nRowStyle = 5
                  DrawHorz( hDC, nRow - 1, nCol, nWidth, hWhitePen )
               endif
            endif
         next
         if ( ::lFullGrid .OR. nMarqStyle >= 4 ) .AND. nLast == Len( ::aDisplay )
            nCol   := acols[ nFor ] - nTemp
            nWidth := ::BrwWidth()
            if nRowStyle <> 6
               DrawHorz( hDC, nRow, nCol, nWidth, hRowPen )
            else
               DrawHorz( hDC, nRow,     nCol, nWidth, hWhitePen )
               DrawHorz( hDC, nRow - 1, nCol, nWidth, hRowPen   )
            endif
            if nRowStyle = 5
               DrawHorz( hDC, nRow - 1, nCol, nWidth, hWhitePen )
            endif
         endif
      enddo
   endif

   if ::bPainted <> nil
      Eval( ::bPainted, ::hDC, ::cPS, Self )
   endif

   ::DispEnd( aInfo )

return 0



static FUNCTION TXBrowse_PaintHeader( hDC, aCols, nLast, hWhitePen, hGrayPen, hColPen ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nRow, nCol, oCol, nHeight, nBrwWidth, aGroup
   local hHeaderPen, aColors, hBrush
   local nFor, nAt
   local cGrpHdr, nGrpHt, nGrpFrom := 0

   nBrwWidth   := ::BrwWidth()
   aColors     := Eval( ::bClrHeader )
   hBrush      := CreateColorBrush( aColors[ 2 ] )
   hHeaderPen  := CreatePen( 0, 1, If( Len( aColors ) >= 3, aColors[ 3 ], aColors[ 1 ] ) )


   nRow    := 0
   if ::lFlatStyle
      DrawHorz( hDC, nRow, 1, nBrwWidth, hHeaderPen )
      nHeight  := ::nHeaderHeight - 1
      nRow++
   else
      nHeight := ::nHeaderHeight - 3
      DrawHorz( hDC, nRow, 2, nBrwWidth, hGrayPen )
      nRow++
      DrawHorz( hDC, nRow, 2, nBrwWidth, hWhitePen )
      nRow++
   endif
   FillRect( hDC, { nRow, If( ::lFlatStyle, 1, 2 ), nRow + nHeight, nBrwWidth}, hBrush )

   for nFor := 1 to nLast
      nCol     := aCols[ nFor ]
      oCol     := ::ColAtPos( nFor )

      if ::lFlatStyle
         DrawVert( hDC, nCol - 2, nRow + 1, nRow + nHeight - 2, hHeaderPen )
      else
         DrawVert( hDC, nCol - 2, nRow + 1, nRow + nHeight - 2, hGrayPen  )
         DrawVert( hDC, nCol - 1, nRow + 1, nRow + nHeight - 2, hWhitePen )
      endif
      oCol:PaintHeader( nRow, nCol, nHeight, .F., hDC )

      if oCol:cGrpHdr <> cGrpHdr
         cGrpHdr     := oCol:cGrpHdr
         if Empty( oCol:cGrpHdr )
            nGrpFrom       := 0
            aGroup         := nil
         else
            nGrpFrom       := nCol
            nGrpHt         := oCol:nGrpHeight
            nAt            := AScan( ::aHeaderTop, { |a| a[ 3 ] == oCol:nPos } )
            aGroup         := If( nAt > 0, ::aHeaderTop[ nAt ], nil )
         endif
      endif

      if nFor == nLast .OR. oCol:cGrpHdr <> ::ColAtPos( nFor + 1 ):cGrpHdr
         if ! Empty( cGrpHdr )


            oCol:PaintHeader( nRow, nGrpFrom, nHeight, .F., hDC, aCols[ nFor + 1 ] - nGrpFrom,  If( aGroup == nil, nil, aGroup[ 6 ] ) )
            DrawHorz( hDC, nRow + nGrpHt, nGrpFrom - 2, aCols[ nFor + 1 ] - 2, hHeaderPen )
         endif
      endif
   next

   nCol     := aCols[ nFor ]
   DrawVert( hDC, nCol - 2,       nRow + 1, nRow + nHeight - 2, hGrayPen  )
   DrawVert( hDC, nCol - 1,       nRow + 1, nRow + nHeight - 2, hWhitePen )
   if ::lFlatStyle
      DrawHorz( hDC, nRow + nHeight - 1, 0, nBrwWidth, hHeaderPen  )
   else
      DrawHorz( hDC, nRow + nHeight, 0, nBrwWidth, hGrayPen  )
   endif

   DeleteObject( hBrush )
   DeleteObject( hHeaderPen )

return nil



static FUNCTION TXBrowse_PaintFooter( hDC, aCols, nLast, nBrwWidth, nBrwHeight, hWhitePen, hGrayPen ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nRow, nCol, nFor, oCol
   local nHeight, hBrush, aColors, hPen

   nHeight  := ::nFooterHeight - 3
   nRow     := nBrwHeight - ::nFooterHeight
   aColors  := Eval( ::bClrFooter )
   hPen     := CreatePen( 0, 1, If( Len( aColors ) >= 3, aColors[ 3 ], aColors[ 1 ] ) )
   DrawHorz( hDC, nRow, 0, nBrwWidth, hGrayPen )
   nRow++
   DrawHorz( hDC, nRow, 0, nBrwWidth, hWhitePen )
   nRow++
   DrawHorz( hDC, nRow + nHeight, 0, nBrwWidth, hGrayPen )
   hBrush  := CreateColorBrush( aColors[ 2 ] )

   FillRect( hDC, { nRow, 1, nRow + nHeight, nBrwWidth}, hBrush )
   DeleteObject( hBrush )
   for nFor := 1 to nLast
      nCol := aCols[ nFor ]
      oCol := ::ColAtPos( nFor )
      if ::lFlatStyle
         DrawVert( hDC, nCol - 2, nRow + 1, nRow + nHeight - 2, hPen )
      else
         DrawVert( hDC, nCol - 2, nRow + 1, nRow + nHeight - 2, hGrayPen )
         DrawVert( hDC, nCol - 1, nRow + 1, nRow + nHeight - 2, hWhitePen )
      endif
      oCol:PaintFooter( nRow, nCol, nHeight )
   next
   nCol := aCols[ nFor ]

   if ::lFlatStyle
      DrawVert( hDC, nCol - 2, nRow + 1, nRow + nHeight - 2, hPen )
   else
      DrawVert( hDC, nCol - 2, nRow + 1, nRow + nHeight - 2, hGrayPen )
      DrawVert( hDC, nCol - 1, nRow + 1, nRow + nHeight - 2, hWhitePen )
   endif
   DeleteObject( hPen )

return nil



static FUNCTION TXBrowse_DrawLine( lSelected, nRowSel ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol

   local nRow, nCol, nFor, nLast, nHeight, nStyle, nWidth, nColStyle, nTemp, nDataHeight, nRight
   local hDC, hBrush, hWhitePen, hColPen
   local lHighLite


   If( lSelected == nil, lSelected := .F., ) ; If( nRowSel == nil, nRowSel := ::nRowSel, );

   if ::nLen == 0
      return nil
   endif

   if ! ::lDrawSelected
      return  nil
   endif

   nHeight     := ::nRowHeight
   nDataHeight := ::DataHeight
   nRow        := ( ( nRowSel - 1 ) * nHeight ) + ::HeaderHeight()

   if nRow > ::LastRow()
      return nil
   endif

   hDC       := ::GetDC()
   nLast     := ::LastDisplayPos()
   nStyle    := ::nMarqueeStyle

   lHighLite := ( nStyle >= 4 .AND. lSelected )

   if ::lMultiSelect .AND. ( nStyle == 6 .OR. ::nMarqueeStyle == 7 )

      lHighLite := ( Ascan( ::aSelected, Eval( ::bBookMark ) ) > 0 )
   endif








   for nFor := 1 to nLast
      oCol := ::ColAtPos ( nFor )
      oCol:PaintData( nRow, nil, nDataHeight, lHighLite, lSelected, nFor, nRowSel )
   next

   if nStyle >= 4 .AND. nStyle <> 7
      nColStyle := ::nColDividerStyle
      nCol      := oCol:nDisplayCol + oCol:nWidth + 2
      nWidth    := ::BrwWidth() - 2
      if nColStyle < 5
         nCol--
         nWidth++
      endif
      nTemp := nRow + nDataHeight
      if nCol < nWidth
         if lHighLite
            if ::hWnd == GetFocus()
               hBrush := CreateColorBrush( Eval( If( ::bClrRowFocus == nil, ::bClrSelFocus, ::bClrRowFocus ) )[ 2 ] )
            else
               hBrush := CreateColorBrush( Eval( ::bClrSel )[ 2 ] )
            endif
         else
            hBrush := CreateColorBrush( Eval( ::bClrStd )[ 2 ] )
         endif
         if lHighLite .OR. ! ::lTransparent
            FillRect( hDC, {nRow, nCol, nTemp, nWidth + 1 }, hBrush )
         endif
         DeleteObject( hBrush )
      endif
      if nStyle == 6
         nCol := iif(::lRecordSelector, ::nRecSelWidth - 1, 0 )
         if lSelected
            FrameDot(hDC, nRow, nCol, nRow + nDataHeight - 1, nWidth - 1)
         elseif nColStyle > 0
            hColPen   := ::hColPen
            hWhitePen := ::hWhitePen
            for nFor := 1 to nLast
               oCol := ::ColAtPos ( nFor )
               nCol := oCol:nDisplayCol + oCol:nWidth
               if nColStyle <> 6
                  DrawVert( hDC, nCol, nRow, nRow + nDataHeight, hColPen )
               else
                  DrawVert( hDC, nCol,     nRow, nRow + nDataHeight, hWhitePen )
                  DrawVert( hDC, nCol + 1, nRow, nRow + nDataHeight, hColPen   )
               endif
               if nColStyle = 5
                  DrawVert( hDC, nCol + 1, nRow, nRow + nDataHeight, hWhitePen )
               endif
            next
         endif
      endif
   endif

   if ::lRecordSelector
      if lSelected

         PalBmpDraw( hDC, nRow + ( nHeight / 2 ) - 8, ::nRecSelWidth - 15, ::hBmpRecSel, 0, 9, 14,, .T., ::nRecSelColor )
      else





         FillRect( hDC, {nRow + 1, ::nRecSelWidth - 15, nRow + nDataHeight - 1 , ::nRecSelWidth - 3}, ::hBrushRecSel )
      endif

   endif

   if lSelected
      nHeight -= 2
      oCol := ::ColAtPos( ::nColSel )
      do case
      case nStyle == 1
         oCol:Box( nRow, nil, nDataHeight, 1 )
      case nStyle == 2
         oCol:Box( nRow, nil, nDataHeight, 2 )
      case nStyle == 3
         oCol:PaintData( nRow, nil, nDataHeight, .T., .T. , ::nColSel, nRowSel )
      case nStyle == 4
         oCol:Box( nRow, nil, nDataHeight, 3 )
      case nStyle == 7
         oCol     := ::ColAtPos( nLast )
         nLast    := Min( oCol:nDisplayCol + oCol:nWidth, ::BrwWidth() )







         RoundBox( hDC, 2, nRow - 1, nLast - 1, nRow + nDataHeight,     2, 2, ( 235 + ( 244 * 256 ) + ( 253 * 65536 ) ), 1 )

         RoundBox( hDC, 1, nRow - 2, nLast,     nRow + nDataHeight + 1, 2, 2, ( 125 + ( 162 * 256 ) + ( 206 * 65536 ) ), 1 )

      endcase
   endif

   ::ReleaseDC()

return nil



static FUNCTION TXBrowse_EraseData( nRow ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nLast, nFor, nHeight, nCol
   local hDC, oBrush

   if ::lTransparent .AND. Empty( ::oBrush:hBitmap )
      oBrush      := ::oWnd:oBrush
   else
      oBrush      := ::oBrush
   endif

   hDC     := ::GetDC()
   nHeight := ::BrwHeight() - ::FooterHeight() - nRow

   if ! ::lColDividerComplete
      nCol := 0
      if ::lRecordSelector
         nCol += ::nRecSelWidth
      endif
      FillRect( hDC, { nRow, nCol, nRow + nHeight, ::BrwWidth() }, oBrush:hBrush )
   else
      nLast   := ::LastDisplayPos()

      if ! ::lTransparent
         for nFor := 1 to nLast
            oCol := ::ColAtPos( nFor )
            oCol:EraseData( nRow, , nHeight, ::oBrush:hBrush, .T. )
         next
         if ::nMarqueeStyle > 3 .AND. nLast == Len( ::aDisplay )
            nCol := oCol:nDisplayCol + oCol:nWidth + 1
            FillRect( hDC, { nRow, nCol, nRow + nHeight, ::BrwWidth() }, oBrush:hBrush )
         endif
      endif
   endif

   if ::lRecordSelector .AND. ::nRowDividerStyle > 0
      FillRect( hDC, { nRow, 2, nRow + nHeight, ::nRecSelWidth - 3 }, ::hBrushRecSel )
   endif

   ::ReleaseDC()

return nil


static FUNCTION TXBrowse_oCol( u ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nAt   := AScan( ::aCols, { |o| o == u } )

return If( nAt > 0, ::aCols[ nAt ], nil )


static FUNCTION TXBrowse_GetDisplayCols( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local aDisplay
   local nFor, nLen, nOffset, nFreeze, nCol, nCols


   if Empty( ::aCols )
      ::aCols     := {}
      WITH OBJECT ::AddCol()
         :cHeader    := "Empty Col"
         :bEditValue := { || "Empty Col" }
         :Adjust()
      END
   endif


   nFreeze  := ::nFreeze
   nOffset  := ::nColOffset + nFreeze
   nLen     := Len( ::aCols )
   aDisplay := {}

   for nFor := 1 to nlen
      oCol := ::aCols[ nFor ]
      oCol:nPos := 0
      if oCol:oBtnList <> nil
         oCol:oBtnList:Hide()
      endif
      if oCol:oBtnElip <> nil
         oCol:oBtnElip:Hide()
      endif
   next

   nCol := 1

   while nFreeze > 0 .AND. nCol <= nLen
      oCol := ::aCols[ nCol ]
      if ! oCol:lHide
         AAdd( aDisplay, nCol )
         oCol:nPos := Len( aDisplay )
         nFreeze--
      endif
      nCol++
   enddo

   nCol := Max( nCol, nOffset )

   while nCol <= nLen
      oCol := ::aCols[ nCol ]
      if ! oCol:lHide
         AAdd( aDisplay, nCol )
         oCol:nPos := Len( aDisplay )
      endif
      nCol++
   enddo


   if Empty( aDisplay )
      ::aCols[ 1 ]:lHide   := .F.
      aDisplay             := { 1 }
   endif


   ::aDisplay := aDisplay

   ::nColSel  := Min( Len( ::aDisplay ), ::nColSel )

   if ::oHScroll <> nil
      nCols := 0
      for nFor := 1 to nlen
         oCol := ::aCols[ nFor ]
         if !oCol:lHide
            nCols++
         endif
      next
      ::oHScroll:SetRange( 1, Max( nCols, 2 ) )
   endif

return aDisplay



static FUNCTION TXBrowse_GetVisibleCols( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local aVisible
   local nFor, nLen, nCol

   aVisible := {}
   nLen     := Len( ::aCols )

   For nCol := 1 to nLen
      oCol := ::aCols[ nCol ]
      if !oCol:lHide
         Aadd( aVisible, oCol )
      endif
   Next

return aVisible



static FUNCTION TXBrowse_GetDisplayColsWidth( aSizes ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nWidth, nPos, nLen

   aSizes := {}
   nPos   := 1
   nLen   := Len( ::aDisplay )

   if ::lRecordSelector
      nWidth := ::nRecSelWidth
   else
      nWidth := 0
   endif

   for nPos := 1 to nLen
      nWidth += ::ColAtPos( nPos ):nWidth + 2
      Aadd(aSizes, ::ColAtPos( nPos ):nWidth )
   next

return nWidth



static FUNCTION TXBrowse_IsDisplayPosVisible( nPos, lComplete ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nWidth, nFor

   If( lComplete == nil, lComplete := .F., ) ;

   if nPos < 1 .OR. nPos > Len( ::aDisplay )
      return .F.
   endif

   if ::lRecordSelector
      nWidth := ::nRecSelWidth
   else
      nWidth := 0
   endif

   for nFor := 1 to nPos - 1
      nWidth += ::ColAtPos( nFor ):nWidth + 2
   next

   if lcomplete
      nWidth += ::ColAtPos( nPos ):nWidth + 2






   endif

return ( nWidth  < ::BrwWidth() )



static FUNCTION TXBrowse_LastDisplayPos( lComplete ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nWidth, nMaxWidth, nPos, nLen

   If( lComplete == nil, lComplete := .F., ) ;

   nPos      := 1
   nMaxWidth := ::BrwWidth()
   nLen      := Len( ::aDisplay )

   if ::lRecordSelector
      nWidth := ::nRecSelWidth
   else
      nWidth := 0
   endif

   while nPos <= nLen .AND. nWidth < nMaxWidth
      nWidth += ::ColAtPos( nPos++ ):nWidth + 2
   enddo

   nPos --

   if lComplete .AND. nWidth >= nMaxwidth
      nPos--
   endif

   nPos := Max( 1, nPos )










return nPos



static FUNCTION TXBrowse_ColStretch( nStretchCol ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aSizes, nDispWidth, nBrwWidth, oCol, nLen, n, o
   local nMaxWidth   := 0

   if ! ::lAdjusted
      return nil
   endif

   if ::aStretchInfo <> nil
      for n := 1 to Len( ::aCols )
         if ::aCols[ n ]:nCreationOrder == ::aStretchInfo[ 1 ]
            ::aCols[ n ]:nWidth  := ::aStretchInfo[ 2 ]
            exit
         endif
      next
      ::aStretchInfo := nil
   endif

   If( nStretchCol == nil, nStretchCol := ::nStretchCol, ) ;

   if nStretchCol <> nil
      nDispWidth  := ::GetDisplayColsWidth( @aSizes )
      nBrwWidth   := ::BrwWidth()

      if nDispWidth < nBrwWidth
         nLen        := Len( ::aDisplay )
         do case
         case ::nStretchCol > 0
            if ( n  := AScan( ::aDisplay, { |nCol| ::aCols[ nCol ]:nCreationOrder == ::nStretchCol } ) ) > 0
               oCol     := ::aCols[ ::aDisplay[ n ] ]
            endif
         case ::nStretchCol == -1
            oCol        := ::aCols[ ::aDisplay[ nLen ] ]
         case ::nStretchCol == -2
            for n := nLen to 1 step -1
               o        := ::aCols[ ::aDisplay[ n ] ]
               if o:cDataType <> nil .AND. o:cDataType $ "FMP"
                  oCol  := o
                  exit
               elseif o:cDataType == "C" .OR. o:cDataType == nil
                  if o:nWidth > nMaxWidth
                     nMaxWidth   := o:nWidth
                     oCol        := o
                  endif
               endif
            next
            if oCol == nil
               oCol     := ::aCols[ ::aDisplay[ nLen ] ]
            endif
         endcase
      endif

      if oCol <> nil
         ::aStretchInfo    := { oCol:nCreationOrder, oCol:nWidth }
         oCol:nWidth       += ( nBrwWidth - nDispWidth - 1 )

         if ! Empty( oCol:aRows )
            AEval( oCol:aRows, { |o| o:nWidth := oCol:nWidth } )
         endif

         ::GetDisplayCols()
      endif
   endif

return nil



static FUNCTION TXBrowse_KeyDown( nKey, nFlags ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol

   do case
   case nKey == 27
        if ::lEditMode
           oCol := ::SelectedCol()
           if oCol:oEditLbx <> nil
              oCol:oEditLbx:nLastKey = 27
           endif
           if oCol:oEditGet <> nil
              oCol:oEditGet:nLastKey := 27
           endif
           ::CancelEdit()
           return 0
        else
           return ::Super:KeyDown( nKey, nFlags )
        endif


   case nKey == 37  .AND. GetKeyState( 16 ) .OR.  nKey == 39 .AND. GetKeyState( 16 )
        return ::Super:KeyDown( nKey, nFlags )

     case nKey == 38 .AND. GetKeyState( 16 )
        ::Select( 5 )
        ::GoUp()
        ::Select( 5 )

     case nKey == 40 .AND. GetKeyState( 16 )
        ::Select( 5 )
        ::GoDown()
        ::Select( 5 )

   case nKey == 38
      if ::KeyNo == 1 .AND. ::lRelyOnKeyNo
         return 0
      endif
      ::Select( 0 )
      ::GoUp()
      ::Select( 1 )

   case nKey == 40
      if ::KeyNo == ::nLen .AND. Empty( ::bPastEof ) .AND. ::lRelyOnKeyNo
         return 0
      endif
      ::Select( 0 )
      ::GoDown()
      ::Select( 1 )

   case nKey == 37

      if GetKeyState( 17 )
         ::GoLeftMost()
      else
         ::GoLeft()
      endif

   case nKey == 39

      if GetKeyState( 17 )
         ::GoRightMost()
      else
         ::GoRight()
      endif

   case nKey == 36
         ::Select( 0 )
         ::GoTop()
         ::Select( 1 )

   case nKey == 35
         ::Select( 0 )
         ::GoBottom()
         ::Select( 1 )

   case nKey == 33
         ::Select( 0 )
         if GetKeyState( 17 )
            ::GoTop()
         else
            ::PageUp()
         endif
         ::Select( 1 )

   case nKey == 34
         ::Select( 0 )
         if GetKeyState( 17 )
            ::GoBottom()
         else
            ::PageDown()
         endif
         ::Select( 1 )

   case nKey == 107 .AND. GetKeyState( 17 )
         ::FontSize( +1 )
         ::Refresh()

   case nKey == 109 .AND. GetKeyState( 17 )
         ::FontSize( -1 )
         ::Refresh()

   case ::lAllowCopy .AND. nKey == ASC( "C" ) .AND. GetKeyState( 17 )
         ::Copy()

   case nKey == 113 .AND. ::lF2KeyToEdit .AND. ! ::lReadOnly
        if ! ::lEditMode
            WITH OBJECT ::SelectedCol()
               if ! :lReadOnly
                  :Edit()
               endif
            END
        endif

   otherwise

      return ::Super:KeyDown( nKey, nFlags )

   endcase

return 0



static FUNCTION TXBrowse_KeyChar( nKey, nFlags ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol, cKey, uRet
   local oClp, uClip

   oCol := ::SelectedCol()
   if oCol:lAutoSave
      if oCol:oEditGet <> nil
         oCol:oEditGet:SetFocus()
         return 0
      endif
   endif

   if ::bKeyChar <> nil
      uRet  := Eval( ::bKeyChar, @nKey, nFlags )
      if ::lEditMode
         return nil
      endif
      if ValType( uRet ) == "N" .AND. uRet == 0
         return 0
      endif
   endif

   do case















      case nKey == 13
         oCol := ::SelectedCol()
         if oCol:oEditGet <> nil
            PostMessage( oCol:oEditGet:hWnd, 256, nKey )
         elseif oCol:lEditable .AND. ! oCol:hChecked .AND. ::lEnterKey2Edit .AND. ! ( oCol:nEditType == 2 )
            return oCol:Edit()
         elseif oCol:nEditType == 2 .AND. oCol:lEditable

            PostMessage( oCol:oBtnList:hWnd, 513, 1, 1 )
            PostMessage( oCol:oBtnList:hWnd, 514, 1, 1 )
         elseif ::oTreeItem<>nil
            If( ::oTreeItem:oTree <> nil,( ::oTreeItem:Toggle(), ::Refresh() ),)
         else
            ::GoRight()
         endif

      case nKey == 18
         ::oVScroll:PageUp()

      case nKey == 3
         ::oVScroll:PageDown()

      case ::lCanPaste .AND. nKey == 22

         if ::SelectedCol():cDataType == "P"
            oClp := TClipBoard():New( Upper("BITMAP"), ::oWnd )
            uClip     := oClp:GetBitmap()
            if uClip <> 0 .AND. ::SelectedCol():nEditType > 0
               ::SelectedCol():VarPut( BmpToStr( uClip ) )
               oClp:Clear()
            endif
            oClp:End()
         endif

         oClp := TClipBoard():New( Upper("TEXT"), ::oWnd )
         uClip    := oClp:GetText()
         if ! Empty( uClip )
           oClp:Clear()
         endif
         oClp:End()
         if ! Empty( uClip )
            ::Paste( uClip )
         endif

      case ::lMultiSelect .AND. nKey == 1
         ::SelectAll()

      otherwise

         cKey := Chr( nKey )
         oCol := ::SelectedCol()

         if nKey == 32 .AND. ::nMarqueeStyle <= 3 .AND.  oCol:hChecked .AND. oCol:lEditable

            oCol:CheckToggle()



         elseif ( ::lFastEdit .OR. nKey == Asc( "=" ) ) .AND.  ( ::nMarqueeStyle <= 3 .OR. ::bClrRowFocus <> nil ) .AND.  oCol:lEditable .AND. oCol:IsEditKey( cKey )

            oCol:Edit( nKey )

         else
            If nKey == 8 .AND. !Empty( ::cSeek )
               ::Seek( Left( ::cSeek, Len( ::cSeek ) -1 ) )
            elseIf nKey > 31
               ::Seek( ::cSeek + cKey )
            Endif
         Endif
   endcase

return 0



static FUNCTION TXBrowse_HScroll( nWParam, nLParam ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nScrHandle  := nLParam
   local nScrollCode := nLoWord( nWParam )
   local nPos        := nHiWord( nWParam )

   if GetFocus() <> ::hWnd
      SetFocus( ::hWnd )
   endif

   do case
   case nScrollCode == 0
      ::GoLeft()

   case nScrollCode == 1
      ::GoRight()

   case nScrollCode == 2
      ::GoLeft( .T. )

   case nScrollCode == 3
      ::GoRight( .T. )

   case nScrollCode == 6
      ::GoLeftMost()

   case nScrollCode == 7
      ::GoRightMost()

   case nScrollCode == 4




      ::SelectCol( Min( nPos, Len( ::aCols ) ), .T. )

   otherwise
      return nil

   endcase

return 0



static FUNCTION TXBrowse_SelectCol( nCol, lOffset ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   If( lOffset == nil, lOffset := .F., ) ;

   if ::nMarqueeStyle == 0 .OR. ( ::nMarqueeStyle >= 5 .AND. ::bClrRowFocus == nil )
      lOffset := .T.
   endif

   ::CancelEdit()
   if ::oHScroll <> nil
      ::oHScroll:SetPos( nCol )
   endif

   If lOffset
      ::nColOffset := Max( nCol - ::nFreeze, 1 )
   else
      ::nColSel    := nCol
   Endif

   ::GetDisplayCols()
   ::nColSel := Min( ::nColSel, ::LastDisplayPos() )
   ::Super:Refresh( .T. )

return nil



static FUNCTION TXBrowse_GoToCol( oCol ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nPos, nCol

   oCol     := ::oCol( oCol )
   if oCol == nil .OR. oCol:lHide
      return .F.
   endif

   if oCol:nPos > 0
      if ::IsDisplayPosVisible( oCol:nPos, .T. )
         if ::nColSel <> oCol:nPos
            ::nColSel   := oCol:nPos
            ::RefreshCurrent()
         endif
         return .T.
      elseif oCol:nPos <= ::nFreeze + ::nColOffSet
         return .F.
      else

         while ! ::IsDisplayPosVisible( oCol:nPos, .T. ) .AND.  oCol:nPos > ::nFreeze + ::nColOffSet

            ::nColOffSet++
            ::GetDisplayCols()
         enddo
      endif
   else
      nCol  := AScan( ::GetVisibleCols(), { |o| o:nCreationOrder == oCol:nCreationOrder } )
      ::nColOffSet   := nCol - ::nFreeze
      ::GetDisplayCols()
   endif

   ::nColSel      := oCol:nPos
   ::Refresh()

return .T.



static FUNCTION TXBrowse_GoLeft( lOffset, lRefresh ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oFirstCol


   If( lOffset == nil, lOffset := .F., ) ; If( lRefresh == nil, lRefresh := .T., );

   ::CancelEdit()

   if ::nMarqueeStyle == 0  .OR. ( ::nMarqueeStyle >= 5 .AND. ::bClrRowFocus == nil )
      lOffset := .T.
   endif

   if ::lFreezeLikeExcel .AND. ::nFreeze > 0 .AND. ::nColOffSet > 1 .AND. ::nColSel == ::nFreeze + 1
      lOffset := .T.
   endif


   if ( !lOffset .AND. ::IsDisplayPosVisible( ::nColSel - 1 ) ) .OR.  ( ::nColOffset == 1 .AND. ::nColSel > 1 )
      ::nColSel--
      if lRefresh
         if ::FullPaint()
            ::Super:Refresh( .T. )
         else
            ::DrawLine( .T. )
         endif
      endif
   elseif ::nColOffset > 1
      ::nColOffset--
      ::GetDisplayCols()
      if lRefresh
         ::Super:Refresh( ::FullPaint() )
      endif
   endif

   if ::oHScroll <> nil
      ::oHScroll:GoUp()
   endif
   ::Change( .F. )

return nil



static FUNCTION TXBrowse_GoRight( lOffset, lRefresh ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol, oLastCol, oNextCol
   local nLen

   ::CancelEdit()

   oLastcol    := ::aCols[ ATail( ::aDisplay ) ]
   if ::SelectedCol():nCreationOrder == oLastCol:nCreationOrder
      return nil
   endif

   if ::nMarqueeStyle == 0 .OR. ( ::nMarqueeStyle >= 5 .AND. ::bClrRowFocus == nil )

   endif


   If( lOffset == nil, lOffset := .F., ) ; If( lRefresh == nil, lRefresh := .T., );

   nLen := Len( ::aDisplay )

   if lOffSet
      if ::IsDisplayPosVisible( oLastCol:nPos, .T. )
         ::nColSel++
         if lRefresh
            ::Super:Refresh( .T. )
         endif
      else
         if ::nColOffSet < ( nLen - ::nFreeze )
            ::nColOffSet++
            ::GetDisplayCols()
            if lRefresh
               ::Super:Refresh( ::FullPaint() )
            endif
         endif
      endif

   else
      ::nColSel++
      ::GetDisplayCols()
      oCol     := ::SelectedCol()
      while ! ::IsDisplayPosVisible( oCol:nPos, .T. ) .AND. ::nColSel > ( ::nFreeze + 1 )
          ::nColOffSet++
         ::nColSel--
         ::GetDisplayCols()
      enddo

      if lRefresh
         ::Super:Refresh( ::FullPaint() )
      endif

   endif


   if ::oHScroll <> nil
      ::oHScroll:GoDown()
   endif

   ::Change( .F. )

return nil





static FUNCTION TXBrowse_GoLeftMost( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   ::CancelEdit()

   ::nColSel := 1
   ::nColOffset := 1
   ::GetDisplayCols()
   ::Super:Refresh( ::FullPaint() )

   if ::oHScroll <> nil
      ::oHScroll:SetPos( 1 )
   endif

   ::Change( .F. )

return nil



static FUNCTION TXBrowse_GoRightMost( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oLast, nLast

   ::CancelEdit()

   nLast    := ATail( ::aDisplay )
   oLast    := ::aCols[ nLast ]

   while ! ::IsDisplayPosvisible( oLast:nPos, .T. ) .AND. ( ::nFreeze + ::nColOffSet ) < Len( ::aDisplay )
      ::nColOffSet++
      ::GetDisplayCols()
   enddo
   ::nColSel   := ::aCols[ nLast ]:nPos
   ::Super:Refresh( ::FullPaint() )

   if ::oHScroll <> nil
      ::oHScroll:SetPos( ::oHScroll:nMax )
   endif
   ::Change( .F. )

return nil



static FUNCTION TXBrowse_VScroll( nWParam, nLParam ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nScrHandle  := nLParam
   local nScrollCode := nLoWord( nWParam )
   local nPos        := nHiWord( nWParam )
   local nRow, nBook

   if GetFocus() <> ::hWnd
      SetFocus( ::hWnd )
   endif

   if nScrHandle == 0 .AND. ::oVScroll <> nil
      do case
      case nScrollCode == 0
         ::GoUp()

      case nScrollCode == 1
         ::GoDown()

      case nScrollCode == 2
         ::PageUp()

      case nScrollCode == 3
         ::PageDown()

      case nScrollCode == 6
         ::GoTop()

      case nScrollCode == 7
         ::GoBottom()


      case nScrollCode == 4 .OR. ( ::lVThumbTrack .AND.  nScrollCode == 5 )
         if ::nLen < 1
            return nil
         endif
         do case
         case nPos == 1
            ::GoTop()
         case nPos == ::oVScroll:GetRange()[ 2 ]
            ::GoBottom()
         otherwise
            ::CancelEdit()
            nRow := ::nRowSel
            CursorWait()
            Eval( ::bSkip, ::VGetThumbPos( nPos ) - ::VGetPos() )
            ::KeyNo( ::VGetThumbPos( nPos ) )
            CursorArrow()
            nBook := Eval( ::bBookMark )
            while nRow > 0 .AND. ::Skip( -1 ) == -1
               nRow--
            enddo
            ::nRowSel := ::nRowSel - nRow
            Eval( ::bBookMark, nBook )
            ::Change( .T. )
            ::VThumbPos( nPos )
            ::lRefreshOnlyData := .F.
            ::Super:Refresh( .F. )
         endcase

      otherwise
         return nil
      endcase
   endif

return 0



static FUNCTION TXBrowse_GoUp( nUp ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nHeight, n, oCol, nAt

   if ::nLen == 0 .OR. ::Bof()
      return nil
   endif

   ::CancelEdit()
   if !::FullPaint()
      ::DrawLine()
   endif
   ::Seek()

   If( nUp == nil, nUp := 1, ) ;

   if ( oCol := ::SelectedCol() ):lMergeVert
      nAt      := ::KeyNo()
      nUp      := oCol:aMerge[ nAt ][ 1 ] + 1
      if ( nAt - nUp ) > 0
         nUp   += oCol:aMerge[ nAt - nUp ][ 1 ]
      endif
   endif

   for n := 1 to nUp

      if ::Skip( -1 ) == -1

         if ::nRowSel > 1
            ::nRowSel--
         else
            if ! ::FullPaint()

               XBrwScrollRow( ::hWnd, -::nRowHeight, ::HeaderHeight(), ::RowCount() * ::nRowHeight )
               AIns( ::aBookMarks, 1 )
               ::aBookMarks[ 1 ]    := ::BookMark
               if n < nUp
                  ::DrawLine( .F. )
               endif

               nHeight := ::BrwHeight() - ::FooterHeight() - ::HeaderHeight()
               If nHeight % ::nRowHeight > 0

                  ::EraseData( ::HeaderHeight() + ::nRowHeight * ::RowCount() )
               Endif

            endif
            If ::nDataRows < ::RowCount()
               ::nDataRows++
            Endif

         endif
      else
         exit
      endif

   next

   if ! ::FullPaint()
      ::DrawLine( .T. )
   endif

   nUp   := n - 1

   if nUp > 0
      ::Change( .T. )
      if ::FullPaint()
         ::Super:Refresh( .T. )
      endif

      if ::oVScroll <> nil
         for n := 1 to nUp
            ::VGoUp()
         next
      endif
   endif

return nil



static FUNCTION TXBrowse_GoDown( nDown ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nLines, n, oCol, nAt

   if ::nLen == 0 .OR. ::Eof()
      if ::bPastEof <> nil
         Eval( ::bPastEof )
      endif

      return 0
   endif

   ::CancelEdit()
   ::Seek()

   If( nDown == nil, nDown := 1, ) ;

   if ( oCol := ::SelectedCol() ):lMergeVert
      nAt         := ::KeyNo()
      nDown       := oCol:aMerge[ nAt ][ 2 ] + 1
      if ( nAt + nDown ) < ::nLen
         nDown    += oCol:aMerge[ nAt + nDown ][ 2 ]
      endif
   endif

   nLines := ::RowCount()

   if ! ::FullPaint()
      ::DrawLine()
   endif

   for n := 1 to nDown

      if ::Skip( 1 ) == 1
         if ::nRowSel < nLines
            ::nRowSel++
         else

            if ! ::FullPaint()
               XBrwScrollRow( ::hWnd, ::nRowHeight, ::HeaderHeight(), nLines * ::nRowHeight )
               if !empty( ::aBookMarks )
                  adel( ::aBookMarks, 1 )
                  if ( ::nRowSel > 0 .AND. ::nRowSel < len( ::aBookMarks ) )
                     ::aBookMarks[ ::nRowSel ] := ::BookMark
                  end
               endif
               if n < nDown
                  ::DrawLine( .F. )
               endif
            endif

         endif
         if ::oVScroll <> nil
            ::VGoDown()
         endif
      else
         if ::bPastEof <> nil .AND. nDown == 1
            Eval( ::bPastEof )
         endif
         if ::oVScroll <> nil
            ::VGoBottom()
         endif
         exit
      endif

   next
   nDown    := n - 1

   if ! ::FullPaint()
      ::DrawLine( .T. )
   endif

   if nDown > 0
      ::Change( .T. )
      if ::FullPaint()
         ::Super:Refresh( .T. )
      endif
   endif

return nDown



static FUNCTION TXBrowse_PageUp( nLines ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nSkipped

   if ::nLen < 1
      return nil
   endif

   If( nLines == nil, nLines := ::RowCount(), ) ;

   ::CancelEdit()
   ::Seek()


   nSkipped = ::Skip( -nLines )

   if nSkipped = 0

      return nil
   endif

   if -nSkipped < nLines
      ::nRowSel = 1
      ::Change( .T. )

      ::Super:Refresh( ::FullPaint() )

      if ::oVScroll <> nil
         ::VGoTop()
      endif
   else
      if ::KeyNo() < ::nRowSel
         ::KeyNo( ::nRowSel )
      endif
      ::Change( .T. )

      ::Super:Refresh( ::FullPaint() )

      if ::oVScroll <> nil
         ::VSetPos( ::VGetPos() + nSkipped )
      endif
   endif

return nil



static FUNCTION TXBrowse_PageDown( nLines ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nSkipped

   if ::nLen < 1
      return nil
   endif

   If( nLines == nil, nLines := ::RowCount(), ) ;

   ::CancelEdit()
   ::Seek()

   nSkipped := ::Skip( nLines )
   if nSkipped > 0
      ::Change( .T. )
      if nSkipped < nLines
         ::Refresh()
         if ::oVScroll <> nil
            ::VGoBottom()
         endif
      else

         ::Refresh()
         if ::oVScroll <> nil
            ::VSetPos( ::VGetPos() + nSkipped )
         endif
      endif
   endif

return nil



static FUNCTION TXBrowse_GoTop( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   if ::Bof() .OR. ::nLen < 1
      return nil
   endif

   ::CancelEdit()
   ::Seek()

   Eval( ::bGoTop )

   if ::oVScroll <> nil
      ::VGoTop()
   endif

   ::nRowSel := 1
   ::Change( .T. )

   ::Super:Refresh( .F. )

return nil



static FUNCTION TXBrowse_GoBottom( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nLines, nRow, nBook

   ::CancelEdit()
   ::Seek()
   ::DrawLine()

   if ::Eof() .OR. ::nLen < 1
      ::DrawLine( .T. )
      return nil
   endif

   Eval( ::bGoBottom )
   if ::lRelyOnKeyNo
      ::nRowSel      := Max( 1, Min( ::nLen, ::RowCount() ) )
   else
      nBook          := ::BookMark
      ::nRowSel      := 1 - ::Skip( 1 - ::RowCount() )
      ::BookMark     := nBook
   endif

   if ::oVScroll <> nil
      ::VGoBottom()
   endif
   ::Change( .T. )
   ::Super:Refresh( .F. )

return nil



static FUNCTION TXBrowse_ColPos( oCol ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nAt

   nAt := Ascan( ::aDisplay, {|v| ::ColAtPos( v ):nCreationOrder == oCol:nCreationOrder } )

return nAt



static FUNCTION TXBrowse_MouseAtHeader( nRow, nCol ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

return ( ::MouseColPos( nCol ) > 0 .AND. nRow < ::HeaderHeight() )



static FUNCTION TXBrowse_MouseAtFooter( nRow, nCol ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

return ( ::MouseColPos( nCol ) > 0 .AND. nRow > ( ::BrwHeight() - ::FooterHeight() ) )



static FUNCTION TXBrowse_MouseRowPos( nRow ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nRowPos, nTmp

   if nRow <= ::HeaderHeight()
      return 0
   endif

   nTmp    := nRow - ::HeaderHeight()
   nRowPos := Int( nTmp / ::nRowHeight ) + 1

   if nRowPos > ::nDataRows
      nRowPos := 0
   endif

return nRowPos



static FUNCTION TXBrowse_MouseColPos( nCol ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nWidth, nColPos, nLen, nFor

   nColPos   := 0
   nLen      := ::LastDisplayPos()

   if ::lRecordSelector
      nWidth := ::nRecSelWidth
   else
      nWidth := 0
   endif

   if nCol < nWidth
      return -1
   endif

   if nCol > nWidth
      for nFor := 1 to nLen
         nWidth += ::ColAtPos( nFor ):nWidth + 2
         if ( nWidth - 2 ) > nCol
            nColPos := nFor
            exit
         endif
      next
   endif

return nColPos



static FUNCTION TXBrowse_SetPos( nRow, nCol, lPixel ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local lRepos   := .F.
   local bm, nSkip := 0

   If( lPixel == nil, lPixel := .F., ) ;

   if nRow == nil
      nRow        := ::nRowSel
   elseif lPixel
      nRow        := ::MouseRowPos( nRow )
   endif
   if nCol == nil
      nCol        := ::nColSel
   elseif lPixel
      ncol        := ::MouseColPos( nCol )
   endif


   if nCol > 0 .AND. nCol <= ::LastDisplayPos( .F. ) .AND.  nRow > 0 .AND. nRow <= ::RowCount()

      if ::nColSel <> nCol
         ::nColSel  := nCol
         lRepos      := .T.
      endif

      if nRow > 0 .AND. nRow <> ::nRowSel

         ::CancelEdit()
         ::Seek()

         if ::lMultiSelect
            ::Select(0)
         endif
         SysRefresh()
         ::DrawLine()

         bm          := Eval( ::bBookMark )
         nSkip     := nRow - ::nRowSel
         if ::Skip( nSkip ) == nSkip
            ::nRowSel := nRow
            ::Change( .T. )
            lRepos      := .T.
         else
            Eval( ::bBookMark, bm )
            nSkip := 0
         endif

         if ::lMultiSelect
            ::Select(1)
         endif

         if ::FullPaint()
            ::Super:Refresh( .T. )
         else
            ::DrawLine( .T. )
         endif
         ::Change( .T. )
      endif

      if nSkip <> 0 .AND. ::oVScroll <> nil
         ::VSetPos( ::KeyNo() )
      endif

      if ::oHScroll <> nil
         ::oHScroll:SetPos( ::nColSel )
      endif

   endif

return lRepos



static FUNCTION TXBrowse_LButtonDown( nRow, nCol, nFlags ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nRowPos, nColPos, nLen, nFor, nTmp, nPos
   local nRowPrev,nColPrev
   local nOldCol := ::nColSel

   ::nRowAdvance = ::MouseRowPos( nRow )
   ::nColAdvance = ::MouseColPos( nCol )
   ::nStartMRow  = ::nRowAdvance
   if ! ::lKinetic
      ::lKineticBrw  := .F.
   endif
   ::lPressed    = ::lKineticBrw .AND. ::bDragBegin == nil
   ::nStartTime  = GetTickCount()

   ::CancelEdit()
   ::Seek()

   ::SetFocus()

   if ::lDrag
      return ::Super:LButtonDown( nRow, nCol, nFlags )
   endif

   nRowPrev  := ::nRowSel
   nColPrev  := ::nColSel
   nRowPos   := 0
   nColPos   := 0
   nLen      := ::LastDisplayPos()

   for nFor := 1 to nLen
      oCol := ::ColAtPos( nFor )



      if oCol:lAllowSizing .AND.  nCol >= ( oCol:nDisplayCol + oCol:nWidth - 1 ) .AND.  nCol <= ( oCol:nDisplayCol + oCol:nWidth + 1 ) .AND.  ( ::nColDividerStyle > 0 .OR. nRow < ::HeaderHeight() )
         oCol:ResizeBeg( nRow, nCol, nFlags )
         return nil
      endif
   next

   nLen := ::nDataRows


   if ::lAllowRowSizing .AND. ::nRowDividerStyle > 0 .AND.  ( ::MouseColPos( nCol ) > 0 .OR. ::nMarqueeStyle >= 4 )
      for nFor := 1 to nLen
         nPos := ( nFor * ::nRowHeight ) + ::HeaderHeight()
         if nRow >= ( nPos - 1 ) .AND. nRow <= ( nPos + 1 )
            ::HorzLine( nRow, 1, nFor )
            return 0
         endif
      next
   endif

   nColPos := ::MouseColPos( nCol )

   if nColPos == 0 .AND. ::nMarqueeStyle < 4
      ::Super:LButtonDown( nRow, nCol, nFlags )
      return nil
   endif

   if nRow < ::HeaderHeight() .AND. nColPos > 0
      oCol := ::ColAtPos( nColPos )
      if oCol <> nil
         oCol:HeaderLButtonDown( nRow, nCol, nFlags )
      else
         ::Super:LButtonDown( nRow, nCol, nFlags )
      endif
      return nil
   elseif nRow > ( ::BrwHeight() - ::FooterHeight() ) .AND. nColPos > 0
      oCol := ::ColAtPos( nColPos )
      if oCol <> nil
         oCol:FooterLButtonDown( nRow, nCol, nFlags )
      else
         ::Super:LButtonDown( nRow, nCol, nFlags )
      endif
      return nil
   else
      nTmp    := nRow - ::HeaderHeight()
      nRowPos := Int( nTmp / ::nRowHeight ) + 1
      if nRowPos > ::nDataRows .OR. nRow < ::HeaderHeight()
         nRowPos := 0
      endif
      if nRowPos == 0
         ::Super:LButtonDown( nRow, nCol, nFlags )
         return nil
      endif
   endif

   if nRowPos > 0 .OR. nColPos > 0

      if ::nMarqueeStyle == 3
         if GetKeyState( 16 )
            ::nMarqueeStyle := 6
            ::aSelected := { Eval( ::bBookMark ) }
            ::nSaveMarq := 3
         endif
      endif
      if ::lMultiSelect
         if !GetKeyState( 17 ) .AND. !GetKeyState( 16 )
            ::Select( 0 )
         endif
      endif


      ::DrawLine()

      if nRowPos > 0
         ::Skip( nRowPos - ::nRowSel )
         ::nRowSel := nRowPos

      endif

      if nColPos > 0
         ::nColSel := nColPos
      endif

      if ::nRowSel <> nRowPrev
         ::Change( .T. )
      elseif ::nColSel <> nColPrev
         ::Change( .F. )
      endif

      if ::lMultiSelect
         do case
         case GetKeyState( 17 )
            ::Select( 2 )
         case GetKeyState( 16 )
             ::Select( 3 )
         otherwise
            ::Select( 1 )
         endcase
      endif

      if ::FullPaint()
         ::Super:Refresh( .T. )
      else
         ::DrawLine( .T. )
      endif

      if ::oVScroll <> nil
         ::VSetPos( ::KeyNo() )
      endif

      if ::oHScroll <> nil
         ::oHScroll:SetPos( ::nColSel )
      endif

   endif

   if ::MouseRowPos( nRow ) <> 0 .AND. ::MouseColPos( nCol ) <> 0
      ::Super:LButtonDown( nRow, nCol, nFlags )
   endif

return 0



static FUNCTION TXBrowse_LButtonUp( nRow, nCol, nFlags ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nCaptured
   local nRowAdvanced, nTimeScrolled, nVelocity, nRowToAdvance
   local nRatio, n, cMsg := ""

   if ::lDrag
      return ::Super:LButtonUp( nRow, nCol, nFlags )
   endif

   if ::lPressed
      ::lPressed    = .F.
      ::nEndMRow    = ::MouseRowPos( nRow )
      ::nEllapsed   = GetTickCount()

      nRowAdvanced  = ::nEndMRow - ::nStartMRow
      nTimeScrolled = ( ::nEllapsed - ::nStartTime ) / 4000
      nTimeScrolled = If( nTimeScrolled == 0, 1, nTimeScrolled )

      nVelocity     =  int( abs( nRowAdvanced ) / nTimeScrolled )

      if nVelocity > ::nMinVelocity
         nRowToAdvance = min( ::nMaxRowToAdvance, nVelocity * 0.125 )

         nRatio   = ( ::nStopRatio * ::nMaxRowToAdvance / nRowToAdvance )
         ::lMoved = .T.
         if nRowAdvanced > 0
            ::Skip( 1 - ::nRowSel )
            ::nRowSel = 1
         elseif nRowAdvanced < 0
            ::Skip( ::nDataRows - ::nRowSel )
            ::nRowSel   = Min( ::nLen, ::Rowcount() )
         endif
         for n = 1 to nRowToAdvance
            if ! ::lMoved
               exit
            endif
            if nRowAdvanced > 0
               ::GoUp()
               if ::KeyNo() == 1
                  exit
               endif
            elseif nRowAdvanced < 0
               ::GoDown()
               if ::KeyNo() >= ::nLen
                  exit
               endif
            endif
            ::Refresh()
            Sleep( Min( 120, n * nRatio ) )
            if PeekMessage( @cMsg, ::hWnd, 0x201, 0x202, 0x0001 )
               ::lPressed = .F.
               exit
            endif
            SysRefresh()
         next

      endif
      ::lMoved = .F.

      ::Refresh()
      ::nStartTime      = 0
      ::nStartMRow      = 0

   endif

   if ::nCaptured > 0
      nCaptured   := ::nCaptured
      ::nCaptured := 0
      ReleaseCapture()
      do case
         case nCaptured == 1
              ::oCapCol:HeaderLButtonUp( nRow, nCol, nFlags )

         case nCaptured == 2
              if ::oCapCol <> nil
                 ::oCapCol:FooterLButtonUp( nRow, nCol, nFlags )
              endif

         case nCaptured == 3
              ::oCapCol:ResizeEnd( nRow, nCol, nFlags )

         case nCaptured == 4
              ::HorzLine( nRow, 2 )
      endcase
      ::oCapCol := nil
   endif

   ::Super:LButtonUp( nRow, nCol, nFlags )

return nil



static FUNCTION TXBrowse_MouseLeave( nRow, nCol, nFlags ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   if ::lKineticBrw .AND. ::lPressed
      ::lPressed = .F.
      ::Refresh()
   endif

return nil



static FUNCTION TXBrowse_MouseMove( nRow, nCol, nKeyFlags ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nLen, nFor, nPos
   local cTxt
   local nVMove, nHMove, nOldRowPos,  nOldColPos
   local nMousePos := ::MouseRowPos( nRow )

   TrackMouseEvent( ::hWnd, 2 )

   if ::lDrag .OR. ::lEditMode
      return ::Super:MouseMove( nRow, nCol, nKeyFlags )
   endif

   if ::oCapCol <> nil
      ::oCapCol:MouseMove( nRow, nCol, nKeyFlags )
      return 0
   endif

   if ::nCaptured == 4
      ::HorzLine( nRow, 3 )
      return 0
   endif

   if ::lPressed

      TrackMouseEvent( ::hWnd, 2 )

      if ::nStartTime == 0
         ::nStartTime := GetTickCount()
      endif
   else
      ::nStartTime := 0
      ::nEllapsed := 0
   endif

   if ::lPressed .AND. ! ::lCaptured

      WSetCursor( ::hCursorHand )

      nVMove        = ::nRowAdvance - ::MouseRowPos( nRow )
      ::nRowAdvance = nMousePos
      nHMove        = ::MouseColPos( nCol ) - ::nColAdvance

      if nHMove < 0
         ::nColSel := ::LastDisplayPos( .T. )
         ::GoRight()
         ::nColSel := ::MouseColPos( nCol )
      elseif nHMove > 0
         ::nColSel := 1
         ::GoLeft()
         ::nColSel := ::MouseColPos( nCol )
      endif

      ::nColAdvance = ::MouseColPos( nCol )

      if nVMove > 0

         if ::lDown
            ::nStartMRow = nMousePos
            ::nStartTime := GetTickCount()
         endif
         nOldRowPos = ::nRowSel

         if ::cAlias == "ARRAY"
            ::nArrayAt += ( ::RowCount() - ::nRowSel )
         endif

         ::nRowSel =  ::RowCount()
         if ::cAlias == "ARRAY"
            ::lDrawSelected = .F.
            ::GoDown()
         endif
         ::Refresh()
         ::nRowSel = Max( 1, nOldRowPos - 1 )

         if ::cAlias == "ARRAY"
            ::nArrayAt-= ( ::RowCount() - ::nRowSel )
         else
            if ( ::nLen - ::RowCount() + ::nRowSel + 1)  <= ::KeyNo()
               ::Skip( -1 )
            endif
         endif

         ::lDrawSelected = .T.
         ::Refresh()
         ::lDown = .F.
      elseif nVMove < 0
         if ! ::lDown
            ::nStartMRow = nMousePos
            ::nStartTime := GetTickCount()
         endif
         nOldRowPos = ::nRowSel

         if ::cAlias == "ARRAY"
            ::nArrayAt -= ( ::RowCount() - ::nRowSel )
         endif

         ::nRowSel = 1
         if ::cAlias == "ARRAY"
            ::lDrawSelected = .F.
            ::GoUp()
         endif
         ::Refresh()
         ::nRowSel = nOldRowPos + 1
         if ::cAlias == "ARRAY"
            ::nArrayAt+= ( ::RowCount() - ::nRowSel )
         else
            if ( ::KeyNo() == ::nRowSel - 1)
               ::Skip( )
               ::nRowSel = ::KeyNo()
            endif
         endif

         ::lDrawSelected = .T.
         ::Refresh()
         ::lDown = .T.
      endif

      if ::nRowSel <> nMousePos
         ::nRowSel = nMousePos
      endif
      return nil

   endif

   nLen := ::LastDisplayPos()

   for nFor := 1 to nLen
      oCol := ::ColAtPos( nFor )



      if oCol:lAllowSizing .AND.  nCol >= ( oCol:nDisplayCol + oCol:nWidth - 1 ) .AND.  nCol <= ( oCol:nDisplayCol + oCol:nWidth + 1 ) .AND.  ( ::nColDividerStyle > 0 .OR. nRow < ::HeaderHeight() )
         CursorWE()
         return 0
      endif
   next

   nFor  := ::MouseColPos( nCol )
   if nFor > 0 .AND. nFor <= nLen

      CursorArrow()
      oCol     := ::ColAtPos( nFor )
      if ! Empty( ::oColToolTip )
         if nMousePos <> ::nRowToolTip .OR. oCol <> ::oColToolTip
            ::DestroyToolTip()
         endif
      endif
      if nRow < ::HeaderHeight()
         if ! Empty( oCol:cToolTip )
            ::ShowToolTip( nRow, nCol, oCol:cToolTip )
            ::oColToolTip     := oCol
            ::nRowToolTip     := 0

            return 0
         endif
      elseif nMousePos > 0
         if ::bDragBegin == nil .AND. ! Empty( oCol:bToolTip )
            if ! Empty( cTxt := Eval( oCol:bToolTip, Self, nRow, nCol, nkeyFlags, oCol, nMousePos ) )
               ::ShowToolTip( nRow, nCol, cTxt )
               ::oColToolTip  := oCol
               ::nRowToolTip  := nMousePos

               return 0
            endif
         endif
      else
         if ::oColToolTip <> nil
            ::DestroyToolTip()
         endif
         ::CheckToolTip()
      endif
   endif



















































   nLen := ::nDataRows


   if ::lAllowRowSizing .AND. ::nRowDividerStyle > 0 .AND.  ( ::MouseColPos( nCol ) > 0 .OR. ::nMarqueeStyle >= 4 )
      for nFor := 1 to nLen
         nPos := ( nFor * ::nRowHeight ) + ::HeaderHeight()
         if nRow >= ( nPos - 1 ) .AND. nRow <= ( nPos + 1 )
            CursorNS()
            return 0
         endif
      next
   endif

   ::Super:MouseMove( nRow, nCol, nKeyFlags )

return 0



static FUNCTION TXBrowse_LDblClick( nRow, nCol, nKeyFlags ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nColPos, nRowPos

   ::CancelEdit()
   ::Seek()

   nColPos := ::MouseColPos( nCol )
   nRowPos := ::MouseRowPos( nRow )

   if nColPos == ::nColSel .AND. nRowPos == ::nRowSel
      oCol := ::ColAtPos( nColPos )

      if oCol:lEditable .AND. oCol:bLDClickData == nil
         if oCol:hChecked .AND. oCol:bOnPostEdit <> nil

            oCol:CheckToggle()
            return 0
         else
            return oCol:Edit()
         endif
      elseif oCol:bLDClickData <> nil
         return Eval( oCol:bLDClickData, nRow, nCol, nKeyFlags, oCol )
      elseif ValType( oCol:Value ) $ "AHO"

         return XBrowse( oCol:Value, oCol:cHeader, nil, nil, nil, nil, nil,  oCol:nEditType > 0 )
      endif

   endif

   if nColPos <> 0 .AND. nRowPos <> 0
      return ::Super:LDblClick( nRow, nCol, nKeyFlags )
   Endif

return 0



static FUNCTION TXBrowse_RButtonDown( nRow, nCol, nKeyFlags ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nColPos, nRowPos
   local bPopUp

   ::CancelEdit()
   ::Seek()

   nRowPos := ::MouseRowPos( nRow )
   nColPos := ::MouseColPos( nCol )

   if nColPos <= 0
      if nRow >= ::FirstRow()
         ::Super:RButtonDown( nRow, nCol, nKeyFlags )
         return nil
      else
         if ::lAllowColHiding
            ::SetColumns( nRow, nCol, nKeyFlags )
         endif
         return nil
      endif
   endif

   oCol     := ::ColAtPos( nColPos )
   bPopUp   := ifnil( oCol:bPopUp, ::bPopUp )

   if ::MouseAtHeader( nRow, nCol )
      if oCol:bRClickHeader <> nil
         return Eval( oCol:bRClickHeader, nRow, nCol, nKeyFlags, oCol )
      elseif ::lAllowColHiding
         return ::SetColumns( nRow, nCol, nKeyFlags )
      endif
   elseif ::MouseAtFooter( nRow, nCol )
      if oCol:bRClickFooter <> nil
         return Eval( oCol:bRClickFooter, nRow, nCol, nKeyFlags, oCol )
      endif
   elseif nRowPos > 0
      if nRowPos <> ::nRowSel
         if ! ::FullPaint()
            ::DrawLine()
         endif
         ::Skip( nRowPos - ::nRowSel )
         ::nRowSel := nRowPos
         if nColPos > 0
            ::nColSel   := nColPos
         endif
         ::Change( .T. )
      elseif nColPos > 0 .AND. ::nColSel <> nColPos
         ::nColSel := nColPos
         ::Change( .F. )
      endif
      if Len( ::aSelected ) > 0 .AND. AScan( ::aSelected, ::BookMark ) == 0
         ::Select( 0 )
         ::Select( 1 )
      endif
      if ::FullPaint()
         ::Super:Refresh( .T. )
      else
         ::DrawLine( .T. )
      endif
      if ::oVScroll <> nil
         ::VSetPos( ::KeyNo() )
      endif
      if ::oHScroll <> nil
         ::oHScroll:SetPos( ::nColSel )
      endif
      if bPopUp <> nil
         Eval( bPopUp, oCol ):Activate( (::nRowSel * ::nRowHeight) + ::nHeaderHeight, oCol:nDisplayCol, Self )
         return 0
      elseif oCol:bRClickData <> nil
         return Eval( oCol:bRClickData, nRow, nCol, nKeyFlags, oCol )
      endif
   else
      return ::Super:RButtonDown( nRow, nCol, nKeyFlags )
   endif

   If nColPos <> 0 .AND. nRowPos <> 0
      return ::Super:RButtonDown( nRow, nCol, nKeyFlags )
   endif

return 0



static FUNCTION TXBrowse_MouseWheel( nKeys, nDelta, nXPos, nYPos ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aPoint := { nYPos, nXPos }

   ScreenToClient( ::hWnd, aPoint )


   if IsOverWnd( ::hWnd, aPoint[ 1 ], aPoint[ 2 ] ) .AND.  ::MouseRowPos( aPoint[ 1 ] ) > 0

      if lAnd( nKeys, 0x0010 )
         if nDelta > 0
            ::PageUp()
         else
            ::PageDown()
         endif
      else
         if nDelta > 0
            ::GoUp( WheelScroll() )
         else
            ::GoDown( WheelScroll() )
         endif
      endif

   endif

Return nil



static FUNCTION TXBrowse_HorzLine( nRow, nOperation, nLine ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   static sLine := 0, sRow := 0

   local hDC, nTop

   if nLine <> nil
      sLine := nLine
   endif

   do case
   case nOperation == 1
      ::nCaptured = 4
      ::Capture()
      sRow := nRow
      InvertRect( ::GetDC(), { nRow - 1, 0 , nRow + 1, ::BrwWidth() } )
      ::ReleaseDC()

   case nOperation == 2
      nTop := ( sLine * ::nRowHeight ) + ::HeaderHeight()
      InvertRect( ::GetDC(), { sRow - 1, 0 , sRow + 1, ::BrwWidth() } )
      ::ReleaseDC()
      if Abs( nRow - nTop ) > 2
         nTop := ( ( sLine - 1 ) * ::nRowHeight ) + ::HeaderHeight()
         ::nRowHeight := Min( Max( nRow - nTop, 20 ), ::BrwHeight() - nTop - 20 )
         ::Super:Refresh()
      endif

   case nOperation == 3
      nTop := ( ( sLine - 1 ) * ::nRowHeight ) + ::HeaderHeight() + 20
      CursorNS()
      if nRow > nTop .AND. nRow < (::BrwHeight() - 20 )
         hDC := ::GetDC()
         InvertRect( hDC, { sRow - 1, 0 , sRow + 1, ::BrwWidth() } )
         sRow := nRow
         InvertRect( hDC, { sRow - 1, 0 , sRow + 1, ::BrwWidth() } )
         ::ReleaseDC()
      endif

   endcase

return nil



static FUNCTION TXBrowse_GetDlgCode( nLastKey ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse




   if ! ::oWnd:lValidating

      if nLastKey == 38 .OR. nLastKey == 40  .OR. nLastKey == 13 .OR. nLastKey == 9
         ::oWnd:nLastKey = nLastKey
      else
         ::oWnd:nLastKey = 0
      endif
   endif

return If( IsWindowEnabled( ::hWnd ), 4, 0 )



static FUNCTION TXBrowse_SetRDD( lAddColumns, lAutoOrder, aFldNames, aRows ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol, aStruct
   local cAlias, cAdsKeyNo, cAdsKeyCount
   local nFields, nFor, n, uData
   local bOnSkip

   if Empty( ::cAlias )
      ::cAlias := Alias()
      if Empty( ::cAlias )
         return nil
      endif
   endif

   if ::lCreated
      if ::nDataType == 1
         if SameDbfStruct( Self, Alias() )
            return nil
         endif
      endif
      ::cAlias := Alias()
      ::ClearBlocks()
      ::aCols  := {}
   endif

   If( lAddColumns == nil, lAddColumns := Empty( ::aCols ) .OR. ! Empty( aFldNames ), ) ;
   If( lAutoOrder == nil, lAutoOrder := ::lAutoSort, ) ;
   ::lAutoSort              := lAutoOrder

   cAlias      := ::cAlias
   if ValType( aRows ) == "A" .AND. Len( aRows ) > 0

      if ValType( aRows[ 1 ] ) == "A"
         bOnSkip        := { | oBrw | ( oBrw:cAlias )->( DbGoTo( oBrw:aArrayData[ oBrw:nArrayAt ][ 1 ] ) ) }
      else
         bOnSkip        := { | oBrw | ( oBrw:cAlias )->( DbGoTo( oBrw:aArrayData[ oBrw:nArrayAt ] ) ) }
      endif
      ::SetArray( aRows, .F., 0, .F., bOnSkip )
      ::nDataType       := nOr( 1, 2 )
      lAutoOrder        := .F.
   else
      ::nDataType := 1
   endif

   ::lSqlRDD := ( ( ::cAlias )->( RddName() ) == "SQLRDD" )
   if ::lSqlRDD
      If( ::bKeyNo == nil, ::bKeyNo := { |n| 0 }, ) ;
   endif









   If( ::bGoTop == nil, ::bGoTop := {|| ( ::cAlias )->( DbGoTop() ) }, ) ; If( ::bGoBottom == nil, ::bGoBottom := {|| ( ::cAlias )->( DbGoBottom() ) }, ); If( ::bSkip == nil, ::bSkip := {| n | ( ::cAlias )->( __DbSkipper( IfNil( n, 1 ) ) ) }, ); If( ::bBof == nil, ::bBof := {|| ( ::cAlias )->( Bof() ) }, ); If( ::bEof == nil, ::bEof := {|| ( ::cAlias )->( Eof() ) }, ); If( ::bBookMark == nil, ::bBookMark := {| n | iif( n == nil, ( ::cAlias )->( RecNo() ), ( ::cAlias )->( DbGoto( n ) ) ) }, );


   If ( "ADS"$( ::cAlias )->( RddName() ) .OR. "ADT" $ ( ::cAlias )->( RddName() ) ) .AND.  ( ::cAlias )->( LastRec() ) > 200









      cAdsKeyNo    := "{| n, Self | iif( n == nil, " + "Round( " + cAlias + "->( ADSGetRelKeyPos() ) * Self:nLen, 0 ), "+ cAlias + "->( ADSSetRelKeyPos( n / Self:nLen ) ) ) }"

      cAdsKeyCount := "{|| " + cAlias + "->( ADSKeyCount(,,1) )}"


      If( ::bKeyNo == nil, ::bKeyNo := &cAdsKeyNo, ) ; If( ::bKeyCount == nil, ::bKeyCount := &cAdsKeyCount, );

      ::lRelyOnKeyNo      := .F.
   else




       If( ::bKeyNo == nil, ::bKeyNo := {| n | iif( n == nil, ( ::cAlias )->( OrdKeyNo() ), ( ::cAlias )->( OrdKeyGoto( n ) ) ) }, ) ; If( ::bKeyCount == nil, ::bKeyCount := {|| ( ::cAlias )->( If( eof() .AND. bof(), 0, OrdKeyCount() ) ) }, );

      ::lRelyOnKeyNo := If( Set( 11 ), "DELETED()" $ Upper( DbFilter() ), .T. )
   Endif
   if ::lSqlRDD
      ::lRelyOnKeyNo    := .F.
   endif

   ::lReadOnly    := ( ( ::cAlias )->( DbInfo( 129 ) ) == .T. )
   aStruct        := ( ::cAlias )->( dbstruct() )

   if lAddColumns
      if Empty( aFldNames )
         aFldNames   := { "*" }
      endif
      for each uData in aFldNames
         if ValType( uData ) == "C" .AND. uData == "*"
            for nFor := 1 to ( ::cAlias )->( FCount() )
               ( ::cAlias )->( SetColFromRDD( ::AddCol(), nFor ) )
            next
         else
            ( ::cAlias )->( SetColFromRDD( ::AddCol(), uData, aStruct ) )
         endif
      next
   endif

   (::cAlias)->( OrderTagInfo( aStruct, 8 ) )

   for nFor := 1 to Len( ::aCols )
      if ( n := AScan( aStruct, { |a| a[ 1 ] == Upper( ::aCols[ nFor ]:cHeader ) } ) ) > 0
         ::aCols[ nFor ]:cSortOrder    := aStruct[ n ][ 8 ]
         ::aCols[ nFor ]:cOrdBag       := ( cAlias )->( OrdBagName( ::aCols[ nFor ]:cSortOrder ) )
      endif
   next

   If( ::bSeek == nil, ::bSeek := { |c,u| ( ::cAlias )->( ::RddIncrSeek( c, @u ) ) }, ) ;

   if ( ::cAlias )->( DbInfo( 36 ) )
      ::bLock     := { || ( ::cAlias )->( DbrLock() ) }
      ::bUnlock   := { || ( ::cAlias )->( DbrUnlock() ) }
   endif



   ::bDelete   := { || ( ::cAlias )->( If( ::nLen > 0 .AND. Eval( ::bLock ), ( DbDelete(), Eval( ::bUnlock ),  If( Set( 11 ), ( DbSkip(1), If( Eof(), DbGoBottom(), nil ) ), nil )  ), nil ) ) }

   if ::lCreated
      ::Adjust()
      ::Refresh()
   endif

return nil



static FUNCTION TXBrowse_SetArray( aData, lAutoOrder, nColOrder, aCols, bOnSkip ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nFor, lAddCols, aWidths
   local lReset   := .F.

   if aData == nil
      return nil
   endif

   if ::lCreated
      if ::nDataType == 2
         ::aArrayData   := aData
         lReset         := .T.
      else
         ::ClearBlocks()
         if !empty( ::aCols )
            ::bBof   := ::bEof := NIL
            ::bKeyCount := ::bKeyNo := ::bBookMark := NIL
            if valtype( ::aArrayData ) == "U"
               aCols := .F.
            endif
         else
            ::aCols  := {}
         endif
         lReset   := .T.
      endif
   endif

   If( lAutoOrder == nil, lAutoOrder := ::lAutosort, ) ;
   ::lAutosort  := lAutoOrder

   ::nRowSel    := 1
   ::nArrayAt   := 1
   ::aArrayData := aData
   if ValType( bOnSkip ) == "B"
      ::bOnSkip   := bOnSkip
   endif
   ::nDataType  := 2















   If( ::bGoTop == nil, ::bGoTop := { || ::nArrayAt := Min( 1, Eval( ::bKeyCount ) ), Eval( ::bOnSkip, Self ) }, ) ; If( ::bGoBottom == nil, ::bGoBottom := { || ::nArrayAt := Eval( ::bKeyCount ), Eval( ::bOnSkip, Self ) }, ); If( ::bSkip == nil, ::bSkip := { | nSkip, nOld |  If( nSkip == nil, nSkip := 1, ),  nOld       := ::nArrayAt,  ::nArrayAt += nSkip,  ::nArrayAt := Min( Max( ::nArrayAt, 1 ), Eval( ::bKeyCount ) ),  Eval( ::bOnSkip, Self ),  ::nArrayAt - nOld }, ); If( ::bBof == nil, ::bBof := { || ::nArrayAt < 1 }, ); If( ::bEof == nil, ::bEof := { || ::nArrayAt > Eval( ::bKeyCount ) }, ); If( ::bBookMark == nil, ::bBookMark := { | n | If( n == nil, ::nArrayAt,  ( ::nArrayAt := n, Eval( ::bOnSkip, Self ), n ) ) }, ); If( ::bKeyNo == nil, ::bKeyNo := ::bBookMark, ); If( ::bKeyCount == nil, ::bKeyCount := { || Len( ::aArrayData ) }, );

   lAddCols := Empty( ::aCols )
   if ValType( aCols ) == "L"
      lAddCols       := aCols
      aCols          := nil
   endif

   if ValType( ::aArrayData ) == "H" .AND. Empty( ::aCols ) .AND. lAddCols

      WITH OBJECT ::AddCol()
         :cHeader    := "Key"
         :bEditValue := { || hb_hKeyAt( ::aArrayData, ::nArrayAt ) }
      END

      WITH OBJECT ::AddCol()
         :cHeader    := "Value"
         :bEditValue := { || hb_hValueAt( ::aArrayData, ::nArrayAt ) }
      END
      ::bSeek        := nil
      lAddCols       := .F.

   else

      if Len( aData ) > 0 .AND. ValType( aData ) == "H" .AND. ValType( ATail( aData ) ) == "H" .AND. lAddCols

         AEval( aData, { |h| hb_hCaseMatch( h, .F. ) } )

         if Empty( aCols )
            for nFor := 1 to Len( aData[ 1 ] )
               WITH OBJECT ::AddCol()
                  :cHeader    := hb_hKeyAt( aData[ 1 ], nFor )
                  :bEditValue := HashEditBlock( Self, :cHeader )
               END
            next
         else
            for nFor := 1 to Len( aCols )
               WITH OBJECT ::AddCol()
                  :cHeader := aCols[ nFor ]
                  :bEditValue := HashEditBlock( Self, :cHeader )
               END
            next
         endif

         lAddCols := .F.
      endif

   endif

   if lAddCols
      ::aCols := {}
      if Empty( aData )
         If( aCols == nil, aCols := { 1 }, ) ;
      endif
      aWidths  := ArrCalcWidths( aData, aCols )
      if Empty( aCols )
         for nFor := 1 to Len( aWidths )
            oCol                 := ::AddCol()
            oCol:nArrayCol       := nFor
            oCol:nDataLen        := aWidths[ nFor ]
         next
      else
         for nFor := 1 to Len( aCols )
            oCol               := ::AddCol()
            if ValType( aCols[ nFor ] ) == "N"
               oCol:nArrayCol     := aCols[ nFor ]
               oCol:nDataLen      := aWidths[ oCol:nArrayCol ]
            else
               oCol:nArrayCol    := 0
               oCol:cSortOrder   := 1
               if ValType( aCols[ nFor ] ) == "B"
                  oCol:bEditValue   := aCols[ nFor ]
               else
                  oCol:bEditValue   := &( "{ |x,oCol| " + cValToChar( aCols[ nFor ] ) + " }" )
               endif
            endif
         next
      endif

      AEval( ::aCols, {| oCol, i | oCol:cHeader := MakeColAlphabet( i ),  oCol:nHeadStrAlign := 2 } )

         if Len( ::aCols ) > 1

            If( nColOrder == nil, nColOrder := ::aCols[ 1 ]:nArrayCol, ) ;
            if Empty( nColOrder )
               nColOrder      := 1
            endif
            if lAutoOrder




               AEval( ::aCols, {|oCol| oCol:cSortOrder := oCol:nArrayCol,  If( oCol:nArrayCol == nColOrder,  (oCol:cOrder := "D", oCol:SortArrayData() ),  nil )  } )
            endif
         else
            oCol:cOrder := "D"
            oCol:cSortOrder := 1
            if lAutoOrder
               oCol:SortArrayData()
            endif
         endif
         ::nArrayAt  := 1

   endif


      ::bSeek := { | c,u | ::ArrayIncrSeek( c, @u ) }


   if lReSet .AND. ::lCreated
      ::Adjust()
      ::Refresh()
   endif

   ::lExcelCellWise  := .T.
   ::lVThumbTrack    := .T.


   ::bDelete         := { || If( ::nLen < 1, nil,   ( hb_ADel( ::aArrayData, ::nArrayAt, .T. ),  ::nArrayAt := Min( ::nArrayAt, Len( ::aArrayData ) ) ) ) }

return Self



static function HashEditBlock( oBrw, c )
return { |x| If( x == nil, oBrw:aRow[ c ], oBrw:aRow[ c ] := x ) }



static function ArrCalcWidths( aData, aCols )

   local aSizes
   local nRow, nCol, nRows, cType, n, uVal, aRow, nCols := 1

   if ! Empty( aCols )
      AEval( aCols, { |n| If( ValType( n ) == "N", nCols := Max( nCols, n ), nil ) } )
   endif

   nRows       := Len( aData )
   aSizes      := Array( nCols )

   if nRows > 0
      for nRow := 1 to nRows
         aRow  := aData[ nRow ]
         if ValType( aRow ) <> "A"
            aRow  := { aRow }
         endif
         nCols   := Len( aRow )
         if nCols > Len( aSizes )
            ASize( aSizes, nCols )
         endif
         nCols   := Min( Len( aRow ), nCols )
         for nCol := 1 to nCols
            uVal  := aRow[ nCol ]
            cType := ValType( uVal )
            if cType == "C"
               if ( n := Len( Trim( uVal ) ) ) > IfNil( aSizes[ nCol ], 0 )
                  aSizes[ nCol ] := n
               endif
            elseif cType $ "DLNT"
               if ( n := Len( cValToStr( uVal ) ) ) > IfNil( aSizes[ nCol ], 0 )
                  aSizes[ nCol ] := n
               endif

            endif
         next
      next
   endif

   for n := 1 to Len( aSizes )
      if aSizes[ n ] == nil
         aSizes[ n ] := 10
      endif
   next

return aSizes



static FUNCTION TXBrowse_ArrCell( nRow, nCol, cPic, lDispZeros ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local uVal






   if nRow > 0 .AND. nRow <= Len( ::aArrayData )
      uVal  := ::aArrayData[ nRow ]
   else
      uVal  := {}
   endif

   if nCol <> nil
      if ValType( uVal ) == "A"
         if nCol > 0 .AND. nCol <= Len( uVal )
            uVal  := uVal[ nCol ]
         else
            uVal  := nil
         endif
      elseif !( nCol == 1 )
         uVal  := nil
      endif
   endif
   if PCount() > 2
      if uVal == nil
         uVal  := ""
      else
         uVal  := cValToStr( uVal, cPic,, IfNil( lDispZeros, ::lDisplayZeros ) )
      endif
   endif

return uVal



static FUNCTION TXBrowse_ArrCellSet( nRow, nCol, uNewVal ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local uRow

   if nRow > 0 .AND. nRow <= Len( ::aArrayData )
      uRow  := ::aArrayData[ nRow ]
      if ValType( uRow ) == "A"
         if nCol > 0
           if nCol > Len( uRow )
              ASize( uRow, nCol )
           endif
           ::aArrayData[ nRow, nCol ] := uNewVal
         endif
      elseif nCol > 1
         ::aArrayData[ nRow ] := ASize( { uRow }, nCol )
         ::aArrayData[ nRow, nCol ] := uNewVal
      else
         ::aArrayData[ nRow ] := uNewVal
      endif
   endif

return ::ArrCell( nRow, nCol )



static FUNCTION TXBrowse_SetExcelRange( oRange, lHeaders, aCols ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oHead
   local nCols, n

   ::oRs       := oRange
   ::nArrayAt  := 1
   ::nDataType := 128
   nCols       := ::oRs:Columns:Count

   if Empty( aCols )
      aCols    := {}
      for n := 1 to nCols
         AAdd( aCols, n )
      next
   endif

   If( lHeaders == nil, lHeaders := .F., ) ;
   if lHeaders
      oHead    := ::oRs:Rows( 1 )
      ::oRs    := ::oRs:OffSet( 1, 0 ):Resize( ::oRs:Rows:Count - 1 )
   endif

   ::bKeyCount  := { || ::oRs:Rows:Count }
   ::bGoTop     := { || ::nArrayAt := 1 }
   ::bGoBottom  := { || ::nArrayAt := ::oRs:Rows:Count }



   ::bSkip      := { |nSkip,nOld| If( nSkip == nil, nSkip := 1, nil ),  nOld := ::nArrayAt, ::nArrayAt += nSkip,  ::nArrayAt := Min( Max( 1, ::nArrayAt ), ::oRs:Rows:Count ),  ::nArrayAt - nOld }
   ::bBof       := { || ::nArrayAt < 1 }
   ::bEof       := { || ::nArrayAt > ::oRs:Rows:Count }
   ::bBookMark  := { |n| If( n == nil, ::nArrayAt, ::nArrayAt := n ) }
   ::bKeyNo     := ::bBookMark

   for n := 1 to Len( aCols )
      WITH OBJECT ::AddCol()
         if oHead == nil
            :cHeader   := Chr( aCols[ n ] + 64 )
         else
            :cHeader   := cValToChar( oHead:Cells( 1, aCols[ n ] ):Value )
         endif
         :nArrayCol    := aCols[ n ]
         :bEditValue    := ExcelColBlock( Self, aCols[ n ] )
      END
   next

return Self



static function ExcelColBlock( oBrw, nCol )


return { |x| If( x == nil, oBrw:oRs:Cells( oBrw:nArrayAt, nCol ):Value,  oBrw:oRs:Cells( oBrw:nArrayAt, nCol ):Value := x ) }



static FUNCTION TXBrowse_SetAdo( oRs, lAddCols, lAutoOrder, aFldNames ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nFields,nFor, oCol, aRsColNames
   local lJet  := .F.

   if ::lCreated
      if ::nDataType == 2
         if SameAdoStruct( Self, oRs )
            return nil
         else
            ::aCols  := {}
         endif
      else
         ::ClearBlocks()
         ::aCols  := {}
      endif
   endif

   ::oRs    := oRs












   If( ::bGoTop == nil, ::bGoTop := {|| If( ::oRs:RecordCount() > 0, ::oRs:MoveFirst(), nil ) }, ) ; If( ::bGoBottom == nil, ::bGoBottom := {|| If( ::oRs:RecordCount() > 0, ::oRs:MoveLast(), nil )  }, ); If( ::bSkip == nil, ::bSkip := {| n | AdoSkip( ::oRs, IfNil( n, 1 ) ) }, ); If( ::bBof == nil, ::bBof := {|| ::oRs:Bof }, ); If( ::bEof == nil, ::bEof := {|| ::oRs:Eof }, ); If( ::bBookMark == nil, ::bBookMark := {| n | If( n == nil, If( ::oRs:RecordCount() > 0, ::oRs:BookMark, 0 ),  If( ::oRs:RecordCount() > 0, ( ::oRs:BookMark := n ), 0 ) ) }, ); If( ::bKeyNo == nil, ::bKeyNo := {| n | If( n == nil,  If( ::oRs:RecordCount() > 0, ::oRs:AbsolutePosition, 0 ),  If( ::oRs:RecordCount() > 0, ( ::oRs:AbsolutePosition := n ), 0 ) ) }, ); If( ::bKeyCount == nil, ::bKeyCount := {|| ::oRs:RecordCount() }, );

   If( lAddCols == nil, lAddCols := Empty( ::aCols ) .OR. ! Empty( aFldNames ), ) ;
   If( lAutoOrder == nil, lAutoOrder := ::lAutoSort, ) ;
   ::lAutosort        := lAutoOrder

   ::nDataType       := 4
   ::lReadOnly       := ( ::oRs:LockType < 2 )
   if ::lReadOnly
      ::lRsCanResync := .F.
   else
      BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
         ::oRs:Resync( 1, 1 )
         ::oRs:Resync( 1, 2 )
         ::lRsCanResync    := .T.
      RECOVER
         ::lRsCanResync    := .F.
      END
   endif

   BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
      lJet  := " JET" $ Upper( oRs:ActiveConnection:Properties( "DBMS Name" ):Value )
   RECOVER
   END


   aRsColNames    := {}
   for nFor := 0 to oRs:Fields:Count - 1
      AAdd( aRsColNames, Upper( oRs:Fields( nFor ):Name ) )
   next
   ASort( aRsColNames,,,{ |x,y| Len( x ) > Len( y ) } )

   if lAddCols
      if aFldNames == nil
         nFields := oRs:Fields:Count - 1
         for nFor := 0 to nFields
            ::SetColFromADO( nFor, lAutoOrder, aRsColNames, lJet )
         next
      else
         nFields := Len( aFldnames )
         for nFor := 1 to nFields
            oCol  := ::SetColFromADO( aFldNames[ nFor ], lAutoOrder, aRsColNames, lJet )
            if Empty( oCol:cHeader )
               oCol:cHeader   := "Col-" + LTrim( Str( nFor ) )
            endif
         next
      endif
   endif

   if ::oRs:LockType > 1 .AND. ::oRs:LockType < 4
      ::bSaveData    := { || XbrAdoSave( Self ) }
   endif
   ::bDelete      := { || XbrAdoDelete( Self ) }
   ::bSeek        := { |c| ::AdoIncrSeek( c ) }
   ::lVThumbTrack := .T.

   if ::lCreated
      ::Adjust()
      ::Refresh()
   endif

return Self



static FUNCTION TXBrowse_SetMySql( oMysql, lAddCols, lAutoOrder, aFldNames ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse
   LOCAL xField    := NIL
   LOCAL cHeader   := ""
   LOCAL cCol      := ""

   If( oMysql == nil, oMysql := ::oMysql, ) ;
   If( aFldNames == nil, aFldNames := {}, ) ;
   If( lAddCols == nil, lAddCols := Empty( ::aCols ) .OR. ! Empty( aFldNames ), ) ;
   If( lAutoOrder == nil, lAutoOrder := ::lAutoSort, ) ;
   ::lAutoSort         := lAutoOrder

   ::oMysql            := oMysql















   If( ::bGoTop == nil, ::bGoTop := {|| If( ::oMysql:RecCount() > 0, ::oMysql:GoTop(), NIL ) }, ) ; If( ::bGoBottom == nil, ::bGoBottom := {|| If( ::oMysql:RecCount() > 0, ::oMysql:GoBottom(), nil )  }, ); If( ::bSkip == nil, ::bSkip := { |n,x| If( ::oMySql:RecCount() > 0, ( x := ::oMySql:RecNo(),  ::oMySql:GoTo( Max( 1,  Min( ::oMySql:RecCount(), ::oMySql:RecNo() + IfNil( n, 1 ) ) ) ),  ::oMySql:RecNo() - x ), 0 ) }, ); If( ::bBof == nil, ::bBof := {|| ::oMysql:Bof() }, ); If( ::bEof == nil, ::bEof := {|| ::oMysql:Eof() }, ); If( ::bBookMark == nil, ::bBookMark := {| n | If( n == nil, If( ::oMysql:RecCount() > 0, ::oMysql:RecNo(), 0 ),  If( ::oMysql:RecCount() > 0, ::oMysql:goto( n ), 0 ) ) }, ); If( ::bKeyNo == nil, ::bKeyNo := {| n | If( n == nil,  If( ::oMysql:RecCount() > 0, ::oMysql:RecNo(), 0 ),  If( ::oMysql:RecCount() > 0, ::oMysql:Goto( n ), 0 ) ) }, ); If( ::bKeyCount == nil, ::bKeyCount := {|| ::oMysql:RecCount() }, );

   ::nDataType         := 64

   IF lAddCols

      IF Len(aFldNames) == 0
         aFldNames := ::oMysql:aFieldStruct
      ENDIF

      FOR EACH xField IN aFldNames
         IF Valtype( xField ) == "A" .AND. Len(xField) == 2
            cCol    := xField[1]
            cHeader := xField[2]
         ELSEIF Valtype( xField ) == "A" .AND. Len(xField) # 2
            cCol    := xField[1]
            cHeader := xField[1]
         ELSE
            cCol    := xField
            cHeader := xField
         ENDIF

         ::SetColFromMySQL( cCol, cHeader, lAutoOrder )
      NEXT

      if __ObjHasMethod( oMySql, "WSEEKPLUS" )
         ::bSeek  := { |c| MysqlSeek( ::oMysql, c, , ::lSeekWild ) }
      endif

   ENDIF

   if ::lCreated
      ::Adjust()
      ::Refresh()
   endif

   RETURN Self



static FUNCTION TXBrowse_SetDolphin( oQry, lAddCols, lAutoOrder, aFldNames, bSeptup ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   LOCAL xField    := NIL
   LOCAL cHeader   := ""
   LOCAL cCol      := ""
   LOCAL oCol
   local cWhere, aQryFldNames

   If( oQry == nil, oQry := ::oMysql, ) ;
   If( aFldNames == nil, aFldNames := {}, ) ;
   If( lAddCols == nil, lAddCols := Empty( ::aCols ) .OR. ! Empty( aFldNames ), ) ;
   If( lAutoOrder == nil, lAutoOrder := ::lAutoSort, ) ;

   ::lAutoSort    := lAutoOrder
   ::oMysql = oQry
   cWhere         := oQry:cWhere












   If( ::bGoTop == nil, ::bGoTop := {|| If( ::oMysql:RecCount() > 0, ::oMysql:GoTop(), NIL ) }, ) ; If( ::bGoBottom == nil, ::bGoBottom := {|| If( ::oMysql:RecCount() > 0, ::oMysql:GoBottom(), nil )  }, ); If( ::bBof == nil, ::bBof := {|| ::oMysql:Bof() }, ); If( ::bEof == nil, ::bEof := {|| ::oMysql:Eof() }, ); If( ::bBookMark == nil, ::bBookMark := {| n | If( n == nil, If( ::oMysql:RecCount() > 0, ::oMysql:RecNo(), 0 ),  If( ::oMysql:RecCount() > 0, ::oMysql:goto( n ), 0 ) ) }, ); If( ::bKeyNo == nil, ::bKeyNo := {| n | If( n == nil,  If( ::oMysql:RecCount() > 0, ::oMysql:RecNo(), 0 ),  If( ::oMysql:RecCount() > 0, ::oMysql:Goto( n ), 0 ) ) }, ); If( ::bKeyCount == nil, ::bKeyCount := {|| ::oMysql:RecCount() }, );

    IF ::oMysql:lPagination



       If( ::bSkip == nil, ::bSkip := {| n | If ( n <> NIL, If( n + ::oMysql:nRecNo < 1 .AND. ::oMysql:nCurrentPage > 1, ( ::oMysql:PrevPage(, .T. ), 0 ),  If( n + ::oMysql:nRecNo > ::oMysql:nRecCount .AND. ::oMysql:nCurrentPage < ::oMysql:nTotalRows, ( ::oMysql:NextPage( , .T. ), 0 ), ::oMysql:Skip( n ) ) ), ::oMysql:Skip( n ) )  }, ) ;
    ELSE
       If( ::bSkip == nil, ::bSkip := { | n | ::oMysql:Skip( n ) }, ) ;
    ENDIF

   ::nDataType          := 64

   IF lAddCols

      aQryFldNames   := ArrTranspose( ::oMySql:aStructure )[ 1 ]
      AEval( aQryFldNames, { |c,i| aQryFldNames[ i ] := Upper( c ) } )
      ASort( aQryFldNames,,,{ |x,y| Len( x ) > Len( y ) } )

      IF Len(aFldNames) == 0
         aFldNames := ::oMysql:aStructure
      ENDIF

      FOR EACH xField IN aFldNames

         if bSeptup <> NIL
            Eval( bSeptup, xField, Self )
         else
            IF Valtype( xField ) == "A" .AND. Len(xField) == 2
               cCol    := xField[1]
               cHeader := xField[2]
            ELSEIF Valtype( xField ) == "A" .AND. Len(xField) # 2
               cCol    := xField[1]
               cHeader := xField[1]
            ELSE
               cCol    := xField
               cHeader := xField
            ENDIF
            ::SetColFromMySQL( cCol, cHeader, lAutoOrder, aQryFldNames )
         endif

      NEXT

      ::bSeek  := { | c | DolphinSeek( c, Self, cWhere ) }

   ENDIF

   ::bSaveData    := { || ::oMySql:Save(), .T. }
   ::bDelete      := { || If( ::nLen < 1, nil, ( ::oMySql:Delete(), ::oMySql:Save() ) ) }

   if ::lCreated
      ::Adjust()
      ::Refresh()
   endif

   RETURN Self



static FUNCTION TXBrowse_ClearBlocks( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse


   ::bGoTop := ::bGoBottom := ::bSkip := ::bBof := ::bEof :=  ::bBookMark := ::bKeyNo := ::bKeyCount := nil
   ::nStretchCol     := nil
   ::nHeaderHeight   := nil
   ::nFooterHeight   := nil

return Self



static FUNCTION TXBrowse_aJustify( aNew ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aJust
   local n, nCols := Len( ::aCols )
   local oCol, j

   if aNew <> nil
      for n := 1 to nCols
         oCol     := ::aCols[ n ]
         if oCol:nCreationOrder <= Len( aNew )
            j     := aNew[ oCol:nCreationOrder ]
            if Valtype( j ) == "L"
               j  := If( j, 1, 0 )
            elseif ValType( j ) == "N"
               j  := Min( 3, Max( 0, j ) )
            endif
            if ValType( j ) == "N"
               oCol:nDataStrAlign  := j
            endif
         endif
      next
   endif

   aJust    := Array( nCols )
   for n := 1 to nCols
      oCol  := ::aCols[ n ]
      j     := oCol:nDataStrAlign
      j     := If( j == 1, .T., If( j == 0, .F. , 2 ) )
      aJust[ oCol:nCreationOrder ] := j
   next

return aJust



static FUNCTION TXBrowse_SetColFromADO( cnCol, lAutoOrder, aRsColNames, lJet ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local   nType, cType, nLen, nDec, cName
   local   oCol, oField, bExpr, uVal
   local   bReplace := { |c| " oCol:oBrw:oRs:Fields('" + Lower( c ) + "'):Value " }

   oCol              := ::AddCol()
   BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
      oField         := ::oRs:Fields( cnCol )
   RECOVER
   END

   if oField == nil

      if ValType( cnCol ) == "B"
         oCol:bEditValue   := cnCol
      else
         if ValType( cnCol ) == "C"
            if !( "U" $ Type( cnCol ) )
               oCol:bEditValue   := &( "{||" + cnCol + "}" )
            else
               bExpr             := RsExprnBlock( aRsColNames, cnCol, bReplace )
               if bExpr <> nil
                  oCol:bEditValue   := bExpr
                  BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
                     Eval( oCol:bEditValue, nil, oCol )
                  RECOVER
                     oCol:bEditValue   := nil
                  END
               endif
            endif
         endif
         if Empty( oCol:bEditValue )
            oCol:bEditValue   := &( "{ |x,oCol|" +  cValToChar( cnCol ) + " }" )
         endif
         oCol:cHeader   := cValToChar( cnCol )
         oCol:cExpr     := oCol:cHeader
      endif
      return oCol
   endif

   oCol:cHeader     := If( ValType( cnCol ) == "C", cnCol, oField:Name )
   oCol:cExpr       := oCol:cHeader
   nType            := oField:Type

   DO CASE
   CASE ASCAN( { 2, 3, 16, 17, 18, 19, 20, 21 }, nType ) > 0
      cType         := "N"
      nLen          := oField:Precision
      nDec          := 0
   CASE ASCAN( { 14, 131, 139 }, nType ) > 0
      cType         := "N"
      nLen          := Min( 19, oField:Precision )
      nDec          := If( oField:NumericScale >= 255, 0, Min( nLen - 2, oField:NumericScale ) )
   CASE ASCAN( { 4, 5, 6 }, nType ) > 0
      cType         := "N"
      nLen          := oField:Precision
      nDec          := 2

   CASE ASCAN( { 7, 133, 135 }, nType ) > 0
      cType         := "D"

      if ::oRs:RecordCount() > 0 .AND. ValType( uVal := oField:Value ) == "T" .AND.  FW_TIMEPART( uVal ) >= 1.0

         cType      := "T"
      endif

      if lJet


         oCol:bEditValue := { |x| If( x <> nil, ::oRs:Fields( cnCol ):Value := x,  IfNil( ::oRs:Fields( cnCol ):Value,  If( oCol:cDataType == "T", HB_CTOT( "" ), CTOD( "" ) ) ) ) }
      else
         oCol:bEditValue := { |x,o| XbrAdoDateIO( x, o, cnCol ) }
      endif
   CASE nType == 11
      cType         := "L"

      oCol:bEditValue := { |x| If( x <> nil, ::oRs:Fields( cnCol ):Value := ! Empty( x ),  ! Empty( ::oRs:Fields( cnCol ):Value ) ) }
   CASE ASCAN( { 128, 204, 205 }, nType ) > 0
      cType         := "M"
      nLen          := 10

      oCol:bEditValue := { |x| If( x <> nil, ::oRs:Fields( cnCol ):Value := HB_StrToHex( x ),  ::oRs:Fields( cnCol ):Value ) }

   CASE ASCAN( { 8,129,130,200,201,202,203 }, nType ) > 0
      cType         := "C"
      nLen          := oField:DefinedSize
      if ! lAnd( oField:Attributes, 0x10 )
         if nLen == 0 .OR. nLen > 100
            cType      := "M"
            nLen       := 40
         else
            nLen       := Min( 100, nLen )
         endif
      endif
      if cType == "M"


         oCol:bEditValue   := { |x| If( x <> nil, ::oRs:Fields( cnCol ):Value := Trim( x ),  If( ::oRs:RecordCount > 0, IfNil( ::oRs:Fields( cnCol ):Value, "" ), "" ) ) }
      elseif lAnd( oField:Attributes, 0x10 )

         oCol:bEditValue   := { |x| If( x <> nil, ::oRs:Fields( cnCol ):Value := PadR( x, nLen ),  PadR( IfNil( ::oRs:Fields( cnCol ):Value, "" ), nLen ) ) }

      else

         oCol:bEditValue   := { |x| If( x <> nil, ::oRs:Fields( cnCol ):Value := Trim( x ),  PadR( IfNil( ::oRs:Fields( cnCol ):Value, "" ), nLen ) ) }
      endif
   ENDCASE

   if oCol:bEditValue == nil .AND. cType == "N"

      oCol:bEditValue := { |x| If( x <> nil, ::oRs:Fields( cnCol ):Value := x,  IfNil( ::oRs:Fields( cnCol ):Value, 0.00 ) ) }

   endif

   oCol:lReadOnly    := ( FW_AdoFieldUpdateable( ::oRs, oField ) == .F. )

   if cType == nil
      if nType == 136
         oCol:bEditValue   := { || ::oRs:Fields( cnCol ):Value }
         oCol:bStrData     := { || "<Child>" }
      else
         oCol:bEditValue   := { || "..." }
      endif
   endif

   if oCol:lReadOnly
      oCol:bOnPostEdit  := { || nil }
   else
      oCol:bOnPostEdit  := { |o,x,n| If( n == 27 .OR. x == nil .OR. EQ( o:Value, x, .T., .T. ), nil, o:Value := x ) }
   endif

   oCol:cDataType    := If( cType == nil, "C", cType )
   oCol:nDataLen     := nLen

   if nDec <> nil
      oCol:nDataDec  := nDec
   endif
   if oCol:cDataType == "D"
      oCol:cEditPicture := "@D"
   elseif oCol:cDataType == "N"
      oCol:cEditPicture := NumPict( nLen, nDec )
   endif

   oCol:cSortOrder   := "[" + oField:Name + "]"

return oCol



static function XbrAdoDateIO( dNew, oCol, cnCol )

   local oRs   := oCol:oBrw:oRs, dVal

   if dNew <> nil

      if Empty( dNew )
         dNew  := 0.0
      endif

      oRs:Fields( cnCol ):Value  := dNew
   endif

   dVal  := oRs:Fields( cnCol ):Value
   if dVal == nil .OR. FW_TTOD( dVal ) == {^ 1899/12/30 }

      dVal  := CtoD( "" )
   endif

return dVal



static function RsExprnBlock( aFldNames, cStr, bReplace )

   local nAt, c, cCol, bExpr, cSave

   cSave := cStr
   cStr  := Upper( cStr )

   for each cCol in aFldNames

      while ( nAt := At( cCol, cStr ) ) > 0
         c := Left( LTrim( SubStr( cStr, nAt + Len( cCol ) ) ), 1 )
         if c $ ")+-*/%^<>," .OR. Empty( c )

            cStr  := Stuff( cStr, nAt, Len( cCol ), Eval( bReplace, cCol )  )

         else
            cStr  := Stuff( cStr, nAt, Len( cCol ), Lower( cCol ) )
         endif
      enddo

   next
   BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
      bExpr    := &( "{ |x,oCol| " + cStr + "}" )
   RECOVER
   END

return bExpr



static FUNCTION TXBrowse_SetColFromMySQL( cnCol, cHeader, lAutoOrder, aQryFldNames ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   LOCAL nType, cType, nLen, nDec, cName
   LOCAL oCol, nCol := 0
   local bReplace    := { |c| " oCol:oBrw:oMySql:" + Lower( c ) + " " }

   if ValType( cnCol ) == "B"
      WITH OBJECT ( oCol := ::AddCol() )
         :bEditValue    := cnCol
         :cHeader       := If( ValType( cHeader ) == "C", cHeader, "Col-" + LTrim( Str( :nCreationOrder ) ) )
      END
      return oCol
   endif

   if ValType( cnCol ) == "N" .AND. cnCol > 0 .AND. cnCol <= ::oMySql:FCount()
      nCol              := cnCol
   elseif ValType( cnCol ) == "C"
      BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
         nCol            := ::oMysql:FieldPos( cnCol )
      RECOVER
      END
   endif
   if nCol == 0
      WITH OBJECT ( oCol := ::AddCol() )
         if ValType( cnCol ) == "C" .AND. aQryFldNames <> nil
            :bEditValue    := RsExprnBlock( aQryFldNames, cnCol, bReplace )
         else
            :bEditValue    := &( "{ |x,oCol| " + cValToChar( cnCol ) + " }" )
         endif
         :cHeader       := If( ValType( cHeader ) == "C", cHeader, "Col-" + LTrim( Str( :nCreationOrder ) ) )
      END
      return oCol
   endif

   cName                 := ::oMysql:FieldName( nCol )

   If( nCol == nil, nCol := cnCol, ) ;
   oCol                  := ::AddCol()
   WITH OBJECT oCol
      :cHeader           := If( ValType( cHeader ) == "C", cHeader, cName )
   END
   cType                 := ::oMysql:FieldType( nCol )
   nLen                  := 0
   nDec                  := 0

   DO CASE
   CASE cType       == "N"
      nLen               := ::oMysql:FieldLen( nCol )
      nDec               := ::oMysql:FieldDec( nCol )
      oCol:cEditPicture  := NumPict( nLen, nDec )

   CASE cType       == "C"
      nLen               := MIN( 100, ::oMysql:FieldLen( nCol ) )

   CASE cType       == "M"
      nLen               := MIN( 100, Len(AllTrim(::oMysql:FieldGet( nCol ))) )
      nLen               := IF(nLen < 30, 30, nLen )

   CASE cType       == "D"
      nLen              := 8

   CASE cType       == "T"
      nLen              := 19
      cType             := "C"

   OTHERWISE

      oCol:bEditValue    := { || "..." }

   ENDCASE

   If( oCol:bEditValue == nil, oCol:bEditValue := { |x| If( x == nil, ::oMySql:FieldGet( cName ), ::oMySql:FieldPut( nCol, x ) ) }, ) ;

   WITH OBJECT oCol
      :cDataType           := If( cType == nil, "C", cType )
      :nDataLen            := nLen
      :nDataDec            := nDec
      :bOnPostEdit         := { |o,x,n| If( n == 27,,o:Value := x ) }
      if lAutoOrder
         :cSortOrder   := cName
      endif
   END

RETURN oCol



static FUNCTION TXBrowse_RddIncrSeek( cExpr, uSeek ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local lFound      := .F.
   local lSoft       := .T.
   local cTemp, uOrdKeyVal, cOrdKeyType

   if ::lIncrFilter
      return ::RDDIncrFilter( cExpr, @uSeek )
   endif

   if Empty( OrdSetFocus() )
      return .F.
   endif

   uOrdKeyVal  := OrdKeyVal()
   cOrdKeyType := ValType( uOrdKeyVal )

   if cOrdKeyType == "C"
      if ::lSeekWild
         if "UPPER" $ Upper( OrdKey() )
            cExpr := Upper( cExpr )
         endif
         lFound   := OrdWildSeek( StrTran( "*" + cExpr + "*", "**", "*" ) )
      else
         lFound   := DbSeek( Upper( cExpr ) ) .OR. DbSeek( cExpr )
      endif
   else
      do case
      case cOrdKeyType == "N"
         cExpr    := Val( cExpr )
      case cOrdKeyType $ "DT"
         cExpr    := SeekDate( cExpr, uOrdKeyVal )
      case cOrdKeyType == "L"
         cExpr    := Upper( Left( cExpr, 1 ) ) == "T"
      otherwise
         lSoft    := .F.
      endcase
      DbSeek( cExpr, lSoft )
      lFound      := !Eof()
   endif

return lFound



static FUNCTION TXBrowse_RddIncrFilter( cExpr, uSeek ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oBrw     := Self
   local lFound   := .F.
   local cKey
   local cFilter

   if ::bFilterExp == nil
      If( ::cFilterFld == nil, ::cFilterFld := OrdKey(), ) ;
      cKey  := ::cFilterFld
      if ::lSQLRDD
         if Empty( cExpr )
            cFilter  := ""
         else
            cExpr := If( ::lSeekWild, "'%", "'" ) + Upper( Trim( cExpr ) ) + "%'"
            cFilter  := cKey + " LIKE " + cExpr
         endif
      else
         if ValType( &cKey ) == "C"
            if ! "UPPER" $ Upper( cKey )
               cKey  := "UPPER( " + cKey + " )"
            endif
         else
            cKey  := "CVALTOCHAR(" + cKey + ")"
         endif
         if Empty( cExpr )
            cFilter     := "!deleted()"
         elseif ::lSeekWild



            cFilter     := 'HB_WildMatch("*' + Upper( Trim( cExpr ) ) + '*",' + cKey + ")"

         else
            cFilter     := cKey + '="' + Upper( Trim( cExpr ) ) + '"'
         endif
      endif
   else
      cFilter        := Eval( ::bFilterExp, cExpr )
   endif

   if ! ::lSQLRDD .AND. &cFilter
      uSeek          := ::BookMark
   endif
   if ( Empty( cFilter ) ) ; dbClearFilter() ; else ; dbSetFilter( {|| &cFilter}, cFilter ) ; end
   dbGoTop()
   lFound      := ::KeyCount() > 0

return lFound



static FUNCTION TXBrowse_AdoIncrSeek( uSeek ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local lFound   := .F.
   local cCol     := CharRem( "[]", StrToken( ::oRs:Sort, 1 ) )
   local cExpr    := ""
   local cType, d, uVal, lSoft, cSaveFilt

   if ::lIncrFilter
      if ::bFilterExp == nil
         If( ::cFilterFld == nil, ::cFilterFld := cCol, ) ;
         cCol     := ::cFilterFld
      else
         cExpr    := Eval( ::bFilterExp, uSeek )
      endif
   endif

   if Empty( cExpr ) .AND. ! Empty( cCol ) .AND. ! ::oRs:Eof() .AND. ! ::oRs:Bof()

      If( lSoft == nil, lSoft := Set(9), ) ; If( ::lSeekWild == nil, ::lSeekWild := .F., );

      uVal     := ::oRs:Fields( cCol ):Value
      cType    := If( uVal == nil, FieldTypeAdoToDbf( ::oRs:Fields( cCol ):Type ), ValType( uVal ) )

      do case
      case cType == "C"

         if ::lSeekWild
            lSoft    := .F.
            cExpr    := cCol + " LIKE '*" + uSeek + "*'"
         else

            cExpr    := If( Set( 1 ), cCol + " = '" + uSeek + "'",  cCol + " LIKE '" + uSeek + "*'" )
         endif

      case cType == "N"

         cExpr    := cCol + " >= " +  LTrim( Str( Val( uSeek ) ) )

      case cType $ "DT"
         cExpr    := cCol + " >= " + d2ado( SeekDate( uSeek, uVal ) )
      endcase

      if ! Empty( cExpr )
         if ::lIncrFilter
            if Empty( uSeek )
               ::oRs:Filter   := ""
               ::oRs:MoveFirst()
               lFound         := .T.
            else
               cSaveFilt      := ::oRs:Filter
               ::oRs:Filter   := cExpr
               if ! ( lFound := ( ::oRs:RecordCount > 0 ) )
                  ::oRs:Filter   := cSaveFilt
               endif
            endif
         else
            if Empty( uSeek )
               if ::oRs:RecordCount() > 0
                  ::oRs:MoveFirst()
               endif
               lFound   := .T.
            else
               ::oRs:Find( cExpr, 0, 1, 1 )
               if ::oRs:Eof() .AND. lSoft .AND. cType == "C"
                  ::oRs:MoveFirst()
                  cExpr := cCol + " > '" + uSeek + "'"
                  ::oRs:Find( cExpr, 0, 1, 1 )
               endif
               if ::oRs:Eof()
                  ::oRs:MoveLast()
               else
                  lFound   := .T.
               endif
            endif
         endif
      endif

   endif

return lFound



static FUNCTION DolphinSeek( c, oBrw, cQryWhere )

   local oQry        := oBrw:oMySql
   local nStart
   local uData, nNum, lRet
   local cSortOrder

   static aLastRec := {}

   if oBrw:lIncrFilter
      If( oBrw:cFilterFld == nil, oBrw:cFilterFld := TOken( oQry:cOrder, , 1 ), ) ;
      if Empty( oBrw:cFilterFld )
         return .F.
      endif

      if Empty( c )
         c     := cQryWhere
      else



         c     := If( Empty( cQryWhere ), "", "(" + cQryWhere + ") and " ) +  Lower( oBrw:cFilterFld ) + " like '" +  If( oBrw:lSeekWild, "%", "" ) +  c + "%'"
      endif
      oQry:SetWhere( c, .T. )
      oQry:GoTop()
      return ( oQry:LastRec() > 0 )

   endif

   if Empty( c )
      return .T.
   endif

   nNum = AScan( oBrw:aCols, {| o | !Empty( o:cOrder ) } )

   if nNum < 1
      RETURN .F.
   endif

   cSortOrder = oBrw:aCols[ nNum ]:cSortOrder

   if Len( c ) == 1
      aLastRec    := {}
   endif

   IF Len( aLastRec ) < Len( c )
      IF Len( aLastRec ) == 0
         nStart = 1
      ELSE
         nStart = oQry:RecNo()
      ENDIF
      AAdd( aLastRec, nStart )
   ELSE


      ASize( aLastRec, Len( c ) - 1 )
      IF Len( aLastRec ) == 0
         nStart = 1
      ELSE
         nStart = ATail( aLastRec )
      ENDIF
   ENDIF

   lRet  := ( oQry:Seek( c, cSortOrder, nStart - 1, oQry:LastRec(), .T., .T. ) <> 0 )

return lRet



static function MysqlSeek( oMysql, uSeek, lSoft, lWildSeek )

   local lFound   := .F.
   local cCol     := oMysql:cSort
   local cExpr    := ""
   local cType, d, uVal

   if ! Empty( cCol ) .AND. ! oMysql:Eof() .AND. ! oMysql:Bof()

      If( lSoft == nil, lSoft := Set(9), ) ; If( lWildSeek == nil, lWildSeek := .F., );

      uVal   := oMysql:FieldGet( cCol )
      cType  := oMysql:FieldType( cCol )

      do case
      case cType == "C"

         if lWildSeek
            lSoft    := .F.
            cExpr    := cCol + " LIKE '%" + uSeek + "%'"
         else

            cExpr    := If( Set( 1 ), cCol + " = '" + uSeek + "'",  cCol + " LIKE '" + uSeek + "%'" )
         endif

      case cType == "N"

         cExpr    := cCol + " >= " +  LTrim( Str( Val( uSeek ) ) )
      case cType == "D"

         if Empty( d := CToD( uSeek ) )
            d  := CToD( uSeek + SubStr( DToC( uVal ), Len( uSeek ) + 1 ) )
         endif
         if ! Empty( d )



            cExpr    := cCol + " >= #" +  StrZero( Year( d ), 4 ) + "-" +  StrZero( Month( d ), 2 ) + "-" +  StrZero( Day( d ), 2 ) + "#"

         endif
      endcase

      if ! Empty( cExpr )
         oMysql:WSeekplus( cExpr, oMysql:cSort, oMysql:recno() )
         if oMysql:Eof() .AND. lSoft .AND. cType == "C"
            oMysql:GoTop()
            cExpr := cCol + " > '" + uSeek + "'"
            oMysql:WSeekplus( cExpr, oMysql:cSort, oMysql:recno() )
         endif
         if oMysql:Eof()
            oMysql:GoBottom()
         else
            lFound   := .T.
         endif
      endif

   endif

return lFound



static FUNCTION TXBrowse_SetTree( oTree, aResource, bOnSkip, aCols ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol, aBmp := { 0, 0, 0 }
   local n, nLevels, aBlocks, bBookMark

   If( oTree == nil, oTree := 2, ) ;

   if ValType( oTree ) == "N"
      if ! Empty( ::aCols ) .AND. Len( ::aCols ) >= 2
         nLevels  := Min( oTree, Len( ::aCols ) )
      else
         return nil
      end

      aBlocks := Array( nLevels )
      for n := 1 to nLevels
         aBlocks[ n ] := If( ::aCols[ n ]:bStrData == nil, ::aCols[ n ]:bEditvalue, ::aCols[ n ]:bStrData )
         ::aCols[ n ]:lHide   := .T.
      next
      ::nLen      := Eval( ::bKeyCount )
      bBookMark   := ::bBookMark
      oTree       := SummaryDataAsTree( ::bSkip, { |nRow| nRow > ::nLen }, aBlocks, ::bBookMark )
      bOnSkip     := { || Eval( bBookMark, ::oTreeItem:cargo ) }
      ::nDataType := nOr( ::nDataType, 32 )
   else
      ::nDataType := 32
   endif

   If( bOnSkip == nil, bOnSkip := { || nil }, ) ;

   ::oTree     := oTree
   ::oTreeItem := oTree:oFirst

   ::bGoTop    := { || ::oTreeItem := ::oTree:oFirst, Eval( bOnSkip, ::oTreeITem ) }
   ::bGoBottom := { || ::oTreeItem := ::oTree:GetLast(), Eval( bOnSkip, ::oTreeITem ) }
   ::bBof      := { || .F. }
   ::bEof      := { || .F. }
   ::bKeyCount := { || ::oTree:ncount() }


   ::bKeyNo    := { |n| If( n == nil, ::oTreeItem:ItemNo() ,  ( n--, ::oTreeItem := ::oTree:oFirst:Skip( @n ), Eval( bOnSkip, ::oTreeITem ), n + 1 ) ) }

   ::bBookMark := ::bKeyNo



   ::bSkip     := { |n| If( n == nil, n := 1, ),  ::oTreeItem := ::oTreeItem:Skip( @n ),   Eval( bOnSkip, ::oTreeItem ),  n }

   if Empty( ::aCols )
      oCol  := ::AddCol()
   else
      oCol  := ::InsCol( 1 )
   endif

   oCol:bEditValue   := { |x| If( x == nil, ::oTreeItem:cPrompt, ::oTreeItem:cPrompt := x ) }
   oCol:cHeader      := "Item"
   oCol:nWidth       := 200
   oCol:bLDClickData := { || If( ::oTreeItem:oTree <> nil,( ::oTreeItem:Toggle(), ::Refresh() ), if( !Empty( ::bLDblClick ), eval( ::bLDblClick ), ) ) }
   oCol:bIndent      := { || ::oTreeItem:nLevel * 20 - 20 }

   if ValType( aResource ) == "A"
      oCol:AddBitmap( aResource )
   endif
   oCol:bBmpData   := { || If( ::oTreeItem:oTree == nil, 3, If( ::oTreeItem:lOpened, 1, 2 ) ) }

   ::nFreeze         := 1

   if ValType( aCols ) == "L" .AND. aCols .AND. ValType( ::oTreeItem:Cargo ) == "A"
      for n := 1 to Len( ::oTreeItem:Cargo )
         ::SetColsForTree( n )
      next
   elseif ValType( aCols ) == "A"
      for n := 1 to Len( aCols )
         ::SetColsForTree( aCols[ n ] )
      next
   endif

return Self



static FUNCTION TXBrowse_SetColsForTree( uData ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol  := ::AddCol()

   if ValType( uData ) == "B"
      oCol:bEditValue   := uData
   elseif ValType( ::oTreeItem:Cargo ) == "A" .AND. ValType( uData ) == "N"
      oCol:bEditValue   := { || ::oTreeItem:Cargo[ uData ] }
   else
      oCol:bEditValue   := &( "{ |x,oCol| " + cValToChar( uData )+ " }" )
   endif

return oCol



static FUNCTION TXBrowse_SetoDbf( oDbf, aCols, lAutoSort, lAutoCols, aRows ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local n, oCol, oRs
   local bOnSkip


   If( lAutoSort == nil, lAutoSort := .F., ) ; If( lAutoCols == nil, lAutoCols := .F., );

   ::oDbf              := oDbf

   if ValType( aRows ) == "A" .AND. Len( aRows ) > 0

      if ValType( aRows[ 1 ] ) == "A"
         bOnSkip        := { | oBrw | oBrw:oDbf:GoTo( oBrw:aArrayData[ oBrw:nArrayAt ][ 1 ] ) }
      else
         bOnSkip        := { | oBrw | oBrw:oDbf:GoTo( oBrw:aArrayData[ oBrw:nArrayAt ] ) }
      endif
      ::SetArray( aRows, .F., 0, .F., bOnSkip )
      ::nDataType       := nOr( 16, 2 )
      lAutoSort         := .F.

   elseif __ObjHasMethod( oDbf, "SETXBROWSE" )
      oDbf:SetXBrowse( Self, aCols, lAutoSort, lAutoCols )
      aCols       := nil
      lAutoCols   := .F.
   else




      If( ::bGoTop == nil, ::bGoTop := {|| oDbf:GoTop() }, ) ; If( ::bGoBottom == nil, ::bGoBottom := {|| oDbf:GoBottom()  }, ); If( ::bSkip == nil, ::bSkip := {| n | oDbf:Skipper( If( n == nil, 1, n ) ) }, ); If( ::bBof == nil, ::bBof := {|| oDbf:Bof() }, ); If( ::bEof == nil, ::bEof := {|| oDbf:Eof() }, );

      if __ObjHasMethod( oDbf, "BOOKMARK" )

         If( ::bBookMark == nil, ::bBookMark := { |u| oDbf:BookMark( u ) }, ) ;

      else



         If( ::bBookMark == nil, ::bBookMark := {| n | If( n == nil, ( oDbf:RecNo() ), ( oDbf:GoTo( n ) ) ) }, ) ;

      endif

      if __ObjHasMethod( oDbf, "KEYNO" ) .AND. __ObjHasMethod( oDbf, "KEYCOUNT" ) .AND.  __ObjHasMethod( oDbf, "KEYGOTO" )


         If( ::bKeyNo == nil, ::bKeyNo := { |n| If( n == nil, oDbf:KeyNo(), oDbf:KeyGoTo( n ) ) }, ) ; If( ::bKeyCount == nil, ::bKeyCount := { || oDbf:KeyCount() }, );
      else


         If( ::bKeyNo == nil, ::bKeyNo := ::bBookMark, ) ; If( ::bKeyCount == nil, ::bKeyCount := {|| oDbf:RecCount()}, );

      endif

      if __ObjHasMethod( oDbf, "SAVE" )
         If( ::bSaveData == nil, ::bSaveData := { || ::oDbf:Save() }, ) ;
      endif

      ::nDataType         := 16

   endif
   if Empty( aCols ) .AND. lAutoCols
      if __ObjHasData( oDbf, "aStruct" )
         aCols := {}
         AEval( oDbf:aStruct, { |a| AAdd( aCols, a[ 1 ] ) } )


      elseif __ObjHasData( oDbf, "cAlias" ) .AND. __ObjHasData( oDbf, "nArea" ) .AND.  Select( oDbf:cAlias ) == oDbf:nArea .AND. ! Empty( oDbf:cAlias ) .AND.  ! Empty( oDbf:nArea )

         aCols := {}
         AEval( ( oDbf:nArea )->( DbStruct() ), { |a| AAdd( aCols, a[ 1 ] ) } )

      elseif __ObjHasData( oDbf, "oRs" )
         oRs   := oDbf:oRs

      elseif __ObjHasData( oDbf, "orecset" )
         oRs   := oDbf:oRecSet

      endif

      if ! Empty( oRs )
         aCols := {}
         for n := 0 to oRs:Fields:Count() - 1
            AAdd( aCols, oRs:Fields( n ):Name )
         next
      endif
   endif

   if aCols <> nil
      for n := 1 to Len( aCols )
         AddoDbfCol( Self, acols[ n ], If( __objHasData( oDbf, "aStruct" ), oDbf:aStruct, nil ) )
         if lAutoSort
            ::aCols[ n ]:cSortOrder := aCols[ n ]
         endif
      next
   endif

   if __ObjHasMethod( oDbf, "SAVE" )
      If( ::bOnRowLeave == nil, ::bOnRowLeave := { || ::oDbf:Save() }, ) ;
   endif
   if __ObjHasMethod( oDbf, "SEEK" )
      If( ::bSeek == nil, ::bSeek := { |c| ::oDbf:Seek( c, , ::lSeekWild ) }, ) ;
   endif

   if __ObjHasMethod( oDbf, "Delete" )
      ::bDelete      := { || ::oDbf:Delete() }
   endif

return Self



static FUNCTION TXBrowse_GetColsData( cData, lByCreationOrder ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aValues  := {}
   local oCol

   cData          := Upper( cData )
   If( lByCreationOrder == nil, lByCreationOrder := !( cData == "NCREATIONORDER" ), ) ;

   if ! Empty( ::aCols ) .AND. __ObjHasData( ::aCols[ 1 ], cData )
      if lByCreationOrder
         aValues  := Array( Len( ::aCols ) )
         for each oCol in ::aCols
            aValues[ oCol:nCreationOrder ]   := OSend( oCol, cData )
         next
      else
         AEval( ::aCols, { |o| AAdd( aValues, OSend( o, cData ) ) } )
      endif
   endif

return aValues



static FUNCTION TXBrowse_SetColsData( cData, aValues, lByCreationOrder ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol

   cData       := Upper( cData )
   if ! Empty( ::aCols ) .AND. __ObjHasData( ::aCols[ 1 ], cData )

      If( lByCreationOrder == nil, lByCreationOrder := !( cData == "NCREATIONORDER" ), ) ;

      cData       := "_" + cData

      if ValType( aValues ) == "A"
         if lByCreationOrder
            for each oCol in ::aCols
               if oCol:nCreationOrder <= Len( aValues )
                  OSend( oCol, cData, aValues[ oCol:nCreationOrder ] )
               endif
            next
         else
            AEval( ::aCols, { |o,i| OSend( o, cData, aValues[ i ] ) }, 1, Len( aValues ) )
         endif
      else
         AEval( ::aCols, { |o,i| OSend( o, cData, aValues ) } )
      endif
   endif

return aValues



static FUNCTION TXBrowse_SetGroupHeader( cGrpHdr, nFrom, nUpto, oFont ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nFor

   If( nFrom == nil, nFrom := 1, ) ; If( nUpto == nil, nUpto := Len( ::aCols ), );

   for nFor := nFrom to nUpto
      ::aCols[ nFor ]:cGrpHdr       := cGrpHdr
      if oFont == nil
         ::aCols[ nFor ]:oGrpFont   := ::oFont
      else
         ::aCols[ nFor ]:oGrpFont   := oFont
      endif

      if ::lAdjusted
         ::aCols[ nFor ]:nGrpHeight   := nil
         ::aCols[ nFor ]:Adjust()
      endif

   next

   if ::lAdjusted
      ::CalcHdrHeight()
      ::Refresh()
   endif

return Self



static FUNCTION TXBrowse_SetGroupTotal( aCols, cHead, nType, oFont ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol, nLastCol, n
   local cGroup

   If( nType == nil, nType := 1, ) ;

   if ValType( aCols ) == "C"
      cGroup      := Upper( aCols )
      for n := Len( ::aCols ) to 1 step -1
         if ! Empty( ::aCols[ n ]:cGrpHdr ) .AND. Upper( ::aCols[ n ]:cGrpHdr ) == cGroup
            nLastCol := n
            exit
         endif
      next
   elseif ValType( aCols ) == "A"
      nLastCol := 0
      for n := 1 to Len( aCols )
         oCol     := ::oCol( aCols[ n ] )
         if ValType( oCol ) == "O"
            nLastCol := Max( nLastCol, oCol:nCreationOrder )
         endif
      next
   endif
   if Empty( nLastCol )
      return nil
   endif

   oCol     := ::InsCol( nLastCol + 1 )
   WITH OBJECT oCol
      :cHeader    := cHead
      :bEditValue := { || oCol:SumOfCols( aCols, nType ) }
      if oFont == nil .AND. ! Empty( cGroup )
         oFont    := ::aCols[ nLastCol ]:oGrpFont
      endif
      if ! Empty( oFont )
         :oHeaderFont := :oDataFont := :oFooterFont := oFont
         if ! Empty( cGroup )
            :oGrpFont   := oFont
         endif
      endif
      if ! Empty( cGroup )
         :cGrpHdr    := ::aCols[ nLastCol ]:cGrpHdr
      endif
   END

return oCol



static FUNCTION TXBrowse_SetBackGround( uBack, uBckMode ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse


   local oBrush

   if uBack == nil .AND. uBckMode == nil

      ::lTransparent := .F.
      ::SetColor( ::nClrText, ::nClrPane )
      if ::lCreated
         ::Refresh()
      endif
   else
      if uBack == nil
         if ::oBrush:aGrad <> nil
            uBckMode    := If( Empty( uBckMode ), 2, 1 )
         elseif Empty( ::oBrush:hBitmap ) .OR. ValType( uBckMode ) <> "N"
            uBckMode := nil
         endif
         if uBckMode <> nil .AND. ::oBrush:nResizeMode <> uBckMode
            ::lTransparent    := .T.
            ::oBrush:nResizeMode := uBckMode
            ::oBrush:oRect       := nil
            ::MakeBrush()
         endif
      else
         If( uBckMode == nil, uBckMode := If( Empty( ::oBrush ), 0, ::oBrush:nResizeMode ), ) ;
         SWITCH ValType( uBack )
         CASE "A"
            if ValType( uBckMode ) == "N"
               uBckMode    := uBckMode < 2
            endif

            oBrush := TBrush():New( Upper(( If( ! Empty( uBckMode ), "VERTICAL", "HORIZONTAL" ) )),,,, uBack, )
            EXIT
         CASE "N"

            oBrush := TBrush():New( nil, nil, nil, nil, uBack,  FW_Decode( uBckMode, 1, "STRETCH", 2, "RESIZE", "TILED" ) )
            EXIT
         CASE "C"
            uBckMode    := FW_Decode( uBckMode, 1, "STRETCH", 2, "RESIZE", "TILED" )
            if "." $ uBack
               oBrush := TBrush():New( Upper(( uBckMode )),, uBack,,, )
            else
               oBrush := TBrush():New( Upper(( uBckMode )),,, uBack,, )
            endif
            EXIT
         CASE "O"
            oBrush   := uBack
            EXIT
         END

         if oBrush <> nil
            ::lTransparent := .T.
            ::SetBrush( oBrush )
            ::MakeBrush()
         endif
      endif
   endif

return Self



static FUNCTION TXBrowse_MakeBrush( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   if ::oBrush <> nil
      if !( Empty( ::oBrush:hBitmap ) .AND. Empty( ::oBrush:aGrad ) )
         ::oBrush:Resize( Self )
         if ::lAdjusted
            ::Refresh()
         endif
      endif
   endif
return Self



static FUNCTION TXBrowse_DataRect( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oRect    := ::GetCliRect()

   if ::lRecordSelector
      oRect:nLeft    += ( ::nRecSelWidth - 1 )
   endif
   if ::lHeader
      oRect:nTop     += ::HeaderHeight()
   endif
   if ::lFooter
      oRect:nBottom  -= ::FooterHeight()
   endif

return oRect



static FUNCTION TXBrowse_cBmpAdjBrush( cFile ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   ::SetBackGround( cFile )

return cFile



static FUNCTION TXBrowse_AddCol( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol          := eval( ::bColClass ):New( Self )

   Aadd( ::aCols, oCol )

   oCol:nCreationOrder := len( ::aCols )

return oCol



static FUNCTION TXBrowse_InsCol( nPos ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nFor

   If( nPos == nil, nPos := Len( ::aCols ), ) ;

   oCol  := Eval( ::bColClass ):New( Self )

   Aadd( ::aCols, nil )
   Ains( ::aCols, nPos )

   ::aCols[ nPos ] := oCol

   for nFor := nPos to Len( ::aCols )
      ::aCols[ nFor ]:nCreationOrder := nFor
   next

   ::GetDisplayCols()
   ::Super:Refresh()

return oCol



static FUNCTION TXBrowse_DelCol( nPos ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nFor

   if Len( ::aCols ) > 1
      ::aCols[ nPos ]:End()

      ADel( ::aCols, nPos )
      ASize( ::aCols, Len( ::aCols ) - 1 )


      for nFor := nPos to Len( ::aCols )
         ::aCols[ nFor ]:nCreationOrder := nFor
      next

      ::GetDisplayCols()
      ::Super:Refresh()
   endif

return nil






static FUNCTION TXBrowse_AddColumn( cHead, bData, cPic, uClrFore, uClrBack,  cAlign, nWidth, lBitmap, lEdit, bOnPostEdit,   cMsg, bWhen, bValid, cErr, lHilite, ncOrder, nAt, bBmpData, aBmp, lHide, nTot, bFooter, uCargo ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol, uTemp





   if ValType( nAt ) == "O" .AND. nAt:IsKindOf( TXBrwColumn() )
      nAt   := nAt:nCreationOrder
   endif
   if ValType( nAt ) == "N" .AND. nAt > 0 .AND. nAt <= Len( ::aCols )
      oCol  := ::InsCol( nAt )
   else
      oCol  := ::AddCol()
   endif

   oCol:cHeader      := IfNil( cHead, "" )
   oCol:cEditPicture := cPic

   if bData <> nil
      if lBitmap .AND. bBmpData == nil
         oCol:bBmpData        := bData
      else
         if ValType( bData ) == "N"
            oCol:nArrayCol    := bData
         else
            oCol:bEditValue   := bData
         endif
      endif
   endif

   if bBmpData <> nil
      oCol:bBmpData  := bBmpData
   endif

   if cAlign <> nil
      cAlign            := Upper( Left( cAlign, 1 ) )
      cAlign            := iif( cAlign == "R", 1, iif( cAlign == "C", 2, nil ) )
      if cAlign <> nil
         oCol:nHeadStrAlign := oCol:nDataStrAlign := oCol:nFootStrAlign := cAlign
      endif
   endif

   if ValType( nWidth ) == "N"
      oCol:nWidth       := nWidth
   endif

   if lEdit .OR. ValType( bOnPostEdit ) == "B" .OR. ValType( bValid ) == "B" .OR. ValType( bWhen ) == "B"
      oCol:nEditType   := 1
      oCol:bEditWhen   := bWhen
      oCol:bEditValid  := bValid
      if bOnPostEdit == nil





         oCol:bOnPostEdit  := { |o,x,n| If( n <> 27 .AND. o:oBrw:Lock(),  o:Value := x, nil ) }

      else
         oCol:bOnPostEdit := bOnPostEdit
      endif

   endif

   if valtype( uClrFore ) == "N"
      if valtype( uClrBack ) == "N"
         oCol:bClrStd   := {|| {uClrFore,uClrBack} }
      elseif valtype( uClrBack ) == "B"
         oCol:bClrStd   := { || {uClrFore,eval(uClrBack)} }
      else
         oCol:bClrStd   := { || { uClrFore, eval( oCol:oBrw:bClrStd )[2] } }
      endif
   elseif valtype( uClrFore ) == "B"
      if uClrBack == nil
         if valtype( uTemp := eval( uClrFore ) ) == "A" .AND. Len( uTemp ) == 2
            oCol:bClrStd   := uClrFore
         else
            oCol:bClrStd   := { || { eval(uClrFore), eval( oCol:oBrw:bClrStd )[2] } }
         endif
      elseif valtype( uClrBack ) == "N"
         oCol:bClrStd      := { || { eval(uClrFore), uClrBack } }
      elseif valtype( uClrBack ) == "B"
         oCol:bClrStd      := { || { eval(uClrFore), eval(uClrBack) } }
      endif
   endif

   if ncOrder <> nil
      oCol:cSortOrder := ncOrder
      ::lAutoSort     := .T.
      if ::nDataType == 1 .AND. ! Empty( ::cAlias ) .AND. SELECT( ::cAlias ) > 0
         oCol:cOrdBag    := ( ::cAlias )->( OrdBagName( ncOrder ) )
      endif
   endif

   if ValType( aBmp ) == "A"
      oCol:AddBitmap( aBmp )
   endif

   oCol:lHide     := lHide

   if ValType( nTot ) == "N"
      oCol:nTotal := nTot
      oCol:lTotal  := .T.
   endif
   if ValType( bFooter ) == "B"
      oCol:bFooter := bFooter
   elseif ValType( nTot ) == "B"
      oCol:bFooter := nTot
   endif

   oCol:Cargo := uCargo

   if ::lCreated
      oCol:Adjust()
   endif

return oCol



static FUNCTION TXBrowse_SwapCols( xCol1, xCol2, lRefresh ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nAt1, nAt2, nPos

   If( lRefresh == nil, lRefresh := .T., ) ;

   if Valtype( xCol1 ) == "O"
      nAt1 := Ascan( ::aCols, {|v| v:nCreationOrder == xCol1:nCreationOrder } )
      nAt2 := Ascan( ::aCols, {|v| v:nCreationOrder == xCol2:nCreationOrder } )
   else
      nAt1 := xCol1
      nAt2 := xCol2
   endif

   if nAt1 > 0 .AND. nAt2 > 0
      oCol := ::aCols[ nAt1 ]
      nPos := oCol:nPos
      ::aCols[ nAt1 ]:nPos := ::aCols[ nAt2 ]:nPos
      ::aCols[ nAt2 ]:nPos := nPos
      ::aCols[ nAt1 ] := ::aCols[ nAt2 ]
      ::aCols[ nAt2 ] := oCol
      if lRefresh
         ::GetDisplayCols()
         ::Super:Refresh()
      endif
   endif

return nil



static FUNCTION TXBrowse_MoveCol( xFrom, xTo, lRefresh, lUser ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local nFrom, nTo, nPos, n, cPrevGrp

   If( lRefresh == nil, lRefresh := .T., ) ; If( lUser == nil, lUser := .F., );

   if Valtype( xFrom ) == "O"
      nFrom := Ascan( ::aCols, {|v| v:nCreationOrder == xFrom:nCreationOrder } )
   else
      nFrom := xFrom
   endif
   if ValType( xTo ) == "O"
      nTo   := Ascan( ::aCols, {|v| v:nCreationOrder == xTo:nCreationOrder   } )
   else
      nTo   := xTo
   endif

   if lUser .AND. ! Empty( ::nFreeze )


      if ( nFrom >  ::nFreeze .AND. nTo <= ::nFreeze ) .OR.  ( nFrom <= ::nFreeze .AND. nTo >  ::nFreeze )

         return nil
      endif
   endif


   if nFrom > 0 .AND. nTo > 0 .AND. ( ::lAllowColReGroup .OR.  ::aCols[ nFrom ]:cGrpHdr == ::aCols[ nTo ]:cGrpHdr )
      oCol := ::aCols[ nFrom ]
      if ::lAllowColReGroup
         cPrevGrp       := oCol:cGrpHdr
         oCol:cGrpHdr   := ::aCols[ nTo ]:cGrpHdr
      endif
      nPos := oCol:nPos
      ADel( ::aCols, nFrom )
      AIns( ::aCols, nTo   )
      ::aCols[ nTo ] := oCol
      ::GetDisplayCols()

      if ::bOnSwapCol <> nil
         Eval( ::bOnSwapCol, Self, nFrom, nTo )
      endif

      if oCol:cGrpHdr <> cPrevGrp
         ::CalcHdrHeight()
      endif

      if lRefresh
         ::Super:Refresh()
      endif
   endif

return nil



static FUNCTION TXBrowse_ReArrangeCols( aSeq, lRetainRest, lReNumber ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aNew     := {}
   local nCol, oCol, n


   If( lRetainRest == nil, lRetainRest := .T., ) ; If( lReNumber == nil, lReNumber := .T., );

   for n := 1 to Len( aSeq )

      nCol  := AScan( ::aCols, { |o| o == aSeq[ n ] } )
      if nCol > 0
         AAdd( aNew, ::aCols[ nCol ] )
         ADel( ::aCols, nCol )
         ASize( ::aCols, Len( ::aCols ) - 1 )
      endif
   next

   if ! Empty( ::aCols )
      if lRetainRest
         AEval( ::aCols, { |o| AAdd( aNew, o ) } )
      else
         for n := 1 to Len( ::aCols )
            ::aCols[ n ]:End()
         next
      endif
      if ! lReNumber
         for n := 1 to Len ( aNew )
            if aNew[ n ]:nCreationOrder > Len( aNew )
               lReNumber   := .F.
            endif
         next
      endif
   endif
   if lReNumber
      AEval( aNew, { |o,i| o:nCreationOrder := i } )
   endif
   ::aCols  := aNew
   if ::lCreated
      ::GetDisplayCols()
   endif

return nil



static FUNCTION TXBrowse_SaveState( aAdditionalData ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aData    := { "nCreationOrders", "nRowHeight", "nWidths", "lHides", "cGrpHdrs", "cHeaders" }
   local aState   := {}

   if hb_isarray( aAdditionalData )
      aeval( aAdditionalData, { |c| aadd( aData, c ) } )
   endif

   aeval( aData, { |c| aadd( aState, { "_" + c, oSend( Self, c ) } ) } )

RETURN "XS1:" + fw_valtoexp( aState )



static FUNCTION TXBrowse_RestoreState( cState ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

  local aState

   if !empty( cState ) .AND. left( cState, 4 ) == "XS1:"

      cState      := SubStr( cState, 5 )

      aState      := &( cState )

      ::reArrangeCols( aState[ 1, 2 ], .T. , .F. )

      aeval( aState, { |a| oSend( Self, a[ 1 ], a[ 2 ] ) }, 2 )

      ::GetDisplayCols()

      ::Refresh()

  end

return nil



static FUNCTION TXBrowse_OldRestoreState( cState ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aCols       := {}
   local aNewOrder   := {}
   local nFor, nLen, nHeight, cCol, oCol, nOrder

   if Empty( cState )
      return nil
   endif

   nLen   := Len( ::aCols )
   nHeight := Val(StrToken( cState, 1, ";" ) )

   if Empty( ::nRowHeight )
      return nil
   endif

   for nFor := 1 to nLen
      cCol := StrToken( cState, nFor + 1, ";" )
      if Empty( cCol )
         return nil
      endif
      nOrder         := Val( StrToken( cCol, 1, ":" ) )
      if nOrder < 1 .OR. nOrder > nLen
         return nil
      endif
      aadd( aNewOrder, nOrder )
   next

   ASort( ::aCols,,, { |x,y| x:nCreationOrder < y:nCreationOrder } )

   ::nRowHeight := nHeight

   for nFor := 1 to nLen
      cCol           := StrToken( cState, nFor + 1, ";" )
      nOrder         := Val( StrToken( cCol, 1, ":" ) )

      WITH OBJECT ::aCols[ nOrder ]
         :lHide      := ( AllTrim( StrToken( cCol, 4, ":" ) ) == "H" )
         :nWidth     := Val( StrToken( cCol, 2, ":" ) )
         :cHeader    := StrToken( cCol, 3, ":" )
         :cGrpHdr    := StrToken( cCol, 5, ":" )
         if Empty( :cGrpHdr )
            :cGrpHdr := nil
         endif
      END
   next

   AEval( aNewOrder, { |n| AAdd( aCols, ::aCols[ n ] ) } )
   ::aCols        := aCols

   ::GetDisplayCols()
   ::Super:Refresh()

return nil



static FUNCTION TXBrowse_CancelEdit( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol, nFor, nlen






   if ::lEditMode
      nLen := Len( ::aCols )
      for nFor := 1 to nLen
         oCol := ::aCols[ nFor ]
         if oCol:oEditGet <> nil
            if oCol:nEditType < 6 .AND. !oCol:lAutoSave
               oCol:oEditGet:VarPut( oCol:Value )
            elseif oCol:lAutoSave
               if oCol:oEditGet:lValid() .AND. oCol:oEditGet:nLastKey <> 27
                  if oCol:oEditGet:ClassName == "TGET"
                     oCol:oEditGet:Assign()
                  elseif oCol:oEditGet:ClassName == "TTIMEPICK"
                     oCol:oEditGet:cText( oCol:oEditGet:cText )
                  endif
               else
                  oCol:oEditGet:VarPut( oCol:Value )
               endif
            endif
            oCol:oEditGet:bValid = nil
            oCol:PostEdit()
         endif
         if oCol:oEditLbx <> nil
            oCol:oEditLbx:End()
         endif
      next

      ::lEditMode := .F.
   endif

   if ::lEdited
      if ::bOnRowLeave <> nil
         Eval( ::bOnRowLeave, Self )
      endif
      ::lEdited   := .F.
   endif

return nil



static FUNCTION TXBrowse_Select( nOperation ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local uBook, uCurRow, uOldRow, uTemp
   local aTemp
   local nAt, nLen
   local lRefresh

   if ! ::lMultiSelect
      return nil
   endif

   If( nOperation == nil, nOperation := 1, ) ;
   do case
   case nOperation ==   0
      if Len( ::aSelected ) == 1 .AND.  Eval( ::bBookMark ) == ::aSelected[ 1 ]
         lRefresh := .F.
      else
         lRefresh := .T.
      endif
      ::aSelected   := {}

      if ! Empty( ::nSaveMarq )
         ::nMarqueeStyle   := ::nSaveMarq
         ::nSaveMarq       := nil
      endif

      if lRefresh

         ::GetDC()
         ::Super:Refresh( .T. )
         ::ReleaseDC()
      endif

   case nOperation == 1 .OR. ( Len( ::aSelected ) == 0 .AND. nOperation <> 4 )
      uBook := Eval( ::bBookMark )
      nAt   := Ascan( ::aSelected, uBook )
      if nAt == 0
         Aadd( ::aSelected, uBook )
         ::DrawLine( .T. )
      endif

   case nOperation == 2
      uBook := Eval( ::bBookMark )
      nAt   := Ascan( ::aSelected, uBook )
      if nAt > 0
         ::DrawLine( .F. )
         ::aSelected[ nAt ] := Atail( ::aSelected )
         Asize( ::aSelected, Len( ::aSelected ) - 1 )
      else
         Aadd( ::aSelected, Eval( ::bBookMark ))
         ::DrawLine( .T. )
      endif

   case nOperation == 3
      uBook   := Eval( ::bBookMark )
      uCurRow := ::KeyNo()
      if ::lSqlRDD
         uCurRow  := ( ::cAlias )->( IfNil( OrdKeyVal(), "" ) + Str( RecNo() ) )
      endif
      Eval( ::bBookMark,  Atail( ::aSelected ) )
      uOldRow := ::KeyNo()
      if ::lSqlRDD
         uOldRow  := ( ::cAlias )->( IfNil( OrdKeyVal(), "" ) + Str( RecNo() ) )
      endif
      if uOldRow <> uCurRow
         ::aSelected := { Atail( ::aSelected ) }
         if uCurRow > uOldRow
            CursorWait()
            while ( uTemp := Eval( ::bBookMark ) ) <> uBook .AND. ! ::Eof()
               If Ascan( ::aSelected, uTemp ) == 0
                  Aadd( ::aSelected, uTemp )
               Endif
               ::Skip( 1 )
            enddo
            CursorArrow()
         else
            CursorWait()
            while ( uTemp := Eval( ::bBookMark ) ) <> uBook .AND. ! ::Bof()
               If Ascan( ::aSelected, uTemp ) == 0
                  Aadd( ::aSelected, uTemp )
               endif
               ::Skip( -1 )
            enddo
            CursorArrow()
         endif
         Aadd( ::aSelected, uBook )
         Eval( ::bBookMark, uBook )

         ::GetDC()
         ::Paint()
         ::ReleaseDC()

      else
         Eval( ::bBookMark, uBook )
      endif

   case nOperation == 4
      uBook       := Eval( ::bBookMark )
      ::aSelected := Array( ::KeyCount() )
      nAt         := 1
      nLen        := ::nLen
      aTemp       := ::aSelected
      CursorWait()
      Eval( ::bGotop )
      while nAt <= nLen
         aTemp[ nAt++ ] := Eval( ::bBookMark )
         ::Skip( 1 )
      enddo
      Eval( ::bBookMark, uBook )
      CursorArrow()

      ::GetDC()
      ::Paint()
      ::ReleaseDC()

   case nOperation == 5
      uBook = Eval( ::bBookMark )
      nAt = Ascan( ::aSelected, uBook )
      if nAt == 1 .AND. Len( ::aSelected ) == 1
         return nil
      elseif nAt == 0
         Aadd( ::aSelected, uBook )
         ::DrawLine( .T. )
      else
         if nAt <> Len( ::aSelected )
            Asize( ::aSelected, Len( ::aSelected ) - 1 )
            ::Refresh()
         endif
      endif

   end

   if ::bOnMultiSelect <> nil
      Eval( ::bOnMultiSelect, Self, nOperation )
   endif

return nil



static FUNCTION TXBrowse_Seek( cSeek ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local uBook, uSeek
   local nFor, nRows, lRet := .F.
   local lRefresh

   if ::bSeek == nil
      return lRet
   endif

   if ::lIncrFilter
      if ValType( cSeek ) == "C"
         uBook    := ::BookMark
         if Eval( ::bSeek, cSeek, @uSeek )
            lRet     := .T.
            if Empty( uSeek )
               ::Refresh( .T. )

                  ::Change( .T. )

            else
               ::BookMark  := uSeek
               ::Refresh()
            endif
            ::cSeek     := cSeek
            if ::oSeek <> nil
               ::oSeek:SetText( cSeek )
            endif
         else
            Eval( ::bSeek, ::cSeek )
            ::BookMark  := uBook
         endif
      endif

      return lRet

   endif

   If cSeek == nil
      if ! Empty( ::cSeek )
         ::cSeek := ""
         If ::oSeek <> nil
            ::oSeek:SetText( "" )
         Endif
      endif
      return lRet
   Endif

   uBook := ::BookMark

   if !Eval( ::bSeek, cSeek )
      ::BookMark  := uBook
      MsgBeep()
      return lRet
   endif

   lRet     := .T.
   ::cSeek  := cSeek
   uSeek    := ::BookMark
   if ::oSeek <> nil
      ::oSeek:SetText( cSeek )
   endif
   if uSeek == uBook

      return .T.
   endif
   nRows    := ::nDataRows
   lRefresh := .T.


   ::BookMark  := uBook
   ::DrawLine( .F. )
   ::Skip( 1 - ::nRowSel )

   for nFor := 1 to nRows
      if ::BookMark == uSeek
         lRefresh := .F.
         exit
      endif
      if ::Skip( 1 ) == 0
         exit
      endif
   next

   if lRefresh
      ::BookMark  := uSeek
      ::Change( .T. )

      ::Refresh()
   else
      if ! ::FullPaint
         ::BookMark  := uBook
         ::DrawLine( .F. )
      endif
      ::nRowSel   := nFor
      ::BookMark  := uSeek
      ::Change( .T. )
      if ::FullPaint
         ::Super:Refresh( .F. )
      else
         ::DrawLine( .T. )
      endif
   endif

   if ::oVScroll <> nil
      ::VSetPos( ::KeyNo() )
   endif

return lRet



static FUNCTION TXBrowse_SetColumns( nRow, nCol, nFlags ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oMenu, oCol
   local nFor, nLen

   nLen := Len( ::aCols )

   oMenu := MenuBegin( .T.,,, .F., .F.,,,,,,,,,, .F.,, .F., .F., .F., .T.,, ,,,,,, .F.,, .F., .F.,,,,,,,,,, .F.,,,,,, )
      if ::l2007
         if WndMain() <> nil .AND. WndMain():oMenu <> nil .AND. WndMain():oMenu:l2010
            oMenu:l2010    := .T.
         else
            oMenu:l2007    := .T.
         endif
      endif
      for nFor := 1 to nLen
         oCol := ::aCols[ nFor ]


         MenuAddItem( oCol:cHeader, , !oCol:lHide,  ( Len(::aDisplay) <> 1 .OR. ocol:nPos <> 1 ),  GenMenuBlock( ::aCols, nFor ) )
      next
   MenuEnd()

   oMenu:Activate( nRow, nCol, Self, ! .F., )

return nil



static FUNCTION TXBrowse_GoNextCtrl( hWnd ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol
   local aCols
   local nCol, nNextPos, n
   local lDir := .F.
   local nI
   local nOldMove

   If hWnd <> Nil
      If ::nLastKey == 9
         PostMessage(hWnd, 256, 13)
      Endif
      return nil
   Endif

   if ::nColSel == ::nLastEditCol
      ::nLastEditCol := 0

      if ::nLastKey == 40
         ::Select( 0 )
         ::GoDown()
         ::Select( 1 )
      elseif ::nLastKey == 38
         ::Select( 0 )
         ::GoUp()
         ::Select( 1 )
      else
         if ::lFastEdit

               DO CASE
               CASE ::nMoveType == 6

                  nNextPos    := 0
                  if ::nColSel < Len( ::aDisplay )
                     nNextPos := AScan( ::aDisplay, { |i| ::aCols[ i ]:lEditable }, ::nColSel + 1 )
                  endif
                  if nNextPos > 0
                     if ::IsDisplayPosVisible( nNextPos, .T. )
                        ::nColSel   := nNextPos
                        if ::FullPaint()
                           ::Super:Refresh( .T. )
                        else
                           ::DrawLine( .T. )
                        endif
                     else
                        for n := ::nColSel + 1 to nNextPos
                           ::GoRight()
                        next
                     endif
                  elseif ::KeyNo() < ::nLen .OR. ::lAutoAppend

                     ::GoLeftMost()
                     ::Select( 0 )
                     ::GoDown()
                     ::Select( 1 )

                     if ! ::SelectedCol():lEditable
                        nNextPos := AScan( ::aDisplay, { |i| ::aCols[ i ]:lEditable  }, ::nColSel + 1 )

                        if nNextPos > ::nColSel
                           if ::IsDisplayPosVisible( nNextPos, .T. )
                              ::nColSel   := nNextPos
                              ::DrawLine( .T. )
                           else
                              for n := ::nColSel to nNextPos - 1
                                 ::GoRight()
                              next
                           endif
                        endif
                     endif
                  endif


               CASE ::nMoveType == 1
                  nNextPos    := ::nColSel + 1
                  if !::IsDisplayPosVisible( nNextPos, .T. )
                     ::GoLeftMost()
                     if ::nDataRows > ::nRowSel
                      ::GoDown()
                     endif
                  else
                     ::GoRight()
                  endif
               CASE ::nMoveType == 7
                  nNextPos    := ::SelectedCol():nCreationOrder  - 1
                  nI := nNextPos
                  if nNextPos > 0
                     while ::aCols[ nI ]:nEditType < 1
                        if ( --nI ) == 0
                           exit
                        endif
                     enddo
                  endif

                  nNextPos := ascan(::aDisplay,{|i| i = nI } )

                  if nNextPos > 0
                     if ::IsDisplayPosVisible( nNextPos, .T. )
                        ::nColSel   := nNextPos
                        if ::FullPaint()
                           ::Super:Refresh( .T. )
                        else
                           ::DrawLine( .T. )
                        endif
                     endif
                  else
                     if nI > 0
                        for n := ::aDisplay[ ::nColSel ] - 1 to nI step -1
                           ::GoLeft()
                        next
                     else
                        ::GoRightMost()
                        nI := len( ::aCols )
                        while ::aCols[ nI ]:nEditType < 1
                           if ( --nI ) == 0
                              exit
                           endif
                        enddo

                        nNextPos := ascan( ::aDisplay, { | i | i == nI } )
                        if nNextPos > 0
                           if ::IsDisplayPosVisible( nNextPos, .T. )
                              ::nColSel   := nNextPos
                              ::DrawLine( .T. )
                           else
                              for n := ::aDisplay[ ::nColSel ] - 1 to nI step -1
                                 ::GoLeft()
                              next
                           endif
                           if ::nDataRows > 1
                              ::GoUp()
                           endif
                        endif
                      endif
                  endif

               CASE ::nMoveType == 2
                  nNextPos  := ::aDisplay[ ::nColSel ] - 1
                  if nNextPos > 0
                     ::GoLeft()
                  else
                     ::GoRightMost()
                     if ::nRowSel > 1
                      ::GoUp()
                     endif
                  endif

               CASE ::nMoveType == 4

                  if ::KeyNo() < ::nLen .OR. ::lAutoAppend
                     ::Select( 0 )
                     ::GoDown()
                     ::Select( 1 )
                  endif

               CASE ::nMoveType == 3
                  ::GoUp()
                  ::refresh()

            ENDCASE
         else
         nOldMove := ::nMoveType
         if ::nMoveType == 7 .OR. ::nMoveType == 6
            ::nMoveType := 5
         endif

         DO CASE
            CASE ::nMoveType == 1
               ::GoRight()
               ::refresh()

            CASE ::nMoveType == 2
                ::GoLeft()
                ::refresh()

            CASE ::nMoveType == 4
                ::GoDown()
                ::refresh()

            CASE ::nMoveType == 3
               ::GoUp()
               ::refresh()
            ENDCASE
            ::nMoveType := nOldMove
         endif
      endif
   endif

return nil



static FUNCTION TXBrowse_SelFont( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCol

   ::Super:SelFont()
   for each oCol in ::aCols
      WITH OBJECT oCol
         :oDataFont     := ::oFont
         :oHeaderFont   := ::oFont
         :oFooterFont   := ::oFont
      END
   next

   ::Refresh()

return nil



static FUNCTION TXBrowse_FontSize( nPlus ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oFont, n

   if ::lCreated .AND. ::oFont:nInpHeight < 0

      If( nPlus == nil, nPlus := 1, ) ;

      oFont := TFont():New( ::oFont:cFaceName, 0, ::oFont:nInpHeight - nPlus,,,,,,,,,,,,,, )

      ::SetFont( oFont )

      for n = 1 to Len( ::aCols )

         if ValType( ::aCols[ n ]:oDataFont ) == "O"
            ::aCols[ n ]:oDataFont := oFont



            ::aCols[ n ]:nWidth    := Max( Max( ::aCols[ n ]:HeaderWidth(), ::aCols[ n ]:FooterWidth() ), ::aCols[ n ]:DataWidth() ) +  6
         endif

      next

      ::Refresh()

   endif

return nil



static FUNCTION TXBrowse_ClpRow( lFullRow, aCols ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local n, RetVal := ""

   If( lFullRow == nil, lFullRow := ( ::nMarqueeStyle >= 4 ) .OR. aCols <> nil, ) ;
   If( aCols == nil, aCols := ::GetVisibleCols(), ) ;

   if lFullRow
      for n := 1 to Len( aCols )
         RetVal += StrTran( StrTran( aCols[ n ]:ClpText, Chr(13)+Chr(10), " ; " ), Chr(9), " " ) + Chr( 9 )
      next
   else
      RetVal := StrTran( StrTran( ::SelectedCol():ClpText, Chr(13)+Chr(10), " ; " ), Chr(9), " " )
   endif

return RetVal



static FUNCTION TXBrowse_Copy( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oClip
   local cText
   local uBm, n, aSel

   if Empty( ::aSelected )
      cText       := ::ClpRow()
   else
      aSel     := AClone( ::aSelected )
      ubm      := Eval( ::bBookMark )
      cText    := ""
      for n := 1 to Len( aSel )
         Eval( ::bBookMark, asel[ n ] )
         if n > 1
            cText    += Chr(13)+Chr(10)
         endif
         cText       += ::ClpRow()
      next
      Eval( ::bBookMark, ubm )
   endif

   oClip := TClipBoard():New( 1, ::oWnd )
   if oClip:Open()
      oClip:SetText( cText )
      oClip:Close()
   endif
   oClip:End()

return cText



static FUNCTION TXBrowse_Paste( cText ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oClp, aText, nRows, nCols, n, j, uBm

   if cText == nil
      oClp := TClipBoard():New( Upper("TEXT"), ::oWnd )
      cText    := oClp:GetText()
      if ! Empty( cText )
        oClp:Clear()
      endif
      oClp:End()
   endif

   if Empty( cText )
      return nil
   endif

   if ::bPaste <> nil
      Eval( ::bPaste, Self, cText )
      return nil
   endif

   if ( Chr(13)+Chr(10) $ cText .OR. Chr(9) $ cText )
      aText    := ClipTextAsArray( cText )
      if Len( aText ) == 1 .AND. Len( aText[ 1 ] ) == 1
         ::SelectedCol():Paste( aText[ 1 ][ 1 ] )
         return nil
      endif
      if ::nDataType == 2
         If Empty( ::aArrayData )
            for n := 1 to Len( aText )
               AEval( aText[ n ], { |c,i| aText[ n, i ] := uCharToVal( c ) } )
            next
            ::aCols     := {}
            ::SetArray( aText )
            ::Refresh( .T. )
         else
            nCols    := Min( Len( aText[ 1 ] ), Len( ::aDisplay ) - ::nColSel + 1 )
            if ::nColSel == 1 .AND. ::lAutoAppend
               nRows := Len( aText )
               if ::nLen < nRows + ::nArrayAt - 1
                  ArrayResize( ::aArrayData, nRows + ::nArrayAt - 1 )
                  ::KeyCount()
               endif
            else
               nRows := Min( Len( aText ), ::nLen - ::nArrayAt + 1 )
            endif
            uBm      := ::nArrayAt
            for n := 1 to nRows
               for j := 1 to nCols
                  ::aCols[ ::aDisplay[ j + ::nColSel - 1 ] ]:Paste( aText[ n, j ] )
               next
               ::nArrayAt++
            next
            ::nArrayAt  := uBm
            ::Refresh()
         endif
      else
         uBm      := Eval( ::bBookMark )
         nCols    := Min( Len( aText[ 1 ] ), Len( ::aDisplay ) - ::nColSel + 1 )
         nRows    := Len( aText )
         n        := 1
         while n <= nRows
            for j := 1 to nCols
               ::aCols[ ::aDisplay[ j + ::nColSel - 1 ] ]:Paste( aText[ n, j ] )
            next
            if ::Skip( 1 ) < 1
               exit
            endif
            n++
         enddo
         Eval( ::bBookMark, uBm )
         if nRows == 1
            ::RefreshCurrent()
         else
            ::Refresh()
         endif
      endif
   else
      ::SelectedCol():Paste( cText )
      ::RefreshCurrent()
   endif

   ::MakeTotals()
   ::RefreshFooters()

return nil



static FUNCTION TXBrowse_Eval( bBlock, bFor, bWhile, nNext, nRec, lRest ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local lFromTop    := bWhile == nil .AND. nNext == nil .AND. nRec == nil .AND. Empty( lRest )
   local uBookMark
   local nRow        := 0


   If( bBlock == nil, bBlock := { || nil }, ) ; If( bFor == nil, bFor := { || .T. }, ); If( bWhile == nil, bWhile := { || .T. }, ); If( nNext == nil, nNext := ::nLen, ); If( nRec == nil, nRec := 0, ); If( lRest == nil, lRest := .T., );

   uBookMark      := ::BookMark
   if lFromTop
      ::GoTop()
   endif
   if nRec > 0
      ::BookMark  := nRec
      Eval( bBlock, Self )
   else
      while ( ::cAlias )->( Eval( bWhile, Self ) )
         nRow++
         if ( ::cAlias )->( Eval( bFor, Self ) )
            ( ::cAlias )->( Eval( bBlock, Self ) )
         endif
         if nRow >= nNext .OR. ::GoDown() < 1
            exit
         endif
      enddo
   endif
   ::BookMark     := uBookMark
   ::Refresh()

return Self



static FUNCTION TXBrowse_MakeTotals( aCols ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local uBm, n, nCols, oCol, nValue
   local bCond    := { |u,o| u <> nil }

   if aCols == nil
      aCols    := {}
      for each oCol in ::aCols
         WITH OBJECT oCol
            if ValType( :nTotal ) == "N" .OR. ! Empty( :nFooterType )
               AAdd( aCols, oCol )
            endif
         END
      next
   else
      if ValType( aCols ) == "O"
         aCols := { aCols }
      endif
      for n := 1 to Len( aCols )
         if Empty( aCols[ n ]:nFooterType )
            ADel( aCols, n )
            ASize( aCols, Len( aCols ) - 1 )
         endif
      next
   endif

   if ! Empty( aCols )

      for each oCol in aCols
         WITH OBJECT oCol
            If( :nFooterType == nil, :nFooterType := 1, ) ;
            :nTotal := :nTotalSq := 0.0
            :nCount := 0
            if :nFooterType == 2 .OR. :nFooterType == 4
               :nTotal := nil
            endif
         END
      next

      nCols    := Len( aCols )
      uBm      := ::BookMark()
      Eval( ::bGoTop )
      while .T.
         for each oCol in aCols
            WITH OBJECT oCol
               nValue   := :Value
               if Eval( IfNil( :bSumCondition, bCond ), nValue, oCol )

                  if :nFooterType == 8
                     :nCount++
                  elseif ValType( nValue ) == "N"
                     if :nFooterType == 2
                        :nTotal  := If( :nTotal == nil, nValue, Min( nValue, :nTotal ) )
                     elseif :nFooterType == 4
                        :nTotal  := If( :nTotal == nil, nvalue, Max( nValue, :nTotal ) )
                     else
                        :nTotal  += nValue
                        :nCount++
                        if lAnd( :nFooterType, 1 + 8 + 16 )
                           :nTotalSq   += ( nValue * nValue )
                        endif
                     endif
                  endif
               endif
            END
         next
      if ( ::Skip( 1 ) < 1 ); exit; end; end

      ::BookMark( uBm )

   endif

return Self



static FUNCTION TXBrowse_Report( cTitle, lPreview, lModal, bSetUp, aGroupBy, cPDF ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oRep, oPrn, oFont, oBold, uRet
   local aCols, nFor, oCol, uBookMark
   local oBrw := Self
   local lAddCols := .T.
   local nRows, nSel, n
   local lEof     := .F.
   local lSetUpTwice := .F.
   local nLevels

   If( cTitle == nil, cTitle := If( ::oWnd:ClassName == "TPANEL", ::oWnd:oWnd:cTitle, ::oWnd:cTitle ), ) ;
   If( lPreview == nil, lPreview := .T., ) ;
   If( lModal == nil, lModal := .T., ) ;

   if ::nLen < 1 .OR. Empty( ::GetVisibleCols )
      return nil
   endif






   oPrn :=  PrintBegin( cTitle,  .F.,  lPreview, nil,  lModal,  .F.,     cPDF )

   if oPrn:hDC == 0
       return .F.
   endif

   if ValType( aGroupBy ) $ "ON"
      aGroupBy    := { aGroupBy }
   endif

   oFont := TFont():New( "TAHOMA", 0, - 8,,,,,,,,,,,,,, )
   oBold := TFont():New( "TAHOMA", 0, - 8,, .T.,,,,,,,,,,,, )




   oRep := RptBegin({{|| cTitle}}, {}, {{|| "Page : " + cValToChar( oRep:nPage )}}, {oFont,oBold}, {}, .F.,,,, .F.,, oPrn,,,, UPPER("CENTER"), )

   if ::oTree <> nil
      nLevels     := ::oTree:Levels()
      oRep:Cargo  := Array( nLevels - 1 )
      ::oTree:OpenAll()

   endif

   if ! Empty( bSetUp )
      uRet := Eval( bSetUp, oRep, Self, 1 )
      if ValType( uRet ) == "L" .AND. uRet
         lAddCols := .F.
      elseif ValType( uRet ) == "N" .AND. uRet == 2
         lSetUpTwice := .T.
      endif
   endif

   if lAddCols

      aCols  := ::GetVisibleCols()

      if ValType( aGroupBy ) == "A"
         for nFor := 1 to Len( aGroupBy )
            if ValType( aGroupBy[ nFor ] ) == "N"
               aGroupBy[ nFor ] := aCols[ aGroupBy[ nFor ] ]
            endif
         next
      else
         aGroupBy := {}
      endif

      for nFor := 1 to Len( aCols )
         if AScan( aGroupBy, { |o| o:nCreationOrder == aCols[ nFor ]:nCreationOrder } ) == 0
            oCol := MakeRepCol( oRep, aCols[ nFor ] )
         endif
      next
      if ::oTree == nil
         for n := 1 to Len( aGroupBy )
            MakeRepGroup( aGroupBy[ n ] )
         next
      else
         for n := 1 to nLevels - 1
            MakeRepTreeGroup( oBrw, oRep, n )
         next
      endif
   endif

   RptEnd()

   if lSetUpTwice
      Eval( bSetUp, oRep, Self, 2 )
   endif

   uBookMark := Eval( ::bBookMark )

   if Len( ::aSelected ) > 1
       Eval( ::bBookMark, ::aSelected[ 1 ] )
       nRows        := Len( ::aSelected )
       nSel         := 1
       oRep:bSkip   := { || nSel++, Eval( oBrw:bBookMark, oBrw:aSelected[ min( nSel, nRows ) ] ) }
   else
      Eval( ::bGoTop )
      nRows           := Eval( ::bKeyCount )
      oRep:bSkip   := { |n| lEof := ( Eval( oBrw:bSkip, n ) <> n ) }

   endif
   oRep:bWhile      := { || oRep:nCounter < nRows .AND. ! lEof }
   oRep:bEnd        := ::bGoTop
   oRep:bToExcel       := { || oBrw:ToExcel( nil, If( Empty( aGroupBy ), nil, 1 ) ) }

   if ::oTree <> nil



      oRep:bFor      := { || If( ::oTreeItem:nLevel < nLevels,  oRep:Cargo[ ::oTreeItem:nLevel ] := ::oTreeItem:cPrompt, ),  ::oTreeItem:nLevel == nLevels }
   endif

   ( ::cAlias )->( oRep:Activate() )

   if ::oTree <> nil
      ::oTree:Collapse()
   endif

   Eval( ::bGoTop )
   Eval( ::bBookMark, UBookMark )

   ::Refresh()
   ::SetFocus()

   oFont:End() ; oFont := nil
   oBold:End() ; oBold := nil

return Self



static FUNCTION TXBrowse_ToExcel( bProgress, nGroupBy, aCols ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oExcel, oBook, oSheet, oWin
   local nCol, nXCol, oCol, cType, uValue, nAt, cFormula
   local uBookMark, nRow
   local nDataRows
   local oClip, cText, nPasteRow, nStep, cFormat
   local aTotals  := {}, lAnyTotals := .F.
   local aWidths  := {}
   local lContinue   := .T.

   if lExcelInstl == .F.

      if lCalcInstl == .F.

         return Self
      else
         return ::ToCalc( bProgress, nGroupBy,,, aCols )
      endif
   endif

   nDataRows   := EVAL( ::bKeyCount )
   if nDataRows == 0
      return Self
   endif

   If( aCols == nil, aCols := ::GetVisibleCols(), ) ;

   if Empty( aCols )
      return Self
   endif

   if ( oExcel := ExcelObj() ) == nil
      lExcelInstl := .F.
      if lCalcInstl == .F.
         Msgstop( FWString( "Excel not installed" ), FWString( "Alert" ) )
         return Self
      else
         return ::ToCalc( bProgress, nGroupBy, , , aCols )
      endif
   endif
   lExcelInstl    := .T.

   if nxlLangID == nil
      SetExcelLanguage( oExcel )
   endif

   oExcel:ScreenUpdating := .F.
   oBook   := oExcel:WorkBooks:Add()
   oSheet   := oExcel:ActiveSheet

   uBookMark   := EVAL( ::bBookMark )

   nRow     := 1
   nCol     := 0
   aWidths  := Array( Len( aCols ) )

   for nXCol := 1 TO Len( aCols )
      oCol   := aCols[ nXCol ]

      nCol ++

      oSheet:Cells( nRow, nCol ):Value   := oCol:cHeader
      cType      := oCol:cDataType

      if ::nDataType <> 2
         DO CASE
         CASE Empty( cType )

         CASE cType == "N"
            cFormat     := Dbf2ExcelNumFormat( oCol:cEditPicture )
            oSheet:Columns( nCol ):NumberFormat := cFormat
            oSheet:Columns( nCol ):HorizontalAlignment := - 4152

         CASE cType == "D"
            if lxlEnglish
              if ValType( oCol:cEditPicture ) == "C" .AND. Left( oCol:cEditPicture, 1 ) <> "@"
                 oSheet:Columns( nCol ):NumberFormat := Lower( oCol:cEditPicture )
              else
                 oSheet:Columns( nCol ):NumberFormat := Lower( Set( 4 ) )
              endif
              oSheet:Columns( nCol ):HorizontalAlignment := - 4152
            endif
         CASE cType $ "LPFM"

         OTHERWISE
            if ::nDataType <> 2
               oSheet:Columns( nCol ):NumberFormat := "@"
               if ! Empty( oCol:nDataStrAlign )
                  oSheet:Columns( nCol ):HorizontalAlignment := If( lAnd( oCol:nDataStrAlign, 2 ), -4108, -4152 )
               endif
            endif
         ENDCASE
      endif

      if cType <> nil .AND. cType $ "PFM"
         aWidths[ nCol ]                     := oCol:nWidth / 7.5
         oSheet:Columns( nCol ):ColumnWidth  := aWidths[ nCol ]
         oSheet:Rows( "2:" + LTrim(Str( ::nLen + 1 )) ):RowHeight := ::nRowHeight
         if cType == "M"
            oSheet:Columns( nCol ):WrapText  := .T.
         endif
      endif

   next

   oSheet:Range( oSheet:Cells( 1, 1 ), oSheet:Cells( 1, Len( aCols ) ) ):Select()

   oExcel:Selection:Borders(9):LineStyle := 1
   oExcel:Selection:Borders(9):Weight    := -4138

   if Empty( ::aSelected ) .OR. Len( ::aSelected ) == 1

      Eval( ::bGoTop )
      if ::oRs <> nil .AND. Len( aCols ) == ::oRs:Fields:Count()
            ::oRs:MoveFirst()
            nRow   := oSheet:Cells( 2, 1 ):CopyFromRecordSet( ::oRs )
            ::oRs:MoveFirst()
         nRow   += 2
      else

         if bProgress == nil
            if ::oWnd:oMsgBar == nil
               bProgress := { || nil }
            else

               bProgress := { | n, t | ::oWnd:SetMsg( FWString( "To Excel" ) +  " : " + Ltrim( Str( n ) ) + "/" + Ltrim( Str( t ) ) ) }
            endif
         endif

         nRow      := 2
         nStep     := Max( 1, Min( 100, Int( nDataRows / 100 ) ) )

         if ::lExcelCellWise
            while nRow <= ( nDataRows + 1 ) .AND. lContinue

               nCol        := 0
               for nxCol   := 1 to Len( aCols )
                  oCol     := aCols[ nXCol ]
                  nCol++
                  oCol:ToExcel( oSheet, nRow, nCol )
               next

               lContinue := ( ::Skip( 1 ) == 1 )
               nRow ++
               If ( nRow - 2 ) % nStep == 0
                  if Eval( bProgress, nRow - 2, nDataRows ) == .F.
                     Exit
                  endif
                  SysRefresh()
               endif

            enddo
         else

            nPasteRow := 2
            cText     := ""
            oClip := TClipBoard():New( 1, ::oWnd )
            if oClip:Open()

               Eval( bProgress, 0, nDataRows )

               while nRow <= ( nDataRows + 1 ) .AND. lContinue
                  if ! Empty( cText )
                     cText += Chr(13)+Chr(10)
                  endif
                  cText    += ::ClpRow( .T., aCols )

                  lContinue := ( ::Skip( 1 ) == 1 )
                  nRow ++

                  if Len( cText ) > 16000
                     oClip:SetText( cText )
                     oSheet:Cells( nPasteRow, 1 ):Select()
                     oSheet:Paste()
                     oClip:Clear()
                     cText       := ""
                     nPasteRow   := nRow
                  endif

                  If ( nRow - 2 ) % nStep == 0
                     if Eval( bProgress, nRow - 2, nDataRows ) == .F.
                        Exit
                     endif
                     SysRefresh()
                  endif

               enddo
               if ! Empty( cText )
                  oClip:SetText( cText )
                  oSheet:Cells( nPasteRow, 1 ):Select()
                  oSheet:Paste()
                  oClip:Clear()
                  cText    := ""
               endif
               oClip:Close()

               Eval( bProgress, nDataRows, nDataRows )
               SysRefresh()

            endif
            oClip:End()
         endif
      endif
   else
      ::Copy()
      oSheet:Cells( 2, 1 ):Select()
      oSheet:Paste()
      nRow := Len( ::aSelected ) + 2
   endif
   oSheet:Cells( 1, 1 ):Select()



   oSheet:Rows(    1 ):Font:Bold   := .T.
   oSheet:Rows( nRow ):Font:Bold   := .T.

   if ValType( nGroupBy ) == "N"
      for nxCol := 1 TO Len( aCols )
         if aCols[ nxCol ]:lTotal
            AAdd( aTotals, nxCol )
         endif
      next
      if ! Empty( aTotals )
         oSheet:Activate()




         oExcel:Selection:Subtotal( nGroupBy , -4157,   aTotals,  .T.,  .F.,  .T. )

      endif
   else
      nCol   := 0
      oSheet:Range( oSheet:Cells( nRow, 1 ), oSheet:Cells( nRow, Len( aCols ) ) ):Select()

      oExcel:Selection:Borders(8):LineStyle := 1
      oExcel:Selection:Borders(8):Weight    := -4138

      for nXCol := 1 TO Len ( aCols )
         oCol   := aCols[ nXCol ]
         nCol ++
         if oCol:lTotal






            cFormula:= "SUBTOTAL(" +  LTrim( Str( FW_DeCode( IfNil( oCol:nFooterType, 0 ), 1, 9, 4, 4, 2, 5,  8, 3, 1 + 8, 1, 1 + 8 + 16, 7, 1 + 8 + 16 + 32, 8, 9 ) ) ) +  "," +  oSheet:Range( oSheet:Cells( 2, nCol ),  oSheet:Cells( nRow - 1, nCol ) ):Address( .F., .F. ) +  ")"
            oSheet:Cells( nRow, nCol ):Formula := "=" + ExcelTranslate( cFormula )
            lAnyTotals := .T.
         endif
      next
      if lAnyTotals
        oExcel:Selection:Borders(9):LineStyle := 1
        oExcel:Selection:Borders(9):Weight    := 4
      endif
   endif

   for nCol := 1 to Len( aCols )
      if aWidths[ nCol ] == nil
         oSheet:Columns( nCol ):AutoFit()
      endif
      oSheet:Columns( nCol ):VerticalAlignment := -4108
   next

   oSheet:Cells(1,1):Select()
   oWin   := oExcel:ActiveWindow
   oWin:SplitRow := 1
   oWin:FreezePanes := .T.



   Eval( ::bBookMark, uBookMark )
   ::Refresh()
   ::SetFocus()

   oExcel:ScreenUpdating   := .T.
   oExcel:visible          := .T.
   ShowWindow( oExcel:hWnd, 3 )
   BringWindowToTop( oExcel:hWnd )

return oSheet



static FUNCTION TXBrowse_ToCalc( bProgress, nGroupBy, nPasteMode, aSaveAs, aCols ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oCalc, oDeskTop,oBook, oSheet, oWin, oLocal, oDispatcher
   local nCol, nXCol, oCol, cType, uValue, nAt
   local uBookMark, nRow
   local nDataRows
   local oClip, cText, nPasteRow, nStep, cFormat,cFileName,cURL,i
   local aTotals  := {}, lAnyTotals := .F. , aProp:={} , aOOFilters:={} , nPos, oCharLocale
   local lContinue := .T.

   if lCalcInstl == .F.

      if lExcelInstl == .F.

      else
         return ::ToExcel( bProgress, nGroupBy, aCols )
      endif
   endif

   If( nPasteMode == nil, nPasteMode := 2, ) ;
   If( aSaveAs == nil, aSaveAs := {}, ) ;
   nxlLangID:=0

   aOOFilters:={ {"PDF","calc_pdf_Export"},{"XLS","MS Excel 97"},{"HTML","XHTML Calc File"} }

   nDataRows   := EVAL( ::bKeyCount )
   if nDataRows == 0
     nxlLangID:=nil
     return nil
   endif

   If( aCols == nil, aCols := ::GetVisibleCols(), ) ;

   if Empty( aCols )
     nxlLangID:=nil
     return nil
   endif

   if ( oCalc := SunCalcObj() ) == nil
      lCalcInstl  := .F.
      if lExcelInstl == .F.

         Msgstop( FWString( "No spreadsheet software installed" ), FWString( "Alert" ) )
         return Self
      else
         return ::ToExcel( bProgress, nGroupBy, aCols )
      endif
   endif
   lCalcInstl := .T.

   lxlEnglish:=.T.

   oDesktop := oCalc:CreateInstance( "com.sun.star.frame.Desktop" )


   aProp:={}
   AAdd(aProp,GetPropertyValue(oCalc, "Hidden", .T. )  )
   oBook    := oDesktop:LoadComponentFromURL( "private:factory/scalc", "_blank", 0, aProp )
   oSheet   := oBook:GetSheets():GetByIndex( 0 )
   oDispatcher:= oCalc:CreateInstance( "com.sun.star.frame.DispatchHelper" )


   oCharLocale = oBook:GetPropertyValue("CharLocale")
   IF oCharLocale:Language == "de"
      cxlSum:="=SUMME("
   ELSEIF oCharLocale:Language == "fr"
      cxlSum:="=SOMME("
   ELSEIF oCharLocale:Language == "es"
      cxlSum:="=SUMA("
   ELSEIF oCharLocale:Language == "pt"
      cxlSum:="=SOMA("
   ELSEIF oCharLocale:Language == "it"
      cxlSum:="=SOMMA("
   ELSE
      cxlSum:="=SUM("
   ENDIF


   oBook:addActionLock()
   oBook:LockControllers()

   uBookMark   := EVAL( ::bBookMark )

   nRow   := 1
   nCol   := 0
   for nXCol := 1 TO Len( aCols )
      oCol   := aCols[ nXCol ]

      nCol ++

      oSheet:GetCellByPosition( nCol-1, nRow-1 ):SetString( oCol:cHeader )
      cType      := oCol:cDataType

      DO CASE
         CASE cType == "N"

            cFormat     := If( FWNumFormat()[ 2 ], If( lxlEnglish, "#,##0", "#.##0" ), "0" )
            if oCol:cEditPicture <> nil
               if "." $ oCol:cEditPicture


                  cFormat  += If( lXlEnglish, ".", "," ) + StrTran(  StrTran( SubStr( oCol:cEditPicture,  At( ".", oCol:cEditPicture ) + 1 ), "9", "0" ), "#", "0" )
               endif
               if ( nAt := At( " ", cFormat ) ) > 0
                  cFormat  := Left( cformat, nAt ) + '"' + SubStr( cFormat, nAt + 1 ) + '"'
               endif
            endif
            oSheet:GetColumns():GetByIndex( nCol-1 ):NumberFormat:=GetNumberFormatId(oBook, cFormat, cType)
            oSheet:GetColumns():GetByIndex( nCol-1 ):HoriJustify = 3

         CASE cType == "D"
            if lxlEnglish
              if ValType( oCol:cEditPicture ) == "C" .AND. Left( oCol:cEditPicture, 1 ) <> "@"
                 oSheet:GetColumns():GetByIndex( nCol-1 ):NumberFormat:=GetNumberFormatId(oBook,  oCol:cEditPicture, oCol:cHeader, cType )
              else
                 oSheet:GetColumns():GetByIndex( nCol-1 ):NumberFormat:=GetNumberFormatId(oBook,   Set( 4 ), oCol:cHeader, cType  )
              endif
              oSheet:GetColumns():GetByIndex( nCol-1 ):HoriJustify = 3
            endif
         CASE cType == "L"

         OTHERWISE

      ENDCASE

   next

   oBook:CurrentController:select( oSheet:GetCellRangeByPosition( 0, 0, Len( aCols )-1,0 ) )
   oSheet:getCellByPosition(0,0):Rows:Height=750


   aProp:={}
   AAdd(aProp,GetPropertyValue(oCalc, "OuterBorder.BottomBorder", {0,0,2,0}  )        )
   oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:SetBorderStyle", "", 0, aProp)


   aProp:={}
   AAdd(aProp,GetPropertyValue(oCalc, "Bold", .T.  )        )
   oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:Bold", "", 0, aProp)


   aProp:={}





    if Empty( ::aSelected ) .OR. Len( ::aSelected ) == 1

      Eval( ::bGoTop )

      if bProgress == nil
         if ::oWnd:oMsgBar == nil
            bProgress := { || nil }
         else

            bProgress := { | n, t | ::oWnd:SetMsg( FWString( "To Calc" ) + " : " +  Ltrim( Str( n ) ) + "/" + Ltrim( Str( t ) ) ) }
         endif
      endif

      nRow      := 2
      nPasteRow := 2
      nStep     := Max( 1, Min( 100, Int( nDataRows / 100 ) ) )
      cText     := ""
      oClip := TClipBoard():New( 1, ::oWnd )
      if oClip:Open()

         Eval( bProgress, 0, nDataRows )
         while nRow <= ( nDataRows + 1 ) .AND. lContinue
            if ! Empty( cText )
               cText += Chr(13)
            endif
            cText    += ::ClpRow( .T. )

            lContinue := ( ::Skip( 1 ) == 1 )
            nRow ++

            if Len( cText ) > 16000
               oClip:SetText( cText )
               oBook:CurrentController:select( oSheet:GetCellByPosition( 0,nPasteRow-1 ) )
               IF nPasteMode == 2
                  oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:Paste", "", 0, aProp)
               else
                  PasteUnformattedText(oCalc,oBook,oSheet,aCols)
               Endif
               oClip:Clear()
               cText       := ""
               nPasteRow   := nRow
            endif

            If ( nRow - 2 ) % nStep == 0
               if Eval( bProgress, nRow - 2, nDataRows ) == .F.
                  Exit
               endif
               SysRefresh()
            endif

         enddo
         if ! Empty( cText )
            oClip:SetText( cText )
            oBook:CurrentController:select( oSheet:GetCellByPosition( 0,nPasteRow-1 ) )
            IF nPasteMode == 2
               oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:Paste", "", 0, aProp)
            else
               PasteUnformattedText(oCalc,oBook,oSheet,aCols)
            Endif
            oClip:Clear()
            cText    := ""
         endif
         oClip:Close()

         Eval( bProgress, nDataRows, nDataRows )
         SysRefresh()

      endif
      oClip:End()

   else
      ::Copy()
      oBook:CurrentController:select( oSheet:GetCellByPosition( 2,1 ) )
      IF nPasteMode == 2
         oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:Paste", "", 0, aProp)
      else
         PasteUnformattedText(oCalc,oBook,oSheet,aCols)
      Endif
      nRow := Len( ::aSelected ) + 2
   ENDIF

   nCol   := 0 ; nRow:=nRow-2
   oBook:CurrentController:select( oSheet:GetCellRangeByPosition( 0, nRow, Len( aCols )-1,nRow ) )


   aProp:={}
   AAdd(aProp,GetPropertyValue(oCalc, "OuterBorder.BottomBorder", {1,1,2,1}  )        )
   oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:SetBorderStyle", "", 0, aProp)

   if ValType( nGroupBy ) == "N"
      for nxCol := 1 TO Len( aCols )
         if aCols[ nxCol ]:lTotal
            AAdd( aTotals, nxCol )
         endif
      next
      if ! Empty( aTotals )
         CalcSubTotal(oCalc,oBook,oSheet,nGroupBy,aTotals,nRow,Len(aCols)-1)
      Endif
   else


      for nXCol := 1 TO Len ( aCols )
         oCol   := aCols[ nXCol ]
         nCol ++
         if oCol:lTotal
            oBook:CurrentController:select( oSheet:GetCellByPosition( nCol-1,nRow+1 ) )
            aProp:={}

            AAdd(aProp,GetPropertyValue(oCalc, "StringName",cxlSum+ MakeColAlphabet(nCol)+"2:"+MakeColAlphabet(nCol)+LTrim(Str(nRow+1))+")"  )  )
            oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:EnterString", "", 0, aProp)
            lAnyTotals := .T.
         endif
      next
      if lAnyTotals
         oBook:CurrentController:select( oSheet:GetCellRangeByPosition( 0, nRow+1, Len( aCols )-1,nRow+1 ) )

         aProp:={}
         AAdd(aProp,GetPropertyValue(oCalc, "OuterBorder.BottomBorder", {1,1,2,1}  )        )
         oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:SetBorderStyle", "", 0, aProp)


         aProp:={}
         AAdd(aProp,GetPropertyValue(oCalc, "Bold", .T.  )        )
         oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:Bold", "", 0, aProp)
      ENDIF
   Endif

   oBook:CurrentController:select( oSheet:GetCellByPosition( 1,1 ) )

   for nCol := 1 to Len( aCols )
     oSheet:GetColumns():GetByIndex( nCol-1 ):OptimalWidth = .T.
   next

   oBook:CurrentController:select( oSheet:GetCellByPosition( 0,1 ) )
   oDispatcher:ExecuteDispatch(oBook:GetCurrentController():GetFrame(), ".uno:FreezePanes", "", 0, {})

   Eval( ::bBookMark, uBookMark )
   ::Refresh()
   ::SetFocus()


   oBook:UnlockControllers()
   oBook:removeActionLock()


   IF Len(aSaveAs) > 0
      FOR I:=1 TO Len(aSaveAs)
         cFormat:=Upper(aSaveAs[i][1])
         cFileName:=aSaveAs[i][2]

         IF LEFT( cFilename, 1 ) <> "/"
            cFileName:= "/" + cFileName
         ENDIF

         cURL:= StrTran( cFilename, "\", "/" )
         cURL = "file://" + cURL

         aProp:={} ; nPos:=0
         nPos:=AScan(aOOFilters,{ |x| x[1] == cFormat})
         IF nPos > 0
            AAdd(aProp,GetPropertyValue(oCalc, "FilterName", aOOFilters[nPos][2])  )
            cURL:=cURL+"."+cFormat
            oBook:StoreToURL( cURL, aProp )
         Endif

      Next
   ENDIF
   oBook:GetCurrentController():GetFrame():GetContainerWindow():SetVisible(.T.)
   oBook:CurrentController:select( oSheet:GetCellByPosition( 0,0 ) )

   nxlLangID:=nil

Return Self



static FUNCTION TXBrowse_ToDbf( cFile, bProgress, aCols, lPrompt ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local aStruct  := {}
   local nKeyNo   := ::KeyNo
   local nRowPos  := ::nRowSel
   local n, uVal, c, oCol, nCols
   local nSelect

   if ::nLen < 1
      return nil
   endif

   If( lPrompt == nil, lPrompt := .F., ) ;

   if aCols == nil
      aCols    := ::GetVisibleCols()
   else
      AEval( aCols, { |u,i| aCols[ i ] := ::oCol[ u ] } )
   endif

   ::GoTop()
   nCols       := Len( aCols )

   for each oCol in aCols
      uVal     := oCol:Value
      AAdd( aStruct, { Upper( PadR( oCol:cHeader, 10 ) ), oCol:cDataType, oCol:nDataLen, oCol:nDataDec } )
      if Empty( oCol:cHeader )
         ATail( aStruct )[ 1 ]   := "COL" + StrZero( oCol:nCreationOrder, 2 )
      endif
      if Empty( c := oCol:cDataType ) .OR. !( c $ "DLMNT" )
         ATail( aStruct )[ 2 ]   := c := If( uVal == nil, "C", ValType( uVal ) )
      endif
      if Empty( oCol:nDataLen ) .OR. c $ "DTLM"
         ATail( aStruct )[ 3 ]   := HB_DeCode( c, "C", 40, "D", 8, "T", 8, "L", 1, "N", 14, 10 )
      endif
      if c == "N"
         if oCol:nDataDec == nil
            ATail( aStruct )[ 4 ]   := 0
         endif
      else
         ATail( aStruct )[ 4 ]   := 0
      endif

   next

   if lPrompt

      XBrowse( aStruct, cFile + ":STRUCTURE",, {|oBrw|(oBrw:cEditPictures := { "@!", "!", "99","99" } )},,,!.F., .T.,,, .F., .F. )
   endif

   nSelect  := Select()

   DBCREATE( cFile, aStruct )

   if bProgress == nil
      if ::oWnd:oMsgBar == nil
         bProgress := { || nil }
      else

         bProgress := { | n, t | ::oWnd:SetMsg( FWString( "To DBF" ) + " : " +  Ltrim( Str( n ) ) + "/" + Ltrim( Str( t ) ) ) }
      endif
   endif

   Eval( bProgress, 0, ::nLen )

   dbUseArea( .T.,, (cFile), "XBRTODBF", iif( .F. .OR. .T., ! .T., NIL ), .F. )
   while .T.

      XBRTODBF->( DbAppend() )
      for n := 1 to nCols
         C     := aStruct[ n ][ 2 ]
         uVal  := aCols[ n ]:Value
         if ! Empty( uVal )
            if c == "C"
               if ValType( uVal ) <> "C"
                  uVal     := cValToChar( uVal )
               endif
            elseif ValType( uVal ) == "C"
               uVal  := uCharToVal( uVal, c )
            endif
            BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
               XBRTODBF->( FieldPut( n, aCols[ n ]:Value ) )
            RECOVER

            END
         endif
      next
      Eval( bProgress, XBRTODBF->( RecNo() ), ::nLen )

   if ::Skip( 1 ) == 0; exit; end; end
   Eval( bProgress, XBRTODBF->( LASTREC() ), XBRTODBF->( LASTREC() ) )
   XBRTODBF->( dbCloseArea() )

   ::KeyNo     := nKeyNo
   ::nRowSel   := nRowPos
   ::Refresh()



   if lPrompt .AND. MsgYesNo( If( FWSetLanguage() == 2, " ", "" ) +  FWString( "View" ) + " " + cFile + " ?", FWString( "Please select" ) )
      XBrowse( cFile )
   endif

   ::SetFocus()

return nil





















static Function MakeColAlphabet( nCol )

   local cCol  := ""
   local nDigit

   while nCol > 0
      nDigit   := nCol % 26
      if nDigit == 0
         nDigit   := 26
         nCol     -= 26
      endif
      cCol     := Chr( nDigit + 64 ) + cCol
      nCol     := Int( nCol / 26 )
   enddo

return cCol



STATIC FUNCTION GetPropertyValue(oService, cName, xValue )
   LOCAL oArg
   oArg := oService:Bridge_GetStruct( "com.sun.star.beans.PropertyValue" )
   oArg:Name  := cName
   oArg:Value := xValue
RETURN oArg



STATIC Function GetNumberFormatId(oBook, cNumberFormat, cColHeader, cDataType)
  LOCAL cCharLocale,nFormatId
  cCharLocale = oBook:GetPropertyValue("CharLocale")
  IF cDataType == "D"
      cNumberFormat:=Upper(cNumberFormat)
      IF cCharLocale:Language == "es" .OR. cCharLocale:Language == "pt" .OR. cCharLocale:Language == "it"
        cNumberFormat:=StrTran(cNumberFormat,"Y","A")
      ELSEIF cCharLocale:Language == "de"
         cNumberFormat:=StrTran(cNumberFormat,"D","T")
         cNumberFormat:=StrTran(cNumberFormat,"Y","J")
      elseif cCharLocale:Language == "fr"
         cNumberFormat:=StrTran(cNumberFormat,"D","J")
         cNumberFormat:=StrTran(cNumberFormat,"Y","A")
      Endif
  Endif
  nFormatId = oBook:GetNumberFormats:QueryKey(cNumberFormat, cCharLocale, .F.)
  IF nFormatId = -1
     BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
        nFormatId = oBook:GetNumberFormats:AddNew(cNumberFormat, cCharLocale)
     RECOVER

        MsgInfo( FWString( "Could not set the format" ) + " " + cNumberFormat + " " +  FWString( "to column" ) + " " + cColHeader, FWString( "Information" ) )
        IF cDataType == "D"
           nFormatId:=37
        Endif
     END
  ENDIF

RETURN nFormatId



STATIC FUNCTION CalcSubTotal(oCalc,oBook,oSheet,nGroupBy,aTotals,nRow,nCol)

   LOCAL oRange, oSubTotDesc,oColumns,aArg:={},nCount

   FOR nCount:=1 TO Len(aTotals)
      oColumns := oCalc:Bridge_GetStruct( "com.sun.star.sheet.SubTotalColumn" )

      oColumns:Column  := aTotals[nCount]-1
      oColumns:Function :=2
      AAdd(aArg,oColumns)
   Next

   oRange:= oSheet:getCellRangeByPosition( 0, 0, nCol,nRow )
   oSubTotDesc:=oRange:createSubTotalDescriptor(.T.)


   oSubTotDesc:addNew(aArg, nGroupBy-1)
   oRange:applySubTotals(oSubTotDesc, .T.)
Return NIL



STATIC Function PasteUnformattedText(oCalc,oBook,oSheet,aCols)
  LOCAL oClipContType,oClipContent,oClip,cStr,i,nClipColNo
  LOCAL lFound,nRow,nCol,k,oCol

  oClip = oCalc:CreateInstance("com.sun.star.datatransfer.clipboard.SystemClipboard")
  oClipContType = oClip:Contents:getTransferDataFlavors

  lFound = .F. ;   i:= 1

  while i <= Len(oClipContType) .AND. !lFound
    if oClipContType[i]:HumanPresentableName = "OEM/ANSI Text"
      lFound = .T.
      k:=i
    else
      i:=i + 1
    endif
  Enddo

  if lFound

    nRow   = oBook:CurrentSelection:getRangeAddress():startrow
    oClipContent:=oClip:Contents:getTransferData( oClipContType[k] )

    i:=1 ;  cStr:="" ; nCol:=0

    while i <= Len(oClipContent)
       if oClipContent[i] = 0 .OR. oClipContent[i] = 13 .OR. oClipContent[i] = 10
        i=i+2 ; nRow:=nRow + 1 ; cStr:="" ;  nCol:=0
     ELSEIF oClipContent[i] = 9
        oCol:=aCols[nCol+1]

        IF oCol:cDataType == "C"
            oSheet:getCellByposition(nCol,nRow):SetString(cStr)
        ELSEIF oCol:cDataType == "N"
            oSheet:getCellByposition(nCol,nRow):SetValue(cStr)
        ELSEIF oCol:cDataType == "D"
           oSheet:getCellByposition(nCol,nRow):SetFormula(cStr)
        ELSE
           oSheet:getCellByposition(nCol,nRow):SetString(cStr)
        Endif
        nCol:=nCol+1 ; cStr:="" ; i:=i+1
      else
        cStr:=cStr + chr(oClipContent[i])
        i:=i+1
      endif
    Enddo

  endif
RETURN NIL



static FUNCTION TXBrowse_CurrentRow( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oRow
   local aHeaders := {}
   local aValues  := {}
   local n

   for n := 1 to Len( ::aCols )
      AAdd( aHeaders, ::aCols[ n ]:cHeader )
      AAdd( aValues,  ::aCols[ n ]:Value   )
   next

   oRow  := TXBrRow():New( Self, Eval( ::bBookMark ), ::KeyNo(), aHeaders, aValues )

return oRow



static FUNCTION TXBrowse_DataRow( lNew, cFieldList, lSourceData ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oRec
   local u

   if ValType( cFieldList ) == "L" .OR. ValType( lSourceData ) == "C"
      u           := lSourceData
      lSourceData := cFieldList
      cFieldList  := u
   endif

   If( lNew == nil, lNew := ( ::nLen == 0 ), ) ; If( lSourceData == nil, lSourceData := .F., );

   oRec  := TDataRow():New( If( lSourceData, ::uDataSource, Self ), cFieldList, lNew )
   oRec:bEdit     := ::bEdit
   oRec:bOnSave   := { || ::Refresh() }

return oRec



static FUNCTION TXBrowse_Edit( lNew, cFieldList, lSourceData ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local u

   if ValType( cFieldList ) == "L" .OR. ValType( lSourceData ) == "C"
      u           := lSourceData
      lSourceData := cFieldList
      cFieldList  := u
   endif

   ::DataRow( lNew, lSourceData, cFieldList ):Edit()
   if lSourceData == .T.
      ::Refresh()
   endif
   ::SetFocus()

return Self



static FUNCTION TXBrowse_aCellCoor( nRow, nCol ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nTop, nLeft, nBottom, nRight
   local oCol

   If( nRow == nil, nRow := ::nRowSel, ) ; If( nCol == nil, nCol := ::nColSel, );

   oCol     := ::ColAtPos( nCol )
   nTop     := ( ( nRow - 1 ) * ::nRowHeight ) + ::HeaderHeight()
   nLeft    := oCol:nDisplayCol
   nBottom  := nTop + ::nRowHeight - 1
   nRight   := nLeft + oCol:nWidth - 1

return { nTop, nLeft, nBottom, nRight }



static FUNCTION TXBrowse_CellBitmap( nRow, nCol ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local oRect    := TRect():New( ::aCellCoor( nRow, nCol ) )

return MakeBkBmpEx( ::hWnd, oRect:nTop, oRect:nLeft, oRect:nWidth, oRect:nHeight )



static FUNCTION TXBrowse_DestroyToolTip( ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

  TWindow():DestroyToolTip()
  ::oColToolTip   := nil
  ::nRowToolTip   := nil

return nil



static FUNCTION TXBrowse_NcMouseMove( nHitTestCode, nRow, nCol ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   TWindow():NcMouseMove( nHitTestCode, nRow, nCol )
   ::oColToolTip   := nil

return nil



static FUNCTION TXBrowse_OnError( uParam1 ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local cMsg   := __GetMessage()
   local nError := If( SubStr( cMsg, 1, 1 ) == "_", 1005, 1004 )
   local oCol, aRet
   local lByCreationOrder  := .T.
   local lAssign := .F.

   if Left( cMsg, 1 ) == "_"
      lAssign     := .T.
      nError      := 1005
      cMsg        := SubStr( cMsg, 2 )
   endif
   oCol           := ::oCol( cMsg )

   if oCol == nil

      if ! Empty( ::aCols ) .AND. Len( cMsg ) > 3 .AND. Upper( Right( cMsg, 1 ) ) == "S" .AND.  __ObjHasData( ::aCols[ 1 ], Left( cMsg, Len( cMsg ) - 1 ) )
         cMsg     := Left( cMsg, Len( cMsg ) - 1 )
         if lAssign
            ::SetColsData( cMsg, uParam1 )
            return uParam1
         else
            return ::GetColsData( cMsg )
         endif
      elseif lAssign .AND. ValType( uParam1 ) == "B"
         oCol              := ::AddCol()
         oCol:cHeader      := cMsg
         oCol:bEditValue   := uParam1
         if ::lCreated
            oCol:Adjust()
         endif
         return oCol
      endif
   else
      if lAssign
         if ValType( uParam1 ) == "B"
            oCol:bEditValue   := uParam1
            return uParam1
         else
            oCol:Value := uParam1
            return oCol:Value
         endif
      else
         return oCol
      endif
   endif

    _ClsSetError( _GenError( nError, ::ClassName(), cMsg ) )

return nil





static function treerecno( oItem )

   local nRec  := - 10000

   oItem:Skip( @nRec )

return -nRec



static function MakeRepCol( oRep, oXCol )

   local oCol, bData, cPic, nSize
   local cAlign







   bData := { || oXCol:Value }
   if oXCol:bEditValue <> nil
      cPic  := oXCol:cEditPicture
   endif

   if Empty( cPic )
      nSize       := oxCol:nWidthChr
   endif

   if bData <> nil


      cAlign   := If( lAnd( oXCol:nDataStrAlign, 1  ), "RIGHT",  If( lAnd( oXCol:nDataStrAlign, 2 ), "CENTER", "LEFT" ))






      oCol := RptAddColumn( { { || oXCol:cHeader } }, nil , { bData }, nSize, { cPic } , nil, oXCol:lTotal, nil , cAlign, .F., .F., nil,  oxCol:cDataType == "M", oxcol:cDataType == "P",  nil, nil, nil, oxCol:nAlphaLevel() )

   endif

return oCol



static function MakeRepGroup( oCol )

   local bData    := { || oCol:cHeader + " " + Eval( oCol:bStrData, nil, oCol ) }

   if ! Empty( bData )
       RptAddGroup( bData, bData, nil, { || 2 }, .F. )
   endif

return nil


static function MakeRepTreeGroup( oBrw, oRep, n )

   RptAddGroup( { || oRep:Cargo[ n ]  }, { || oRep:Cargo[ n ] }, nil, { || 2 },, .F. )

return nil



static function RepTreeFor( oBrw, oRep, nCols, nLevels )

   local nLevel   := oBrw:oTreeItem:nLevel

   nCols    := Len( oRep:aColumns )

   if nLevel < nLevels
      oRep:Cargo[ nLevel ] := oBrw:oTreeItem:cPrompt
   endif

return ( oBrw:oTreeItem:nLevel == nLevels )



static function AdoSkip( oRs, n )

   LOCAL nRec

   if oRs:RecordCount() == 0
      return 0
   endif

   nRec := oRs:AbsolutePosition
   If( oRs:Eof, oRs:MoveLast(), If( oRs:Bof, oRs:MoveFirst(),) )
   oRs:Move( n )
   If( oRs:Eof, oRs:MoveLast(), If( oRs:Bof, oRs:MoveFirst(),) )

return oRs:AbsolutePosition - nRec



static FUNCTION TXBrowse_ArrayIncrSeek( cSeek, nGoTo ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local nAt, nBrwCol, nSortCol, nRow, uVal
   local lExact

   if ::lIncrFilter
      return ::ArrayIncrFilter( cSeek, @nGoTo )
   endif

   if ( nBrwCol := AScan( ::aCols, { |o| !Empty( o:cOrder ) } ) ) > 0
      if ! Empty( nSortCol := ::aCols[ nBrwCol ]:cSortOrder ) .AND. ValTyPe( nSortCol ) == "N"
         if ! ::aCols[ nBrwCol ]:lCaseSensitive
            cSeek    := Upper( cSeek )
         endif
         for nRow := 1 to ::nLen
            uVal  := ::ArrCell( nRow, nSortCol )
            if ValType( uVal ) $ "CDLN"
               uVal     := cValToChar( uVal )
               if ! ::aCols[ nBrwCol ]:lCaseSensitive
                  uVal  := Upper( uVal )
               endif
               if ::lSeekWild
                  if hb_WildMatch( "*" + cSeek, uVal )
                     nAt   := nRow
                  endif
               else
                  lExact := Set( 1, .F. )
                  if uVal = cSeek
                     nAt   := nRow
                  endif
                  Set( 1, lExact )
               endif
               if ! Empty( nAt )
                  ::nArrayAt  := nAt
                  return .T.
               endif
            endif
         next
      endif
   endif

return .F.



static FUNCTION TXBrowse_ArrayIncrFilter( cSeek, nGoTo ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   local lFound   := .F.
   local nLen, x, n, nSave, cVal, lMatch := .F.
   local oCol
   local nMatches := 0

   cSeek    := Upper( cSeek )
   if cSeek == Upper( ::cSeek )
      return .T.
   endif
   if cSeek == ""
      ::bKeyCount    := { || Len( ::aArrayData ) }
       AEval( ::aCols, { |o| If( Empty( o:cOrder ), nil, oCol := o ) } )
       oCol:cOrder := If( oCol:cOrder == "A", "D", "A" )
       ::KeyCount()
       oCol:SetOrder()
       nGoTo   := ::nArrayAt
      return .T.
   endif

   If( ::cFilterFld == nil, ::cFilterFld := ::SelectedCol():cHeader, ) ;
   oCol     := ::oCol( ::cFilterFld )
   nLen     := If( Len( cSeek ) >= Len( ::cSeek ), ::nLen, Len( ::aArrayData ) )
   if ::lSeekWild
      cSeek    := "*" + cSeek + "*"
   endif
   nSave       := ::nArrayAt
   cVal     := Upper( Eval( oCol:bStrData, nil, oCol ) )


   lMatch      := If( Empty( ::bFilterExp ),  If( ::lSeekWild, WildMatch( cSeek, cVal ), cVal = cSeek ),  Eval( ::bFilterExp, cSeek, ::aRow, Self ) )

   for n := 1 to nLen
      ::nArrayAt     := n
      cVal     := Upper( Eval( oCol:bStrData, nil, oCol ) )


      if If( Empty( ::bFilterExp ) , If( ::lSeekWild, WildMatch( cSeek, cVal ), cVal = cSeek ),  Eval( ::bFilterExp, cSeek, ::aArrayData[ n ], Self ) )
         nMatches++
         if n > nMatches
            x                          := ::aArrayData[ nMatches ]
            ::aArrayData[ nMatches ]   := ::aArrayData[ n ]
            ::aArrayData[ n ]          := x
            if lMatch .AND. n == nSave

               nSave    := nMatches
            endif
         endif
      endif
   next
   if nMatches > 0
      lFound         := .T.
      ::nArrayAt     := If( lMatch, nSave, 1 )
      ::bKeyCount    := { || nMatches }
      if nLen > ::nLen
         oCol        := nil
         AEval( ::aCols, { |o| If( Empty( o:cOrder ), nil, oCol := o ) } )
         oCol:cOrder := If( oCol:cOrder == "A", "D", "A" )
         ::KeyCount()
         oCol:SetOrder()
      endif
      if lMatch
         nGoTo       := ::nArrayAt
      endif
   else
      ::nArrayAt  := nSave
   endif

return lFound



static FUNCTION TXBrowse_SetChecks( aBmp, lEdit, aPrompt ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   AEval( ::aCols, { |o| If( o:cDataType == "L", o:SetCheck( aBmp, lEdit, aPrompt ), nil ) } )

return nil



static FUNCTION TXBrowse_VSetPos( nPos ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   if !hb_isNumeric( nPos )
      return nil
   end

   ::nVScrollPos  := nPos

   ::oVScroll:SetPos( iif( ::nLen <= 10000, nPos, int( nPos * 10000 / ::nLen ) ) )

return nil














































static function GenMenuBlock( aCols, nFor )

   local oCol := aCols[ nFor ]

return {|| iif( oCol:lHide, oCol:Show(), oCol:Hide() ) }





static function SetColFromRDD( oCol, uData )

   local cFldType, cFldName, nFldPos
   local a,c

   oCol:cHeader      := "Col-" + LTrim( Str( oCol:nCreationOrder ) )
   oCol:cExpr        := cValToChar( uData )

   SWITCH ValType( uData )
   CASE "B"
      oCol:bEditValue   := uData
      EXIT
   CASE "N"
      if ! Empty( cFldName := FieldName( uData ) )
         nFldPos        := uData
      endif
      EXIT
   CASE "C"
      if At( "FIELD->", uData ) == 1 .OR. At( Alias() + "->", uData ) == 1
         uData          := AFTERATNUM( "->", uData, 1 )
      endif
      if ( nFldPos := FieldPos( uData ) ) > 0
         cFldName       := uData
      endif
      EXIT
   END

   if Empty( oCol:bEditValue )
      if Empty( nFldPos ) .OR. Empty( cFldName )
         oCol:bEditValue   := &( "{ |x,oCol| " + cValToChar( uData ) + " }" )
         BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
            Eval( oCol:bEditValue )
         RECOVER
            oCol:bEditValue   := { || uData }
         END
         oCol:cDataType    := ValType( Eval( oCol:bEditValue ) )
         if oCol:cDataType == "N"
            oCol:cEditPicture := NumPict( 12, 2 )
         endif
         if Empty( c := FieldInExpr( oCol:cExpr ) )
            oCol:cHeader   := oCol:cExpr
         else
            oCol:cHeader   := c
         endif
      else

         cFldType             := FieldType( nFldPos )
         WITH OBJECT oCol

            :cHeader          := cFldName
            :bEditValue       := FIELDBLOCK( cFldName )
            :nDataLen         := FieldLen( nFldPos )
            :nDataDec         := FieldDec( nFldPos )

            if Len( cFldType ) == 1
               :cDataType     := cFldType
            else










               for each a in {  { "M", { "CHAR", "VARBIN", "MEMO", "BLOB", "RAW" } },  { "@", { "TIMESTAMP" } },  { "=", { "MODITIME"  } },  { "T", { "TIME" } },  { "^", { "ROWVER" } },  { "+", { "AUTOINC" } },  { "B", { "DOUBLE" } },  { "Y", { "CURR" } },  { "Z", { "CURD" } },  { "P", { "IMAGE" } } }

                  for each c in a[ 2 ]
                     if c $ cFldType
                        :cDataType  := a[ 1 ]
                        exit
                     endif
                  next
                  if ! Empty( :cDataType )
                     exit
                  endif
               next
               if Empty( :cDataType )
                  :cDataType  := "C"
               endif
            endif

            do case
            case :cDataType == "CDLN"

            case :cDataType $ "MWQ"
               :cDataType     := "M"
               :nDataLen      := 10
            case :cDataType == "I"
               :nDataLen      := If( :nDataLen < 3, 6, 13 )
               :nDataDec      := 0
            case :cDataType $ "^+"
               :cDataType     := "N"
               :nDataLen      := If( :cDataType == "^", 20, :nDataLen )
            case :cDataType $ "YZ"
               :cDataType     := "N"
               :nDataDec      := 2
            case :cDataType $ "T@="
               :cDataType     := "T"
               :cEditPicture  := "@T"
            otherwise
               :cDataType     := ValType( FieldGet( nFldPos ) )
            endcase
         END
         if oCol:cDataType $ "+="
            oCol:lReadOnly    := .T.
         endif

      endif
   endif

   if DBINFO( 129 ) == .T. .OR. oCol:lReadOnly
      oCol:bOnPostEdit  := { || nil }
   else

      oCol:bOnPostEdit  := { |o,x,n| If( n <> 27 .AND. !eq( o:Value, x, .T., .T. ) .AND. o:oBrw:Lock(),   o:Value := x, nil ) }
   endif

return oCol



static function AddOdbfCol( oBrw, cCol, aStruct )

   local oCol := oBrw:AddCol()
   local n

   oCol:cHeader         := cCol
   oCol:bEditValue      := { |x| If( x <> nil, oSend( oBrw:oDbf, "_" + cCol, x ), ), OSend( oBrw:oDbf, cCol ) }
   oCol:bOnPostEdit     := { |o,x,n| If( n <> 27, o:Value := x, ) }

   if aStruct <> nil
      if ( n := AScan( aStruct, { |a| Upper( Trim( a[ 1 ] ) ) == Upper( Trim( cCol ) ) } ) ) > 0
         oCol:cDataType    := aStruct[ n ][ 2 ]
         oCol:nDataLen     := aStruct[ n ][ 3 ]
         oCol:nDataDec     := aStruct[ n ][ 4 ]
      endif
   endif

return oCol



static function SetExcelLanguage( oExcel )

   if nxlLangID == nil
      nxlLangID   := ExcelLangID()
      cxlTrue     := ExcelTranslate( "TRUE" )
      cxlFalse    := ExcelTranslate( "FALSE" )
      lxlEnglish  := ( ExcelLang() == "en" )
   endif

return nil



_HB_CLASS TXBrwColumn ; function TXBrwColumn ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TXBrwColumn", iif( .F., { }, { @HBObject() } ), @TXBrwColumn() ) ) ;














   _HB_MEMBER { oBrw, oDataFont, oHeaderFont, oDataFontBold, oGrpFont, oFooterFont, oDragWnd, oBtnList, oBtnElip, oEditGet, oEditLbx, oEditFont, bPopUp, oBrush } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oBrw", "oDataFont", "oHeaderFont", "oDataFontBold", "oGrpFont", "oFooterFont", "oDragWnd", "oBtnList", "oBtnElip", "oEditGet", "oEditLbx", "oEditFont", "bPopUp", "oBrush"}, .F. )

   _HB_MEMBER { aBitmaps } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aBitmaps"}, .F. )






   _HB_MEMBER { aEditListTxt, aEditListBound } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aEditListTxt", "aEditListBound"}, .F. )






   _HB_MEMBER { bStrData, bBmpData, bIndent, bStrImage } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bStrData", "bBmpData", "bIndent", "bStrImage"}, .F. )







   _HB_MEMBER { bEditValue, bEditValid, bEditWhen, bGetChange, bOnChange, bEditBlock } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bEditValue", "bEditValid", "bEditWhen", "bGetChange", "bOnChange", "bEditBlock"}, .F. )

   _HB_MEMBER { bOnPostEdit } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnPostEdit"}, .F. )

   _HB_MEMBER { bOnPreEdit } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bOnPreEdit"}, .F. )






   _HB_MEMBER { bLClickHeader, bRClickHeader, bLClickFooter, bRClickFooter, bLDClickData, bRClickData } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bLClickHeader", "bRClickHeader", "bLClickFooter", "bRClickFooter", "bLDClickData", "bRClickData"}, .F. )







   _HB_MEMBER { bClrHeader, bClrFooter, bClrGrad, bClrStd, bClrSel, bClrSelFocus, bClrEdit } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bClrHeader", "bClrFooter", "bClrGrad", "bClrStd", "bClrSel", "bClrSelFocus", "bClrEdit"}, .F. )

   _HB_MEMBER { bPaintText } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bPaintText"}, .F. )

   _HB_MEMBER { bToolTip } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bToolTip"}, .F. )













   _HB_MEMBER { cHeader, cExpr, cGrpHdr, cFooter, cEditPicture, cFooterPicture, cOrder, cSortOrder, cOrdBag, cDataType, cEditKeys, bFooter, cToolTip } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cHeader", "cExpr", "cGrpHdr", "cFooter", "cEditPicture", "cFooterPicture", "cOrder", "cSortOrder", "cOrdBag", "cDataType", "cEditKeys", "bFooter", "cToolTip"}, .F. )






   _HB_MEMBER { nWidth, nDisplayCol, nCreationOrder, nResizeCol, nPos, nTotal } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nWidth", "nDisplayCol", "nCreationOrder", "nResizeCol", "nPos", "nTotal"}, .F. )

   _HB_MEMBER { nCellHeight } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nCellHeight"}, .F. )
   _HB_MEMBER { aRows } ; oClass:AddMultiData(,, nScope + iif( .T., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aRows"}, .F. )

   _HB_MEMBER { nCount } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nCount"}, .F. )
   _HB_MEMBER { nTotalSq } ; oClass:AddMultiData(, 0.0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nTotalSq"}, .F. )
   _HB_MEMBER { bSumCondition } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bSumCondition"}, .F. )


   _HB_MEMBER { nGrpHeight } ; oClass:AddMultiData(, 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nGrpHeight"}, .F. )



   _HB_MEMBER { nDataLen, nDataDec, nDataLines } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nDataLen", "nDataDec", "nDataLines"}, .F. )



   _HB_MEMBER { nDataStrAlign, nHeadStrAlign, nFootStrAlign } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nDataStrAlign", "nHeadStrAlign", "nFootStrAlign"}, .F. )



   _HB_MEMBER { nDataBmpAlign, nHeadBmpAlign, nFootBmpAlign } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nDataBmpAlign", "nHeadBmpAlign", "nFootBmpAlign"}, .F. )

   _HB_MEMBER { AS NUMERIC nBtnBmp } ; oClass:AddMultiData( "NUMERIC", 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBtnBmp"}, .F. )



   _HB_MEMBER { nDataStyle, nHeadStyle, nFootStyle } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nDataStyle", "nHeadStyle", "nFootStyle"}, .F. )

   _HB_MEMBER { nColDividerStyle, nColDividerColor, hColPen } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nColDividerStyle", "nColDividerColor", "hColPen"}, .F. )
   _HB_MEMBER { nColDividerWidth } ; oClass:AddMultiData(,, 2 + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nColDividerWidth"}, .F. )

   _HB_MEMBER { AS NUMERIC nArrayCol } ; oClass:AddMultiData( "NUMERIC", 0, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nArrayCol"}, .F. )

   _HB_MEMBER { nHeadBmpNo } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nHeadBmpNo"}, .F. )



   _HB_MEMBER { AS NUMERIC nGrpBmpNo, nFootBmpNo } ; oClass:AddMultiData( "NUMERIC",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nGrpBmpNo", "nFootBmpNo"}, .F. )

   _HB_MEMBER { AS NUMERIC nAlphaLevelHeader } ; oClass:AddMultiData( "NUMERIC", 255, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nAlphaLevelHeader"}, .F. )
   _HB_MEMBER { AS NUMERIC nAlphaLevelFooter } ; oClass:AddMultiData( "NUMERIC", 255, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nAlphaLevelFooter"}, .F. )



   _HB_MEMBER { AS NUMERIC hEditType } ; oClass:AddMultiData( "NUMERIC",, 2 + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hEditType"}, .F. )









   _HB_MEMBER { AS LOGICAL lAllowSizing, lEditBorder, lHide, lOnPostEdit, lBmpStretch } ; oClass:AddMultiData( "LOGICAL",, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lAllowSizing", "lEditBorder", "lHide", "lOnPostEdit", "lBmpStretch"}, .F. )

   _HB_MEMBER { AS LOGICAL lCaseSensitive } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lCaseSensitive"}, .F. )
   _HB_MEMBER { lBmpTransparent } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lBmpTransparent"}, .F. )
   _HB_MEMBER { AS LOGICAL lBtnTransparent } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lBtnTransparent"}, .F. )
   _HB_MEMBER { AS LOGICAL lAutoSave } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lAutoSave"}, .F. )
   _HB_MEMBER { lColTransparent } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lColTransparent"}, .F. )
   _HB_MEMBER { lDisplayZeros } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lDisplayZeros"}, .F. )
   _HB_MEMBER { lOemAnsi } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lOemAnsi"}, .F. )


   _HB_MEMBER { AS LOGICAL lProgBar } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lProgBar"}, .F. )
   _HB_MEMBER { bClrProg } ; oClass:AddMultiData(, { || { ( 200 + ( 200 * 256 ) + ( 255 * 65536 ) ), 65535 } }, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bClrProg"}, .F. )
   _HB_MEMBER { nProgTot } ; oClass:AddMultiData(, 1, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nProgTot"}, .F. )

   _HB_MEMBER { AS LOGICAL lTotal } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lTotal"}, .F. )
   _HB_MEMBER { hFooterType } ; oClass:AddMultiData(,, 2 + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hFooterType"}, .F. )
   _HB_MEMBER { AS LOGICAL hChecked } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hChecked"}, .F. )

   _HB_MEMBER { Cargo } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Cargo"}, .F. )

   _HB_MEMBER { lMergeVert } ; oClass:AddMultiData(, .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lMergeVert"}, .F. )
   _HB_MEMBER { aMerge } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aMerge"}, .F. )

   _HB_MEMBER { nHeaderType } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nHeaderType"}, .F. )

   _HB_MEMBER { bAlphaLevel } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bAlphaLevel"}, .F. )
   _HB_MEMBER { hAlphaLevel } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hAlphaLevel"}, .F. )

   _HB_MEMBER { AS LOGICAL lWillShowABtn } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lWillShowABtn"}, .F. )
   _HB_MEMBER { nBtnWidth, cBtnCaption } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nBtnWidth", "cBtnCaption"}, .F. )

   _HB_MEMBER { AS LOGICAL lReadOnly } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lReadOnly"}, .F. )



   _HB_MEMBER New( oBrw); oClass:AddMethod( "New", @TXBrwColumn_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER End(); oClass:AddMethod( "End", @TXBrwColumn_End(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Edit( nKey); oClass:AddMethod( "Edit", @TXBrwColumn_Edit(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )





   _HB_MEMBER EditDateTime( nKey); oClass:AddMethod( "EditDateTime", @TXBrwColumn_EditDateTime(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER nEditType(); _HB_MEMBER _nEditType(); oClass:AddMethod( "nEditType", @TXBrwColumn_nEditType(), nScope + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) ) ; oClass:AddMethod( "_nEditType", @TXBrwColumn_nEditType(), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER nFooterType(); _HB_MEMBER _nFooterType(); oClass:AddMethod( "nFooterType", @TXBrwColumn_nFooterType(), nScope + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) ) ; oClass:AddMethod( "_nFooterType", @TXBrwColumn_nFooterType(), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER AddBitmap(); oClass:AddInline( "AddBitmap", {|Self, uBmp | ( ( Self ) ), fnAddBitmap( Self, uBmp ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER AddBmpFile(); oClass:AddInline( "AddBmpFile", {|Self, cBmpFile, nBmpNo | ( ( Self ) ), ( ( nbmpNo := fnAddBitmap( Self, cBmpFile ) ) > 0 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER AddResource(); oClass:AddInline( "AddResource", {|Self, cnResource, nBmpNo | ( ( Self ) ), ( ( nbmpNo := fnAddBitmap( Self, cnResource ) ) > 0 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER AddBmpHandle(); oClass:AddInline( "AddBmpHandle", {|Self, hBmp, nBmpNo | ( ( Self ) ), ( ( nbmpNo := fnAddBitmap( Self, hBmp) ) > 0 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER aBitmap(); oClass:AddInline( "aBitmap", {|Self, n | ( ( Self ) ), ( n := IfNil( n, 0 ),  If( n > 0, If( n <= Len( ::aBitmaps ), ::aBitmaps[ n ], ::oBrw:aBitmap( n ) ),  If( n < 0, ::oBrw:aBitmap( -n ), nil ) ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ChangeBitmap(); oClass:AddMethod( "ChangeBitmap", @TXBrwColumn_ChangeBitmap(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER DefStyle( nAlign, lSingleLine); oClass:AddMethod( "DefStyle", @TXBrwColumn_DefStyle(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )





   _HB_MEMBER Show(); oClass:AddInline( "Show", {|Self | ( ( Self ) ), ( ::lHide := .F., ::oBrw:GetDisplayCols(), ::oBrw:Refresh() ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER Hide(); oClass:AddInline( "Hide", {|Self | ( ( Self ) ), ( ::lHide := .T., ::oBrw:GetDisplayCols(), ::oBrw:Refresh() ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER nAlphaLevel( nLevel); _HB_MEMBER _nAlphaLevel( nLevel); oClass:AddMethod( "nAlphaLevel", @TXBrwColumn_nAlphaLevel(), nScope + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) ) ; oClass:AddMethod( "_nAlphaLevel", @TXBrwColumn_nAlphaLevel(), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER Adjust(); oClass:AddMethod( "Adjust", @TXBrwColumn_Adjust(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER HeaderHeight(); oClass:AddMethod( "HeaderHeight", @TXBrwColumn_HeaderHeight(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER HeaderWidth(); oClass:AddMethod( "HeaderWidth", @TXBrwColumn_HeaderWidth(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER FooterHeight(); oClass:AddMethod( "FooterHeight", @TXBrwColumn_FooterHeight(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER FooterWidth(); oClass:AddMethod( "FooterWidth", @TXBrwColumn_FooterWidth(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER DataHeight(); oClass:AddMethod( "DataHeight", @TXBrwColumn_DataHeight(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER DataWidth(); oClass:AddMethod( "DataWidth", @TXBrwColumn_DataWidth(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER nWidthChr(); _HB_MEMBER _nWidthChr(); oClass:AddMethod( "nWidthChr", @TXBrwColumn_nWidthChr(), nScope + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) ) ; oClass:AddMethod( "_nWidthChr", @TXBrwColumn_nWidthChr(), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER PaintHeader( nRow, nCol, nHeight, lInvert, hDC, nGrpWidth); oClass:AddMethod( "PaintHeader", @TXBrwColumn_PaintHeader(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER DataCol(); oClass:AddMethod( "DataCol", @TXBrwColumn_DataCol(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER PaintData( nRow, nCol, nHeight, lHighLite, lSelected, nOrder, nPaintRow); oClass:AddMethod( "PaintData", @TXBrwColumn_PaintData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER PaintCell( nRow, nCol, nHeight, lHighLite, lSelected, nOrder, nPaintRow); oClass:AddMethod( "PaintCell", @TXBrwColumn_PaintCell(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER EraseData( nRow, nCol, nHeight, hBrush, lFixHeight); oClass:AddMethod( "EraseData", @TXBrwColumn_EraseData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Box( nRow, nCol, nHeight, lDotted); oClass:AddMethod( "Box", @TXBrwColumn_Box(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER PaintFooter( nRow, nCol, nHeight, lInvert); oClass:AddMethod( "PaintFooter", @TXBrwColumn_PaintFooter(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER RefreshFooter(); oClass:AddMethod( "RefreshFooter", @TXBrwColumn_RefreshFooter(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER footerStr(); oClass:AddMethod( "footerStr", @TXBrwColumn_footerStr(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER IsVisible(); oClass:AddInline( "IsVisible", {|Self, lComplete | ( ( Self ) ), ( ! ::lHide .AND. ::oBrw:IsDisplayPosVisible( ::nPos, lComplete ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER HeaderLButtonDown( nRow, nCol, nFlags); oClass:AddMethod( "HeaderLButtonDown", @TXBrwColumn_HeaderLButtonDown(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER HeaderLButtonUp( nRow, nCol, nFlags); oClass:AddMethod( "HeaderLButtonUp", @TXBrwColumn_HeaderLButtonUp(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER FooterLButtonDown( nRow, nCol, nFlags); oClass:AddMethod( "FooterLButtonDown", @TXBrwColumn_FooterLButtonDown(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER FooterLButtonUp( nRow, nCol, nFlags); oClass:AddMethod( "FooterLButtonUp", @TXBrwColumn_FooterLButtonUp(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER MouseMove( nRow, nCol, nFlags); oClass:AddMethod( "MouseMove", @TXBrwColumn_MouseMove(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ResizeBeg( nRow, nCol, nFlags); oClass:AddMethod( "ResizeBeg", @TXBrwColumn_ResizeBeg(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ResizeEnd( nRow, nCol, nFlags); oClass:AddMethod( "ResizeEnd", @TXBrwColumn_ResizeEnd(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER CreateButtons(); oClass:AddMethod( "CreateButtons", @TXBrwColumn_CreateButtons(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ShowBtnList(); oClass:AddMethod( "ShowBtnList", @TXBrwColumn_ShowBtnList(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER RunBtnAction(); oClass:AddMethod( "RunBtnAction", @TXBrwColumn_RunBtnAction(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER PostEdit(); oClass:AddMethod( "PostEdit", @TXBrwColumn_PostEdit(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SetCheck( aBmps, uEdit, aPrompts); oClass:AddMethod( "SetCheck", @TXBrwColumn_SetCheck(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetLogical( uTrue, uFalse); oClass:AddMethod( "SetLogical", @TXBrwColumn_SetLogical(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER CheckToggle(); oClass:AddMethod( "CheckToggle", @TXBrwColumn_CheckToggle(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetProgBar( nProgTotal, nWidth, bClrProg); oClass:AddMethod( "SetProgBar", @TXBrwColumn_SetProgBar(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetAlign( nAlign); oClass:AddMethod( "SetAlign", @TXBrwColumn_SetAlign(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetOrder(); oClass:AddMethod( "SetOrder", @TXBrwColumn_SetOrder(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SortArrayData(); oClass:AddMethod( "SortArrayData", @TXBrwColumn_SortArrayData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ClpText(); oClass:AddMethod( "ClpText", @TXBrwColumn_ClpText(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Paste( cText); oClass:AddMethod( "Paste", @TXBrwColumn_Paste(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ToExcel( oSheet, nRow, nCol); oClass:AddMethod( "ToExcel", @TXBrwColumn_ToExcel(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER isEditKey( nKey); oClass:AddMethod( "isEditKey", @TXBrwColumn_isEditKey(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Value( uVal); _HB_MEMBER _Value( uVal); oClass:AddMethod( "Value", @TXBrwColumn_Value(), nScope + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) ) ; oClass:AddMethod( "_Value", @TXBrwColumn_Value(), nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER BlankValue(); oClass:AddMethod( "BlankValue", @TXBrwColumn_BlankValue(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER VarGet(); oClass:AddInline( "VarGet", {|Self | ( ( Self ) ), ::Value }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER VarPut(); oClass:AddInline( "VarPut", {|Self, uVal | ( ( Self ) ), If( ::bOnPostEdit == nil, nil, ( ::PostEdit( uVal,, .T. ), uVal ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER lEditable(); oClass:AddInline( "lEditable", {|Self| ( ( Self ) ), ( ! ::oBrw:lReadOnly .AND. ! ::lReadOnly .AND.  ::nEditType > 0 .AND. ::bOnPostEdit <> nil .AND.  ( ::bEditWhen == nil .OR. Eval( ::bEditWhen, Self ) ) )}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER IsMemo(); oClass:AddInline( "IsMemo", {|Self | ( ( Self ) ), ( IfNil( ::cDataType, "C" ) $ "MPm" .OR.  ( ValType( ::Value ) == "C" .AND. ( Len( ::Value ) > FWAdoMemoSizeThreshold() .OR.  Chr(13)+Chr(10) $ ::Value .OR. IsBinaryData( ::Value ) ) ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetColsAsRows( aCols); oClass:AddMethod( "SetColsAsRows", @TXBrwColumn_SetColsAsRows(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER WorkMergeData(); oClass:AddMethod( "WorkMergeData", @TXBrwColumn_WorkMergeData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER HasBorder(); oClass:AddMethod( "HasBorder", @TXBrwColumn_HasBorder(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER MergeArea(); oClass:AddMethod( "MergeArea", @TXBrwColumn_MergeArea(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER RecalcTotal( nOldVal, nNewVal); oClass:AddMethod( "RecalcTotal", @TXBrwColumn_RecalcTotal(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SumOfCols( aCols, nType); oClass:AddMethod( "SumOfCols", @TXBrwColumn_SumOfCols(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SameColAs( u); oClass:AddMethod( "SameColAs", @TXBrwColumn_SameColAs(), 2 + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   oClass:AddInline( "==", {|Self,u| ( ( Self ) ), ::SameColAs( u )}, nScope + iif( .F., 2048, 0 ) )
   oClass:AddInline( "<>", {|Self,u| ( ( Self ) ), ! ::SameColAs( u )}, nScope + iif( .F., 2048, 0 ) )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TXBrwColumn ;



static FUNCTION TXBrwColumn_New( oBrw ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   ::oBrw  := oBrw

   ::aBitmaps := {}

   ::cHeader := ""
   ::cFooter := ""
   ::cOrder  := ""

   ::nDisplayCol    := 0
   ::nCreationOrder := Len( oBrw:aCols ) + 1

   ::lAllowSizing := .T.
   ::lBmpStretch  := .F.

return Self



static FUNCTION TXBrwColumn_End( ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nFor

   if ::oBtnList <> nil
      ::oBtnList:End()
   endif

   if ::oBtnElip <> nil
      ::oBtnElip:End()
   endif

   if ::oEditGet <> nil
      ::oEditGet:End()
   endif

   if ::hColPen <> nil
      DeleteObject( ::hColPen )
      ::hColPen   := nil
   endif

   for nFor := 1 to Len( ::aBitmaps )
      PalBmpFree( ::aBitmaps[ nFor, 1 ], ::aBitmaps[ nFor, 2 ] )
   next

return nil



static FUNCTION TXBrwColumn_Adjust( ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nWid, tmp, aToken, cOrder, cType

   If( ::cOrder == nil, ::cOrder := "", ) ;

   if ::cEditPicture == nil .AND. ::cDataType == "T"
      ::cEditPicture := "@T"
   endif

   if ValType( ::oBrw:aArrayData ) == "A"

      If( ::cEditPicture == nil, ::cEditPicture := { |u| If( ValType( u ) == "N",  NumPict( ::nWidthChr, Len( AfterAtNum( ".", cValToChar( u ) ) ) ), nil ) }, ) ;

      if ::bEditValue == nil
         if ::nArrayCol > 0


            ::bEditValue   :=  { |x| If( x == nil, ::oBrw:ArrCell( ::oBrw:nArrayAt, ::nArrayCol ),  ::oBrw:ArrCellSet( ::oBrw:nArrayAt, ::nArrayCol, x ) ) }
            if ValType( ::bBmpData) == "N"
               tmp                     := ::bBmpData
               ::bBmpData              := { || ::oBrw:aRow[ tmp ] }
            elseif ::bStrData == nil .AND. ! ::hChecked
               if ::nEditType == 2 .AND. ! Empty( ::aEditListTxt ) .AND. ! Empty( ::aEditListBound )
                  ::bStrData  := { || XbrLbxLookUp( ::Value, ::aEditListBound, ::aEditListTxt ) }
               else


                  ::bStrData     :=  { || ::oBrw:ArrCell( ::oBrw:nArrayAt, ::nArrayCol, ::cEditPicture,  ::lDisplayZeros ) }
               endif
            endif
         endif
      endif

   elseif ValType( ::oBrw:aArrayData ) == "H"
         If( ::nWidth == nil, ::nWidth := 100, ) ;
   endif

   if ::bEditValue <> nil

      if Empty( ::cDataType ) .OR. ::cDataType == "U"
         ::cDataType := ValType( ::Value )
      endif

      if ::cEditPicture == nil .AND. ::cDataType == "N" .AND.  ::nDataLen <> nil .AND. ::oBrw:nDataType <> 2
         ::cEditPicture := NumPict( ::nDataLen, ::nDataDec, .T. )
      endif





      if ::cDataType $ "DT"

         If( ::nDataStrAlign == nil, ::nDataStrAlign := 1, ) ; If( ::nHeadStrAlign == nil, ::nHeadStrAlign := 1, );
      endif

      if ::cDataType == "N"


         If( ::nDataStrAlign == nil, ::nDataStrAlign := 1, ) ; If( ::nHeadStrAlign == nil, ::nHeadStrAlign := 1, ); If( ::nFootStrAlign == nil, ::nFootStrAlign := 1, );
      else
         ::lTotal := .F.
      endif

      if ::bStrData == nil .AND. !( ::cDataType $ "PF" )
         if ::nEditType == 2 .AND. ! Empty( ::aEditListTxt ) .AND. ! Empty( ::aEditListBound )
            ::bStrData  := { || XbrLbxLookUp( ::Value, ::aEditListBound, ::aEditListTxt ) }
         else

            ::bStrData  := { || cValToStr( ::Value, ::cEditPicture,,  IfNil( ::lDisplayZeros, ::oBrw:lDisplayZeros ) ) }
         endif
      elseif ValType( ::bStrData ) <> "B"
         ::bStrData  := nil
      endif

      If( ::bOnPostEdit == nil, ::bOnPostEdit := { |o,x,n| If( n <> 27 .AND. ::oBrw:Lock(), ::Value := x, nil ) }, ) ;

      if ::cSortOrder <> nil
         if ValType( ::cSortOrder ) <> "B"
            if ( ::oBrw:nDataType == 1 )

               if Empty( ::cOrdBag ) .OR. ( ValType( ::cOrdBag ) == "C" .AND.  (::oBrw:cAlias)->( OrdNumber( ::cSortOrder, ::cOrdBag ) ) == 0 )
                  ::cOrdBag    := (::oBrw:cAlias)->( OrdBagName( ::cSortOrder ) )
               endif
               if EQ( (::oBrw:cAlias)->( OrdSetFocus() ), ::cSortOrder )
                  ::cOrder       := "A"
               endif
            elseif ( ::oBrw:nDataType == 4 )
               if EQ( CharRem( "[]", ::oBrw:oRs:Sort ), CharRem( "[]", ::cSortOrder ) )
                  ::cOrder       := "A"
               endif
            elseif ( ::oBrw:nDataType == 64 )
               if ::oBrw:oMysql:IsKindOf( "TDOLPHINQRY" )
                  if ! Empty( ::oBrw:oMySql:cOrder )
                     aToken := HB_ATokens( ::oBrw:oMySql:cOrder, " " )
                     IF Len( aToken ) == 1
                        AAdd( aToken, "ASC" )
                     ENDIF
                     cOrder = AllTrim( Lower( aToken[ 1 ] ) )
                     cType = aToken[ 2 ]
                     if EQ( cOrder, ::cSortOrder )
                        IF Upper( cType ) == "ASC"
                           ::cOrder = "A"
                        ELSE
                           ::cOrder = "D"
                        ENDIF
                     endif
                  endif
               else
                  if EQ( ::oBrw:oMysql:cSort, ::cSortOrder )
                     ::cOrder       := "A"
                  endif
               endif
            elseif ( ::oBrw:nDataType == 16 )
               if EQ( ::oBrw:oDbf:SetOrder, ::cSortOrder )
                  ::cOrder       := "A"
               endif
            endif
         endif
      endif
   endif

   if ::nEditType == -1 .OR. ::bStrImage <> nil
      ::cDataType        := "F"
   endif

   if ValType( tmp := ::Value ) == "C" .AND. IsBinaryData( tmp )
      if IfNil( FITypeFromMemory( tmp ), -1 ) >= 0
         ::cDataType    := "P"
      endif
   endif

   If( ::cDataType == nil, ::cDataType := "C", ) ;

   if ::cDataType $ "PF"
      ::oBrw:lExcelCellWise   := .T.
      If( ::lBmpTransparent == nil, ::lBmpTransparent := .F., ) ;
   elseif ::cDataType == "M"
      If( ::nWidth == nil, ::nWidth := 200, ) ;
   endif

   If( ::lBmpTransparent == nil, ::lBmpTransparent := .T., ) ;


   if ( ::bStrData == nil .OR. Eval( ::bStrData, nil, Self ) == nil ) .AND.  ( ::bBmpData <> nil .OR. ::cDataType $ "PF")

      If( ::nDataBmpAlign == nil, ::nDataBmpAlign := 2, ) ;

   endif

   if ! Empty( ::hFooterType )
      If( ::nTotal == nil, ::nTotal := 0, ) ;
   endif
   if ValType( ::nTotal ) == "N"
      If( ::hFooterType == nil, ::hFooterType := 1, ) ;
   endif






   If( ::oDataFont == nil, ::oDataFont := ::oBrw:oFont, ) ; If( ::oHeaderFont == nil, ::oHeaderFont := ::oBrw:oFont, ); If( ::oDataFontBold == nil, ::oDataFontBold := ::oBrw:oFont, ); If( ::oFooterFont == nil, ::oFooterFont := ::oBrw:oFont, ); If( ::oGrpFont == nil, ::oGrpFont := ::oDataFontBold, ); If( ::oEditFont == nil, ::oEditFont := ::oBrw:oFont, );






   If( ::nDataStrAlign == nil, ::nDataStrAlign := 0, ) ; If( ::nDataBmpAlign == nil, ::nDataBmpAlign := 0, ); If( ::nHeadStrAlign == nil, ::nHeadStrAlign := 0, ); If( ::nFootStrAlign == nil, ::nFootStrAlign := 0, ); If( ::nHeadBmpAlign == nil, ::nHeadBmpAlign := 0, ); If( ::nFootBmpAlign == nil, ::nFootBmpAlign := 0, );







   If( ::bClrHeader == nil, ::bClrHeader := ::oBrw:bClrHeader, ) ; If( ::bClrFooter == nil, ::bClrFooter := ::oBrw:bClrFooter, ); If( ::bClrGrad == nil, ::bClrGrad := ::oBrw:bClrGrad, ); If( ::bClrStd == nil, ::bClrStd := ::oBrw:bClrStd, ); If( ::bClrSel == nil, ::bClrSel := ::oBrw:bClrSel, ); If( ::bClrSelFocus == nil, ::bClrSelFocus := ::oBrw:bClrSelFocus, ); If( ::bClrEdit == nil, ::bClrEdit := ::bClrStd, );



   If( ::nWidth == nil, ::nWidth := Max( Max( ::HeaderWidth(), ::FooterWidth() ), ::DataWidth() ) + 6, ) ;



   If( ::nDataStyle == nil, ::nDataStyle := ::DefStyle( ::nDataStrAlign, ( ::oBrw:nDataLines == 1 ) ), ) ; If( ::nHeadStyle == nil, ::nHeadStyle := ::DefStyle( ::nHeadStrAlign, ( ::oBrw:nHeaderLines == 1 ) ), ); If( ::nFootStyle == nil, ::nFootStyle := ::DefStyle( ::nFootStrAlign, ( ::oBrw:nFooterLines == 1 ) ), );

   if ! Empty( ::cGrpHdr ) .AND. Empty( ::nGrpHeight )
      ::nGrpHeight   := FontHeight( ::oBrw, ::oGrpFont )
   endif

   if ::nColDividerStyle <> nil
      ::hColPen   := CreateLinePen( ::oBrw, ::nColDividerStyle, 0, ::nColDividerWidth, ::nColDividerColor )
   endif

   ::CreateButtons()

   if ::lMergeVert
      ::oBrw:lMergeVert := .T.
      ::WorkMergeData()
   endif

return nil



static FUNCTION TXBrwColumn_Value( uNew ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local uVal


   if ! ::oBrw:lReadOnly .AND. ! ::lReadOnly .AND.  PCount() > 0 .AND. ::bEditValue <> nil

      if HB_IsString( uNew ) .AND. IfNil( ::lOemAnsi, ::oBrw:lOemAnsi )
         uNew     := AnsiToOem( uNew )
      endif
      BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
         ( ::oBrw:cAlias )->( Eval( ::bEditValue, uNew, Self ) )
         ::oBrw:lEdited    := .T.
      RECOVER
      END

   endif

   if ::bEditValue == nil .AND. ::nArrayCol > 0

      uVal     := ::oBrw:ArrCell( ::oBrw:nArrayAt, ::nArrayCol )
   elseif ::bEditValue <> nil
      BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
         uVal  := ( ::oBrw:cAlias )->( Eval( ::bEditValue, nil, Self ) )
      RECOVER
         uVal  := ::BlankValue()
      END
   elseif ::bStrData <> nil
      BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
         uVal  := ( ::oBrw:cAlias )->( Eval( ::bStrData, nil, Self ) )
      RECOVER
         uVal  := ""
      END
   endif

   if HB_IsString( uVal ) .AND. IfNil( ::lOemAnsi, ::oBrw:lOemAnsi )
      uVal  := OemToAnsi( uVal )
   endif

return uVal



static FUNCTION TXBrwColumn_BlankValue( ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local uVal  := ""

   if ::cDataType == "N"
      if IfNil( ::nDataDec, 0 ) > 0
         uVal  := Val( "0." + Replicate( "0", ::nDataDec ) )
      else
         uVal  := 0
      endif
   elseif ::cDataType == "D"
      uVal     := CToD( "" )
   elseif ::cDataType == "T"
      uVal     := HB_CTOT( "" )
   elseif ::cDataType == "L"
      uVal     := .F.
   else
      uVal     := Space( If( Empty( ::nDataLen ), ::nWidthChr, ::nDataLen ) )
   endif

return uVal



static FUNCTION TXBrwColumn_SameColAs( u ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local lRet  := .F.
   local cParType := ValType( u )
   local cHeader, cHead

   if cParType == "O"
      lRet  :=  ( u:IsKindOf( "TXBRWCOLUMN" ) .AND. ::nCreationOrder == u:nCreationOrder )
   elseif cParType == "N"
      lRet  :=  ( ::nCreationOrder == u )

   elseif cParType == "C" .AND. ValType( ::cHeader ) == "C" .AND.  ! Empty( ::cHeader ) .AND. ! Empty( u )

      u        := Upper( u )
      cHeader  := Upper( ::cHeader )
      cHead    := CharRem( Chr(9) + Chr(10) + Chr(13) + Chr(32), cHeader )
      if cHeader == u .OR. cHead == u
         lRet  := .T.
      elseif ! Empty( ::cGrpHdr )
         if Upper( ::cGrpHdr ) + "_" + cHeader == u
            lRet  := .T.
         elseif Upper( ::cGrpHdr ) + "_" + cHead == u
            lRet  := .T.
         endif
      endif
   endif

return lRet



static FUNCTION TXBrwColumn_nAlphaLevel( uNew ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   if uNew <> NIL
      ::hAlphaLevel := uNew
   else
      if ::bAlphaLevel <> NIL
         ::hAlphaLevel = eval( ::bAlphaLevel, Self )
      endif
   endif

return ::hAlphaLevel



static FUNCTION TXBrwColumn_SetLogical( uTrue, uFalse ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local lSet     := .F.
   local b

   if ! Empty( ::bEditValue )
      b     := ::bEditValue
      if ::cDataType == "N"
         ::bEditValue   := { |x| If( x == nil, ! Empty( Eval( b ) ), Eval( b, If( x, 1, 0 ) ) ) }
         ::cDataType    := "L"
         lSet     := .T.
      elseif ::cDataType == "C"
         If( uTrue == nil, uTrue := "Y", ) ; If( uFalse == nil, uFalse := "N", );
         uTrue    := Upper( Left( uTrue, 1 ) )
         uFalse   := Upper( Left( uFalse, 1 ) )

         ::bEditValue   := { |x| If( x == nil, !( Upper( Left( IfNil( Eval( b ), uFalse ), 1 ) ) == uFalse ),  Eval( b, If( x, uTrue, uFalse ) ) ) }
         ::cDataType    := "L"
         lSet     := .T.
      endif
   endif

return lSet



static FUNCTION TXBrwColumn_SetCheck( aBmps, uEdit, aPrompts ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nBmpOn, nBmpOff := 0, nBmpNull := 0
   local LogiVal := .F.

   if Empty( aBmps )
      aBmps    := { FWBmpOn(), FWBmpOff() }
   elseif ValType( aBmps ) == "A" .AND. Len( aBmps ) < 2
      AAdd( aBmps, FWBmpOff() )
   endif
   nBmpOn   := ::AddBitmap( aBmps[ 1 ] )
   nBmpOff  := ::AddBitmap( aBmps[ 2 ] )
   if Len( aBmps ) > 2
      nBmpNull := ::AddBitmap( aBmps[ 3 ] )
   endif

   ::bBmpData  := { | u | If( ValType( u := ::Value ) == "L", If( u, nBmpOn, nBmpOff ), nBmpNull ) }
   ::bStrData  := .F.
   ::hChecked  := .T.
   if ValType( uEdit ) == "B"
      ::bOnPostEdit  := uEdit
      ::nEditType    := 1
   elseif ValType( uEdit ) == "N"
      ::nEditType    := uEdit
   elseif ValType( uEdit ) == "L"
      ::nEditType    := If( uEdit, 1, 0 )
   endif
   if ValType( aPrompts ) == "A"
      if Len( aPrompts ) < 3
         ASize( aPrompts, 3 )
      endif
      AEval( aPrompts, { |c, i| If( ValType( c ) <> "C", aPrompts[ i ] := "", ) } )

      ::bStrData  := { | u | If( ValType( u := ::Value ) == "L",  If( u, aPrompts[ 1 ], aPrompts[ 2 ] ), aPrompts[ 3 ] ) }
   endif

return nil



static FUNCTION TXBrwColumn_CheckToggle( lOverRide ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local uVal  := IfNil( ::Value, .F. )





   if ValType( uVal ) == "L"
      ::PostEdit( ! uVal, nil, lOverRide )
   endif

return Self



static FUNCTION TXBrwColumn_SetProgBar( nProgTotal, nWidth, bClrProg ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   ::lProgBar        := .T.
   if nProgTotal <> nil
      ::nProgTot     := nProgTotal
   endif
   if ValType( bClrProg )  == "B"
      ::bClrProg     := bClrProg
   endif

   ::nDataStrAlign := ::nHeadStrAlign := 2

   if nWidth <> nil
      ::nWidth       := nWidth
   endif

return nil



static FUNCTION TXBrwColumn_SetAlign( nAlign ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   if ValType( nAlign ) == "N"
      nAlign      := Min( Max( nAlign, 0 ), 2 )
      if nAlign <> ::nDataStrAlign
         ::nDataStrAlign      := nAlign
         ::nDataStyle         := ::DefStyle( nAlign, ::oBrw:nDataLines == 1 )
         ::oBrw:Refresh()
      endif
   endif

Return Self



static FUNCTION TXBrwColumn_HeaderHeight( lGrpHdr ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nHeight := 0
   local aBitmap

   If( lGrpHdr == nil, lGrpHdr := .F., ) ;

   if lGrpHdr
      if ! Empty( ::cGrpHdr )
         nHeight  := ( FontHeight( ::oBrw, IfNil( ::oGrpFont, ::oHeaderFont ) ) + 2 ) * MLCount( ::cGrpHdr ) + 2
      endif
      if ! Empty( aBitmap := ::aBitmap( ::nGrpBmpNo ) )
         nHeight := Max( nHeight, aBitmap[ 4 ] + 2 )
      endif
   else

      nHeight := FontHeight( ::oBrw, ::oBrw:oWnd:oFont )
      if ! Empty( ::cHeader ) .AND. ::oHeaderFont <> nil

         nHeight := FontHeight( ::oBrw, ::oHeaderFont ) * MLCount( ::cHeader )
         if FontEsc( ::oHeaderFont ) % 1800  == 900
            nHeight := Max( nHeight, ::oBrw:GetWidth( ::cHeader, ::oHeaderFont ) + 6 )
         endif
      endif

      if ! Empty( aBitmap := ::aBitmap( If( ValType( ::nHeadBmpNo ) == "B", Eval( ::nHeadBmpNo ), ::nHeadBmpNo ) ) )
         nHeight := Max( nHeight, aBitmap[ 4 ] + 2 )
      endif
      if Empty( ::cGrpHdr )
         ::nGrpHeight   := 0
      else
         nHeight  += ::nGrpHeight + 1
      endif

   endif

return nHeight



static FUNCTION TXBrwColumn_HeaderWidth( ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local cText, cLine
   local nWidth, nFrom, nLen, nFor, nTemp
   local aBitmap

   cText  := ::cHeader
   nWidth := 0
   nFrom  := 1

   if !Empty( cText )
      if FontEsc( ::oHeaderFont ) % 1800 == 900
         nWidth   := FontHeight( ::oBrw, ::oHeaderFont ) + 6
      else
          nLen  := Len( cText )
          While nFrom <= nLen
            cLine  := ExtractLine( cText, @nFrom )
            nWidth := Max( nWidth, ::oBrw:GetWidth( cLine, ::oHeaderFont ) )
          enddo
      endif
   endif

   if ! Empty( aBitmap := ::aBitmap( If( ValType( ::nHeadBmpNo ) == "B", Eval( ::nHeadBmpNo ), ::nHeadBmpNo ) ) )
      nWidth   += aBitmap[ 3 ] + 5
   elseif ! Empty( ::cSortOrder )
      nWidth += ::oBrw:aSortBmp[ 1 ][ 3 ] + 5
   endif

return Max( nWidth, 16 )



static FUNCTION TXBrwColumn_FooterHeight( ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nHeight
   local cFooter
   local aBitmap

   nHeight := FontHeight( ::oBrw, ::oBrw:oWnd:oFont )

   cFooter := ::footerStr()

   if cFooter <> nil .AND. ::oFooterFont <> nil
      nHeight := FontHeight( ::oBrw, ::oFooterFont )
   endif

   if ! Empty( aBitmap := ::aBitmap( ::nFootBmpNo ) )
      nHeight := Max( nHeight, aBitmap[ 4 ] )
   endif

return nHeight



static FUNCTION TXBrwColumn_FooterWidth( ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local cText, cLine
   local nWidth, nFrom, nLen
   local aBitmap

   cText  := ::footerStr()
   nWidth := 0
   nFrom  := 1

   if !Empty( cText )
       nLen  := Len( cText )
       While nFrom <= nLen
         cLine  := ExtractLine( cText, @nFrom )
         nWidth := Max( nWidth, ::oBrw:GetWidth( cLine, ::oFooterFont ) )
       enddo
   endif

   if ! Empty( aBitmap := ::aBitmap( ::nFootBmpNo ) )
      nWidth := Max( nWidth, aBitmap[ 3 ] ) + 5
   endif

return Max( nWidth, 16 )



static FUNCTION TXBrwColumn_DataHeight( ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nHeight, nBmpHeight, cData, nBmp := 0

   nHeight := FontHeight( ::oBrw, ::oBrw:oWnd:oFont )

   if ::bStrData <> nil .AND. ::oDataFont <> nil
      if ValType( ::oDataFont ) == "B"
         nHeight := FontHeight( ::oBrw, Eval( ::oDataFont, Self ) )
      else
         nHeight := FontHeight( ::oBrw, ::oDataFont )
      endif
   endif

   if ::bBmpData <> nil

      nBmpHeight   := 0
      AEval( ::aBitmaps, { |a| nBmpHeight := Max( nBmpHeight, a[ 4 ] ) } )
      nHeight  := Max( nHeight, nBmpHeight )

   endif

   if ::cDataType $ "PF"

      if ValType( ::Value ) == "C" .AND. ! Empty( ::Value )
         if ::cDataType == "F" .AND. File( ::Value )
            nBmp     := FILoadImg( ::Value )
         else
            nBmp     := FILoadFromMemory( ::Value )
         endif
      endif
      nHeight     := Int( GetSysMetrics( 1 ) / 10 )
      if nBmp > 0
         nHeight  := Min( nBmpHeight( nBmp ) + 4, nHeight )
      endif
      DeleteObject( nBmp )
      if ::oBrw:nDataLines > 1
         nheight  := Round( nHeight / ::oBrw:nDataLines, 0 )
      endif
   endif

   if ::nEditType == 6
      nHeight  := Max( 24, nHeight )
   endif

   if ::nCellHeight <> nil .AND. ::nCellHeight > nHeight
      nHeight     := ::nCellHeight
   endif

   ::nCellHeight  := nHeight

return nHeight



static FUNCTION TXBrwColumn_DataWidth( ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local cText, cLine, oFont
   local nWidth, nFrom, nLen, nBmp := 0
   local nBmpWidth

   nWidth := 0
   nFrom  := 1

   if ::bStrData <> nil
      cText := Eval( ::bStrData, nil, Self )
      nLen  := Len( cText )
      if ValType ( ::oDataFont ) == "B"
         oFont = Eval( ::oDataFont, Self )
      else
         oFont = ::oDataFont
      endif
      while nFrom <= nLen
        cLine  := ExtractLine( cText, @nFrom )
        cLine  := Replicate( "B", Len( cLine ) )
        nWidth := Max( nWidth, ::oBrw:GetWidth( cLine, oFont ) )
      enddo

      if ::nDataLen <> nil .AND. ::bEditValue <> nil .AND. ::cEditPicture == nil
         nWidth   := Max( nWidth, ::oBrw:GetWidth( Replicate( "B", ::nDataLen ), oFont ) )
      endif

   endif

   if ::bBmpData <> nil
      nBmpWidth   := 0
      AEval( ::aBitmaps, { |a| nBmpWidth := Max( nBmpWidth, a[ 3 ] ) } )
      nWidth   += nBmpWidth + 5
   endif

   if ::cDataType $ "PF"

      if ValType( ::Value ) == "C" .AND. ! Empty( ::Value )
         if ::cDataType == "F" .AND. File( ::Value )
            nBmp     := FILoadImg( ::Value )
         else
            nBmp     := FILoadFromMemory( ::Value )
         endif
      endif
      nWidth      := Int( GetSysMetrics( 0 ) / 10 )
      if nBmp > 0
         nWidth   := Min( nBmpWidth( nBmp ) + 4, nWidth )
      endif
      DeleteObject( nBmp )
   endif





   if ::nEditType > 1
      nWidth += ( IfNil( ::nBtnWidth, 10 ) + 5 )
   endif

return nWidth



static FUNCTION TXBrwColumn_nWidthChr( nChars ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local oFont
   local n


   oFont    := If( ValType( ::oDataFont ) == "B", Eval( ::oDataFont, Self ),  ::oDataFont )
   if PCount() == 0
      n        := ::oBrw:GetWidth( Replicate( "B", 100 ), oFont )
      nChars   := If( ::nWidth == nil, 10, Int( ::nWidth * 100 /  n ) )
   else
      nChars   := Max( 3, nChars )
      ::nWidth  := ::oBrw:GetWidth( Replicate( "B", nChars ), oFont )
   endif

return nChars



static FUNCTION TXBrwColumn_PaintHeader( nRow, nCol, nHeight, lInvert, hDC, nGrpWidth, aBitmap ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local hBrush
   local oFont
   local aColors
   local cHeader
   local nWidth, nBmpRow, nBmpCol, nBmpNo, nBmpAlign
   local lOwnDC, nBottom, nStyle

   If( lInvert == nil, lInvert := .F., ) ;

   if ::bClrHeader == nil
      ::Adjust()
   endif

   if nCol <> nil
      if nCol <> 0
         ::nDisplayCol := nCol
      endif
   else
      nCol := ::nDisplayCol
   endif

   if ! lInvert
      aColors := Eval( ::bClrHeader )
   else
      aColors := { If( ::oBrw:l2007, 0, 16777215 ), 8388608 }
   endif

   if hDC == nil
      hDC := ::oBrw:GetDC()
      lOwnDC := .F.
   else
      lOwnDC := .T.
   endif

   if nGrpWidth == nil

      nWidth   := ::nWidth
      if ::cHeader == nil

         ::cHeader := ""
      endif
      cHeader  := ::cHeader
      nRow     := nRow + ::nGrpHeight
      nHeight  := nHeight - ::nGrpHeight
      oFont    := ::oHeaderFont
      nStyle   := ::DefStyle( ::nHeadStrAlign, ! ( Chr(13)+Chr(10) $ cHeader ) )
      nBmpNo   := If( ValType( ::nHeadBmpNo ) == "B", Eval( ::nHeadBmpNo ), ::nHeadBmpNo )
      if ! Empty( ::cOrder )
         aBitmap     := ::oBrw:aSortBmp[ If( ::cOrder == "A", 1, 2 ) ]
         nBmpAlign   := 1
      elseif !Empty( aBitmap := ::aBitmap( nBmpNo ) )
         nBmpAlign   := ::nHeadBmpAlign
      endif
   else

      nWidth   := nGrpWidth
      cHeader  := ::cGrpHdr
      nHeight  := ::nGrpHeight
      oFont    := ::oGrpFont
      nStyle   := ::DefStyle( 2, ! ( Chr(13)+Chr(10) $ cHeader ) )
      if Empty( aBitmap )
         nBmpNo         := ::nGrpBmpNo
         aBitmap     := ::aBitmap( nBmpNo )
      endif
      nBmpAlign   := 0
   endif

   if ::oBrw:l2007

      GradientFill( hDC, nRow - 1, nCol, nRow + nHeight - 1, nCol + nWidth,  Eval( ::bClrGrad, lInvert ) )
   else
      hBrush  := CreateSolidBrush( aColors[ 2 ] )
      FillRect( hDC, { nRow, nCol, nRow + nHeight, nCol + nWidth }, hBrush )
      DeleteObject( hBrush )
   endif

   nCol    += ( 6 / 2 )
   nWidth  -=  6
   nRow    += ( 4 / 2 )
   nHeight -=  4












   if ! Empty( aBitmap )

      nWidth         -= aBitmap[ 3 ]
      if Empty(cHeader)
         nBmpCol := nCol + nwidth / 2
      elseif nBmpAlign == 0
         nBmpCol     := nCol
         nCol        += aBitmap[ 3 ] + 5
      else
         nBmpCol := nCol + nWidth
      endif
      nWidth         -= 5
      nBmpRow        := nRow + ( nHeight - aBitmap[ 4 ] ) / 2
      if SetAlpha() .AND. aBitmap[ 6 ]
         ABPaint( hDC, nBmpCol, nBmpRow, aBitmap[ 1 ], ::nAlphaLevelHeader )
      elseif ::oBrw:l2007
         If( aBitmap[ 5 ] == nil, aBitmap[ 5 ] := GetZeroZeroClr( hDC, aBitmap[ 1 ] ), ) ;
         SetBkColor( hDC, nRGB( 255, 255, 255 ) )


         TransBmp( aBitmap[ 1 ], aBitmap[ 3 ], aBitmap[ 4 ], aBitmap[ 5 ], hDC, nBmpCol, nBmpRow, nBmpWidth( aBitmap[ 1 ] ), nBmpHeight( aBitmap[ 1 ] ) )
      else





         PalBmpDraw( hDC, nBmpRow, nBmpCol, aBitmap[ 1 ], aBitmap[ 2 ], aBitmap[ 3 ], aBitmap[ 4 ] ,, .T., aColors[ 2 ] )
      endif
   endif

   if Empty( cHeader )
      ::oBrw:ReleaseDC()
      return nil
   endif

   oFont:Activate( hDC )
   SetTextColor( hDC, aColors[ 1 ] )
   SetBkColor( hDC, aColors[ 2 ] )
   SetBkMode ( hDC, 1 )

   if FontEsc( oFont ) % 3600 == 900

      nBottom  := nRow + nHeight / 2
      nBottom  += ( ::oBrw:GetWidth( cHeader, ::oHeaderFont ) / 2 )
      nCol     := nCol + nWidth / 2
      nCol     -= FontHeight( ::oBrw, ::oHeaderFont ) / 2



      DrawTextEx( hDC, cHeader, { nBottom, nCol, nRow, nCol + nWidth },  0x00000000 + 0x00000004 )

   elseif FontEsc( oFont ) % 3600  == 2700

      nBottom  := nRow + nHeight / 2
      nBottom  += ( ::oBrw:GetWidth( cHeader, ::oHeaderFont ) / 2 )
      nCol     := nCol + nWidth / 2
      nCol     += FontHeight( ::oBrw, ::oHeaderFont ) / 2



      DrawTextEx( hDC, cHeader, { nRow, nCol, nBottom, nCol - nWidth / 2 },  0x00000000 + 0x00000004 )

   else
      nBottom  := nRow + nHeight
      DrawTextEx( hDC, cHeader, { nRow, nCol, nBottom, nCol + Min( nWidth, ::oBrw:nWidth - 50 ) }, nStyle )
   endif

   oFont:Deactivate( hDC )

   if !lOwnDC
      ::oBrw:ReleaseDC()
   endif

return nil



static FUNCTION TXBrwColumn_nFooterType( nType ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   if PCount() > 0

      if ValType( nType ) == "N" .AND.  AScan( { 1, 4, 2, 8, 1 + 8, 1 + 8 + 16, 1 + 8 + 16 + 32 }, nType ) > 0
         if ValType( ::nTotal ) <> "N"
            ::nTotal := 0.0
         endif
         ::hFooterType  := nType
         ::lTotal       := .T.
      else
         ::hFooterType  := nil
         ::nTotal       := nil
         ::lTotal       := .F.
      endif
   endif

RETURN ::hFooterType



static FUNCTION TXBrwColumn_footerStr( ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local cFooter := "", cType

   if ::bFooter <> nil
      cFooter  := Eval( ::bFooter, Self )
      If( cFooter == nil, cFooter := "", ) ;
   elseif ::nTotal <> nil .OR. ! Empty( ::nFooterType )
      If( ::nFooterType == nil, ::nFooterType := 1, ) ; If( ::nTotal == nil, ::nTotal := 0.0, );
      if ::nFooterType >= 1 + 8 + 16
         if ::nCount > 0
            cFooter  := ::nTotalSq - ( ::nTotal * ::nTotal / ::nCount )
            cFooter  /= ::nCount - If( ::nFooterType == 1 + 8 + 16 + 32, 0, 1 )
            cFooter  ^= 0.5
         else
            cFooter  := 0
         endif
      elseif ::nFooterType == 1 + 8
         cFooter  := If( ::nCount > 0, ::nTotal / ::nCount, 0 )
      elseif ::nFooterType == 8
         cFooter  := ::nCount
      else
         cFooter  := ::nTotal
      endif
   elseif ::cFooter <> nil
      cFooter  := ::cFooter
   endif

   cType    := ValType( cFooter )
   if cType <> "C"
      if cType == ::cDataType .AND. IfNil( ::cFooterPicture, ::cEditPicture ) <> nil

         cFooter  := cValToStr( cFooter, IfNil( ::cFooterPicture, ::cEditPicture ),,  IfNil( ::lDisplayZeros, ::oBrw:lDisplayZeros ) )
      else
         cFooter := cValToChar( cFooter )
      endif
   endif

return cFooter



static FUNCTION TXBrwColumn_PaintFooter( nRow, nCol, nHeight, lInvert ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local hDC, hBrush
   local oFont
   local aColors, aBitmap
   local cFooter
   local nWidth, nBmpRow, nBmpCol, nBmpNo, nBottom

   If( lInvert == nil, lInvert := .F., ) ;

   if nCol <> nil
      ::nDisplayCol := nCol
   else
      nCol := ::nDisplayCol
   endif

   if !lInvert
      aColors := Eval( ::bClrFooter )
   else
      aColors := { 16777215, 8388608 }
   endif

   hDC     := ::oBrw:GetDC()
   oFont   := ::oFooterFont
   cFooter := ::footerStr()
   nWidth  := ::nWidth
   nBmpNo  := ::nFootBmpNo

   nBottom = nRow + ( nHeight / 3 )
   if ::oBrw:l2007

      GradientFill( hDC, nRow - 1, nCol, nRow + nHeight - 1, nCol + nWidth,  Eval( ::bClrGrad, lInvert ) )

   else
      hBrush  := CreateColorBrush( aColors[ 2 ] )
      FillRect( hDC, {nRow, nCol, nRow + nHeight, nCol + nWidth}, hBrush )
      DeleteObject( hBrush )
   endif

   nCol    += ( 6 / 2 )
   nWidth  -=  6
   nRow    += ( 4 / 2 )
   nHeight -=  4

   if !Empty( aBitmap := ::aBitmap( nBmpNo ) )
      nWidth  -= aBitmap[ 3 ]
      if Empty(cFooter)
         nBmpCol := nCol + nWidth / 2
      elseif ::nFootBmpAlign == 0
         nBmpCol := nCol
         nCol    += aBitmap[ 3 ] + 5
      else
         nBmpCol := nCol + nWidth
      endif
      nWidth  -= 5
      nBmpRow := nRow + ( nHeight - aBitmap[ 4 ] ) / 2 + 2
      if ! ::oBrw:l2007
         if SetAlpha() .AND. aBitmap[ 6 ]
            ABPaint( hDC, nBmpCol, nBmpRow, aBitmap[ 1 ], ::nAlphaLevelFooter )
         else






            PalBmpDraw( hDC, nBmpRow, nBmpCol, aBitmap[ 1 ], aBitmap[ 2 ], aBitmap[ 3 ], aBitmap[ 4 ] ,, .T., aColors[ 2 ] )
         endif
      else
         if SetAlpha() .AND. aBitmap[ 6 ]
            ABPaint( hDC, nBmpCol, nBmpRow, aBitmap[ 1 ], ::nAlphaLevelFooter )
         else

            If( aBitmap[ 5 ] == nil, aBitmap[ 5 ] := GetZeroZeroClr( hDC, aBitmap[ 1 ] ), ) ;
            SetBkColor( hDC, nRGB( 255, 255, 255 ) )


            TransBmp( aBitmap[ 1 ], aBitmap[ 3 ], aBitmap[ 4 ], aBitmap[ 5 ], hDC, nBmpCol, nBmpRow, nBmpWidth( aBitmap[ 1 ] ), nBmpHeight( aBitmap[ 1 ] ) )
         endif
      endif
   endif

   if Empty( cFooter )
      ::oBrw:ReleaseDC()
      return nil
   endif

   oFont:Activate( hDC )
   SetTextColor( hDC, aColors[ 1 ] )
   SetBkColor( hDC, aColors[ 2 ] )
   SetBkMode ( hDC, 1 )


   DrawTextEx( hDC, cFooter, {nRow, nCol, nRow + nHeight, nCol + nWidth}, ::nFootStyle )
   oFont:Deactivate( hDC )

   ::oBrw:ReleaseDC()

return nil



static FUNCTION TXBrwColumn_RefreshFooter( ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   if ! Empty( ::oBrw:nFooterHeight ) .AND. ::IsVisible()
      ::PaintFooter(::oBrw:FooterRow()+1,nil,::oBrw:nFooterHeight-4)
   endif

return nil



static FUNCTION TXBrwColumn_DataCol( ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nCol  := ::nDisplayCol
   local aBitmap

   if ::bIndent <> nil
      nCol     += IfNil( Eval( ::bIndent, Self ), 0 )
   endif
   if ::nDataBmpAlign == 0 .AND. ::bBmpData <> nil
      aBitmap  := ::aBitmap( Eval( ::bBmpData ) )
      if !Empty( aBitmap )
         nCol  += aBitmap[ 3 ] + 5
      endif
   endif

return nCol



static FUNCTION TXBrwColumn_SetColsAsRows( ... ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn



   local aCols := HB_AParams()

   if ! Empty( aCols )
      if ValType( aCols[ 1 ] ) == "A"
         aCols    := aCols[ 1 ]
      endif
      ::aRows     := {}
      AEval( aCols, { |u| AAdd( ::aRows, ::oBrw:oCol( u ) ) } )
      AEval( ::aRows, { |o| o:lHide := .T. }, 2 )
      WITH OBJECT ATail( ::aRows )
         :nDataStyle := :DefStyle( :nDataStrAlign, .F. )
      END
   endif

return Self



static FUNCTION TXBrwColumn_PaintData( nRow, nCol, nHeight, lHighLite, lSelected, nOrder, nPaintRow ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local oCol, n, nDataHeight

   if nCol <> nil
      ::nDisplayCol := nCol
   else
      nCol := ::nDisplayCol
   endif
   if ::oBrw:lTransparent .AND. Empty( ::oBrw:nRowDividerStyle )
      nHeight     -= 4
   endif
   nDataHeight    := If( Empty( ::aRows ), nHeight, IfNil( ::nCellHeight, ::DataHeight() ) )
   ::PaintCell( nRow, nCol, nDataHeight, lHighLite, lSelected, nOrder, nPaintRow )

   if ! Empty( ::aRows )
      for n := 2 to Len( ::aRows )
         nHeight        -= nDataHeight
         nRow           += nDataHeight
         oCol           := ::aRows[ n ]
         nDataHeight    := If( n == Len( ::aRows ), nHeight, IfNil( oCol:nCellHeight, oCol:DataHeight() ) )
         oCol:PaintCell( nRow, nCol, nDataHeight, lHighLite, lSelected, nOrder, nPaintRow )
      next

   endif

return nil



static FUNCTION TXBrwColumn_PaintCell( nRow, nCol, nHeight, lHighLite, lSelected, nOrder, nPaintRow ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local hDC, oBrush, hBrush, nOldColor, hBmp
   local oBrush1, oBrush2, hBrush1, hBrush2, aColor2, nWidth1
   local oFont
   local aColors, aBitmap, aBmpPal
   local cData, nTxtHeight, aRect

   local nWidth, nTop, nBottom, nBmpRow, nBmpCol, nBmpNo, nButtonRow, nButtonCol,nBtnWidth, nRectWidth, nRectCol, nStyle, nType, nIndent, nBtnBmp, nFontHeight
   local lTransparent := .F.
   local lStretch     := .F.
   local lBrush       := .F.
   local cImagen, nBmpW, nBmpH



   If( lHighLite == nil, lHighLite := .F., ) ; If( lSelected == nil, lSelected := .F., ); If( nOrder == nil, nOrder := 0, );

   nBtnBmp := 0

   if ( ::oEditGet <> nil .AND. nPaintRow == ::oBrw:nRowSel ) .OR. ::oEditLbx <> nil .OR. ::oBrw:nLen == 0
      return nil
   endif

   if nCol <> nil
      ::nDisplayCol := nCol
   else
      nCol := ::nDisplayCol
   endif

   if ValType( ::bStrData ) == "B"
      cData := Eval( ::bStrData, nil, Self )
      if ValType( cData ) <> "C"
         cData := cValToChar( cData )
      endif
      if ! Empty( ::nDataStrAlign )
         cData := AllTrim( cData )
      endif
      if isrtf( cData )
         cData := "<RichText>"
      elseif isGtf( cData )
         cData := GtfToTxt( cData )
      endif
   else
      cData := ""
   endif

   if ::bBmpData <> nil
      nBmpNo := Eval( ::bBmpData, ::Value() )
   else
      nBmpNo := 0
   endif

   if lHighLite
      if ::oBrw:hWnd == GetFocus()
         if lSelected
            if nOrder == ::oBrw:nColSel
               aColors  := Eval( ::bClrSelFocus )
            else
               aColors := Eval( If( ::oBrw:bClrRowFocus <> nil, ::oBrw:bClrRowFocus, ::bClrSelFocus ) )
            endif
          else
            aColors := Eval( If( ::oBrw:bClrRowFocus <> nil, ::oBrw:bClrRowFocus, ::bClrSelFocus ) )
          endif
      else
         aColors := Eval( ::bClrSel )
      endif
   else
      aColors := Eval( ::bClrStd )
      lTransparent := IfNil( ::lColTransparent, ::oBrw:lTransparent )
   endif

   hDC     := ::oBrw:GetDC()
   oFont   := ::oDataFont
   if ValType( oFont ) == "B"
      oFont = Eval( oFont, Self )
   endif
   nWidth  := ::nWidth
   if ::oBrw:lTransparent .AND. Empty( ::oBrw:nColDividerStyle )
      nWidth   -= 6
   endif

   if ::oBrush <> nil
      if ValType( ::oBrush ) == "B"
         oBrush   := Eval( ::oBrush, Self )
      else
         oBrush   := ::oBrush
      endif
   endif

   if oBrush <> nil
      hBrush      := oBrush:hBrush
      lBrush      := .T.
      lTransparent:= .F.

   elseif ! IfNil( ::lColTransparent, lTransparent )
      hBrush  := CreateColorBrush( aColors[ 2 ] )
   elseif ::lColTransparent == .T.
      hBrush := CreateColorBrush( 0 )
      lTransparent := .T.
   endif

   nStyle  := ::oBrw:nColDividerStyle
   nType   := ::nEditType

   if nStyle == 0
      nRectWidth := nWidth + 2
      nRectCol   := nCol
   elseif nStyle < 5 .AND. nOrder > 1
      nRectWidth := nWidth + 1
      nRectCol   := nCol - 1
   else
      nRectWidth := nWidth
      nRectCol   := nCol
   endif

   nBottom  := nRow + nHeight
   if ! lTransparent
      nTop        := nRow
      if ::lMergeVert .AND. lHighLite .AND. lSelected .AND. nOrder == ::oBrw:nColSel
         ::MergeArea( @nTop, @nBottom, nPaintRow )
      endif
      if ValType( aColors[ 2 ] ) == "A"
         GradientFill( hDC, nTop, nRectCol, nBottom-1, Min( nRectCol + nRectWidth, ::oBrw:BrwWidth() ), aColors[ 2 ], .T. )
      else
         FillRect( hDC, { nTop, nRectCol, nBottom, Min( nRectCol + nRectWidth, ::oBrw:BrwWidth() ) }, hBrush )
      endif
   endif

   if ::bIndent <> nil
      nIndent  := Eval( ::bIndent, Self )
      if ! Empty( nIndent )
         nCol   += nIndent
         nWidth -= nIndent
      endif
   endif

   nCol    += ( 6 / 2 )
   nWidth  -=  6
   nRow    += ( 4 / 2 )
   nHeight -=  4







   if nType > 1
      if ! Empty( aBitmap := ::aBitmap( ::nBtnBmp ) )
         nBtnWidth      := aBitMap[ 3 ] + 1
         aBitmap        := nil
      else
         nBtnWidth      := IfNil( ::nBtnWidth, 10 )
      endif
      nButtonRow  := nRow
      nButtonCol  := nCol + nWidth - nBtnWidth
      nWidth      -= ( nBtnWidth + 5 )
   else
      if ::lWillShowABtn
         nWidth -= ( IfNil( ::nBtnWidth, 10 ) + 5 )
      endif
   endif

   if ::lProgBar
      aColor2  := Eval( ::bClrProg )
      hBrush1  := CreateColorBrush( aColor2[ 1 ] )
      hBrush2  := CreateColorBrush( aColor2[ 2 ] )


      nWidth1  := Min( ::Value() * nWidth /  Max( 1, If( ValType( ::nProgTot ) == "B", Eval( ::nProgTot, Self ), ::nProgTot ) ),  nWidth )

      FillRect( hDC, { nRow, nCol, nRow + nHeight, Min( nCol + nWidth1, ::oBrw:BrwWidth() - 4 ) }, hBrush1 )

      if nCol + nWidth1 < ::oBrw:BrwWidth() - 4

         FillRect( hDC, { nRow, nCol + nWidth1 + 1, nRow + nHeight,  Min( nCol + nWidth, ::oBrw:BrwWidth() - 4 ) }, hBrush2 )
      endif
      DeleteObject( hBrush1 )
      DeleteObject( hBrush2 )

   endif

   if !Empty( aBitmap := ::aBitmap( nBmpNo ) )
      nWidth  -= aBitmap[ 3 ]
      if ::bStrData == nil .OR. ::nDataBmpAlign == 2
         nBmpCol  := Max( 0, nCol + nWidth / 2 )
         lStretch := ::lBmpStretch

      elseif ::nDataBmpAlign == 0
         nBmpCol := nCol
         nCol    += aBitmap[ 3 ] + 5
      else
         nBmpCol := nCol + nWidth
      endif
      nWidth  -= 5
      nBmpRow := nRow + ( ( nHeight - aBitmap[ 4 ] ) / 2 )

      if ::lMergeVert
         nTop     := nRow
         nBottom  := nRow + nHeight - 1
         ::MergeArea( @nTop, @nBottom, nPaintRow )
         nBmpRow := nTop + ( ( ( nBottom - nTop + 1 ) - aBitmap[ 4 ] ) / 2 )
      endif

 aBitmap[ 5 ] := GetZeroZeroClr( hDC, aBitmap[ 1 ] )

      if lStretch

         if SetAlpha() .AND. aBitmap[ 6 ]
            hBmp := ResizeImg( aBitmap[ 1 ], Min( nRectWidth,::oBrw:BrwWidth() - nRectCol - 4 ), nBottom - nRow )
            ABPaint( hDC, nRectCol, nRow, hBmp, ::nAlphaLevel() )
         else
            nOldColor  := SetBkColor( hDC, nRGB( 255, 255, 255 ) )


            TransBmp( aBitmap[ 1 ], aBitmap[ 3 ], aBitmap[ 4 ], aBitmap[ 5 ], hDC, nRectCol, nRow, Min( nRectWidth,::oBrw:BrwWidth() - nRectCol - 4 ),  nBottom - nRow )
            SetBkColor( hDC, nOldcolor )
         endif

      else
         if SetAlpha() .AND. aBitmap[ 6 ]
            ABPaint( hDC, nBmpCol, nBmpRow,aBitmap[ 1 ], ::nAlphaLevel() )
         else
            if ::oBrw:lTransparent .OR. ValType( aColors[ 2 ] ) == "A"
                nOldColor := SetBkColor( hDC, nRGB( 255, 255, 255 ) )



                TransBmp( aBitmap[ 1 ], aBitmap[ 3 ], aBitmap[ 4 ], aBitmap[ 5 ], hDC, nBmpCol, nBmpRow, aBitmap[ 3 ],  aBitmap[ 4 ] )

                SetBkColor( hDC, nOldColor )
             else





                PalBmpDraw( hDC, nBmpRow, nBmpCol, aBitmap[ 1 ], aBitmap[ 2 ], aBitmap[ 3 ], aBitmap[ 4 ] ,, ::lBmpTransparent, aColors[ 2 ] )

            endif
         endif
      endif
   endif

   if ! Empty( cData ) .AND. IsBinaryData( cData )
      if IfNil( FITypeFromMemory( cData ), -1 ) >= 0
         cImagen  := cData
         cData    := ""
      else
         cData    := RangeRepl( Chr(0), Chr(31), cData, "." )

      endif
   endif

   if ! Empty( cImagen ) .OR. ::cDataType $ "FP"
      if ! Empty( cImagen )
         hBmp     := FILoadFromMemory( cImagen )
      else
         if ::bStrImage == NIL
            cImagen := ::Value()
         else
            cImagen := Eval( ::bStrImage, Self, ::oBrw )
         endif
         if ::cDataType == "F" .AND. File( cImagen )
            hBmp     := FILoadImg( cImagen )
         else
            hBmp     := FILoadFromMemory( IfNil( cImagen, "" ) )
         endif
      endif

      aBmpPal     := { hBmp, 0 }
      if aBmpPal[ 1 ] == 0
         aBmpPal := PalBmpLoad( cImagen )
      endif

      if aBmpPal[ 1 ] <> 0
         Aadd(aBmpPal, nBmpWidth( aBmpPal[ 1 ] ) )
         Aadd(aBmpPal, nBmpHeight( aBmpPal[ 1 ] ) )
         Aadd(aBmpPal, if ( ::lBmpTransparent, GetZeroZeroClr( hDC, aBmpPal[ 1 ] ),0) )
         Aadd(aBmpPal, HasAlpha( aBmpPal[ 1 ] ) )

         if ::lBmpStretch
            nBmpW       := nWidth - 2
            nBmpH       := nBottom - nRow - 2
            nBmpCol     := nCol + 1
            nBmpRow     := nRow + 1
         else
            nBmpW       := aBmpPal[ 3 ]
            nBmpH       := aBmpPal[ 4 ]
            if nBmpW > ( nWidth - 4 )
               nBmpH    *= ( ( nWidth - 4 ) / nBmpW )
               nBmpW    := nWidth - 4
            endif
            if nBmpH > ( nBottom - nRow - 4 )
               nBmpW    *= ( ( nBottom - nRow - 4 ) / nBmpH )
               nBmpH    := ( nBottom - nRow ) - 4
            endif
            nBmpRow     := nRow + ( nHeight - nBmpH ) / 2 + 2
            nBmpCol     := nCol + 2

            if ::nDataBmpAlign == 2
               nBmpCol  := nCol + ( nWidth - nBmpW ) / 2
            elseif ::nDataBmpAlign == 1
               nBmpCol  := nCol + nWidth - nBmpW
            endif

         endif

         if SetAlpha() .AND. aBmpPal[ 6 ]

            hBmp := ResizeImg( aBmpPal[ 1 ], nBmpW, nBmpH )
            ABPaint( hDC, nBmpCol, nBmpRow, hBmp, ::nAlphaLevel() )
            DeleteObject( hBmp )

         elseif ::lBmpTransparent

            nOldColor := SetBkColor( hDC, nRGB( 255, 255, 255 ) )

            TransBmp( aBmpPal[ 1 ], aBmpPal[ 3 ], aBmpPal[ 4 ], aBmpPal[ 5 ], hDC, nBmpCol, nBmpRow, nBmpW, nBmpH )
            SetBkColor( hDC, nOldColor )

         else

            if nBmpW <> aBmpPal[ 3 ] .OR. nBmpH <> aBmpPal[ 4 ]
               hBmp := ResizeImg( aBmpPal[ 1 ], nBmpW, nBmpH )
               DrawBitmap( hDC, hBmp, nBmpRow, nBmpCol )
               DeleteObject( hBmp )
            else
               DrawBitmap( hDC, aBmpPal[ 1 ], nBmpRow, nBmpCol )
            endif

         endif

      endif

   endif

   if ! Empty( cData ) .AND. ! ( ::cDataType $ "PF" )
      oFont:Activate( hDC )
      nFontHeight := GetTextHeight( ::oBrw:hWnd, hDC )
      if ::oBrw:lTransparent .AND. ::oBrw:lContrastClr


         SetTextColor( hDC, ContrastColor( hDC, nCol, nRow,  Min( nWidth, ::oBrw:BrwWidth() - nCol ),  nHeight, aColors[ 1 ] ) )
      else
         SetTextColor( hDC, aColors[ 1 ] )
      endif
      if lTransparent .OR. lBrush .OR. ::lProgBar .OR. ValType( aColors[ 2 ] ) == "A"
         SetBkMode( hDC, 1 )
      else
         nOldColor := SetBkColor( hDC, aColors[ 2 ] )
      endif

      nTop     := nRow
      nBottom  := nRow + nHeight

      if ::lMergeVert
         ::MergeArea( @nTop, @nBottom, nPaintRow )
      endif

      aRect       := { nTop, nCol, nBottom, Min( nCol + nWidth, ::oBrw:BrwWidth() - 5 ) }
      if ::bPaintText == nil

         nStyle      := ::nDataStyle


         if ::oBrw:nDataType == 2 .AND.  ::nDataStrAlign == 0 .AND.  ValType( ::Value ) $ "ND"

            nStyle   := ::DefStyle( 1, .T. )
         endif












         if Chr(13)+Chr(10) $ cData .OR. ( ::cDataType <> nil .AND. ::cDataType $ "CM" .AND. lAnd( nStyle, 0x00000020 ) .AND.  ::oBrw:nRowHeight > 2 * nFontHeight + 2 )

            cData    := Trim( cData )

            if ( nTxtHeight := DrawTextEx( hDC, cData, aRect, nOr( 0x00000400, 0x00000010 ) ) ) >  DrawTextEx( hDC, cData, aRect, nOr( 0x00000400, 0x00000020 ) )

               nStyle      := nOr( nAnd( nStyle, nNot( 0x00000020 ) ), 0x00000010 )
               if lAnd( ::nDataStrAlign, 4 )

               elseif lAnd( ::nDataStrAlign, 8 )
                  aRect[ 1 ]  += Max( 0, Int( ( nHeight - nTxtHeight - 1 ) ) )
               else
                  aRect[ 1 ]  += Max( 0, Int( ( nHeight - nTxtHeight ) / 2 ) )
               endif

               if ::nDataLines == nil .AND. ::cDataType == "M"
                  ::nDataLines   := 2
               endif

            endif
         endif

         DrawTextEx( hDC, cData, aRect, nStyle )
      else
         Eval( ::bPaintText, Self, hDC, cData, aRect, aColors, lHighLite )
      endif
      if nOldColor <> nil
         SetBkcolor( hDC, nOldColor )
         nOldColor := nil
      endif
      oFont:Deactivate( hDC )
   else
      aRect       := { nRow, nCol, nRow + nHeight, Min( nCol + nWidth, ::oBrw:BrwWidth() - 5 ) }
      if ::bPaintText <> nil
         Eval( ::bPaintText, Self, hDC, "", aRect, aColors, lHighLite )
      endif
   endif

   if nType > 1 .AND. nType < 6
      if lSelected
         if !::lBtnTransparent

               WndBoxRaised(hDC, nButtonRow -1 , nButtonCol - 1, nButtonRow + nHeight, nButtonCol + nBtnWidth + 1 )
         endif

         if nType == 2 .OR. nType == 4
           ::oBtnElip:Hide()
           ::oBtnList:Move( nButtonRow, nButtonCol, nBtnWidth + 1, nHeight, .F.)
           ::oBtnList:Show()
           ::oBtnList:GetDC()
           if ::lBtnTransparent
              ::oBtnList:SetColor( aColors[ 1 ],aColors[ 2 ] )
           else

              FillRect( hDC, {nButtonRow, nButtonCol, nButtonRow + nHeight , nButtonCol + nBtnWidth + 1 } , ::oBtnList:oBrush:hBrush  )
           endif
           ::oBtnList:Paint()
           ::oBtnList:ReleaseDC()
         else
            ::oBtnList:Hide()
            ::oBtnElip:Move( nButtonRow, nButtonCol, nBtnWidth + 1, nHeight, .F.)
            ::oBtnElip:Show()
            ::oBtnElip:GetDC()
           if ::lBtnTransparent
              ::oBtnElip:SetColor( aColors[ 1 ],aColors[ 2 ] )
           else

              FillRect( hDC, {nButtonRow, nButtonCol, nButtonRow + nHeight , nButtonCol + nBtnWidth + 1 }, ::oBtnElip:oBrush:hBrush )
           endif
            ::oBtnElip:Paint()
            ::oBtnElip:ReleaseDC()
         endif
      endif
   endif

   if hBrush <> nil .AND. ! lBrush
      DeleteObject( hBrush )
   endif
   if aBmpPal <> nil
      DeleteObject( aBmpPal[ 1 ]  )
   endif
   ::oBrw:ReleaseDC()

return nil



static FUNCTION TXBrwColumn_EraseData( nRow, nCol, nHeight, hBrush, lFixHeight ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local hDC
   local aColors
   local nWidth
   local lCreated

   If( lFixHeight == nil, lFixHeight := .F., ) ;

   lCreated := .F.

   if nCol <> nil
      ::nDisplayCol := nCol
   else
      nCol := ::nDisplayCol
   endif

   if hBrush == nil
      aColors  := Eval( ::bClrStd )
      hBrush   := CreateColorBrush( aColors[ 2 ] )
      lCreated := .T.
   endif

   hDC     := ::oBrw:GetDC()
   nWidth  := ::nWidth

   if ::oBrw:nColDividerStyle < 5
      nCol--
      nWidth++
   endif

   if ::oBrw:nColDividerStyle == 0
      nWidth += 2
   endif

   if !lFixHeight .AND. ::oBrw:nRowDividerStyle > 0
      nHeight --
   endif

   if !lFixHeight .AND. ::oBrw:nRowDividerStyle >= 5
      nHeight --
   endif

   FillRect( hDC, {nRow, nCol, nRow + nHeight, nCol + nWidth}, hBrush )

   if lCreated
      DeleteObject( hBrush )
   endif

return nil



static FUNCTION TXBrwColumn_Box( nRow, nCol, nHeight, nType ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local hDC
   local nWidth

    nType := 1

   if nCol <> nil
      ::nDisplayCol := nCol
   else
      nCol := ::nDisplayCol
   endif

   hDC     := ::oBrw:GetDC()
   nWidth  := ::nWidth

   if ::nPos > 1 .AND. ::oBrw:nColDividerStyle < 5
      nCol--
      nWidth++
   endif

   do case
   case nType == 1
      DrawFocusRect( hDC, nRow, nCol, nRow + nHeight - 1, nCol + nWidth - 1 )
   case nType == 2
      WndBox( hDC, nRow, nCol, nRow + nHeight - 1, nCol + nWidth - 1 )
   case nType == 3
      WndBoxRaised( hDC, nRow, nCol, nRow + nHeight - 1, nCol + nWidth - 1 )
   endcase

return nil



static FUNCTION TXBrwColumn_DefStyle( nAlign, lSingleLine ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nStyle, nVAlign

   nStyle   := nOr( 0x00010000, 0x00002000, 0x00000800 )
   nVAlign  := nAnd( nAlign, 12 )
   nVAlign  := If( nVAlign == 4, 0x00000000, If( nVAlign == 8, 0x00000008, 0x00000004 ) )
   nAlign   := nAnd( nAlign, 3 )

   do case
   case nAlign == 0
      nStyle  := nOr( nStyle, 0x00000000 )
   case nAlign == 1
      nStyle  := nOr( nStyle, 0x00000002 )
   case nAlign == 2
      nStyle  := nOr( nStyle, 0x00000001 )
   end

   if lSingleLine
      nStyle := nOr( nStyle, 0x00000020, nVAlign )
   else
      nStyle := nOr( nStyle, 0x00000010)
   endif

return nStyle



static FUNCTION TXBrwColumn_HeaderLButtonDown( nMRow, nMCol, nFlags ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn



   if ::oBrw:nCaptured == 0 .AND.  ( ::oBrw:lAllowColSwapping .OR. ! Empty( ::cSortOrder ) .OR.  ::bLClickHeader <> nil )

      ::oBrw:oCapCol   := Self
      ::oBrw:nCaptured := 1
      ::oBrw:Capture()
      ::PaintHeader( 2, nil, ::oBrw:nHeaderHeight - 3, .T. )
   endif

return nil



static FUNCTION TXBrwColumn_HeaderLButtonUp( nMRow, nMCol, nFlags ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local oCol
   local nCol
   local lDragged

   lDragged := .F.

   if ::oDragWnd <> nil
      ::oDragWnd:End()
      ::oDragWnd := nil
      lDragged := .T.
   endif

   ::PaintHeader( 2, nil, ::oBrw:nHeaderHeight - 3 )

   if !lDragged

      if empty( nMRow ) .OR. empty( nMCol )
        return .F.
      end


      if nMRow <= ::oBrw:nHeaderHeight   .AND. nMCol <= ( ::nWidth + ::nDisplayCol )

         if ::SetOrder()
            ::oBrw:Refresh()
            ::oBrw:oWnd:Update()
         else
            ::PaintHeader( 2, nil, ::oBrw:nHeaderHeight - 3 )
         endif

         if ::bLClickHeader <> nil
            Eval( ::bLClickHeader, nMRow, nMCol, nFlags, Self )
            ::PaintHeader( 2, nil, ::oBrw:nHeaderHeight - 3 )
         endif

      endif

   else

      nCol := ::oBrw:MouseColPos( nMCol )
      if nCol > 0
         oCol := ::oBrw:ColAtPos( nCol )
         if oCol:nCreationOrder <> ::nCreationOrder

            ::oBrw:MoveCol( Self, oCol, .T., .T. )
         endif
      endif

   endif

return nil



static FUNCTION TXBrwColumn_FooterLButtonDown( nMRow, nMCol, nFlags ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   if ::oBrw:nCaptured == 0 .AND. ::blClickFooter <> nil
      ::oBrw:oCapCol   := Self
      ::oBrw:nCaptured := 2
      ::oBrw:Capture()
      ::PaintFooter( ::oBrw:FooterRow()+ 1 , nil, ::oBrw:nFooterHeight - 4, .T. )
   endif

return nil



static FUNCTION TXBrwColumn_FooterLButtonUp( nMRow, nMCol, nFlags ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   ::PaintFooter( ::oBrw:FooterRow()+ 1 , nil, ::oBrw:nFooterHeight - 4)





   if ::bLClickFooter <> nil .AND.  nMRow >= ::oBrw:FooterRow() .AND.  nMRow <= ( ::oBrw:FooterRow() + ::oBrw:nFooterHeight - 3 ) .AND.  nMCol >= ::nDisplayCol .AND.  nMCol <= ( ::nWidth + ::nDisplayCol )
      Eval( ::bLClickFooter, nMRow, nMCol, nFlags, Self )
   endif

return nil



static FUNCTION TXBrwColumn_ResizeBeg( nMRow, nMCol, nFlags ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nCol, nWidth

   if ::oBrw:nCaptured == 0
      ::oBrw:oCapCol   := Self
      ::oBrw:nCaptured := 3
      ::oBrw:Capture()
      nCol   := ::nDisplayCol + ::nWidth
      nWidth := nCol + iif( ::oBrw:nColDividerStyle >= 5, 3, 1)
      ::nResizeCol := nCol
      InvertRect( ::oBrw:GetDC(), { 0, nCol - 1 , ::oBrw:BrwHeight(),  nWidth + 1} )
      ::oBrw:ReleaseDC()
   endif

return nil



static FUNCTION TXBrwColumn_ResizeEnd( nMRow, nMCol, nFlags ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nWidth

   if ::nResizeCol <> nil
      nWidth := ::nResizeCol + iif( ::oBrw:nColDividerStyle >= 5, 3, 1)
      InvertRect( ::oBrw:GetDC(), { 0, ::nResizeCol - 1, ::oBrw:BrwHeight(),  nWidth + 1 } )
      ::oBrw:ReleaseDC()
      if Abs( nMCol - ::nDisplayCol - ::nWidth ) > 2
         ::nWidth := Max( nMCol - ::nDisplayCol, 10 )
         ::oBrw:ColStretch()
         ::oBrw:Refresh()
      endif
      ::nResizeCol := nil
   endif

return nil



static FUNCTION TXBrwColumn_MouseMove( nMRow, nMCol, nFlags ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nRow, nCol, nWidth
   local hDC

   do case
   case ::oBrw:nCaptured == 1



      if ::oDragWnd == nil .AND.  nMRow <= ::oBrw:nHeaderHeight  .AND.  nMCol <= ( ::nWidth + ::nDisplayCol ) .AND.  nMCol >= ::nDisplayCol
         return nil
      endif

      if !::oBrw:lAllowColSwapping
         return nil
      endif

      nRow := 0
      nCol := nMCol - ( ::nWidth / 2 )

      if ::oDragWnd == nil
         ::PaintHeader( 2, nil, ::oBrw:nHeaderHeight - 3 )
         ::oDragWnd := TWindow():New(,,,,, 1073741824,,,, ::oBrw,,,,,,, !.F., !.F., !.F., !.F., .F.,, "::oDragWnd",, )

         ::oDragWnd:bPainted := {| hDC | ::PaintHeader( 0, 0, ::oBrw:nHeaderHeight, .T., hDC ), WndRaised( ::oDragWnd:hWnd, hDC ) }
         ::oDragWnd:Move(nRow, nCol, ::nWidth, ::oBrw:nHeaderHeight)
         ::oDragWnd:Activate(, ::oDragWnd:bLClicked, ::oDragWnd:bRClicked, ::oDragWnd:bMoved, ::oDragWnd:bResized, ::oDragWnd:bPainted, ::oDragWnd:bKeyDown, ::oDragWnd:bInit,,,,,,,,,,, ::oDragWnd:bLButtonUp, .F. )
      else
         ::oDragWnd:Move(nRow, nCol, ::nWidth, ::oBrw:nHeaderHeight, .T.)
      endif

   case ::oBrw:nCaptured == 3
      CursorWE()
      if nMCol > ( ::nDisplayCol + 10 ) .AND. nMCol < ( ::oBrw:BrwWidth() - 10 )
         hDC    := ::oBrw:GetDC()
         nWidth := iif( ::oBrw:nColDividerStyle >= 5, 3, 1)
         if ::nResizeCol <> nil
            InvertRect( hDC, { 0, ::nResizeCol - 1 , ::oBrw:BrwHeight(),  ::nResizeCol + nWidth + 1 } )
         endif
         ::nResizeCol := nMCol
         InvertRect( hDC, { 0, nMCol - 1, ::oBrw:BrwHeight(),  nMCol + nWidth + 1} )
         ::oBrw:ReleaseDC()
      endif

   endcase

return nil



static FUNCTION TXBrwColumn_CreateButtons( ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local aColors

    if ::oBtnList <> nil .AND. ::oBtnElip <> nil
        ::oBtnList:Hide()
        ::oBtnElip:Hide()
        return nil
    endif

   if ::oBrw:lCreated

      aColors := Eval( ::bClrHeader )

      if ::oBtnList <> nil
         ::oBtnList:End()
      endif
      if ::oBtnElip <> nil
         ::oBtnElip:End()
      endif

      ::oBtnList := TBtnBmp():New( 0, 0, 0, 0, "",,,,, ::oBrw,,, .F., .F.,,,,, !.T.,, .F.,,, .F.,, !.F.,, .F., .F., .F.,,, .F. )
      ::oBtnList:hBitmap1 := FwDArrow()
      ::oBtnList:bAction := { || ::ShowBtnList() }
      ::oBtnList:SetFont( If( ValType( ::oDataFont ) == "B", Eval( ::oDataFont, Self ), ::oDataFont ) )
      ::oBtnList:SetColor( aColors[ 1 ], aColors[ 2 ] )

      ::oBtnElip := TBtnBmp():New( 0, 0, 0, 0,,,,,, ::oBrw,,, .F., .F.,,,,, !.T.,, .F.,,, .F.,, !.F.,, .F., .F., .F.,,, .F. )
      ::oBtnElip:cCaption := IfNil( ::cBtnCaption, "..." )
      ::oBtnElip:bAction := {|| ::RunBtnAction() }
      ::oBtnElip:SetFont( If( ValType( ::oDataFont ) == "B", Eval( ::oDataFont, Self ), ::oDataFont ) )
      ::oBtnElip:SetColor( aColors[ 1 ], aColors[ 2 ] )

      if ::nBtnBmp > 0 .AND. !empty( ::aBitMaps )
         if ::nBtnBmp > len( ::aBitMaps )
            ::nBtnBmp := len( ::aBitMaps )
         endif
            ::ChangeBitMap()
      endif

      ::oBtnList:Hide()
      ::oBtnElip:Hide()

   endif

return nil



static FUNCTION TXBrwColumn_ChangeBitmap( ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   if ::nBtnBmp > 0 .AND. len( ::aBitmaps ) >= ::nBtnBmp
      DeleteObject( ::oBtnElip:hBitmap1 )
      ::oBtnElip:hBitmap1 := ::aBitMaps[::nBtnBmp, 1 ]
      DeleteObject( ::oBtnList:hBitmap1 )
      ::oBtnList:hBitmap1 := ::aBitMaps[::nBtnBmp, 1 ]
      ::oBtnElip:cCaption := ""
  else
      ::oBtnElip:hBitmap1 := 0
      ::oBtnList:hBitmap1 := 0
      ::oBtnElip:cCaption := "..."
  endif

  ::oBrw:refresh()

return nil



static FUNCTION TXBrwColumn_nEditType( nType ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   if nType <> nil
      ::hEditType := ntype
      ::CreateButtons()
   endif

return ::hEditType



static FUNCTION TXBrwColumn_isEditKey( cKey ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local lEditKey := .F.
   local cDataType

   if ValType( cKey ) == "N"
      cKey     := Upper( Chr( cKey ) )
   endif

   if ::cEditKeys <> nil
      if cKey $ ::cEditKeys
         lEditKey := .T.
      endif
   else
      cDataType      := ::cDataType
      if cDataType == nil
         cDataType   := ValType( ::Value )
      endif
      if cDataType == "N"
         if IsDigit( cKey ) .OR. cKey == "-" .OR. cKey == "." .OR. ( cKey == "=" .AND. ::oBrw:lFormulaEdit )
            lEditKey := .T.
         endif
      elseif cDataType $ "DT"
         lEditKey := IsDigit( cKey )
      else
         if IsAlpha( cKey ) .OR. IsDigit( cKey )
            lEditKey := .T.
         endif
      endif
   endif

return lEditKey



static FUNCTION TXBrwColumn_Edit( nKey ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local aColors
   local uValue, cPic
   local nRow, nCol, nWidth, nHeight, nBtnWidth
   local hBrush
   local lCenter, lRight
   local oFont

   if ::cDataType <> nil .AND. ::cDataType $ "FP"
      return nil
   endif

   if ValType ( ::oEditFont ) == "B"
         oFont = Eval( ::oEditFont, Self )
    else
         oFont = ::oEditFont
   endif

   nBtnWidth := 10

   if ::bOnPostEdit == nil

      MsgStop( "oCol:bOnPostEdit not defined", "Fivewin: Class TXBrwColumn" )
      return .F.
   endif

   if ::nEditType == 2
      return ::ShowBtnList( nKey )
    endif

    if ::nEditType == 3
        return ::RunBtnAction( nKey )
    endif

    if ::oEditGet <> nil
        ::oEditGet:End()
    endif





   cPic    := ::cEditPicture
   If( cPic == nil, cPic := "", ) ;

   uValue  := IfNil( ::Value, ::BlankValue() )

   if ValType( uValue ) == "B"
      uValue   := Eval( uValue )
   endif

   if ValType( uValue ) == "T" .AND. cPic == "@D"
      uValue   := FW_TTOD( uValue )
   endif
   if ValType( uValue ) $ "DT"
      cPic     := nil
   endif

   if ::nEditType >= 6
      return ::EditDateTime( nKey )
   endif

   aColors := Eval( ::bClrEdit )
   lCenter := lAnd( ::nDataStrAlign, 2 )
   lRight  := lAnd( ::nDataStrAlign, 1 )

   nRow    := ( ( ::oBrw:nRowSel - 1 ) * ::oBrw:nRowHeight ) + ::oBrw:HeaderHeight()

   hBrush := CreateColorBrush( aColors[ 2 ] )
   ::EraseData( nRow, ::nDisplayCol, ::oBrw:nRowHeight  , hBrush )
   DeleteObject( hBrush )

   if ValType( uValue ) == "C"
      if IsBinaryData( uValue )
         return ::RunBtnAction()
      elseif ::cDataType == "M" .AND. IfNil( ::nDataLines, ::oBrw:nDataLines ) < 2
         return ::RunBtnAction()
      endif
   endif

   cPic     := xEval( cPic, uValue )

   if ValType( uValue ) == "C" .AND. IfNil( ::nDataLines, ::oBrw:nDataLines ) >= 2 .AND.  Empty( cPic )

      if isRtf( uValue ) .OR. isGtf( uValue )
         return nil
      else


         ::oEditGet := TMultiGet():New( 0,0,{ | u | If(PCount()==0,uValue,uValue:= u ) }, ::oBrw,0,0,oFont,.F.,aColors[ 1 ],aColors[ 2 ] ,,.F.,,.F.,,lCenter,lRight,.F.,,,.F.,.T.,.F. )
      endif
   else

      if ValType( uValue ) $ "AHO"
         XBrowse( uValue, ::cHeader, nil, nil, nil, nil, nil, .T. )
         return .F.
      else
         if nKey == Asc( "=" )
            uValue   := Space( 128 )
            cPic     := "@KS" + LTrim( Str( ::nWidthChr() ) )
         endif


         if Empty( cPic ) .AND. ValType( uValue ) == "N"
            cPic     := NumPict( ::nWidthChr, Len( AfterAtNum( ".", cValToChar( uValue ) ) ) )
         endif




         ::oEditGet := TGet():New( 0,0,{ | u | If(PCount()==0,uValue,uValue:= u ) }, ::oBrw,0,0,cPic,,aColors[ 1 ],aColors[ 2 ] ,oFont,.F.,,.F.,,.F.,,lCenter,lRight,,.F.,.F.,.T.,,.F.,,,,)
      endif
   endif

   nRow    := ( ( ::oBrw:nRowSel - 1  ) * ::oBrw:nRowHeight ) + ::oBrw:HeaderHeight() + 2

   nCol     := ::DataCol()

   if ::nBtnBmp > 0 .AND. len( ::aBitmaps ) >= ::nBtnBmp
      nBtnWidth      :=    ::aBitMaps[ ::nBtnBmp, 3 ]
   else
      nBtnWidth      :=    4
   endif

   nWidth  := ::nWidth - nBtnWidth

   nHeight := ::oBrw:nRowHeight - 4

   if ::nEditType > 2
      nWidth -= 13
   endif

   if nKey == Asc( "=" )
     ::oEditGet:bValid  := {| oGet |
                              local lValid, cBuf

                              oGet:lValidating := .T.
                              cBuf        := SubStr( oGet:VarGet(), 2 )
                              lValid      := Type( StrTran( cBuf, "%", "/100" ) ) == "N"
                              if lValid
                                 oGet:VarPut( &( StrTran( cBuf, "%", "/100" ) ) )
                                 if ::bEditValid <> nil
                                    if ! ( lValid := Eval( ::bEditValid, oGet, Self ) )
                                       oGet:VarPut( "=" + cBuf )
                                    endif
                                 endif
                              endif
                              if lValid
                                 oGet:bValid := nil
                              else
                                 oGet:SetFocus()
                              endif
                              oGet:lValidating := .F.
                              return lValid
                           }
   else

   if ::bEditValid <> nil









      ::oEditGet:bValid := { | oGet, lRet | oGet:lValidating := .T.,  lRet := Eval( ::bEditValid, oGet, Self ), oGet:lValidating := .F.,  If( lRet, oGet:bValid := nil, oGet:SetFocus() ), lRet }

   endif

   endif

   ::oEditGet:bKeyDown   := { | nKey | EditGetkeyDown( Self, nKey ) }

   ::oEditGet:bLostFocus := { | oGet, hWndFocus | EditGetLostFocus( oGet, hWndFocus, ::oBrw, ::oEditGet, Self ) }

   if ::bGetChange <> nil
      ::oEditGet:bChange   := { | k, f, o | ::oBrw:nLastKey := k, Eval( ::bGetChange, k, f, o, Self ) }
   else
      ::oEditGet:bChange    := { | k, f, o | ::oBrw:nLastKey := k, .T. }
   endif

   ::oEditGet:nLastKey := 0

   ::oEditGet:Move( nRow, nCol, nWidth, nHeight, .T. )
   ::oEditGet:SetFocus()


   if XbrGetSelectAll() == .T. .OR.  ( XBrGetSelectAll() == nil .AND. nKey <> nil .AND. ValType( uValue ) <> "N" .AND.  ::oEditGet:ClassName() == "TGET" )
      ::oEditGet:SelectAll()
   endif

   ::oBrw:lEditMode := .T.

   if ::oBtnElip <> nil
      ::oBtnElip:Refresh()
   endif

   if ::oBtnList <> nil
      ::oBtnList:Refresh()
   endif

    if ::lEditBorder
      WndBoxIn( ::oBrw:GetDC(), nRow-1, nCol-1, nRow + nHeight + 1, nCol + nWidth + 1)
       ::oBrw:ReleaseDC()
   endif

    if nKey <> nil
      PostMessage( ::oEditGet:hWnd, 258, nKey )
    endif

   ::oBrw:nLastEditCol := ::nPos

   if ::bOnPreEdit <> nil
      Eval( ::bOnPreEdit, Self )
   endif

return .T.



static function fnAddBitmap( o, uBmp )

   local nBmpNo := 0, aBmpPal, hBmp, oBrw

   if ValType( uBmp ) == "A"
      AEval( uBmp, { |u| nBmpNo := fnAddBitmap( o, u ) } )
      return nBmpNo
   endif

   if ValType( uBmp ) == "N" .AND. uBmp <> 0
      if IsGdiObject( uBmp )
         hBmp                     := uBmp
         aBmpPal                  := { hBmp, 0, 0, 0, nil, .F. }
      else
         aBmpPal := PalBmpLoad( uBmp )
      endif
   elseif ValType( uBmp ) == "C"
      uBmp     := AllTrim( uBmp )
      if Lower( Right( uBmp, 4 ) ) == ".bmp"
         if file( uBmp )
            oBrw     := If( o:IsKindOf( "TXBROWSE" ), o, o:oBrw )
            aBmpPal := PalBmpRead( oBrw:GetDC(), uBmp )
            oBrw:ReleaseDC()
         endif
      elseif !( "." $ uBmp )
         aBmpPal := PalBmpLoad( uBmp )
      endif
   endif

   if ! Empty( aBmpPal ) .AND. ( hBmp := aBmpPal[ 1 ] ) <> 0
      ASize( aBmpPal, 6 )
      aBmpPal[ 3  ] := nBmpWidth(  hBmp )
      aBmpPal[ 4 ] := nBmpHeight( hBmp )
      aBmpPal[ 6  ] := HasAlpha(   hBmp )
      AAdd( o:aBitmaps, aBmpPal )
      nBmpNo   := Len( o:aBitmaps )
   endif

return nBmpNo



static function EditGetLostFocus( oGet, hWndFocus, oBrw, oEditGet, oCol )

   local oWnd



   if ( oWnd := oWndFromHwnd( hWndFocus ) ) <> nil .AND. ! ( oWnd == oBrw ) .AND.  Upper( oWnd:ClassName() ) <> "TGET"
      oBrw:CancelEdit()
      SetFocus( hWndFocus )
      return nil
   endif


   if GetWindowThreadProcessId( hWndFocus ) <> GetWindowThreadProcessId( oBrw:hWnd )
      if !oCol:lAutoSave
         oBrw:CancelEdit()
      endif
      return nil
   endif

   if oEditGet <> nil .AND. !oEditGet:lValidating
      oCol:PostEdit()
   endif

return nil



static function EditGetkeyDown( Self, nKey )

   local lExit
   lExit := .F.

   do case
      case nKey == 27
           lExit := .T.
           ::oEditGet:bValid = nil

      case nKey == 13
           if Empty( ::cEditPicture ) .AND. ::oBrw:nDataLines > 1
              if ! GetKeyState( 17 )
                 lExit := .T.
              endif
           else
              lExit := .T.
           endif

      case nKey == 40 .OR. nKey == 38
           if !( Empty( ::cEditPicture ) .AND. ::oBrw:nDataLines > 1 )
              lExit := .T.
           endif



      case ::oBrw:lExitGetOnTypeOut .AND.  ( nKey == 32 .OR. ( nKey > 47 .AND. nKey < 96 ) ) .AND.  ::oEditGet:oGet:TypeOut .AND. !Set( 27 )

           lExit    := .T.
           ::oEditGet:nLastKey := 13
           ::oEditGet:End()
           ::PostEdit()
           if ::oBrw:lFastEdit
              PostMessage( ::oBrw:hWnd, 256, nKey )
           endif

           return nil

   endcase

   If lExit .AND. ::nEditType <> 6
      if ::oEditGet <> nil
         ::oEditGet:nLastKey := nKey
         ::oEditGet:End()
      endif
   else
      if lExit
         ::PostEdit()
      endif
   Endif

return nil



static FUNCTION TXBrwColumn_EditDateTime( nKey ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn
local aColors
local lCenter, lRight
local nRow, nCol, nWidth, nHeight
local hBrush
local oFont
local uValue

   if ValType ( ::oEditFont ) == "B"
         oFont = Eval( ::oEditFont, Self )
    else
         oFont = ::oEditFont
   endif

   uValue  := ::Value

   aColors := Eval( ::bClrEdit )
   lCenter := lAnd( ::nDataStrAlign, 2 )
   lRight  := lAnd( ::nDataStrAlign, 1 )

   nRow    := ( ( ::oBrw:nRowSel - 1 ) * ::oBrw:nRowHeight ) + ::oBrw:HeaderHeight()

   hBrush := CreateColorBrush( aColors[ 2 ] )
   ::EraseData( nRow, ::nDisplayCol, ::oBrw:nRowHeight , hBrush )
   DeleteObject( hBrush )

   if ::nEditType == 6

      ::oEditGet := TDatePick():New( 0, 0, { | u | If(PCount()==0,uValue,uValue:= u ) }, ::oBrw, 0, 0, , aColors[ 1 ], aColors[ 2 ], oFont, .F., , , , .F., , , ::cEditPicture )
   else

      ::oEditGet := TTimePick():New( 0, 0, { | u | If(PCount()==0,uValue,uValue:= u ) }, ::oBrw, 0, 0, , aColors[ 1 ], aColors[ 2 ], oFont, .F., , , , .F., , , )
      ::oEditGet:SetTime( uValue )
   endif

   nRow    := ( ( ::oBrw:nRowSel - 1 ) * ::oBrw:nRowHeight ) + ::oBrw:HeaderHeight() + 2
   nCol    := ::nDisplayCol + 3

   nWidth  := ::nWidth - 4

   nHeight := ::oBrw:nRowHeight - 4

   if ::bEditValid <> nil
      ::oEditGet:bValid := { | oGet, lRet | oGet:lValidating := .T., lRet := Eval( ::bEditValid, oGet, Self ), oGet:lValidating := .F., If( ! lRet, oGet:SetFocus(),), lRet }
   endif

   ::oEditGet:bKeyDown   := { | nKey | EditGetkeyDown( Self, nKey ) }

   if ::nEditType <> 6
      ::oEditGet:bLostFocus := { | oGet, hWndFocus | EditGetLostFocus( oGet, hWndFocus, ::oBrw, ::oEditGet, Self ) }
   endif

   ::oEditGet:nLastKey := 0

   ::oEditGet:Move( nRow, nCol, nWidth, nHeight, .T. )
   ::oEditGet:SetFocus()
   ::oEditGet:SelectAll()

   ::oBrw:lEditMode := .T.

    if ::lEditBorder
      WndBoxIn( ::oBrw:GetDC(), nRow-1, nCol-1, nRow + nHeight + 1, nCol + nWidth + 1)
       ::oBrw:ReleaseDC()
   endif

    if nKey <> nil
      PostMessage( ::oEditGet:hWnd, 258, nKey )
    endif

   ::oBrw:nLastEditCol := ::nPos

RETURN .T.



static FUNCTION TXBrwColumn_ShowBtnList( nKey ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local aBound
   local xValue
   local hBrush
   local nAt, nRow, nCol, nWidth, nHeight, aColors, oFont
   local lWhen    := ( ::bEditWhen == nil .OR. Eval( ::bEditWhen, Self ) )

   if ::aEditListTxt == nil
      MsgStop( "oCol:aEditListTxt not defined", "Fivewin: Class TXBrwColumn" )
      return .F.
   endif

   if ::bOnPostEdit == nil

      MsgStop( "oCol:bOnPostEdit not defined", "Fivewin: Class TXBrwColumn" )
      return .F.
   endif

   ::oBrw:nColSel := ::nPos

   aBound   := IfNil( ::aEditListBound, AClone( ::aEditListTxt ) )
   if ValType( xValue := ::Value ) == "C"
      xValue   := Trim( xValue )
   endif

   if ( nAt := Ascan( aBound, xValue ) ) == 0
      if ValType( xValue ) == "C"
         while Len( xValue ) > 1 .AND. nAt == 0
            xValue      := Left( xValue, Len( xValue ) - 1 )
            nAt         := AScan( aBound, xValue )
         enddo
      elseif ( nAt := AScan( aBound, { |u| xValue <= u } ) ) > 0
         nAt   := Len( aBound )
      endif
   endif
   xValue   := nil

   nRow     := ( ::oBrw:nRowSel * ::oBrw:nRowHeight ) + ::oBrw:HeaderHeight() - 1
   nCol     := ::nDisplayCol - 2
   nWidth   := ::nWidth + 3
   nHeight  := Len( ::aEditListTxt ) * ( FontHeight( ::oBrw, ::oBrw:oFont ) ) + 2

   If nRow + nHeight > ::oBrw:BrwHeight() - ::oBrw:FooterHeight()
      if nHeight <= ( nRow - ::oBrw:nRowHeight - ::oBrw:HeaderHeight() )
         nRow     := nRow - ::oBrw:nRowHeight - nHeight
      elseif ( nRow - ::oBrw:nRowHeight - ::oBrw:HeaderHeight() ) > ( ::oBrw:BrwHeight() - ::oBrw:FooterHeight() - nRow )
         nHeight  := Min( nHeight, nRow - ::oBrw:nRowHeight - ::oBrw:HeaderHeight() )
         nRow     -= ( nHeight + ::oBrw:nRowHeight )
      else
         nHeight  := Min( nHeight, ::oBrw:BrwHeight() - ::oBrw:FooterHeight() - nRow )
      endif
   Endif

   if ::oEditGet <> nil
      ::oEditGet:End()
      ::oEditGet := nil
      hBrush := CreateColorBrush( Eval( ::bClrSel )[ 2 ] )

      ::EraseData( ( ( ::oBrw:nRowSel - 1 ) * ::oBrw:nRowHeight ) + ::oBrw:HeaderHeight(), ::nDisplayCol, ::oBrw:nRowHeight , hBrush )
      DeleteObject( hBrush )
   endif

   aColors  := Eval( ::bClrEdit )
   oFont    := If( ValType( ::oEditFont ) == "B", Eval( ::oEditFont ), ::oEditFont )

   ::oEditLbx := TListBox():New( 0, 0, { | u | If( PCount()==0, nAt, nAt:= u ) }, ::aEditListTxt, 0, 0,, ::oBrw,, aColors[ 1 ], aColors[ 2 ], .F., .F.,, oFont,, .F.,,,, .F., .F. )


   ::oEditLbx:bLostFocus := { | oLbx, hWndFocus | ::PostEdit( nil, .T. ) }

   ::oEditLbx:bLButtonUp := {|| ::oEditLbx:Change(), ::PostEdit( If( lWhen, aBound[ nAt ], nil ), .T. ) }

   ::oEditLbx:bChange = {|| If( ::oEditLbx <> nil, ::oEditLbx:nLastKey := 13,) }

   IF ::oBrw:oWnd:IsKindOf( "TDIALOG" )
      ::oEditLbx:nDlgCode = 4


      ::oEditLbx:bKeyDown   := { | nKey | If( nKey == 13, ( If( ::oEditLbx <> nil, ::oEditLbx:Change(),), ::PostEdit( If( lWhen, aBound[ nAt ], nil ), .T. ) ),) }

   ELSE


      ::oEditLbx:bKeyDown   := {|k| ::oEditLbx:nLastKey := k,  If( k == 13 .AND. nAt > 0 .AND. lWhen,  xValue := aBound[ nAt ], ), If( k == 13 .OR. k == 27, ::PostEdit( xValue, .T. ), ) }
   ENDIF

   ::oEditLbx:Move( nRow, nCol, nWidth, nHeight, .T. )
   ::oEditLbx:SetFocus()

   ::oBrw:lEditMode := .T.

   if nKey <> nil
      PostMessage( ::oEditLbx:hWnd, 258, nKey )
   endif

   ::oBrw:nLastEditCol := ::nPos

return .T.



static FUNCTION TXBrwColumn_RunBtnAction( nKey ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nRow, nCol
   local hBrush, bEditBlock

   if ::bEditBlock == nil
      if ::IsMemo()
         bEditBlock     := { |r,c,o,k| XbrEditMemo( r,c,o,k ) }
      else
         MsgStop( "oCol:bEditBlock not defined", "Fivewin: Class TXBrwColumn")
         return .F.
      endif
   else
      bEditBlock  := ::bEditBlock
   endif

   ::oBrw:nColSel := ::nPos

   if ::oEditGet <> nil
      ::oEditGet:End()
      ::oEditGet := nil
      hBrush := CreateColorBrush( Eval( ::bClrSel )[ 2 ] )

      ::EraseData( ( ( ::oBrw:nRowSel - 1 ) * ::oBrw:nRowHeight ) + ::oBrw:HeaderHeight(), ::nDisplayCol, ::oBrw:nRowHeight , hBrush )
      DeleteObject( hBrush )
   endif

   nRow := ( ::oBrw:nRowSel * ::oBrw:nRowHeight ) + ::oBrw:HeaderHeight() - 3
   nCol := ::nDisplayCol

   ::oBrw:lEditMode := .T.
   ::PostEdit( Eval( bEditBlock, nRow, nCol, Self, nKey ), .T. )
   ::oBrw:nLastEditCol := ::nPos

return .T.



static FUNCTION TXBrwColumn_PostEdit( xValue, lButton, lDirectAssign ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local lGoNext := .F.
   local uOriginal    := ::Value()
   local nLastKey := 0
   local bOnPostEdit

   if ::lOnPostEdit
      return nil
   Endif

   if ::lReadOnly .OR. ::oBrw:lReadOnly
      return nil
   endif

   ::lOnPostEdit := .T.

   if ValType( uOriginal ) == "B"
      bOnPostEdit    := { |o,x,k| If( k <> 27, xEval( uOriginal, x, o ), nil ) }
   else
      bOnPostEdit    := ::bOnPostEdit
   endif


   If( lButton == nil, lButton := .F., ) ; If( lDirectAssign == nil, lDirectAssign := .F., );

   do case
      case xValue <> nil .AND. ( ::nEditType == 1 .OR. lDirectAssign )
         Eval( bOnPostEdit, Self, xValue, 13 )
         nLastKey    := If( lDirectAssign, 0, 13 )

      case ::nEditType == 1 .OR. ::nEditType >= 6
         if ::oEditGet <> nil
            Eval( bOnPostEdit, Self, Eval( ::oEditGet:bSetGet ), ::oEditGet:nLastKey )
            nLastKey := ::oEditGet:nLastKey
            ::oEditGet:End()
            ::oEditGet := nil
         endif

      case ::nEditType == 2
         if xValue <> nil
            if ::oEditLbx:nLastKey == 13
               Eval( bOnPostEdit, Self, xValue, If( ::oEditLbx <> nil, ::oEditLbx:nLastKey, 0 ) )
            endif
            nLastKey   := If( ::oEditLbx <> nil, ::oEditLbx:nLastKey, 0 )
         endif
         if ::oEditLbx <> nil .AND. IsWindow( ::oEditLbx:hWnd )
            ::oEditLbx:End()
            ::oEditLbx := nil
         endif

      case ::nEditType == 3

         nLastKey     := If( xValue == nil, 27, 13 )
         Eval( bOnPostEdit, Self, xValue, nLastKey )

      case ::nEditType == 4
         if ::oEditLbx <> nil .AND. IsWindow( ::oEditLbx:hWnd )
            nLastKey  := ::oEditLbx:nLastKey
            ::oEditLbx:End()
            ::oEditLbx := nil
         endif
         if ::oEditGet <> nil
            if ! lButton
               xValue    := Eval( ::oEditGet:bSetGet )
               nLastKey  := ::oEditGet:nLastKey
            endif
            ::oEditGet:End()
            ::oEditGet   := nil
         endif
         if xValue <> nil .AND. ( ::bEditWhen == nil .OR. Eval( ::bEditWhen, Self ) )
            Eval( bOnPostEdit, Self, xValue, nLastKey )
         endif

      case ::nEditType == 5
         if ! lButton
            if ::oEditGet <> nil

               Eval( bOnPostEdit, Self, Eval( ::oEditGet:bSetGet ), ::oEditGet:nLastKey )
               nLastKey    := ::oEditGet:nLastKey

               ::oEditGet:End()
               ::oEditGet := nil
            endif
         else
            nLastKey    := If( xValue == nil, 27, 13 )
            Eval( bOnPostEdit, Self, xValue, nLastKey )
         endif
   endcase

   lGoNext := !lDirectAssign .AND. ( AScan( { 13, 40, 38, 9 }, nLastKey ) > 0 )

   ::oBrw:SaveData()
   ::oBrw:Unlock()

   ::lOnPostEdit     := .F.
   ::oBrw:lEditMode  := .F.
   ::oBrw:nLastKey   := nLastKey


   if ::bOnChange <> nil .AND. ( ! EQ( ::Value, uOriginal, .T., .T. ) .OR.  ValType( uOriginal ) == "B" )
      Eval( ::bOnChange, Self, uOriginal )
   endif

   ::oBrw:SetFocus()
   if Empty( ::cOrder )
      ::oBrw:DrawLine( .T. )
   else
      if ::oBrw:nDataType == 2
         ::cOrder    := If( ::cOrder == "A", "D", "A" )
         ::SetOrder()
      endif
      ::oBrw:Refresh()
   endif


   if ! Empty( ::nFooterType ) .OR.  ( ::cDataType == "N" .AND. ( ::cFooter <> nil .OR. ::bFooter <> nil .OR. ::nTotal <> nil ) )
      ::RecalcTotal( uOriginal, ::Value )
      ::RefreshFooter()
   endif

   If lGoNext

      ::oBrw:GoNextCtrl()
   Endif

return nil



static FUNCTION TXBrwColumn_RecalcTotal( nOldVal, nNewVal ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   if ! EQ( nOldVal, nNewVal )

      if ::bFooter <> nil
         Eval( ::bFooter, Self, If( ValType( nNewVal ) == "N", nNewVal, 0 ) - If( ValType( nOldVal ) == "N", nOldVal, 0 ) )
      elseif ::nTotal <> nil .OR. ! Empty( ::nFooterType )
         If( ::nFooterType == nil, ::nFooterType := 1, ) ;
         if ::nTotal == nil
            if ::nFooterType == 8
               if nOldVal == nil .OR. nNewVal == nil
                  if nOldVal == nil
                     ::nCount++
                  else
                     ::nCount--
                  endif
               endif
            endif
         else
            if ::nFooterType == 4
               if ValType( nNewVal ) == "N" .AND. nNewVal > ::nTotal
                  ::nTotal := nNewVal
               elseif ValType( nOldVal ) == "N" .AND. nOldVal == ::nTotal
                  ::oBrw:MakeTotals( Self )
               endif
            elseif ::nFooterType == 2
               if ValType( nNewVal ) == "N" .AND. nNewVal < ::nTotal
                  ::nTotal := nNewVal
               elseif ValType( nOldVal ) == "N" .AND. nOldVal == ::nTotal
                  ::oBrw:MakeTotals( Self )
               endif
            else
               if ValType( nOldVal ) == "N"
                  ::nCount--
                  ::nTotal    -= nOldVal
                  if ! Empty( ::nTotalSq )
                     ::nTotalSq  -= ( nOldVal * nOldVal )
                  endif
               endif
               if ValType( nNewVal ) == "N"
                  ::nCount++
                  ::nTotal    += nNewVal
                  if ! Empty( ::nTotalSq )
                     ::nTotalSq  += ( nNewVal * nNewVal )
                  endif
               endif
            endif
         endif
      endif

   endif

return nil



static FUNCTION TXBrwColumn_SumOfCols( aCols, nType ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nSum, nSumSq, nCount
   local u, n, oCol

   If( nType == nil, nType := 1, ) ;

   if ValType( aCols ) == "C"

      u     := Upper( aCols )
      aCols := {}

      for each oCol in ::oBrw:aCols
         if ! Empty( oCol:cGrpHdr ) .AND. Upper( oCol:cGrpHdr ) == u
            AAdd( aCols, oCol )
         endif
      next

   endif

   nCount   := 0
   if nType <> 2 .AND. nType <> 4
      nSum := nSumSq := 0
   endif
   if ! Empty( aCols )
      for each oCol in aCols
         if ValType( oCol ) <> "O"
            oCol     := ::oBrw:oCol( oCol )
         endif
         if oCol <> nil .AND. oCol <> Self
            if ValType( n := oCol:Value() ) == "N"
               if nType == 2
                  nSum  := If( nSum == nil, n, Min( n, nSum ) )
               elseif nType == 4
                  nSum  := If( nSum == nil, n, Max( n, nSum ) )
               else
                  nSum     += n
                  nCount++
                  if lAnd( nType, 1 + 8 + 16 )
                     nSumSq   += ( n * n )
                  endif
               endif
            endif
         endif
      next
   endif

   if nType == 8
      nSum  := nCount
   elseif nType == 1 + 8
      nSum  := If( nCount > 0, nSum / nCount, 0 )
   elseif nType >= 1 + 8 + 16
      if nCount > 0
         nSum  := nSumSq - ( nSum * nSum / nCount )
         if nType == 1 + 8 + 16 + 32 .OR. nCount == 1
            nSum  /= nCount
         else
            nSum  /= ( nCount - 1 )
         endif
         nSum  ^= 0.5
      else
         nSum  := 0
      endif
   endif

return nSum



static FUNCTION TXBrwColumn_SetOrder( ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   LOCAL   lSorted   := .F.
   LOCAL   n, cSort, uVal
   LOCAL   lDolphin  := .F.
   LOCAL   cOrdBag   := If( ValType( ::cOrdBag ) == "B", Eval( ::cOrdBag ), ::cOrdBag )

   if ::cOrder == "A" .AND. ! ::oBrw:lSortDescend
      return .F.
   endif

   if ::oBrw:lAutoSort .AND. ::cSortOrder <> nil

      if ValType( ::cSortOrder ) == "B"
         uVal  := Eval( ::cSortOrder, Self )
         lSorted := ( ValType( uVal ) == "C" .AND. Upper( uVal ) $ "AD" )
         if lSorted
            ::oBrw:cOrders := " "
            ::cOrder       := Upper( uVal )
         endif

      elseif ::oBrw:nDataType == 2
         lSorted := ::SortArrayData()

      elseif lAnd( ::oBrw:nDataType, 4 ) .AND. ::oBrw:oRs <> nil

         n       := If( ::oBrw:oRs:RecordCount > 0, ::oBrw:oRs:BookMark, nil )
         cSort   := Upper( ::oBrw:oRs:Sort )
         cSort   := TRIM( StrTran( StrTran( cSort, " DESC", "" ), " ASC", "" ) )
         if EQ( CharRem( "[]", cSort ), CharRem( "[]", ::cSortOrder ) )
            ::cOrder       := If( ::cOrder == "D", "A", "D" )
         else
            ::oBrw:cOrders := " "
            ::cOrder       := "A"
         endif
         lSorted           := .T.
         ::oBrw:oRs:Sort   := ::cSortOrder + If( ::cOrder == "D", " DESC", "" )
         if lSorted .AND. n <> nil
            ::oBrw:oRs:BookMark  := n
         endif
      elseif lAnd( ::oBrw:nDataType, 64 ) .AND. ::oBrw:oMysql <> nil
         n                 := 0
         lDolphin          := ::oBrw:oMysql:IsKindOf( "TDOLPHINQRY" )
         if lDolphin
            cSort   := Lower( ::oBrw:oMysql:cOrder )
         else
            cSort   := Lower( ::oBrw:oMysql:cSort )
         endif
         cSort   := AllTrim( StrTran( StrTran( cSort, " desc", "" ), " asc", "" ) )
         if EQ( cSort, ::cSortOrder )
            ::cOrder    := If( ::cOrder == "D", "A", "D" )
            n           := ::oBrw:oMySql:LastRec() - ::oBrw:oMySql:RecNo() + 1
         else
            ::oBrw:cOrders       := " "
            ::cOrder             := "A"
         endif
         lSorted     := .T.
         cSort       := ::cSortOrder + If( ::cOrder == "D", " DESC", "" )
         if lDolphin
            uVal     := ::Value
            ::oBrw:oMySql:lInverted := ( ::cOrder == "D" )
            ::oBrw:oMySql:SetOrder( cSort )
            if n > 0
               ::oBrw:oMySql:GoTo( n )
            else
               ::oBrw:oMySql:Seek( uVal, Token( ::cSortOrder, nil, 1 ), 1, ::oBrw:oMySql:LastRec(), .T., .T. )
            endif

         else
            ::oBrw:oMysql:cSort := cSort
         endif

      elseif lAnd( ::oBrw:nDataType, 16 ) .AND. ValType( ::cSortOrder ) == "C"

         if ::oBrw:oDbf:IsKindOf( "TDATABASE" )

            If( cOrdBag == nil, cOrdBag := ::oBrw:oDbf:IndexBagName(), ) ;

            if ValType( cOrdBag ) == "C"
               cOrdBag        := Upper( cOrdBag )
            endif

            if ::oBrw:oDbf:SetOrder() == Upper( ::cSortOrder )
               if !Empty( ::cOrder ) .AND. ::oBrw:oDbf:IndexBagName() == cOrdBag
                  ::oBrw:oDbf:OrdDescend( nil, nil, ::cOrder == "A" )
                  ::cOrder       := If( ::cOrder == "A", "D", "A" )
                  lSorted        := .T.
               else
                  ::oBrw:oDbf:SetOrder( ::cSortOrder, cOrdBag )
                  lSorted        := .T.
                  ::oBrw:cOrders := " "
                  ::cOrder       := "A"
               endif
            else
               ::oBrw:oDbf:SetOrder( ::cSortOrder, cOrdBag )
               lSorted  := .T.
               ::oBrw:cOrders     := " "
               ::cOrder           := "A"
            endif
         else

            if __ObjHasMethod( ::oBrw:oDbf, "ORDDESCEND" ) .AND.  ( ::cOrder == "A" .OR. ::cOrder == "D" )
               ::oBrw:oDbf:OrdDescend( nil, nil, ::cOrder == "A" )
               ::cOrder          := If( ::cOrder == "A", "D", "A" )
               lSorted           := .T.

            elseif ! Eq( ::oBrw:oDbf:SetOrder(), ::cSortOrder )
               ::oBrw:oDbf:SetOrder( ::cSortOrder, cOrdBag )
               lSorted  := .T.
               ::oBrw:cOrders     := " "
               ::cOrder           := "A"
            endif
         endif
      elseif ValType( ::oBrw:cAlias ) == "C" .AND. ValType( ::cSortOrder ) == "C"

         cSort         := ( ::oBrw:cAlias )->( OrdSetFocus() )

         If( cOrdBag == nil, cOrdBag := ( ::oBrw:cAlias )->( OrdBagName() ), ) ;

         if (::oBrw:cAlias)->( OrdSetFocus() ) == Upper( ::cSortOrder )
            if !Empty( ::cOrder ) .AND. Upper( cOrdBag ) == ( ::oBrw:cAlias )->( OrdBagName() )
               (::oBrw:cAlias)->( OrdDescend( , , ! OrdDescend() ) )
               if ::oBrw:lSQLRDD
                  M->u__bm       := ::oBrw:BookMark
                  ::oBrw:GoTop()
                  ::oBrw:BookMark   := M->u__bm
               endif
               ::cOrder          := If( ( ::oBrw:cAlias )->( OrdDescend() ), "D", "A" )
            else
               (::oBrw:cAlias)->( OrdSetFocus( ::cSortOrder, cOrdBag ) )
               ::cOrder          := "A"
            endif
            lSorted              := .T.

         else

            (::oBrw:cAlias)->( OrdSetFocus( ::cSortOrder, cOrdBag ) )
            lSorted            := .T.
            ::oBrw:cOrders     := " "
            ::cOrder           := If( ( ::oBrw:cAlias )->( OrdDescend() ), "D", "A" )



         endif

      endif

   endif

   if lSorted
      ::oBrw:Seek()
   endif

return lSorted



static FUNCTION TXBrwColumn_SortArrayData( ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local aCols
   local cOrder
   local nAt, nFor, nLen
   local uSave, cType

   aCols  := ::oBrw:aCols
   cOrder := ::cOrder
   nLen   := Len( aCols )
   nAt    := If( ValType( ::cSortOrder ) == "N", ::cSortOrder, ::nArrayCol )
   if Empty( nAt ) .OR. ValType( nAt ) <> "N"
      nAt   := 1
   endif

   if Len( ::oBrw:aArrayData ) > 0

      for nFor := 1 to nLen
         if aCols[ nFor ]:nArrayCol <> ::nArrayCol
            aCols[ nFor ]:cOrder := ""
         endif
      next

      uSave    := ::oBrw:aArrayData[ ::oBrw:nArrayAt ]
      if cOrder == "A"
         ::oBrw:aArrayData := Asort( ::oBrw:aArrayData,,::oBrw:nLen, {|x,y| ACompare( x, y, nAt, ::lCaseSensitive ) < 0 } )
         ::cOrder     := "D"
      else
         ::oBrw:aArrayData := Asort( ::oBrw:aArrayData,,::oBrw:nLen, {|x,y| ACompare( x, y, nAt, ::lCaseSensitive ) > 0 } )
         ::cOrder     := "A"
      endif
      ::oBrw:nArrayAt   := AScan( ::oBrw:aArrayData, { |a| a == uSave } )



   endif

return .T.



static function ACompare( x, y, nAt, lCaseSensitive )

   local nRet := -1
   local xVal, yVal, xType, yType
   local aType := "ULNPDCHO"

   if ValType( x ) <> "A"
      x     := { x }
   endif
   xVal     := If( nAt <= Len( x ), x[ nAt ], nil )
   xType    := ValType( xVal )

   if ValType( y ) <> "A"
      y     := { y }
   endif
   yVal     := If( nAt <= Len( y ), y[ nAt ], nil )
   yType    := ValType( yVal )

   if xType == yType .AND. xType $ "CDLN"
      if xType == "C" .AND. ! lCaseSensitive
         xVal  := Upper( xVal )
         yVal  := Upper( yVal )
      endif
   else
      xVal  := At( xType, aType )
      yVal  := At( yType, aType )
   endif

   nRet  := If( xVal == yVal, 0, If( xVal < yVal, 1, -1 ) )

return nRet



static FUNCTION TXBrwColumn_ClpText( ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local RetVal    := ""
   local cDtFmt, cTmFmt

   if nxlLangID == nil
      SetExcelLanguage()
   endif

   if ::bEditValue == nil
      if ::bStrData == nil
         RetVal   := ""
      else
         RetVal   := AllTrim( Eval( ::bStrData, nil, Self ) )
      endif
   else
      RetVal       := ::Value()
      if ::cDataType == "P" .OR. ::nEditType < 0
         RetVal    := ""
      elseif ::cDataType == "D"

         cDtFmt    := Set( 4 )
         Set( 4, "YYYY-MM-DD" )
         RetVal   := DTOC( RetVal )
         Set(4, cDtFmt )













      elseif ::cDataType == "L"

         RetVal    := If( RetVal == nil, "", If( RetVal, cxlTrue, cxlFalse ) )

      else

         RetVal    := Trim( cValToChar( RetVal ) )

      endif

   endif

   if Left( RetVal, 1 ) == '"'
      RetVal   := " " + RetVal
   endif

return RetVal



static FUNCTION TXBrwColumn_ToExcel( oSheet, nRow, nCol ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local uVal     := ::Value
   local hBmp, hBmp2, nHeight, nWidth, oClp

   if ValType( uVal ) $ "DT" .AND. Empty( uVal )
      oSheet:Cells( nRow, nCol ):NumberFormat   := Lower( Set( 4 ) )
      return Self
   endif

   if uVal <> nil
      if ::cDataType $ "PF"
         if ::cDataType == "F" .AND. File( uVal )
            hBmp     := FILoadImg( uVal )
         else
            hBmp     := FILoadFromMemory( uVal )
         endif
         if hBmp <> 0
            nHeight  := nBmpHeight( hBmp )
            nWidth   := nBmpWidth(  hBmp )
            if nWidth > ::nWidth .OR. nHeight > ::oBrw:nRowHeight
               if nWidth > ::nWidth
                  nHeight  *= ( ::nWidth / nWidth )
                  nWidth   := ::nWidth
               endif
               if nHeight > ::oBrw:nRowHeight
                  nWidth   *= ( ::oBrw:nRowHeight / nHeight )
                  nHeight  := ::oBrw:nRowHeight
               endif
               hBmp2       := hBmp
               hBmp        := ResizeImg( hBmp2, nWidth, nHeight )
               DeleteObject( hBmp2 )
            endif

            oClp     := TClipBoard():New( 2, ::oBrw:oWnd )
            oClp:Open()
            oClp:Empty()
            SetClipboardData( 2, hBmp )
            oClp:Close()
            oSheet:Cells( nRow, nCol ):Select()
            oSheet:Paste()
            oClp:Clear()
            oClp:End()
         endif
         DeleteObject( hBmp )

      else
         if ValType( uVal ) $ "DT" .AND. Year( uVal ) < 1900
            uVal  := DToC( uVal )
         endif
         oSheet:Cells( nRow, nCol ):Value := uVal
      endif
   endif

return Self



static FUNCTION TXBrwColumn_Paste( cText ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local uNew, cType

   if ::cDataType $  "CM"
      ::VarPut( Trim( cText ) )
   else
      uNew        := uCharToVal( cText, @cType )
      if uNew <> nil
         if ::cDataType == nil .OR. ::cDataType == cType
            ::VarPut( uNew )
         endif
      endif
   endif

return nil



static FUNCTION TXBrwColumn_WorkMergeData( ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nKount   := 0
   local uPrev, uVal, nAt
   local nLen     := Eval( ::oBrw:bKeyCount )

   ::aMerge    := {}

   Eval( ::oBrw:bGoTop )
   for nAt  := 1 to nLen
      uVal  := ::Value()
      if uVal == nil
         msgStop( "Column value is nil" )
         __Quit()
      endif
      if uVal == uPrev
         nKount++
      else
         nKount  := 0
         uPrev := uVal
      endif
      AAdd( ::aMerge, { nKount, 0, ::oBrw:KeyNo() } )
      ::oBrw:Skip(1)
   next
   Eval( ::oBrw:bGoTop )

   nKount   := 0
   for nAt := nLen to 1 step -1
      ::aMerge[ nAt ][ 2 ] := nKount
      nKount++
      if ::aMerge[ nAt ][ 1 ] == 0
         nKount   := 0
      endif
   next

return nil



static FUNCTION TXBrowse_HandleEvent( nMsg, nWParam, nLParam ) ; local Self AS CLASS TXBrowse := QSelf() AS CLASS TXBrowse

   if nMsg == 675
      return ::MouseLeave( nHiWord( nLParam ), nLoWord( nLParam ), nWParam )
   endif
return ::Super:HandleEvent( nMsg, nWParam, nLParam )



static FUNCTION TXBrwColumn_HasBorder( nRowPos ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local lBorder     := .T.
   local nDataRows   := If( Empty( ::oBrw:nDataRows ), ::oBrw:RowCount(), ::oBrw:nDataRows )
   local nAt

   if ::lMergeVert .AND. nRowPos < nDataRows
      nAt   := nRowPos - ::oBrw:nRowSel + ::oBrw:KeyNo()
      lBorder  := ( ::aMerge[ nAt ][ 2 ] == 0 )
   endif

return lBorder



static FUNCTION TXBrwColumn_MergeArea( nTop, nBottom, nRowPos ) ; local Self AS CLASS TXBrwColumn := QSelf() AS CLASS TXBrwColumn

   local nAt, uVal, nRowOffset, nPos
   local aData
   local nFirstRow, nLastRow
   local n1, n2
   local nDataRows   := If( Empty( ::oBrw:nDataRows ), ::oBrw:Rowcount(), ::oBrw:nDataRows )
   if ::lMergeVert
      nAt         := ::oBrw:KeyNo()
      n1          := Min( nRowPos - 1, ::aMerge[ nAt ][ 1 ] )
      n2          := Min( nDataRows - nRowPos, ::aMerge[ nAt ][ 2 ] )
      nTop        -= n1 * ::oBrw:nRowHeight
      nBottom     += n2 * ::oBrw:nRowHeight
   endif

return nTop







static function GetZeroZeroClr( hDC, hBmp )

    local hDCMem, hOldBmp, nZeroZeroClr

    hDCMem = CreateCompatibleDC( hDC )
    hOldBmp = SelectObject( hDCMem, hBmp )
    nZeroZeroClr = GetPixel( hDCMem,0,0)
    SelectObject( hDCMem, hOldBmp )
    DeleteDC( hDCMem )

return nZerozeroClr



static function FontHeight( oBrw, oFont )

   local hDC
   local nHeight

   hDC := oBrw:GetDC()
   oFont:Activate( hDC )
   nHeight := GetTextHeight( oBrw:hWnd, hDC )
   oBrw:ReleaseDC()

return nHeight



function ExtractLine( cText, nFrom )

  local cLine, nAt

  nAt := At( Chr(13)+Chr(10), SubStr( cText, nFrom ) )

  if nAt > 0
    cLine := Substr( cText, nFrom, nAt - 1 )
    nFrom += nAt + 1
  else
    cLine := Substr( cText, nFrom )
    nFrom := Len( cText ) + 1
  endif

return cLine



static function EQ( uFirst, uSecond, lExact, lCaseSensitive )

   local   c, lRet := .F.

   If( lExact == nil, lExact := .T., ) ; If( lCaseSensitive == nil, lCaseSensitive := .F., );

   BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
      uFirst   := xEval( uFirst )
   RECOVER
   END

   BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
      uSecond  := xEval( uSecond )
   RECOVER
   END

   if ( C := valtype( uFirst ) ) == valtype( uSecond )
      if c == "C"
         if lExact
            if lCaseSensitive
               lRet     := ( AllTrim( uFirst ) == AllTrim( uSecond ) )
            else
               lRet     := ( Upper( AllTrim( uFirst ) ) == Upper( AllTrim( uSecond ) ) )
            endif
         else
            lRet        := Upper( AllTrim( uFirst ) ) = Upper( AllTrim( uSecond ) )
         endif
      else
         lRet  := ( uFirst == uSecond )
      endif
   endif

return lRet



static function FontEsc( oFont )

   local nEsc := 0

   if oFont <> nil .AND. ValType( oFont:nEscapement ) == "N"
      nEsc = Abs( oFont:nEscapement )
   endif

return nEsc



static function ClipTextAsArray( cText )

   local aText, n

   cText       := StrTran( cText, Chr(13)+Chr(10), Chr(10) )


   if Right( cText, 1 ) == Chr(10)
      cText    := Left( cText, Len( cText ) - 1 )
   endif

   aText       := hb_aTokens( cText, Chr(10) )
   for n := 1 to Len( aText )
      aText[ n ]  := hb_aTokens( aText[ n ], Chr(9) )
   next

return aText



static function ArrayResize( aData, nSize )

   local aBlank   := {}
   local n

   if nSize < Len( aData )
      ASize( aData, nSize )
   elseif nSize > Len( aData )
      for n := 1 to Len( aData[ 1 ] )
         AAdd( aBlank, uValBlank( aData [ 1 ][ n ] ) )
      next
      for n := Len( aData ) + 1 to nSize
         AAdd( aData, AClone( aBlank ) )
      next
   endif

return aData















function XbrowseNew( oWnd, nRow, nCol, nWidth, nHeight, aFlds, aHeaders, aColSizes,   bChange, bLDblClick, bRClick,  oFont, oCursor, nClrFore, nClrBack,  cMsg, lUpdate, cDataSrc, bWhen,  lDesign, bValid, lPixel, nResID, lAutoSort, lAddCols,  aPics, aCols, aJust, aSort, lFooter, lFastEdit,  lCell, lLines, aRows, uBack, cBckMode, bClass, lTransparent, lNoBorder, cVarName )

   local oBrw, n, i, oCol, oClass

   If( lTransparent == nil, lTransparent := .F., ) ;
   If( oWnd == nil, oWnd := If( GetWndDefault() == nil, TWindow():New(), GetWndDefault() ), ) ;




   if ValType( bClass ) == "B"
      oClass      := Eval( bClass )
   endif
   if oClass <> nil .AND. oClass:IsKindOf( "TXBROWSE" )
      oBrw        := oClass:New( oWnd )
   else
      oBrw        := TXBrows():New( oWnd )
      if oClass <> nil .AND. oClass:IsKindOf( "TXBRWCOLUMN" )
         oBrw:bColClass := bClass
      endif
   endif

   if ValType( aCols ) == "A" .AND. Len( aCols ) == 1 .AND. ValType( aCols[ 1 ] ) == "C" .AND. AllTrim( aCols[ 1 ] ) == "*"
      lAddCols    := .T.
      aCols       := nil
   endif
   if ValType( aSort ) == "A" .AND. Len( aSort ) == 1 .AND. ValType( aSort[ 1 ] ) == "C" .AND. Upper( AllTrim( aSort[ 1 ] ) ) == "AUTO"
      lAutoSort   := .T.
      aSort       := nil
   endif

   oBrw:lAutoSort  := lAutoSort
   oBrw:bLDblClick := bLDblClick
   oBrw:bRClicked  := bRClick

   aFlds          := CheckArray( aFlds )
   aHeaders       := CheckArray( aHeaders )
   aColSizes      := CheckArray( aColSizes )
   aPics          := CheckArray( aPics )
   aCols          := CheckArray( aCols )
   aJust          := CheckArray( aJust )
   aSort          := CheckArray( aSort )

   if aCols <> nil
      aCols          := ASize( ArrTranspose( aCols ), 6 )
   endif


   XbrwSetDataSource( oBrw, cDataSrc, lAddCols, lAutoSort,  If( aCols == nil, nil, aCols[ 1 ] ), aRows, aHeaders, bChange  )

   If( oBrw:bChange == nil, oBrw:bChange := bChange, ) ;

   If( aHeaders == nil, aHeaders := {}, ) ; If( aPics == nil, aPics := {}, ); If( aColSizes == nil, aColSizes := {}, ); If( aSort == nil, aSort := {}, );

   if aCols <> nil
      aHeaders       := ArrMerge( aCols[ 2 ], aHeaders )
      aPics          := ArrMerge( aCols[ 3 ], aPics )
      aColSizes      := ArrMerge( aCols[ 4 ], aColSizes )
      aJust          := ArrMerge( aCols[ 5 ], aJust )
      aSort          := ArrMerge( aCols[ 6 ], aSort )

      AEval( oBrw:aCols, { |o,i| If( Empty( o:cExpr ), o:cExpr := cValToChar( aCols[ 1, i ] ), nil ) },,Len( aCols[ 1 ] ) )
   endif

   if ! Empty( aFlds )
      for n := 1 to Len( aFlds )
         oBrw:AddCol():bEditValue   := aFlds[ n ]
      next
   endif

   for i := 1 to Len( oBrw:aCols )
      oCol  := oBrw:aCols[ i ]
      if Len( aPics ) >= i .AND. aPics[ i ] <> nil
         if ValType( aPics[ i ] ) == "A"
            oCol:SetCheck( aPics[ i ] )
         elseif !Empty( aPics[ i ] )
            oCol:cEditPicture := aPics[ i ]
         endif
      endif
      if Len( aHeaders ) >= i .AND. aHeaders[ i ] <> nil
        oCol:cHeader   := cValToChar( aHeaders[ i ] )
      endif
      if Len( aColSizes ) >= i
         if aColSizes[ i ] <> nil .AND. aColSizes[ i ] < 0
            n              := -aColSizes[ i ]
            oCol:nDataLen  := Int( n )
            if n > oCol:nDataLen
               n           := Int( 10 * ( n - oCol:nDataLen ) )
               oCol:nDataDec  := n
            endif
         else
            oCol:nWidth    := aColSizes[ i ]
         endif
      endif
      if Len( aSort ) >= i .AND. ! Empty( aSort[ i ] )
         oCol:cSortOrder := aSort[ i ]
      endif
   next

   if valtype( nClrFore ) == "N"
      If( nClrBack == nil, nClrBack := 16777215, ) ;
      oBrw:bClrStd      := {|| { nClrFore, nClrBack } }
      oBrw:SetColor( nClrFore, nClrBack )
   endif

   if ValType( uBack ) $ "ACNO"
      if ValType( uBack ) == "A"
         n     := If( ValType( cBckMode ) == "C", ( cBckMode <> "HORIZONTAL" ), .T. )
      else
         n     := If( ValType( cBckMode ) == "C", AScan( { "TILED","STRETCH","FILL" }, cBckMode ), 0 )

         n     := If( n > 0, n - 1, nil )
      endif
      oBrw:SetBackGround( uBack, n )
   endif

   if oFont <> nil
      oBrw:SetFont( oFont )
   endif
   if bWhen <> nil
      oBrw:bWhen      := bWhen
   endif
   if bValid <> nil
      oBrw:bValid     := bValid
   endif
   if oCursor <> nil
      oBrw:oCursor    := oCursor
   endif
   if cMsg <> nil
      oBrw:cMsg       := cMsg
   endif

   oBrw:lDesign       := lDesign

   if ! Empty( aJust )
      oBrw:aJustify  := aJust
   endif

   oBrw:lFooter   := lFooter
   oBrw:lFastEdit := lFastEdit

   if lLines
      oBrw:nColDividerStyle         := 1
      oBrw:nRowDividerStyle         := 1
      oBrw:lColDividerComplete      := .T.
   endif

   if lCell
      oBrw:nMarqueeStyle            := 3
   endif

   if ValType( nResID ) == "N"
      oBrw:CreateFromResource( nResID )
   else
      if nRow <> nil
         oBrw:nTop       := nRow * If( lPixel, 1, 14 )
      endif

      if nCol <> nil
         oBrw:nLeft      := nCol * If( lPixel, 1, 8 )
      endif

      if nWidth <> nil
         if nWidth <= 0
            oBrw:nRightMargin := -nWidth
            if oWnd:IsKindOf( "TDIALOG" )
               oBrw:nRightMargin *= 2
            endif
         else
            oBrw:nRight     := oBrw:nLeft + nWidth - 1
         endif
      endif

      if nHeight <> nil
         if nHeight <= 0
            oBrw:nBottomMargin    := -nHeight
            if oWnd:IsKindOf( "TDIALOG" )
               oBrw:nBottomMargin *= 2
            endif
         else
            oBrw:nBottom    := oBrw:nTop + nHeight - 1
         endif
      endif

      if lNoBorder == .T. .AND. lAnd( oBrw:nStyle, 8388608 )
         oBrw:nStyle       -= 8388608
      endif
      if lTransparent
         oBrw:lTransparent := .T.
      endif
      oBrw:lUpdate      := lUpdate
   endif

   oBrw:cVarName = cVarName

return oBrw



static function CheckArray( aArray )



   if ValType( aArray ) == "A" .AND.  Len( aArray ) == 1 .AND.  ValType( aArray[ 1 ] ) == "A"

      aArray   := aArray[ 1 ]
   endif

return aArray



function XbrwSetDataSource( oBrw, uDataSrc, lAddCols, lAutoSort, aCols, aRows, aHeaders, bChange  )




   local cType    := ValType( uDataSrc ), tmp, lSet := .F.

   if ! Empty( aCols )
      lAddCols    := .T.
   endif

   do case
   case cType == "C"

      if Select( uDataSrc ) > 0
         oBrw:cAlias    := uDataSrc
         oBrw:nDataType := 1
         if .T.
            oBrw:SetRDD( lAddCols, lAutoSort, aCols, aRows )
         elseif ! Empty( aRows )
            oBrw:SetRDD( .F., lAutoSort, nil, aRows )
         endif
         oBrw:bChange   := bChange
      endif

   case cType == "A"
      oBrw:nDataType    := 2
      oBrw:aArrayData   := uDataSrc
      if lAddCols .OR. ! Empty( aCols )
         oBrw:SetArray( uDataSrc, lAutoSort, nil, aCols )
      else
         oBrw:SetArray( uDataSrc, nil, nil, .F. )
      endif
      oBrw:bChange   := bChange

   case cType == "H"
      oBrw:aArrayData   := uDataSrc
      oBrw:nDataType    := 2
      oBrw:SetArray( uDataSrc, nil, nil, .T. )
      if bChange <> nil
         oBrw:bChange   := bChange
      endif

   case cType == "O"

      if IsRecordSet( uDataSrc )
         oBrw:nDataType := 4
         oBrw:oRs       := uDataSrc
         if .T.
            oBrw:SetADO( uDataSrc, lAddCols, lAutoSort, aCols )
         endif
         lSet  := .T.
      elseif IsXlRange( uDataSrc )
         oBrw:nDataType := 128
         oBrw:oRs       := uDataSrc
         oBrw:SetExcelRange( uDataSrc, Empty( aHeaders ), aCols )
         lSet  := .T.
      elseif uDataSrc:ClassName() == "TOLEAUTO" .AND. ! Empty( tmp := GetOleProperties( uDataSrc ) )
         oBrw:SetArray( tmp, .F., nil, { 1, 2, 3 } )
         oBrw:cHeaders  := { "Num", "Name", "Value" }
         oBrw:lReadOnly := .T.
         lSet  := .T.
      elseif __ObjHasMethod( uDataSrc, "ISKINDOF" )
         if uDataSrc:IsKindOf( "TMYSQLQUERY" )
            oBrw:nDataType := 64
            oBrw:oMysql       := uDataSrc
            if .T.
               oBrw:SetMysql( uDataSrc, lAddCols, lAutoSort, aCols )
            endif
            oBrw:bChange   := bChange
            lSet  := .T.
         elseif  uDataSrc:IsKindOf( "TDOLPHINQRY" )
            oBrw:nDataType := 64
            oBrw:oMysql       := uDataSrc
            if .T.
               oBrw:SetDolphin( uDataSrc, lAddCols, lAutoSort, aCols )
            endif
            oBrw:bChange   := bChange
            lSet  := .T.

         elseif uDataSrc:IsKindOf( "TLINKLIST" )
            oBrw:SetTree( uDataSrc, , bChange, If( aCols == nil, lAddCols, aCols ) )
            lSet  := .T.

         elseif uDataSrc:IsKindOf( "TSTRUCT" )
            oBrw:SetArray( aObjStructure( uDataSrc ), .F., nil, { 1, 2 } )
            oBrw:aCols[ 1 ]:cHeader := "Member"
            WITH OBJECT oBrw:aCols[ 2 ]
               :cHeader    := "Value"
               :nEditType  := 1



               :bOnPostEdit:= { |o,x,n| If( n <> 27,  ( OSend( uDataSrc, "_" + oBrw:aRow[ 1 ], x ),     o:Value := OSend( uDataSrc, oBrw:aRow[ 1 ] ) ),  nil ) }
            END
            oBrw:lFastEdit := .T.
            oBrw:bChange   := bChange
            lSet = .T.

         elseif XBrowsableObj( uDataSrc )
            oBrw:SetoDbf( uDataSrc, aCols, lAutoSort, lAddCols, aRows )
            oBrw:bChange   := bChange
            lSet  := .T.
         endif
      endif

      if ! lSet

         oBrw:SetArray( aObjData( uDataSrc ), .F., nil, { 1, 2, 3 } )
         oBrw:aCols[ 1 ]:cHeader := "Num"
         oBrw:aCols[ 1 ]:nWidth := 40
         oBrw:aCols[ 2 ]:cHeader := "Data"
         WITH OBJECT oBrw:aCols[ 3 ]
            :cHeader    := "Value"
            :nEditType  := 1
            :bEditWhen  := { || oBrw:aArrayData[ oBrw:nArrayAt, 4 ] }



            :bOnPostEdit:= { |o,x,n| If( n <> 27,  ( OSend( uDataSrc, "_" + oBrw:aRow[ 2 ], x ),     o:Value := OSend( uDataSrc, oBrw:aRow[ 2 ] ) ),  nil ) }
         END
         oBrw:lFastEdit := .T.
         oBrw:bChange   := bChange
         lSet  := .T.
      endif
   otherwise

   endcase

return nil



static function IsRecordSet( o )

   local lRecSet  := .F.
   local u




   if ! lRecSet
      BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
         u  := o:Fields:Count()
         BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
            u  := o:RecordCount()
            lRecSet  := .T.
         RECOVER
         END
      RECOVER
      END
   endif

return lRecSet



static function IsXlRange( o )

   local lXlRange  := .F.




   local u

   BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
      u  := o:Cells(1,1):Value
      lXlRange  := .T.
   RECOVER
   END


return lXlRange



static function GetOleProperties( o )

   local aProp    := {}
   local nProp, oProp, i

   BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
      nProp    := o:Properties:Count()
      oProp    := o:Properties
   RECOVER
      BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
         nProp    := o:Count()
         oProp    := o
      RECOVER
      END
   END
   if nProp <> nil .AND. nProp > 0
      for i := 0 to nProp - 1
         AAdd( aProp, { i, oProp:Item( i ):Name, oProp:Item( i ):Value } )
      next
   endif

return aProp



function XBrowsableObj( oObj )









   return  __ObjHasMethod( oObj, "SETXBROWSE" ) .OR.  ( AScan( { "GOTOP", "GOBOTTOM", "BOF", "EOF", "SKIPPER", "RECCOUNT" },  { |c| ! __ObjHasMethod( oObj, c ) }  ) == 0 .AND.  ( __ObjHasMethod( oObj, "BOOKMARK" ) .OR.  (__ObjHasMsg( oObj, "RECNO" ) .AND. __ObjHasMethod( oObj, "GOTO" ) )  )  )



static function aObjData( obj )

   local n, v, l, aData := AOData( obj )

   for n := 1 to Len( aData )
      BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
         v  := OSend( obj, aData[ n ] )
         l  := .T.
      RECOVER
         v  := "<protected>"
         l  := .F.
      END


      aData[ n ]  := Lower( Left( aData[ n ], 1 ) ) +  SubStr( aData[ n ], 2 , 1 ) +  Lower( SubStr( aData[ n ], 3 ) )
      aData[ n ]  := { n, aData[ n ], V, l }
   next

return aData



static function aObjStructure( obj )
   local n, aData := {}

   for n = 1 to len( obj:aMembers )
      AAdd( aData, { obj:aMembers[ n ][ 1 ], obj:GetMember( n ) } )
   next

return aData



function XbrJustify( oBrw, aJust )
return   ( oBrw:aJustify := aJust )



function xbrNumFormat(...)
return   HB_ExecFromArray( "FWNumFormat", HB_AParams() )



function TXBrows( bChild )

   if bXBrowse == nil
      bXBrowse    := { || TXBrowse() }
   endif



   if ValType( bChild ) == "B" .AND.  ValType( Eval( bChild ) ) == "O" .AND.  Eval( bChild ):IsKindOf( TXBrowse() )

      bXBrowse    := bChild
   endif

return Eval( bXBrowse )



function SetXBrowse( bChild )

   local bPrev

   if bXBrowse == nil
      bXBrowse    := { || TXBrowse() }
   endif

   bPrev          := bXBrowse



   if ValType( bChild ) == "B" .AND.  ValType( Eval( bChild ) ) == "O" .AND.  Eval( bChild ):IsKindOf( TXBrowse() )

      bXBrowse    := bChild
   endif

return bPrev



_HB_CLASS TXbrRow ; STATIC function TXbrRow ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "TXbrRow", iif( .F., { }, { @HBObject() } ), @TXbrRow() ) ) ;

   _HB_MEMBER { oBrw } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oBrw"}, .F. )


   _HB_MEMBER { nRecNo, nKeyNo } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nRecNo", "nKeyNo"}, .F. )

   _HB_MEMBER { aHeaders } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aHeaders"}, .F. )
   _HB_MEMBER { aOriginals } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aOriginals"}, .F. )
   _HB_MEMBER { aValues } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aValues"}, .F. )
   _HB_MEMBER { bSave } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bSave"}, .F. )

   _HB_MEMBER New( oBrw, nRecNo, nKeyNo, aHeaders, aValues); oClass:AddMethod( "New", @TXbrRow_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Save(); oClass:AddMethod( "Save", @TXbrRow_Save(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Undo(); oClass:AddInline( "Undo", {|Self | ( ( Self ) ), ACopy( ::aOriginals, ::aValues )}, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Modified(); oClass:AddMethod( "Modified", @TXbrRow_Modified(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER onError(); oClass:SetOnError( @TXbrRow_onError() )

oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS TXbrRow ;



static FUNCTION TXbrRow_New( oBrw, nRecNo, nKeyNo, aHeaders, aValues ) ; local Self AS CLASS TXbrRow := QSelf() AS CLASS TXbrRow

   ::oBrw      := oBrw
   ::nRecNo    := nRecNo
   ::nKeyNo    := nKeyNo
   ::aHeaders  := AClone( aHeaders )
   ::aValues   := aValues
   ::aOriginals:= AClone( aValues )

return Self



static FUNCTION TXbrRow_Save( ) ; local Self AS CLASS TXbrRow := QSelf() AS CLASS TXbrRow

   local lSaved   := .F.
   local uBm      := Eval( ::oBrw:bBookMark )
   local oCol, n

   Eval( ::oBrw:bBookMark, ::nRecNo )
   if ::oBrw:Lock()
      for n := 1 to Len( ::aHeaders )
         if ::aOriginals[ n ] <> ::aValues[ n ]
            oCol     := ::oBrw:oCol( ::aHeaders[ n ] )
            if oCol:bOnPostEdit == nil
               if oCol:bEditValue <> nil
                  oCol:Value := ::aValues[ n ]
               endif
            else
               Eval( oCol:bOnPostEdit, oCol, ::aValues[ n ], 13 )
            endif
         endif
      next
      if ::bSave <> nil
         Eval( ::bSave, Self )
      endif
      Eval( ::oBrw:Unlock())
      if ::oBrw:bOnRowLeave <> nil
         Eval( ::oBrw:bOnRowLeave )
      endif
      lSaved   := .T.
      ACopy( ::aValues, ::aOriginals )
   endif
   if uBm == Eval( ::oBrw:bBookMark )
      ::oBrw:RefreshCurrent()
   else
      Eval( ::oBrw:bBookMark, uBm )
      ::oBrw:Refresh()
   endif

return lSaved



static FUNCTION TXbrRow_Modified( ) ; local Self AS CLASS TXbrRow := QSelf() AS CLASS TXbrRow

Return ( AScan( ::aValues, { |u,i| u <> ::aOriginals[ i ] } ) > 0 )



static FUNCTION TXbrRow_onError( uParam1 ) ; local Self AS CLASS TXbrRow := QSelf() AS CLASS TXbrRow

   local cMsg   := __GetMessage()
   local nError := If( SubStr( cMsg, 1, 1 ) == "_", 1005, 1004 )
   local nCol
   local lAssign := .F.

   if Left( cMsg, 1 ) == "_"
      lAssign     := .T.
      nError      := 1005
      cMsg        := SubStr( cMsg, 2 )
   endif
   nCol           := AScan( ::aHeaders, { |c| Upper( c ) == Upper( cMsg ) } )

   if nCol > 0
      if lAssign
         ::aValues[ nCol ] := uParam1
      endif
      return ::aValues[ nCol ]
   endif

    _ClsSetError( _GenError( nError, ::ClassName(), cMsg ) )

return nil



static function SameDbfStruct( oBrw, cAlias )

   local aStr1, aStr2
   local lSame    := .T.

   if ! Empty( oBrw:cAlias ) .AND. Select( oBrw:cAlias ) > 0
      aStr1    := ( oBrw:cAlias )->( dbStruct() )
      aStr2    := ( cAlias )->( dbStruct() )
      if Len( aStr1 ) == Len( aStr2 )


         lSame := ( AScan( aStr1, { |a,i| Upper( a[ 1 ] ) <> Upper( aStr2[ i ][ 1 ] ) .OR.  a[ 2 ] <> aStr2[ i ][ 2 ] } ) == 0 )
      else
         lSame := .F.
      endif
   else
      lSame    := .F.
   endif

return lSame



static function SameAdoStruct( oBrw, oRs )

   local lSame    := .T.
   local n, nFlds, oFld

   nFlds := oBrw:oRs:Fields:Count()
   if nFlds == oRs:Fields:Count()
      for n := 0 to nFlds - 1
         if Upper( oBrw:oRs:Fields( n ):Name ) <> Upper( oRs:Fields( n ):Name )
            lSame := .F.
            exit
         endif
         if Upper( oBrw:oRs:Fields( n ):Type ) <> Upper( oRs:Fields( n ):Type )
            lSame := .F.
            exit
         endif
      next
   else
      lSame    := .F.
   endif

return lSame



function ContrastColor( hDC, nCol, nRow, nWidth, nHeight, nDefClr )

   local nClr, nLuma, nLuma0, nContrast, n, k

   If( nDefClr == nil, nDefClr := 0, ) ;
   nContrast        := nDefClr

   nRow     += Int( nHeight / 2 )
   nLuma    := 0
   k        := 0
   for n    := Int( nCol ) + 10 to nCol + nWidth step 10
      nClr  := GetPixel( hDC, n, nRow )
      nLuma += ( 0.299 * nRGBRed( nClr ) + 0.587 * nRGBGreen( nClr ) + 0.114 * nRGBBlue( nClr ) )
      k++
   next

   if k > 0
      nLuma /= k
      nLuma0   := 0.299 * nRGBRed( nDefClr ) + 0.587 * nRGBGreen( nDefClr ) + 0.114 * nRGBBlue( nDefClr )
      if Abs( nLuma - nLuma0 ) < 150
         nContrast   := If( nLuma < 150, 16777215, 0 )
      endif
   endif

return nContrast



static function CreateColorBrush( uClr )

   if ValType( uClr ) == "A"
      uClr     := uClr[ 1 ][ 2 ]
   endif

return CreateSolidBrush( uClr )



static function CreateLinePen( oBrw, nLineStyle, nPenStyle, nWidth, nColor )

   local hPen




   If( nLineStyle == nil, nLineStyle := 1, ) ; If( nPenStyle == nil, nPenStyle := 0, ); If( nWidth == nil, nWidth := 1, ); If( nColor == nil, nColor := 0, );

   do case
   case nLineStyle == 1 .OR. nLineStyle == 6 .OR. nLineStyle == 5
      hPen := CreatePen( 0, nWidth, nColor )
   case nLineStyle == 2
      hPen := CreatePen( 0, nWidth, 8421504 )
   case nLineStyle == 3
      hPen := CreatePen( 0, nWidth, oBrw:nClrText )
   case nLineStyle == 4
      hPen := CreatePen( 0, nWidth, 12632256 )
   otherwise
      hPen  := 0
   end

return hPen



function DrawPen( hDC, aFromRC, aUptoRC, hPen )

   if ! Empty( hPen )
      MoveTo( hDC, aFromRC[ 2 ], aFromRC[ 1 ] )
      LineTo( hDC, aUptoRC[ 2 ], aUptoRC[ 1 ], hPen )
   endif

return nil



function DrawHorz( hDC, nRow, nLeft, nRight, hPen )
return   DrawPen(  hDC, { nRow, nLeft }, { nRow, nRight }, hPen )



function DrawVert( hDC, nCol, nTop, nBottom, hPen )
return   DrawPen(  hDC, { nTop, nCol }, { nBottom, nCol }, hPen )



function SetKinetic( lOnOff )

   local lOldStatus

   static lStatus := .T.

   lOldStatus = lStatus

   if PCount() == 1 .AND. ValType( lOnOff ) == "L"
      lStatus = lOnOff
   endif

return lOldStatus



function ArrTranspose( aArray, lSquare )

   local nRows, nCols, nRow, nCol, nWidth
   local aNew

   If( lSquare == nil, lSquare := .F., ) ;

   nRows          := Len( aArray )
   if lSquare
      nCols       := Len( aArray[ 1 ] )
   else
      nCols       := 1
      for nRow := 1 to nRows
         if ValType( aArray[ nRow ] ) == "A"
            nCols    := Max( nCols, Len( aArray[ nRow ] ) )
         endif
      next
   endif

   aNew           := Array( nCols, nRows )
   for nRow := 1 to nRows
      if ValType( aArray[ nRow ] ) == "A"
         nWidth  := Len( aArray[ nRow ] )
         for nCol := 1 to nWidth
            aNew[ nCol, nRow ]   := aArray[ nRow, nCol ]
         next
      else
         aNew[ 1, nRow ]      := aArray[ nRow ]
      endif
   next

return aNew



static function ArrMerge( aArray1, aArray2 )

   local n, nLen

   if Empty( aArray1 )
      aArray1    := aArray2
   elseif ! Empty( aArray2 )
      if Len( aArray1 ) < Len( aArray2 )
         ASize( aArray1, Len( aArray2 ) )
      endif
      AEval( aArray2, { |u,i| If( u == nil, , aArray1[ i ] := u ) } )
   endif

return aArray1



static function XbrLbxLookUp( uVal, aBound, aText )

   local uRetVal  := Blank( aText[ 1 ] )
   local nAt

   if ! Empty( uVal )
      if ValType( uVal ) == "C"
         uVal     := Upper( uVal )
         nAt      := AScan( aBound, { |c| Upper( c ) == uVal } )
      else
         nAt      := AScan( aBound, uVal )
      endif
      if nAt > 0
         uRetVal  := aText[ nAt ]
      endif
   endif

return uRetVal





static function adoIsEmptyRow( oRs )

   local lEmpty := .T.
   local n, nFlds := oRs:Fields:Count() - 1

   for n := 0 to nFlds
      if ! ( oRs:Fields( n ):Value == nil )
         lEmpty   := .F.
         exit
      endif
   next

return lEmpty



function XbrAdoSave( oBrw )

   local lSaved   := .F.
   local oRs      := oBrw:oRs
   local lCanResync  := oBrw:lRsCanResync
   local tmp

   if oRs:LockType > 1
      BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
         oRs:Update()
         lSaved   := .T.
      RECOVER
         oRs:CancelUpdate()
         tmp   := oRs:AbsolutePosition
         if lCanResync
            BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
               oRs:Resync( 1, 2 )
            RECOVER
               oRs:ReQuery()
               oRs:AbsolutePosition := Max( 1, Min( tmp, oRs:RecordCount() ) )
               oBrw:Refresh()
            END
         endif
      END
   endif

return lSaved



static function XBrAdoDelete( oBrw )

   local oRs   := oBrw:oRs
   local n

   WITH OBJECT oRs
      n  := :AbsolutePosition
      BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
         :Delete()
      RECOVER
         :CancelUpdate()
         :ReQuery()
      END
      :AbsolutePosition := Max( 1, Min( n, :RecordCount() ) )
   END

return nil



static function SeekDate( cSeek, dDefault )

   local dSeek
   local nLen

   if IsDigit( SubStr( cSeek, 3 ) )
      cSeek    := CharOnly( "0123456789", cSeek )
      if IsDigit( SubStr( cSeek, 3 ) )
         if ( nLen := Len( cSeek ) ) >= 8
            cSeek    := Left( cSeek, 8 )
         elseif nLen >= 6
            cSeek    := Left( cSeek, 6 ) + "01"
         elseif nLen >= 4
            cSeek    := Left( cSeek, 4 ) + "0101"
         else
            cSeek    += "00101"
         endif
      endif
      dSeek          := SToD( cSeek )
   elseif Len( cSeek ) > 6
      cSeek       := PadR( cSeek, 10, "0" )
      dSeek       := CToD( cSeek )
   endif

return If( Empty( dSeek ), dDefault, dSeek )



static function d2ado( dDate )

   if Empty( dDate ) .OR. dDate < {^ 1900/01/01 }
      return "#1900-01-01#"
   endif

return "#" + TRANSFORM( DTOS( dDate ), "@R XXXX-XX-XX" ) + "#"



function XbrSQLRDDmode( nSet )

   static nMode := 0

   local nOldMode    := nMode

   if ValType( nSet ) == "N"
      nMode    := nSet
   endif

return nOldMode



function XbrGetSelectAll( uNew )

   static lSet    := .T.

   local lPrevSet := lSet

   if PCount() > 0 .AND. ( uNew == nil .OR. ValType( uNew ) == "L" )
      lSet     := uNew
   endif

return lPrevSet



function FieldTypeAdoToDbf( nType )

   do case
   case AScan( { 8,128,129,130,200,201,202,203,204,205 }, nType ) > 0; return "C"
   case AScan( { 7, 133, 135 }, nType ) > 0; return "D"
   case nType == 11; return "L"
   case AScan( { 2, 3, 4, 5, 6, 14, 16, 17, 18, 19, 20, 21, 131, 139 }, nType ) > 0; return "N"
   endcase

return ""



function IsImageData( cBuf )



   if ValType( cBuf ) == "C" .AND.   IsBinaryData( cBuf ) .AND.     IfNil( FITypeFromMemory( cBuf ), -1 ) >= 0

      return .T.
   endif

return .F.



function xEval(...)

   local aParams  := HB_AParams()
   local uRet

   if Len( aParams ) > 0
      if ValType( aParams[ 1 ] ) == "B"
         BEGIN SEQUENCE WITH {| oErr | Break( oErr ) }
            uRet     := HB_ExecFromArray( aParams )
         RECOVER
         END
      else
         uRet     := aParams[ 1 ]
      endif
   endif

return uRet



function XbrHexEdit( cVal, cTitle, lReadOnly )

   local cTmp     := cVal
   local nLen     := Len( cTmp )
   local nLines   := Ceiling( nLen / 16 )
   local oDlg, oBrw, oFont, lEdited := .F.

   If( cTitle == nil, cTitle := "HEXEDIT", ) ; If( lReadOnly == nil, lReadOnly := .F., );

   oFont := TFont():New( "Lucida Console", 0, -14,,,,,,,,,,,,,, )
   oDlg = TDialog():New(,,,, cTitle,,, .F.,,,,,, .T.,, oFont,, 700, 400, .F.,, "oDlg", nil, )

   oBrw := XbrowseNew( oDlg, 30, 10, -10, -30,,,,,,,,,,,, .F., {},, .F.,, .T.,, .F., .F. ,,,,, .F., .F., .F., .F.,,,,, .F., .T., "oBrw", )

   oBrw:AddColumn( If(.F., OemToAnsi("LineHex"), "LineHex"), If( ValType(NUMTOHEX( oBrw:nArrayAt, 8 ))=="B", NUMTOHEX( oBrw:nArrayAt, 8 ), {|| NUMTOHEX( oBrw:nArrayAt, 8 )} ),,,,,, .F., .F.,,,,,, .F.,,,,, .F.,,, )

   oBrw:AddColumn( If(.F., OemToAnsi("Text"), "Text"), If( ValType(RangeRepl( Chr(0), Chr(31), SubStr( cTmp, oBrw:nArrayAt * 16 - 15, 16 ), "." ))=="B", RangeRepl( Chr(0), Chr(31), SubStr( cTmp, oBrw:nArrayAt * 16 - 15, 16 ), "." ), {|| RangeRepl( Chr(0), Chr(31), SubStr( cTmp, oBrw:nArrayAt * 16 - 15, 16 ), "." )} ),,,,,, .F., .F.,,,,,, .F.,,,,, .F.,,, )

   oBrw:AddColumn( If(.F., OemToAnsi("HexChar"), "HexChar"), If( ValType(STRTOHEX( SubStr( cTmp, oBrw:nArrayAt * 16 -15, 16 ) ))=="B", STRTOHEX( SubStr( cTmp, oBrw:nArrayAt * 16 -15, 16 ) ), {|| STRTOHEX( SubStr( cTmp, oBrw:nArrayAt * 16 -15, 16 ) )} ), "@R" + Replicate( " !!", 16 ),,,,, .F., .F.,,,,,, .F.,,,,, .F.,,, )

   WITH OBJECT oBrw


      :bSeek            := { |c,nAt| If( Empty( c ), nAt := 1, nAt := At( Upper( c ), cTmp ) ),  If( nAt > 0, oBrw:nArrayAt := Int( nAt / 16 ) + 1, nil ),  nAt > 0 }
      :bKeyCount        := { || nLines }
      :nHeadStrAligns   := 2
      :nColDividerStyle := 1
      :nStretchCol      := 2
      WITH OBJECT :aCols[ 3 ]
         :nEditType     := If( lReadOnly, 0, 1 )
         :bEditValid    := { |o| Len( HEXTOSTR( CharRem( " ", o:VarGet() ) ) ) == 16  }
         :bClrEdit      := { || { 0, 65535 } }






         :bOnPostEdit   := { |o,x,n| If( n == 27, nil, (  x := HEXTOSTR( CharRem( " ", x ) ),  If( x == o:Value, nil, ( cTmp :=  Left( cTmp, oBrw:nArrayAt * 16 - 16 ) +  x + SubStr( cTmp, oBrw:nArrayAt * 16 + 1 ),  oDlg:AEvalWhen() )  ) ) ) }
      END

      :CreateFromCode()
   END

   oBrw:oSeek := TSay():New( 10, 10, {|| oBrw:cSeek}, oDlg,,, .F., .F., .F., .T., 0, 65535, 330, 10, .F., .F., .F., .F., .F., .F., .F., "oBrw:oSeek",, .F. )
   TButton():New( 180, 255, "Save", oDlg, {|| ( oDlg:End() )}, 40, 12,,, .F., .T., .F.,, .F., {|| cTmp <> cVal},, .F.,, .F. )
   TButton():New( 180, 300, "Cancel", oDlg, {|| ( cTmp := cVal, oDlg:End() )}, 40, 12,,, .F., .T., .F.,, .F.,,, .F.,, .F. )

   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked,,, )
   oFont:End() ; oFont := nil

   lEdited    := !( cVal == cTmp )
   if lEdited
      cVal     := cTmp
   endif

return lEdited



function XBrImageEdit( cBuf, cTitle, lReadOnly )

   local cTmp        := cBuf
   local hBitmap, hBmp
   local oDlg, oImage, oFont, cFile
   local oClp, uClip, lEdited := .F.

   If( cTitle == nil, cTitle := "IMAGE", ) ; If( lReadOnly == nil, lReadOnly := .F., );

   oFont := TFont():New( "TAHOMA", 0, -12,,,,,,,,,,,,,, )
   oDlg = TDialog():New(,,,,,,, .F.,,,,,, .T.,, oFont,, 600, 400, .F.,, "oDlg", nil, )

   if !lReadOnly
      oClp := TClipBoard():New( Upper("BITMAP"), oDlg )
      uClip    := oClp:GetBitmap()
   endif

   oImage := TImage():New( 10, 10, 280, 160,,, .T., oDlg,,, .F., .F.,,, .F.,, .T.,, .F., "oImage" )
   oImage:LoadFromMemory( cTmp, , 320 )

   if lReadOnly

      TButton():New( 180, 250, "Close", oDlg, {|| oDlg:End()}, 40, 12,,, .F., .T., .F.,, .F.,,, .F.,, .F. )

   else






      TButton():New( 180, 10, "Open", oDlg, {|| (  If( Empty( cFile := cGetFile( "Image File (*.bmp,jpg,png)|*.bmp;*.jpg;*.jpeg;*.png|",  CurDir() ) ), nil,  ( cTmp := MemoRead( cFile ), oImage:LoadFromMemory( cTmp, , 320 ),  oImage:Refresh(), oDlg:AEvalWhen() ) )  )}, 40, 12,,, .F., .T., .F.,, .F.,,, .F.,, .F. )



      TButton():New( 180, 55, "Paste", oDlg, {|| ( cTmp := BmpToStr( uClip ),  oClp:Clear(), uClip := nil,  oImage:LoadFromMemory( cTmp, , 320 ), oImage:Refresh(),  oDlg:AEvalWhen() )}, 40, 12,,, .F., .T., .F.,, .F., {|| ! Empty( uClip )},, .F.,, .F. )



      TButton():New( 180, 160, "Undo", oDlg, {|| ( cTmp := cBuf, oImage:LoadFromMemory( cTmp, , 320 ), oImage:Refresh(),  oDlg:AEvalWhen() )}, 40, 12,,, .F., .T., .F.,, .F., {|| !( cTmp  == cBuf )},, .F.,, .F. )
      TButton():New( 180, 205, "Save", oDlg, {|| oDlg:End()}, 40, 12,,, .F., .T., .F.,, .F., {|| !( cTmp  == cBuf )},, .F.,, .F. )
      TButton():New( 180, 250, "Cancel", oDlg, {|| ( cTmp := cBuf, oDlg:End() )}, 40, 12,,, .F., .T., .F.,, .F.,,, .F.,, .F. )

   endif

   if ! lReadOnly
      oDlg:bGotFocus    := { || uClip := oClp:GetBitmap(), oDlg:AEvalWhen() }
   endif


   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,,, oDlg:bRClicked := {|nRow,nCol,nFlags|( oImage:LoadFromMemory( memoread( "everest.jpg" ), , 320 ), oImage:Refresh() )},,, )

   oFont:End() ; oFont := nil
   if oClp <> nil
      oClp:End()
   endif

   if ! lReadOnly
      lEdited  := !( cBuf == cTmp )
      if lEdited
         cBuf  := cTmp
      endif
   endif

return lEdited



function XbrEditMemo( nRow, nCol, oCol, nKey, cTitle )

   local lReadOnly      := ! oCol:lEditable
   local cVal           := IfNil( oCol:Value, "" )
   local lBinaryData    := IsBinaryData( cVal )
   local lText          := ( ! lBinaryData .AND. ! IsRTF( cVal ) .AND. ! IsGTF( cVal ) )
   local lEdited        := .F.

   If( cTitle == nil, cTitle := oCol:cHeader, ) ;

   if IsRtf( cVal ) .OR. IsGtf( cVal ) .OR. ! lBinaryData

      lEdited     := MemoEdit( @cVal, cTitle, nil, nil, nil, nil,  If( lText, MsgYesNo( "Edit as RTF?", cTitle ), nil ) )
   elseif IsImageData( cVal )
      lEdited     := XbrImageEdit( @cVal, cTitle, lReadOnly )
   else
      lEdited     := XBrHexEdit( @cVal, cTitle, lReadOnly )
   endif

   lEdited     := !lReadOnly .AND. lEdited .AND. ! ( cVal == oCol:Value )

return If( lEdited, cVal, nil )



function FW_ArrSum( aArray, bnCol, nStart, nCount )

   local nRet  := 0
   local x

   if Empty( bnCol )
      AEval( aArray, { |n| If( ValType( n ) == "N", nRet += n, nil ) }, nStart, nCount )
   elseif ValType( bnCol ) == "B"

      AEval( aArray, { |a,i| If( ValType( x := xEval( bnCol, a, i, aArray ) ) == "N", nRet += x, nil ) },  nStart, nCount )
   elseif ValType( bnCol ) == "N"
      AEval( aArray, { |a| If( ValType( a[ bnCol ] ) == "N", nRet += a[ bnCol ], nil ) }, nStart, nCount )
   endif

return nRet
